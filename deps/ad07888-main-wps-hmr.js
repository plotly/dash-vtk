webpackHotUpdatedash_vtk("main",{

/***/ "./node_modules/blueimp-md5/js/md5.js":
/*!********************************************!*\
  !*** ./node_modules/blueimp-md5/js/md5.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 * JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/* global define */

/* eslint-disable strict */

;(function ($) {
  'use strict'

  /**
   * Add integers, wrapping at 2^32.
   * This uses 16-bit operations internally to work around bugs in interpreters.
   *
   * @param {number} x First integer
   * @param {number} y Second integer
   * @returns {number} Sum
   */
  function safeAdd(x, y) {
    var lsw = (x & 0xffff) + (y & 0xffff)
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)
    return (msw << 16) | (lsw & 0xffff)
  }

  /**
   * Bitwise rotate a 32-bit number to the left.
   *
   * @param {number} num 32-bit number
   * @param {number} cnt Rotation count
   * @returns {number} Rotated number
   */
  function bitRotateLeft(num, cnt) {
    return (num << cnt) | (num >>> (32 - cnt))
  }

  /**
   * Basic operation the algorithm uses.
   *
   * @param {number} q q
   * @param {number} a a
   * @param {number} b b
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */
  function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)
  }
  /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */
  function md5ff(a, b, c, d, x, s, t) {
    return md5cmn((b & c) | (~b & d), a, b, x, s, t)
  }
  /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */
  function md5gg(a, b, c, d, x, s, t) {
    return md5cmn((b & d) | (c & ~d), a, b, x, s, t)
  }
  /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */
  function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t)
  }
  /**
   * Basic operation the algorithm uses.
   *
   * @param {number} a a
   * @param {number} b b
   * @param {number} c c
   * @param {number} d d
   * @param {number} x x
   * @param {number} s s
   * @param {number} t t
   * @returns {number} Result
   */
  function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t)
  }

  /**
   * Calculate the MD5 of an array of little-endian words, and a bit length.
   *
   * @param {Array} x Array of little-endian words
   * @param {number} len Bit length
   * @returns {Array<number>} MD5 Array
   */
  function binlMD5(x, len) {
    /* append padding */
    x[len >> 5] |= 0x80 << len % 32
    x[(((len + 64) >>> 9) << 4) + 14] = len

    var i
    var olda
    var oldb
    var oldc
    var oldd
    var a = 1732584193
    var b = -271733879
    var c = -1732584194
    var d = 271733878

    for (i = 0; i < x.length; i += 16) {
      olda = a
      oldb = b
      oldc = c
      oldd = d

      a = md5ff(a, b, c, d, x[i], 7, -680876936)
      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)
      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)
      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)
      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)
      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)
      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)
      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)
      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)
      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)
      c = md5ff(c, d, a, b, x[i + 10], 17, -42063)
      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)
      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)
      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)
      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)
      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)

      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)
      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)
      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)
      b = md5gg(b, c, d, a, x[i], 20, -373897302)
      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)
      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)
      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)
      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)
      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)
      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)
      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)
      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)
      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)
      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)
      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)
      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)

      a = md5hh(a, b, c, d, x[i + 5], 4, -378558)
      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)
      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)
      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)
      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)
      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)
      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)
      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)
      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)
      d = md5hh(d, a, b, c, x[i], 11, -358537222)
      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)
      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)
      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)
      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)
      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)
      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)

      a = md5ii(a, b, c, d, x[i], 6, -198630844)
      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)
      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)
      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)
      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)
      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)
      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)
      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)
      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)
      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)
      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)
      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)
      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)
      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)
      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)
      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)

      a = safeAdd(a, olda)
      b = safeAdd(b, oldb)
      c = safeAdd(c, oldc)
      d = safeAdd(d, oldd)
    }
    return [a, b, c, d]
  }

  /**
   * Convert an array of little-endian words to a string
   *
   * @param {Array<number>} input MD5 Array
   * @returns {string} MD5 string
   */
  function binl2rstr(input) {
    var i
    var output = ''
    var length32 = input.length * 32
    for (i = 0; i < length32; i += 8) {
      output += String.fromCharCode((input[i >> 5] >>> i % 32) & 0xff)
    }
    return output
  }

  /**
   * Convert a raw string to an array of little-endian words
   * Characters >255 have their high-byte silently ignored.
   *
   * @param {string} input Raw input string
   * @returns {Array<number>} Array of little-endian words
   */
  function rstr2binl(input) {
    var i
    var output = []
    output[(input.length >> 2) - 1] = undefined
    for (i = 0; i < output.length; i += 1) {
      output[i] = 0
    }
    var length8 = input.length * 8
    for (i = 0; i < length8; i += 8) {
      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32
    }
    return output
  }

  /**
   * Calculate the MD5 of a raw string
   *
   * @param {string} s Input string
   * @returns {string} Raw MD5 string
   */
  function rstrMD5(s) {
    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))
  }

  /**
   * Calculates the HMAC-MD5 of a key and some data (raw strings)
   *
   * @param {string} key HMAC key
   * @param {string} data Raw input string
   * @returns {string} Raw MD5 string
   */
  function rstrHMACMD5(key, data) {
    var i
    var bkey = rstr2binl(key)
    var ipad = []
    var opad = []
    var hash
    ipad[15] = opad[15] = undefined
    if (bkey.length > 16) {
      bkey = binlMD5(bkey, key.length * 8)
    }
    for (i = 0; i < 16; i += 1) {
      ipad[i] = bkey[i] ^ 0x36363636
      opad[i] = bkey[i] ^ 0x5c5c5c5c
    }
    hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)
    return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))
  }

  /**
   * Convert a raw string to a hex string
   *
   * @param {string} input Raw input string
   * @returns {string} Hex encoded string
   */
  function rstr2hex(input) {
    var hexTab = '0123456789abcdef'
    var output = ''
    var x
    var i
    for (i = 0; i < input.length; i += 1) {
      x = input.charCodeAt(i)
      output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f)
    }
    return output
  }

  /**
   * Encode a string as UTF-8
   *
   * @param {string} input Input string
   * @returns {string} UTF8 string
   */
  function str2rstrUTF8(input) {
    return unescape(encodeURIComponent(input))
  }

  /**
   * Encodes input string as raw MD5 string
   *
   * @param {string} s Input string
   * @returns {string} Raw MD5 string
   */
  function rawMD5(s) {
    return rstrMD5(str2rstrUTF8(s))
  }
  /**
   * Encodes input string as Hex encoded string
   *
   * @param {string} s Input string
   * @returns {string} Hex encoded string
   */
  function hexMD5(s) {
    return rstr2hex(rawMD5(s))
  }
  /**
   * Calculates the raw HMAC-MD5 for the given key and data
   *
   * @param {string} k HMAC key
   * @param {string} d Input string
   * @returns {string} Raw MD5 string
   */
  function rawHMACMD5(k, d) {
    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))
  }
  /**
   * Calculates the Hex encoded HMAC-MD5 for the given key and data
   *
   * @param {string} k HMAC key
   * @param {string} d Input string
   * @returns {string} Raw MD5 string
   */
  function hexHMACMD5(k, d) {
    return rstr2hex(rawHMACMD5(k, d))
  }

  /**
   * Calculates MD5 value for a given string.
   * If a key is provided, calculates the HMAC-MD5 value.
   * Returns a Hex encoded string unless the raw argument is given.
   *
   * @param {string} string Input string
   * @param {string} [key] HMAC key
   * @param {boolean} [raw] Raw output switch
   * @returns {string} MD5 output
   */
  function md5(string, key, raw) {
    if (!key) {
      if (!raw) {
        return hexMD5(string)
      }
      return rawMD5(string)
    }
    if (!raw) {
      return hexHMACMD5(key, string)
    }
    return rawHMACMD5(key, string)
  }

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return md5
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else {}
})(this)


/***/ }),

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON", function() { return EPSILON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RANDOM", function() { return RANDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMatrixArrayType", function() { return setMatrixArrayType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadian", function() { return toRadian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}
if (!Math.hypot) Math.hypot = function () {
  var y = 0,
      i = arguments.length;

  while (i--) {
    y += arguments[i] * arguments[i];
  }

  return Math.sqrt(y);
};

/***/ }),

/***/ "./node_modules/gl-matrix/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/index.js ***!
  \*********************************************/
/*! exports provided: glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat2.js */ "./node_modules/gl-matrix/esm/mat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return _mat2_js__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat2d.js */ "./node_modules/gl-matrix/esm/mat2d.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return _mat2d_js__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/gl-matrix/esm/mat3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return _mat3_js__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return _mat4_js__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quat.js */ "./node_modules/gl-matrix/esm/quat.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return _quat_js__WEBPACK_IMPORTED_MODULE_5__; });
/* harmony import */ var _quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./quat2.js */ "./node_modules/gl-matrix/esm/quat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat2", function() { return _quat2_js__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony import */ var _vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vec2.js */ "./node_modules/gl-matrix/esm/vec2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return _vec2_js__WEBPACK_IMPORTED_MODULE_7__; });
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return _vec3_js__WEBPACK_IMPORTED_MODULE_8__; });
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/gl-matrix/esm/vec4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return _vec4_js__WEBPACK_IMPORTED_MODULE_9__; });












/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2.js ***!
  \********************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, transpose, invert, adjoint, determinant, multiply, rotate, scale, fromRotation, fromScaling, str, frob, LDU, add, subtract, exactEquals, equals, multiplyScalar, multiplyScalarAndAdd, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LDU", function() { return LDU; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */

function fromValues(m00, m01, m10, m11) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */

function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {ReadonlyMat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {ReadonlyMat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {ReadonlyMat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3]);
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {ReadonlyMat2} L the lower triangular matrix
 * @param {ReadonlyMat2} D the diagonal matrix
 * @param {ReadonlyMat2} U the upper triangular matrix
 * @param {ReadonlyMat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @returns {mat2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2} a The first matrix.
 * @param {ReadonlyMat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {ReadonlyMat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {ReadonlyMat2} a the first operand
 * @param {ReadonlyMat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2d.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2d.js ***!
  \*********************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, invert, determinant, multiply, rotate, scale, translate, fromRotation, fromScaling, fromTranslation, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2x3 Matrix
 * @module mat2d
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, b,
 *  c, d,
 *  tx, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, b, 0,
 *  c, d, 0,
 *  tx, ty, 1]
 * </pre>
 * The last column is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {ReadonlyMat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */

function fromValues(a, b, c, d, tx, ty) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */

function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {mat2d} out
 */

function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {ReadonlyMat2d} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to translate
 * @param {ReadonlyVec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/

function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat2d} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat2d} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {ReadonlyMat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat2d(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")";
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {ReadonlyMat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @returns {mat2d} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {ReadonlyMat2d} a the first operand
 * @param {ReadonlyMat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat2d} a The first matrix.
 * @param {ReadonlyMat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat3.js ***!
  \********************************************/
/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat2d", function() { return fromMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalFromMat4", function() { return normalFromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projection", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {ReadonlyMat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {ReadonlyMat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to translate
 * @param {ReadonlyVec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to rotate
 * @param {ReadonlyVec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyVec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
 * Calculates a 3x3 matrix from the given quaternion
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat3} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
 * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {ReadonlyMat4} a Mat4 to derive the normal matrix from
 *
 * @returns {mat3} out
 */

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {ReadonlyMat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {ReadonlyMat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {ReadonlyMat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {ReadonlyMat3} a the first operand
 * @param {ReadonlyMat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat3} a The first matrix.
 * @param {ReadonlyMat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromXRotation", function() { return fromXRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromYRotation", function() { return fromYRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromZRotation", function() { return fromZRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat2", function() { return fromQuat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaling", function() { return getScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotation", function() { return getRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScale", function() { return fromRotationTranslationScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScaleOrigin", function() { return fromRotationTranslationScaleOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frustum", function() { return frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspective", function() { return perspective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspectiveFromFieldOfView", function() { return perspectiveFromFieldOfView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ortho", function() { return ortho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookAt", function() { return lookAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetTo", function() { return targetTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {ReadonlyMat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {ReadonlyMat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {ReadonlyVec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyVec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.hypot(x, y, z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {ReadonlyQuat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {ReadonlyMat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  var scaling = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {ReadonlyVec3} v Translation vector
 * @param {ReadonlyVec3} s Scaling vector
 * @param {ReadonlyVec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {ReadonlyQuat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.hypot(z0, z1, z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.hypot(x0, x1, x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.hypot(y0, y1, y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {ReadonlyVec3} eye Position of the viewer
 * @param {ReadonlyVec3} center Point the viewer is looking at
 * @param {ReadonlyVec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
/**
 * Returns a string representation of a mat4
 *
 * @param {ReadonlyMat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {ReadonlyMat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {ReadonlyMat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {ReadonlyMat4} a the first operand
 * @param {ReadonlyMat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {ReadonlyMat4} a The first matrix.
 * @param {ReadonlyMat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat.js ***!
  \********************************************/
/*! exports provided: create, identity, setAxisAngle, getAxisAngle, getAngle, multiply, rotateX, rotateY, rotateZ, calculateW, exp, ln, pow, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisAngle", function() { return setAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisAngle", function() { return getAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAngle", function() { return getAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateW", function() { return calculateW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exp", function() { return exp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ln", function() { return ln; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slerp", function() { return slerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat3", function() { return fromMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEuler", function() { return fromEuler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationTo", function() { return rotationTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqlerp", function() { return sqlerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxes", function() { return setAxes; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/gl-matrix/esm/vec4.js");




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyVec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {ReadonlyQuat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Gets the angular distance between two unit quaternions
 *
 * @param  {ReadonlyQuat} a     Origin unit quaternion
 * @param  {ReadonlyQuat} b     Destination unit quaternion
 * @return {Number}     Angle, in radians, between the two quaternions
 */

function getAngle(a, b) {
  var dotproduct = dot(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {ReadonlyQuat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Calculate the exponential of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function exp(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
/**
 * Calculate the natural logarithm of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @returns {quat} out
 */

function ln(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
/**
 * Calculate the scalar power of a unit quaternion.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate the exponential of
 * @param {Number} b amount to scale the quaternion by
 * @returns {quat} out
 */

function pow(out, a, b) {
  ln(out, a);
  scale(out, out, b);
  exp(out, out);
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random unit quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyMat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {ReadonlyQuat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["clone"];
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["fromValues"];
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["copy"];
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["set"];
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["add"];
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {ReadonlyQuat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["scale"];
/**
 * Calculates the dot product of two quat's
 *
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["dot"];
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["lerp"];
/**
 * Calculates the length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["length"];
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {ReadonlyQuat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["squaredLength"];
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["normalize"];
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat} a The first quaternion.
 * @param {ReadonlyQuat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["exactEquals"];
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat} a The first vector.
 * @param {ReadonlyQuat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["equals"];
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {ReadonlyVec3} a the initial vector
 * @param {ReadonlyVec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["create"]();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["dot"](a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__["len"](tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {ReadonlyQuat} a the first operand
 * @param {ReadonlyQuat} b the second operand
 * @param {ReadonlyQuat} c the third operand
 * @param {ReadonlyQuat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {ReadonlyVec3} view  the vector representing the viewing direction
 * @param {ReadonlyVec3} right the vector representing the local "right" direction
 * @param {ReadonlyVec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat2.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat2.js ***!
  \*********************************************/
/*! exports provided: create, clone, fromValues, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy, identity, set, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add, multiply, mul, scale, dot, lerp, invert, conjugate, length, len, squaredLength, sqrLen, normalize, str, exactEquals, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationValues", function() { return fromRotationTranslationValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReal", function() { return getReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDual", function() { return getDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setReal", function() { return setReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDual", function() { return setDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatAppend", function() { return rotateByQuatAppend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatPrepend", function() { return rotateByQuatPrepend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAroundAxis", function() { return rotateAroundAxis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ "./node_modules/gl-matrix/esm/quat.js");
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/gl-matrix/esm/mat4.js");



/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */

function create() {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {ReadonlyQuat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */

function clone(a) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q a normalized quaternion
 * @param {ReadonlyVec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyVec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {ReadonlyQuat2} dual quaternion receiving operation result
 * @param {ReadonlyQuat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {ReadonlyMat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */

function fromMat4(out, a) {
  //TODO Optimize this
  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getRotation"](outer, a);
  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getTranslation"](t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */

function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} real part
 */

var getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {ReadonlyQuat2} a Dual Quaternion
 * @return {quat} dual part
 */

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */

var setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {ReadonlyQuat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */

function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to translate
 * @param {ReadonlyVec3} v vector to translate by
 * @returns {quat2} out
 */

function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateX"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateY"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateZ"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @returns {quat2} out
 */

function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat} q quaternion to rotate by
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */

function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the dual quaternion to rotate
 * @param {ReadonlyVec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */

function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return copy(out, a);
  }

  var axisLength = Math.hypot(axis[0], axis[1], axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 * @function
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {quat2} out
 */

function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__["dot"];
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {ReadonlyQuat2} a the first operand
 * @param {ReadonlyQuat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */

function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {ReadonlyQuat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */

var length = _quat_js__WEBPACK_IMPORTED_MODULE_1__["length"];
/**
 * Alias for {@link quat2.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {ReadonlyQuat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__["squaredLength"];
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {ReadonlyQuat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {ReadonlyQuat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */

function str(a) {
  return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")";
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyQuat2} a the first dual quaternion.
 * @param {ReadonlyQuat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {ReadonlyQuat2} a the first dual quat.
 * @param {ReadonlyQuat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec2.js ***!
  \********************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2", function() { return transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2d", function() { return transformMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {ReadonlyVec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.hypot(x, y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {ReadonlyVec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the first operand
 * @param {ReadonlyVec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {ReadonlyVec2} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {ReadonlyVec2} a The vec2 point to rotate
 * @param {ReadonlyVec2} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec2} out
 */

function rotate(out, a, b, rad) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(rad),
      cosC = Math.cos(rad); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {ReadonlyVec2} a The first operand
 * @param {ReadonlyVec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1],
      // mag is the product of the magnitudes of a and b
  mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2),
      // mag &&.. short circuits if mag == 0
  cosine = mag && (x1 * x2 + y1 * y2) / mag; // Math.min(Math.max(cosine, -1), 1) clamps the cosine between -1 and 1

  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec2(" + a[0] + ", " + a[1] + ")";
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec2} a The first vector.
 * @param {ReadonlyVec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hermite", function() { return hermite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bezier", function() { return bezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {ReadonlyVec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {ReadonlyVec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the first operand
 * @param {ReadonlyVec3} b the second operand
 * @param {ReadonlyVec3} c the third operand
 * @param {ReadonlyVec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyMat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {ReadonlyVec3} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateX(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateY(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {ReadonlyVec3} a The vec3 point to rotate
 * @param {ReadonlyVec3} b The origin of the rotation
 * @param {Number} rad The angle of rotation in radians
 * @returns {vec3} out
 */

function rotateZ(out, a, b, rad) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {ReadonlyVec3} a The first operand
 * @param {ReadonlyVec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      bx = b[0],
      by = b[1],
      bz = b[2],
      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),
      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),
      mag = mag1 * mag2,
      cosine = mag && dot(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec3} a The first vector.
 * @param {ReadonlyVec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec4.js ***!
  \********************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat4, transformQuat, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {ReadonlyVec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {ReadonlyVec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {ReadonlyVec4} result the receiving vector
 * @param {ReadonlyVec4} U the first vector
 * @param {ReadonlyVec4} V the second vector
 * @param {ReadonlyVec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the first operand
 * @param {ReadonlyVec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyMat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {ReadonlyVec4} a the vector to transform
 * @param {ReadonlyQuat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {ReadonlyVec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {ReadonlyVec4} a The first vector.
 * @param {ReadonlyVec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/seedrandom/index.js":
/*!******************************************!*\
  !*** ./node_modules/seedrandom/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baage.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = __webpack_require__(/*! ./lib/alea */ "./node_modules/seedrandom/lib/alea.js");

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = __webpack_require__(/*! ./lib/xor128 */ "./node_modules/seedrandom/lib/xor128.js");

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = __webpack_require__(/*! ./lib/xorwow */ "./node_modules/seedrandom/lib/xorwow.js");

// xorshift7, by Franois Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = __webpack_require__(/*! ./lib/xorshift7 */ "./node_modules/seedrandom/lib/xorshift7.js");

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = __webpack_require__(/*! ./lib/xor4096 */ "./node_modules/seedrandom/lib/xor4096.js");

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = __webpack_require__(/*! ./lib/tychei */ "./node_modules/seedrandom/lib/tychei.js");

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = __webpack_require__(/*! ./seedrandom */ "./node_modules/seedrandom/seedrandom.js");

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;


/***/ }),

/***/ "./node_modules/seedrandom/lib/alea.js":
/*!*********************************************!*\
  !*** ./node_modules/seedrandom/lib/alea.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A port of an algorithm by Johannes Baage <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baage <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = String(data);
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js") && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.alea = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js")   // present with an AMD loader
);



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/seedrandom/lib/tychei.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/tychei.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js") && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.tychei = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js")   // present with an AMD loader
);



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/seedrandom/lib/xor128.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xor128.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js") && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor128 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js")   // present with an AMD loader
);



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/seedrandom/lib/xor4096.js":
/*!************************************************!*\
  !*** ./node_modules/seedrandom/lib/xor4096.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js") && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
   true && module,    // present in node.js
  __webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js")   // present with an AMD loader
);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/seedrandom/lib/xorshift7.js":
/*!**************************************************!*\
  !*** ./node_modules/seedrandom/lib/xorshift7.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorshift7" algorithm by
// Franois Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js") && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorshift7 = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js")   // present with an AMD loader
);


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/seedrandom/lib/xorwow.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/lib/xorwow.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_RESULT__;// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (__webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js") && __webpack_require__(/*! !webpack amd options */ "./node_modules/webpack/buildin/amd-options.js")) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return impl; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {
  this.xorwow = impl;
}

})(
  this,
   true && module,    // present in node.js
  __webpack_require__(/*! !webpack amd define */ "./node_modules/webpack/buildin/amd-define.js")   // present with an AMD loader
);



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/seedrandom/seedrandom.js":
/*!***********************************************!*\
  !*** ./node_modules/seedrandom/seedrandom.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
Copyright 2019 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (global, pool, math) {
//
// The following constants are related to IEEE 754 limits.
//

var width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ( true && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = __webpack_require__(/*! crypto */ 1);
  } catch (ex) {}
} else if (true) {
  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return seedrandom; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}


// End anonymous scope, and pass initial values.
})(
  // global: `self` in browsers (including strict mode and web workers),
  // otherwise `this` in Node and other environments
  (typeof self !== 'undefined') ? self : this,
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/Core/CellArray/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/Core/CellArray/index.js ***!
  \********************************************************************/
/*! exports provided: STATIC, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATIC", function() { return STATIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray/Constants */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/Constants.js");




// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

function extractCellSizes(cellArray) {
  let currentIdx = 0;
  return cellArray.filter((value, index) => {
    if (index === currentIdx) {
      currentIdx += value + 1;
      return true;
    }
    return false;
  });
}

function getNumberOfCells(cellArray) {
  return extractCellSizes(cellArray).length;
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  extractCellSizes,
  getNumberOfCells,
};

// ----------------------------------------------------------------------------
// vtkCellArray methods
// ----------------------------------------------------------------------------

function vtkCellArray(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCellArray');

  publicAPI.getNumberOfCells = (recompute) => {
    if (model.numberOfCells !== undefined && !recompute) {
      return model.numberOfCells;
    }

    model.cellSizes = extractCellSizes(model.values);
    model.numberOfCells = model.cellSizes.length;
    return model.numberOfCells;
  };

  publicAPI.getCellSizes = (recompute) => {
    if (model.cellSizes !== undefined && !recompute) {
      return model.cellSizes;
    }

    model.cellSizes = extractCellSizes(model.values);
    return model.cellSizes;
  };

  const superSetData = publicAPI.setData;
  publicAPI.setData = (typedArray) => {
    superSetData(typedArray, 1);
    model.numberOfCells = undefined;
    model.cellSizes = undefined;
  };

  /**
   * Returns the point indexes at the given location as a subarray.
   */
  publicAPI.getCell = (loc) => {
    let cellLoc = loc;
    const numberOfPoints = model.values[cellLoc++];
    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  empty: true,
  numberOfComponents: 1,
  dataType: vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_2__["VtkDataTypes"].UNSIGNED_INT,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_1__["default"].extend(publicAPI, model, initialValues);
  vtkCellArray(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkCellArray');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...STATIC });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/Core/DataArray/Constants.js":
/*!************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/Core/DataArray/Constants.js ***!
  \************************************************************************/
/*! exports provided: DataTypeByteSize, VtkDataTypes, DefaultDataType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTypeByteSize", function() { return DataTypeByteSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VtkDataTypes", function() { return VtkDataTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultDataType", function() { return DefaultDataType; });
const DataTypeByteSize = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8,
};

const VtkDataTypes = {
  VOID: '', // not sure to know what that should be
  CHAR: 'Int8Array',
  SIGNED_CHAR: 'Int8Array',
  UNSIGNED_CHAR: 'Uint8Array',
  SHORT: 'Int16Array',
  UNSIGNED_SHORT: 'Uint16Array',
  INT: 'Int32Array',
  UNSIGNED_INT: 'Uint32Array',
  FLOAT: 'Float32Array',
  DOUBLE: 'Float64Array',
};

const DefaultDataType = VtkDataTypes.FLOAT;

/* harmony default export */ __webpack_exports__["default"] = ({
  DefaultDataType,
  DataTypeByteSize,
  VtkDataTypes,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/Core/DataArray/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/Core/DataArray/index.js ***!
  \********************************************************************/
/*! exports provided: STATIC, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATIC", function() { return STATIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray/Constants */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/Constants.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");




const { DefaultDataType } = vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_0__["default"];
const TUPLE_HOLDER = [];

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

function createRangeHelper() {
  let min = Number.MAX_VALUE;
  let max = -Number.MAX_VALUE;
  let count = 0;
  let sum = 0;

  return {
    add(value) {
      if (min > value) {
        min = value;
      }
      if (max < value) {
        max = value;
      }
      count++;
      sum += value;
    },
    get() {
      return { min, max, count, sum, mean: sum / count };
    },
    getRange() {
      return { min, max };
    },
  };
}

function computeRange(values, component = 0, numberOfComponents = 1) {
  const helper = createRangeHelper();
  const size = values.length;
  let value = 0;

  if (component < 0 && numberOfComponents > 1) {
    // Compute magnitude
    for (let i = 0; i < size; i += numberOfComponents) {
      value = 0;
      for (let j = 0; j < numberOfComponents; j++) {
        value += values[i + j] * values[i + j];
      }
      value **= 0.5;
      helper.add(value);
    }
    return helper.getRange();
  }

  const offset = component < 0 ? 0 : component;
  for (let i = offset; i < size; i += numberOfComponents) {
    helper.add(values[i]);
  }

  return helper.getRange();
}

function ensureRangeSize(rangeArray, size = 0) {
  const ranges = rangeArray || [];
  // Pad ranges with null value to get the
  while (ranges.length <= size) {
    ranges.push(null);
  }
  return ranges;
}

function getDataType(typedArray) {
  // Expects toString() to return "[object ...Array]"
  return Object.prototype.toString.call(typedArray).slice(8, -1);
}

function getMaxNorm(normArray) {
  const numComps = normArray.getNumberOfComponents();
  let maxNorm = 0.0;
  for (let i = 0; i < normArray.getNumberOfTuples(); ++i) {
    const norm = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["norm"](normArray.getTuple(i), numComps);
    if (norm > maxNorm) {
      maxNorm = norm;
    }
  }
  return maxNorm;
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  computeRange,
  createRangeHelper,
  getDataType,
  getMaxNorm,
};

// ----------------------------------------------------------------------------
// vtkDataArray methods
// ----------------------------------------------------------------------------

function vtkDataArray(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkDataArray');

  function dataChange() {
    model.ranges = null;
    publicAPI.modified();
  }

  publicAPI.getElementComponentSize = () => model.values.BYTES_PER_ELEMENT;

  // Description:
  // Return the data component at the location specified by tupleIdx and
  // compIdx.
  publicAPI.getComponent = (tupleIdx, compIdx = 0) =>
    model.values[tupleIdx * model.numberOfComponents + compIdx];

  // Description:
  // Set the data component at the location specified by tupleIdx and compIdx
  // to value.
  // Note that i is less than NumberOfTuples and j is less than
  //  NumberOfComponents. Make sure enough memory has been allocated
  // (use SetNumberOfTuples() and SetNumberOfComponents()).
  publicAPI.setComponent = (tupleIdx, compIdx, value) => {
    if (value !== model.values[tupleIdx * model.numberOfComponents + compIdx]) {
      model.values[tupleIdx * model.numberOfComponents + compIdx] = value;
      dataChange();
    }
  };

  publicAPI.getData = () => model.values;

  publicAPI.getRange = (componentIndex = -1) => {
    const rangeIdx =
      componentIndex < 0 ? model.numberOfComponents : componentIndex;
    let range = null;

    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    range = model.ranges[rangeIdx];

    if (range) {
      model.rangeTuple[0] = range.min;
      model.rangeTuple[1] = range.max;
      return model.rangeTuple;
    }

    // Need to compute ranges...
    range = computeRange(
      model.values,
      componentIndex,
      model.numberOfComponents
    );
    model.ranges[rangeIdx] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;
    return model.rangeTuple;
  };

  publicAPI.setRange = (rangeValue, componentIndex) => {
    if (!model.ranges) {
      model.ranges = ensureRangeSize(model.ranges, model.numberOfComponents);
    }
    const range = { min: rangeValue.min, max: rangeValue.max };

    model.ranges[componentIndex] = range;
    model.rangeTuple[0] = range.min;
    model.rangeTuple[1] = range.max;

    return model.rangeTuple;
  };

  publicAPI.setTuple = (idx, tuple) => {
    const offset = idx * model.numberOfComponents;
    for (let i = 0; i < model.numberOfComponents; i++) {
      model.values[offset + i] = tuple[i];
    }
  };

  publicAPI.getTuple = (idx, tupleToFill = TUPLE_HOLDER) => {
    const numberOfComponents = model.numberOfComponents || 1;
    if (tupleToFill.length !== numberOfComponents) {
      tupleToFill.length = numberOfComponents;
    }
    const offset = idx * numberOfComponents;
    // Check most common component sizes first
    // to avoid doing a for loop if possible
    if (numberOfComponents === 1) {
      tupleToFill[0] = model.values[offset];
    } else if (numberOfComponents === 2) {
      tupleToFill[0] = model.values[offset];
      tupleToFill[1] = model.values[offset + 1];
    } else if (numberOfComponents === 3) {
      tupleToFill[0] = model.values[offset];
      tupleToFill[1] = model.values[offset + 1];
      tupleToFill[2] = model.values[offset + 2];
    } else if (numberOfComponents === 4) {
      tupleToFill[0] = model.values[offset];
      tupleToFill[1] = model.values[offset + 1];
      tupleToFill[2] = model.values[offset + 2];
      tupleToFill[3] = model.values[offset + 3];
    } else {
      for (let i = 0; i < numberOfComponents; i++) {
        tupleToFill[i] = model.values[offset + i];
      }
    }
    return tupleToFill;
  };

  publicAPI.getTupleLocation = (idx = 1) => idx * model.numberOfComponents;
  publicAPI.getNumberOfComponents = () => model.numberOfComponents;
  publicAPI.getNumberOfValues = () => model.values.length;
  publicAPI.getNumberOfTuples = () =>
    model.values.length / model.numberOfComponents;
  publicAPI.getDataType = () => model.dataType;
  /* eslint-disable no-use-before-define */
  publicAPI.newClone = () =>
    newInstance({
      empty: true,
      name: model.name,
      dataType: model.dataType,
      numberOfComponents: model.numberOfComponents,
    });
  /* eslint-enable no-use-before-define */

  publicAPI.getName = () => {
    if (!model.name) {
      publicAPI.modified();
      model.name = `vtkDataArray${publicAPI.getMTime()}`;
    }
    return model.name;
  };

  publicAPI.setData = (typedArray, numberOfComponents) => {
    model.values = typedArray;
    model.size = typedArray.length;
    model.dataType = getDataType(typedArray);
    if (numberOfComponents) {
      model.numberOfComponents = numberOfComponents;
    }
    if (model.size % model.numberOfComponents !== 0) {
      model.numberOfComponents = 1;
    }
    dataChange();
  };

  // Override serialization support
  publicAPI.getState = () => {
    const jsonArchive = { ...model, vtkClass: publicAPI.getClassName() };

    // Convert typed array to regular array
    jsonArchive.values = Array.from(jsonArchive.values);
    delete jsonArchive.buffer;

    // Clean any empty data
    Object.keys(jsonArchive).forEach((keyName) => {
      if (!jsonArchive[keyName]) {
        delete jsonArchive[keyName];
      }
    });

    // Sort resulting object by key name
    const sortedObj = {};
    Object.keys(jsonArchive)
      .sort()
      .forEach((name) => {
        sortedObj[name] = jsonArchive[name];
      });

    // Remove mtime
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }

    return sortedObj;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  name: '',
  numberOfComponents: 1,
  size: 0,
  dataType: DefaultDataType,
  rangeTuple: [0, 0],
  // values: null,
  // ranges: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  if (!model.empty && !model.values && !model.size) {
    throw new TypeError(
      'Cannot create vtkDataArray object without: size > 0, values'
    );
  }

  if (!model.values) {
    model.values = new window[model.dataType](model.size);
  } else if (Array.isArray(model.values)) {
    model.values = window[model.dataType].from(model.values);
  }

  if (model.values) {
    model.size = model.values.length;
    model.dataType = getDataType(model.values);
  }

  // Object methods
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["obj"](publicAPI, model);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["set"](publicAPI, model, ['name', 'numberOfComponents']);

  // Object specific methods
  vtkDataArray(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["newInstance"](extend, 'vtkDataArray');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...STATIC, ...vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_0__["default"] });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/Core/LookupTable/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/Core/LookupTable/index.js ***!
  \**********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_ScalarsToColors__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/ScalarsToColors */ "./node_modules/vtk.js/Sources/Common/Core/ScalarsToColors/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_ScalarsToColors_Constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/ScalarsToColors/Constants */ "./node_modules/vtk.js/Sources/Common/Core/ScalarsToColors/Constants.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray/Constants */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/Constants.js");







const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// Add module-level functions or api that you want to expose statically via
// the next section...

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const BELOW_RANGE_COLOR_INDEX = 0;
const ABOVE_RANGE_COLOR_INDEX = 1;
const NAN_COLOR_INDEX = 2;

// ----------------------------------------------------------------------------
// vtkMyClass methods
// ----------------------------------------------------------------------------

function vtkLookupTable(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkLookupTable');

  //----------------------------------------------------------------------------
  // Description:
  // Return true if all of the values defining the mapping have an opacity
  // equal to 1. Default implementation return true.
  publicAPI.isOpaque = () => {
    if (model.opaqueFlagBuildTime.getMTime() < publicAPI.getMTime()) {
      let opaque = true;
      if (model.nanColor[3] < 1.0) {
        opaque = 0;
      }
      if (model.useBelowRangeColor && model.belowRangeColor[3] < 1.0) {
        opaque = 0;
      }
      if (model.useAboveRangeColor && model.aboveRangeColor[3] < 1.0) {
        opaque = 0;
      }
      for (let i = 3; i < model.table.length && opaque; i += 4) {
        if (model.table[i] < 255) {
          opaque = false;
        }
      }
      model.opaqueFlag = opaque;
      model.opaqueFlagBuildTime.modified();
    }

    return model.opaqueFlag;
  };

  publicAPI.usingLogScale = () => false;

  //----------------------------------------------------------------------------
  publicAPI.getNumberOfAvailableColors = () => model.table.length;

  //----------------------------------------------------------------------------
  // Apply shift/scale to the scalar value v and return the index.
  publicAPI.linearIndexLookup = (v, p) => {
    let dIndex = 0;

    if (v < p.range[0]) {
      dIndex = p.maxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
    } else if (v > p.range[1]) {
      dIndex = p.maxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
    } else {
      dIndex = (v + p.shift) * p.scale;

      // This conditional is needed because when v is very close to
      // p.Range[1], it may map above p.MaxIndex in the linear mapping
      // above.
      dIndex = dIndex < p.maxIndex ? dIndex : p.maxIndex;
    }

    return Math.floor(dIndex);
  };

  publicAPI.linearLookup = (v, table, p) => {
    let index = 0;
    if (vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["isNan"](v)) {
      index = Math.floor(p.maxIndex + 1.5 + NAN_COLOR_INDEX);
    } else {
      index = publicAPI.linearIndexLookup(v, p);
    }
    const offset = 4 * index;
    return [
      table[offset],
      table[offset + 1],
      table[offset + 2],
      table[offset + 3],
    ];
  };

  publicAPI.indexedLookupFunction = (v, table, p) => {
    let index = publicAPI.getAnnotatedValueIndexInternal(v);
    if (index === -1) {
      index = model.numberOfColors + NAN_COLOR_INDEX;
    }
    const offset = 4 * index;
    return [
      table[offset],
      table[offset + 1],
      table[offset + 2],
      table[offset + 3],
    ];
  };

  //----------------------------------------------------------------------------
  publicAPI.lookupShiftAndScale = (range, p) => {
    p.shift = -range[0];
    p.scale = Number.MAX_VALUE;
    if (range[1] > range[0]) {
      p.scale = (p.maxIndex + 1) / (range[1] - range[0]);
    }
  };

  // Public API methods
  publicAPI.mapScalarsThroughTable = (
    input,
    output,
    outFormat,
    inputOffset
  ) => {
    let lookupFunc = publicAPI.linearLookup;
    if (model.indexedLookup) {
      lookupFunc = publicAPI.indexedLookupFunction;
    }

    const trange = publicAPI.getMappingRange();

    const p = {
      maxIndex: publicAPI.getNumberOfColors() - 1,
      range: trange,
      shift: 0.0,
      scale: 0.0,
    };
    publicAPI.lookupShiftAndScale(trange, p);

    const alpha = publicAPI.getAlpha();
    const length = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();

    const outputV = output.getData();
    const inputV = input.getData();

    if (alpha >= 1.0) {
      if (outFormat === vtk_js_Sources_Common_Core_ScalarsToColors_Constants__WEBPACK_IMPORTED_MODULE_3__["ScalarMappingTarget"].RGBA) {
        for (let i = 0; i < length; i++) {
          const cptr = lookupFunc(
            inputV[i * inIncr + inputOffset],
            model.table,
            p
          );
          outputV[i * 4] = cptr[0];
          outputV[i * 4 + 1] = cptr[1];
          outputV[i * 4 + 2] = cptr[2];
          outputV[i * 4 + 3] = cptr[3];
        }
      }
    } else {
      /* eslint-disable no-lonely-if */
      if (outFormat === vtk_js_Sources_Common_Core_ScalarsToColors_Constants__WEBPACK_IMPORTED_MODULE_3__["ScalarMappingTarget"].RGBA) {
        for (let i = 0; i < length; i++) {
          const cptr = lookupFunc(
            inputV[i * inIncr + inputOffset],
            model.table,
            p
          );
          outputV[i * 4] = cptr[0];
          outputV[i * 4 + 1] = cptr[1];
          outputV[i * 4 + 2] = cptr[2];
          outputV[i * 4 + 3] = Math.floor(cptr[3] * alpha + 0.5);
        }
      }
    } // alpha blending
  };

  publicAPI.forceBuild = () => {
    let hinc = 0.0;
    let sinc = 0.0;
    let vinc = 0.0;
    let ainc = 0.0;

    const maxIndex = model.numberOfColors - 1;

    if (maxIndex) {
      hinc = (model.hueRange[1] - model.hueRange[0]) / maxIndex;
      sinc = (model.saturationRange[1] - model.saturationRange[0]) / maxIndex;
      vinc = (model.valueRange[1] - model.valueRange[0]) / maxIndex;
      ainc = (model.alphaRange[1] - model.alphaRange[0]) / maxIndex;
    }

    const hsv = [];
    const rgba = [];
    for (let i = 0; i <= maxIndex; i++) {
      hsv[0] = model.hueRange[0] + i * hinc;
      hsv[1] = model.saturationRange[0] + i * sinc;
      hsv[2] = model.valueRange[0] + i * vinc;

      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["hsv2rgb"](hsv, rgba);
      rgba[3] = model.alphaRange[0] + i * ainc;

      //  case VTK_RAMP_LINEAR:
      model.table[i * 4] = rgba[0] * 255.0 + 0.5;
      model.table[i * 4 + 1] = rgba[1] * 255.0 + 0.5;
      model.table[i * 4 + 2] = rgba[2] * 255.0 + 0.5;
      model.table[i * 4 + 3] = rgba[3] * 255.0 + 0.5;
    }

    publicAPI.buildSpecialColors();

    model.buildTime.modified();
  };

  publicAPI.setTable = (table) => {
    if (table.getNumberOfComponents() !== 4) {
      vtkErrorMacro('Expected 4 components for RGBA colors');
      return;
    }
    if (table.getDataType() !== vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_4__["VtkDataTypes"].UNSIGNED_CHAR) {
      vtkErrorMacro('Expected unsigned char values for RGBA colors');
      return;
    }
    model.numberOfColors = table.getNumberOfTuples();
    const data = table.getData();
    for (let i = 0; i < data.length; i++) {
      model.table[i] = data[i];
    }

    publicAPI.buildSpecialColors();
    model.insertTime.modified();
    publicAPI.modified();
  };

  publicAPI.buildSpecialColors = () => {
    // Add "special" colors (NaN, below range, above range) to table here.
    const { numberOfColors } = model;

    const tptr = model.table;
    let base = (numberOfColors + BELOW_RANGE_COLOR_INDEX) * 4;

    // Below range color
    if (model.useBelowRangeColor || numberOfColors === 0) {
      tptr[base] = model.belowRangeColor[0] * 255.0 + 0.5;
      tptr[base + 1] = model.belowRangeColor[1] * 255.0 + 0.5;
      tptr[base + 2] = model.belowRangeColor[2] * 255.0 + 0.5;
      tptr[base + 3] = model.belowRangeColor[3] * 255.0 + 0.5;
    } else {
      // Duplicate the first color in the table.
      tptr[base] = tptr[0];
      tptr[base + 1] = tptr[1];
      tptr[base + 2] = tptr[2];
      tptr[base + 3] = tptr[3];
    }

    // Above range color
    base = (numberOfColors + ABOVE_RANGE_COLOR_INDEX) * 4;
    if (model.useAboveRangeColor || numberOfColors === 0) {
      tptr[base] = model.aboveRangeColor[0] * 255.0 + 0.5;
      tptr[base + 1] = model.aboveRangeColor[1] * 255.0 + 0.5;
      tptr[base + 2] = model.aboveRangeColor[2] * 255.0 + 0.5;
      tptr[base + 3] = model.aboveRangeColor[3] * 255.0 + 0.5;
    } else {
      // Duplicate the last color in the table.
      tptr[base] = tptr[4 * (numberOfColors - 1) + 0];
      tptr[base + 1] = tptr[4 * (numberOfColors - 1) + 1];
      tptr[base + 2] = tptr[4 * (numberOfColors - 1) + 2];
      tptr[base + 3] = tptr[4 * (numberOfColors - 1) + 3];
    }

    // Always use NanColor
    base = (numberOfColors + NAN_COLOR_INDEX) * 4;
    tptr[base] = model.nanColor[0] * 255.0 + 0.5;
    tptr[base + 1] = model.nanColor[1] * 255.0 + 0.5;
    tptr[base + 2] = model.nanColor[2] * 255.0 + 0.5;
    tptr[base + 3] = model.nanColor[3] * 255.0 + 0.5;
  };

  publicAPI.build = () => {
    if (
      model.table.length < 1 ||
      (publicAPI.getMTime() > model.buildTime.getMTime() &&
        model.insertTime.getMTime() <= model.buildTime.getMTime())
    ) {
      publicAPI.forceBuild();
    }
  };

  if (model.table.length > 0) {
    // ensure insertTime is more recently modified than buildTime if
    // a table is provided via the constructor
    model.insertTime.modified();
  }
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  numberOfColors: 256,
  // table: null,

  hueRange: [0.0, 0.66667],
  saturationRange: [1.0, 1.0],
  valueRange: [1.0, 1.0],
  alphaRange: [1.0, 1.0],

  nanColor: [0.5, 0.0, 0.0, 1.0],
  belowRangeColor: [0.0, 0.0, 0.0, 1.0],
  aboveRangeColor: [1.0, 1.0, 1.0, 1.0],
  useAboveRangeColor: false,
  useBelowRangeColor: false,

  alpha: 1.0,
  // buildTime: null,
  // opaqueFlagBuildTime: null,
  // insertTime: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Common_Core_ScalarsToColors__WEBPACK_IMPORTED_MODULE_2__["default"].extend(publicAPI, model, initialValues);

  // Internal objects initialization
  if (!model.table) {
    model.table = [];
  }

  model.buildTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(model.buildTime);

  model.opaqueFlagBuildTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(model.opaqueFlagBuildTime, { mtime: 0 });

  model.insertTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(model.insertTime, { mtime: 0 });

  // Create get-only macros
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['buildTime']);

  // Create get-set macros
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'numberOfColors',
    'useAboveRangeColor',
    'useBelowRangeColor',
  ]);

  // Create set macros for array (needs to know size)
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setArray(
    publicAPI,
    model,
    ['alphaRange', 'hueRange', 'saturationRange', 'valueRange'],
    2
  );

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setArray(
    publicAPI,
    model,
    ['nanColor', 'belowRangeColor', 'aboveRangeColor'],
    4
  );

  // Create get macros for array
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].getArray(publicAPI, model, [
    'hueRange',
    'saturationRange',
    'valueRange',
    'alphaRange',
    'nanColor',
    'belowRangeColor',
    'aboveRangeColor',
  ]);

  // For more macro methods, see "Sources/macro.js"

  // Object specific methods
  vtkLookupTable(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkLookupTable');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/Core/Math/index.js ***!
  \***************************************************************/
/*! exports provided: Pi, radiansFromDegrees, degreesFromRadians, round, floor, ceil, min, max, arrayMin, arrayMax, arrayRange, ceilLog2, factorial, nearestPowerOfTwo, isPowerOfTwo, binomial, beginCombination, nextCombination, randomSeed, getSeed, random, gaussian, add, subtract, multiplyScalar, multiplyScalar2D, multiplyAccumulate, multiplyAccumulate2D, dot, outer, cross, norm, normalize, perpendiculars, projectVector, dot2D, projectVector2D, distance2BetweenPoints, angleBetweenVectors, gaussianAmplitude, gaussianWeight, outer2D, norm2D, normalize2D, determinant2x2, LUFactor3x3, LUSolve3x3, linearSolve3x3, multiply3x3_vect3, multiply3x3_mat3, multiplyMatrix, transpose3x3, invert3x3, identity3x3, determinant3x3, quaternionToMatrix3x3, areEquals, areMatricesEqual, jacobiN, matrix3x3ToQuaternion, multiplyQuaternion, orthogonalize3x3, diagonalize3x3, singularValueDecomposition3x3, luFactorLinearSystem, luSolveLinearSystem, solveLinearSystem, invertMatrix, estimateMatrixCondition, jacobi, solveHomogeneousLeastSquares, solveLeastSquares, hex2float, rgb2hsv, hsv2rgb, lab2xyz, xyz2lab, xyz2rgb, rgb2xyz, rgb2lab, lab2rgb, uninitializeBounds, areBoundsInitialized, computeBoundsFromPoints, clampValue, clampVector, roundVector, clampAndNormalizeValue, getScalarTypeFittingRange, getAdjustedScalarRange, extentIsWithinOtherExtent, boundsIsWithinOtherBounds, pointIsWithinBounds, solve3PointCircle, inf, negInf, isInf, isFinite, isNaN, isNan, createUninitializedBounds, getMajorAxisIndex, floatToHex2, floatRGB2HexCode, float2CssRGBA, rotateVector, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Pi", function() { return Pi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radiansFromDegrees", function() { return radiansFromDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degreesFromRadians", function() { return degreesFromRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayMin", function() { return arrayMin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayMax", function() { return arrayMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayRange", function() { return arrayRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceilLog2", function() { return ceilLog2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "factorial", function() { return factorial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nearestPowerOfTwo", function() { return nearestPowerOfTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPowerOfTwo", function() { return isPowerOfTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binomial", function() { return binomial; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "beginCombination", function() { return beginCombination; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextCombination", function() { return nextCombination; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomSeed", function() { return randomSeed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSeed", function() { return getSeed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gaussian", function() { return gaussian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar2D", function() { return multiplyScalar2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyAccumulate", function() { return multiplyAccumulate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyAccumulate2D", function() { return multiplyAccumulate2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outer", function() { return outer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "norm", function() { return norm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perpendiculars", function() { return perpendiculars; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projectVector", function() { return projectVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot2D", function() { return dot2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projectVector2D", function() { return projectVector2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance2BetweenPoints", function() { return distance2BetweenPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angleBetweenVectors", function() { return angleBetweenVectors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gaussianAmplitude", function() { return gaussianAmplitude; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gaussianWeight", function() { return gaussianWeight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "outer2D", function() { return outer2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "norm2D", function() { return norm2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize2D", function() { return normalize2D; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant2x2", function() { return determinant2x2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LUFactor3x3", function() { return LUFactor3x3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LUSolve3x3", function() { return LUSolve3x3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linearSolve3x3", function() { return linearSolve3x3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply3x3_vect3", function() { return multiply3x3_vect3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply3x3_mat3", function() { return multiply3x3_mat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyMatrix", function() { return multiplyMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose3x3", function() { return transpose3x3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert3x3", function() { return invert3x3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity3x3", function() { return identity3x3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant3x3", function() { return determinant3x3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "quaternionToMatrix3x3", function() { return quaternionToMatrix3x3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areEquals", function() { return areEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areMatricesEqual", function() { return areMatricesEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "jacobiN", function() { return jacobiN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "matrix3x3ToQuaternion", function() { return matrix3x3ToQuaternion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyQuaternion", function() { return multiplyQuaternion; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "orthogonalize3x3", function() { return orthogonalize3x3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "diagonalize3x3", function() { return diagonalize3x3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "singularValueDecomposition3x3", function() { return singularValueDecomposition3x3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "luFactorLinearSystem", function() { return luFactorLinearSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "luSolveLinearSystem", function() { return luSolveLinearSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solveLinearSystem", function() { return solveLinearSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invertMatrix", function() { return invertMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "estimateMatrixCondition", function() { return estimateMatrixCondition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "jacobi", function() { return jacobi; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solveHomogeneousLeastSquares", function() { return solveHomogeneousLeastSquares; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solveLeastSquares", function() { return solveLeastSquares; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hex2float", function() { return hex2float; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb2hsv", function() { return rgb2hsv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsv2rgb", function() { return hsv2rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lab2xyz", function() { return lab2xyz; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xyz2lab", function() { return xyz2lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "xyz2rgb", function() { return xyz2rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb2xyz", function() { return rgb2xyz; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb2lab", function() { return rgb2lab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lab2rgb", function() { return lab2rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uninitializeBounds", function() { return uninitializeBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areBoundsInitialized", function() { return areBoundsInitialized; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeBoundsFromPoints", function() { return computeBoundsFromPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clampValue", function() { return clampValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clampVector", function() { return clampVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "roundVector", function() { return roundVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clampAndNormalizeValue", function() { return clampAndNormalizeValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScalarTypeFittingRange", function() { return getScalarTypeFittingRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAdjustedScalarRange", function() { return getAdjustedScalarRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extentIsWithinOtherExtent", function() { return extentIsWithinOtherExtent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "boundsIsWithinOtherBounds", function() { return boundsIsWithinOtherBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointIsWithinBounds", function() { return pointIsWithinBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "solve3PointCircle", function() { return solve3PointCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inf", function() { return inf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negInf", function() { return negInf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isInf", function() { return isInf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFinite", function() { return isFinite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNaN", function() { return isNaN; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNan", function() { return isNan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createUninitializedBounds", function() { return createUninitializedBounds; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMajorAxisIndex", function() { return getMajorAxisIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatToHex2", function() { return floatToHex2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floatRGB2HexCode", function() { return floatRGB2HexCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "float2CssRGBA", function() { return float2CssRGBA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateVector", function() { return rotateVector; });
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! seedrandom */ "./node_modules/seedrandom/index.js");
/* harmony import */ var seedrandom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(seedrandom__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/MatrixBuilder */ "./node_modules/vtk.js/Sources/Common/Core/MatrixBuilder/index.js");



// eslint-disable-next-line import/no-cycle


const { vtkErrorMacro, vtkWarningMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"];

// ----------------------------------------------------------------------------
/* eslint-disable camelcase                                                  */
/* eslint-disable no-cond-assign                                             */
/* eslint-disable no-bitwise                                                 */
/* eslint-disable no-multi-assign                                            */
// ----------------------------------------------------------------------------
let randomSeedValue = 0;
const VTK_MAX_ROTATIONS = 20;
const VTK_SMALL_NUMBER = 1.0e-12;

function notImplemented(method) {
  return () => vtkErrorMacro(`vtkMath::${method} - NOT IMPLEMENTED`);
}

function vtkSwapVectors3(v1, v2) {
  for (let i = 0; i < 3; i++) {
    const tmp = v1[i];
    v1[i] = v2[i];
    v2[i] = tmp;
  }
}

function createArray(size = 3) {
  const array = [];
  while (array.length < size) {
    array.push(0);
  }
  return array;
}

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

const Pi = () => Math.PI;

function radiansFromDegrees(deg) {
  return (deg / 180) * Math.PI;
}

function degreesFromRadians(rad) {
  return (rad * 180) / Math.PI;
}

const { round, floor, ceil, min, max } = Math;

function arrayMin(arr, offset = 0, stride = 1) {
  let minValue = Infinity;
  for (let i = offset, len = arr.length; i < len; i += stride) {
    if (arr[i] < minValue) {
      minValue = arr[i];
    }
  }

  return minValue;
}

function arrayMax(arr, offset = 0, stride = 1) {
  let maxValue = -Infinity;
  for (let i = offset, len = arr.length; i < len; i += stride) {
    if (maxValue < arr[i]) {
      maxValue = arr[i];
    }
  }

  return maxValue;
}

function arrayRange(arr, offset = 0, stride = 1) {
  let minValue = Infinity;
  let maxValue = -Infinity;
  for (let i = offset, len = arr.length; i < len; i += stride) {
    if (arr[i] < minValue) {
      minValue = arr[i];
    }
    if (maxValue < arr[i]) {
      maxValue = arr[i];
    }
  }

  return [minValue, maxValue];
}

const ceilLog2 = notImplemented('ceilLog2');
const factorial = notImplemented('factorial');

function nearestPowerOfTwo(xi) {
  let v = 1;
  while (v < xi) {
    v *= 2;
  }
  return v;
}

function isPowerOfTwo(x) {
  return x === nearestPowerOfTwo(x);
}

function binomial(m, n) {
  let r = 1;
  for (let i = 1; i <= n; ++i) {
    r *= (m - i + 1) / i;
  }
  return Math.floor(r);
}

function beginCombination(m, n) {
  if (m < n) {
    return 0;
  }

  const r = createArray(n);
  for (let i = 0; i < n; ++i) {
    r[i] = i;
  }
  return r;
}

function nextCombination(m, n, r) {
  let status = 0;
  for (let i = n - 1; i >= 0; --i) {
    if (r[i] < m - n + i) {
      let j = r[i] + 1;
      while (i < n) {
        r[i++] = j++;
      }
      status = 1;
      break;
    }
  }
  return status;
}

function randomSeed(seed) {
  seedrandom__WEBPACK_IMPORTED_MODULE_0___default()(`${seed}`, { global: true });
  randomSeedValue = seed;
}

function getSeed() {
  return randomSeedValue;
}

function random(minValue = 0, maxValue = 1) {
  const delta = maxValue - minValue;
  return minValue + delta * Math.random();
}

const gaussian = notImplemented('gaussian');

// Vect3 operations
function add(a, b, out) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

function subtract(a, b, out) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

function multiplyScalar(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  vec[2] *= scalar;
  return vec;
}

function multiplyScalar2D(vec, scalar) {
  vec[0] *= scalar;
  vec[1] *= scalar;
  return vec;
}

function multiplyAccumulate(a, b, scalar, out) {
  out[0] = a[0] + b[0] * scalar;
  out[1] = a[1] + b[1] * scalar;
  out[2] = a[2] + b[2] * scalar;
  return out;
}

function multiplyAccumulate2D(a, b, scalar, out) {
  out[0] = a[0] + b[0] * scalar;
  out[1] = a[1] + b[1] * scalar;
  return out;
}

function dot(x, y) {
  return x[0] * y[0] + x[1] * y[1] + x[2] * y[2];
}

function outer(x, y, out_3x3) {
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      out_3x3[i][j] = x[i] * y[j];
    }
  }
}

function cross(x, y, out) {
  const Zx = x[1] * y[2] - x[2] * y[1];
  const Zy = x[2] * y[0] - x[0] * y[2];
  const Zz = x[0] * y[1] - x[1] * y[0];
  out[0] = Zx;
  out[1] = Zy;
  out[2] = Zz;
  return out;
}

function norm(x, n = 3) {
  switch (n) {
    case 1:
      return Math.abs(x);
    case 2:
      return Math.sqrt(x[0] * x[0] + x[1] * x[1]);
    case 3:
      return Math.sqrt(x[0] * x[0] + x[1] * x[1] + x[2] * x[2]);
    default: {
      let sum = 0;
      for (let i = 0; i < n; i++) {
        sum += x[i] * x[i];
      }
      return Math.sqrt(sum);
    }
  }
}

function normalize(x) {
  const den = norm(x);
  if (den !== 0.0) {
    x[0] /= den;
    x[1] /= den;
    x[2] /= den;
  }
  return den;
}

function perpendiculars(x, y, z, theta) {
  const x2 = x[0] * x[0];
  const y2 = x[1] * x[1];
  const z2 = x[2] * x[2];
  const r = Math.sqrt(x2 + y2 + z2);

  let dx;
  let dy;
  let dz;

  // transpose the vector to avoid divide-by-zero error
  if (x2 > y2 && x2 > z2) {
    dx = 0;
    dy = 1;
    dz = 2;
  } else if (y2 > z2) {
    dx = 1;
    dy = 2;
    dz = 0;
  } else {
    dx = 2;
    dy = 0;
    dz = 1;
  }

  const a = x[dx] / r;
  const b = x[dy] / r;
  const c = x[dz] / r;
  const tmp = Math.sqrt(a * a + c * c);

  if (theta !== 0) {
    const sintheta = Math.sin(theta);
    const costheta = Math.cos(theta);

    if (y) {
      y[dx] = (c * costheta - a * b * sintheta) / tmp;
      y[dy] = sintheta * tmp;
      y[dz] = (-(a * costheta) - b * c * sintheta) / tmp;
    }

    if (z) {
      z[dx] = (-(c * sintheta) - a * b * costheta) / tmp;
      z[dy] = costheta * tmp;
      z[dz] = (a * sintheta - b * c * costheta) / tmp;
    }
  } else {
    if (y) {
      y[dx] = c / tmp;
      y[dy] = 0;
      y[dz] = -a / tmp;
    }

    if (z) {
      z[dx] = (-a * b) / tmp;
      z[dy] = tmp;
      z[dz] = (-b * c) / tmp;
    }
  }
}

function projectVector(a, b, projection) {
  const bSquared = dot(b, b);

  if (bSquared === 0) {
    projection[0] = 0;
    projection[1] = 0;
    projection[2] = 0;
    return false;
  }

  const scale = dot(a, b) / bSquared;

  for (let i = 0; i < 3; i++) {
    projection[i] = b[i];
  }
  multiplyScalar(projection, scale);

  return true;
}

function dot2D(x, y) {
  return x[0] * y[0] + x[1] * y[1];
}

function projectVector2D(a, b, projection) {
  const bSquared = dot2D(b, b);

  if (bSquared === 0) {
    projection[0] = 0;
    projection[1] = 0;
    return false;
  }

  const scale = dot2D(a, b) / bSquared;

  for (let i = 0; i < 2; i++) {
    projection[i] = b[i];
  }
  multiplyScalar2D(projection, scale);

  return true;
}

function distance2BetweenPoints(x, y) {
  return (
    (x[0] - y[0]) * (x[0] - y[0]) +
    (x[1] - y[1]) * (x[1] - y[1]) +
    (x[2] - y[2]) * (x[2] - y[2])
  );
}

function angleBetweenVectors(v1, v2) {
  const crossVect = [0, 0, 0];
  cross(v1, v2, crossVect);
  return Math.atan2(norm(crossVect), dot(v1, v2));
}

function gaussianAmplitude(mean, variance, position) {
  const distanceFromMean = Math.abs(mean - position);
  return (
    (1 / Math.sqrt(2 * Math.PI * variance)) *
    Math.exp(-(distanceFromMean ** 2) / (2 * variance))
  );
}

function gaussianWeight(mean, variance, position) {
  const distanceFromMean = Math.abs(mean - position);
  return Math.exp(-(distanceFromMean ** 2) / (2 * variance));
}

function outer2D(x, y, out_2x2) {
  for (let i = 0; i < 2; i++) {
    for (let j = 0; j < 2; j++) {
      out_2x2[i][j] = x[i] * y[j];
    }
  }
}

function norm2D(x2D) {
  return Math.sqrt(x2D[0] * x2D[0] + x2D[1] * x2D[1]);
}

function normalize2D(x) {
  const den = norm2D(x);
  if (den !== 0.0) {
    x[0] /= den;
    x[1] /= den;
  }
  return den;
}

function determinant2x2(...args) {
  if (args.length === 2) {
    return args[0][0] * args[1][1] - args[1][0] * args[0][1];
  }
  if (args.length === 4) {
    return args[0] * args[3] - args[1] * args[2];
  }
  return Number.NaN;
}

function LUFactor3x3(mat_3x3, index_3) {
  let maxI;
  let tmp;
  let largest;
  const scale = [0, 0, 0];

  // Loop over rows to get implicit scaling information
  for (let i = 0; i < 3; i++) {
    largest = Math.abs(mat_3x3[i][0]);
    if ((tmp = Math.abs(mat_3x3[i][1])) > largest) {
      largest = tmp;
    }
    if ((tmp = Math.abs(mat_3x3[i][2])) > largest) {
      largest = tmp;
    }
    scale[i] = 1 / largest;
  }

  // Loop over all columns using Crout's method

  // first column
  largest = scale[0] * Math.abs(mat_3x3[0][0]);
  maxI = 0;
  if ((tmp = scale[1] * Math.abs(mat_3x3[1][0])) >= largest) {
    largest = tmp;
    maxI = 1;
  }
  if ((tmp = scale[2] * Math.abs(mat_3x3[2][0])) >= largest) {
    maxI = 2;
  }
  if (maxI !== 0) {
    vtkSwapVectors3(mat_3x3[maxI], mat_3x3[0]);
    scale[maxI] = scale[0];
  }
  index_3[0] = maxI;

  mat_3x3[1][0] /= mat_3x3[0][0];
  mat_3x3[2][0] /= mat_3x3[0][0];

  // second column
  mat_3x3[1][1] -= mat_3x3[1][0] * mat_3x3[0][1];
  mat_3x3[2][1] -= mat_3x3[2][0] * mat_3x3[0][1];
  largest = scale[1] * Math.abs(mat_3x3[1][1]);
  maxI = 1;
  if ((tmp = scale[2] * Math.abs(mat_3x3[2][1])) >= largest) {
    maxI = 2;
    vtkSwapVectors3(mat_3x3[2], mat_3x3[1]);
    scale[2] = scale[1];
  }
  index_3[1] = maxI;
  mat_3x3[2][1] /= mat_3x3[1][1];

  // third column
  mat_3x3[1][2] -= mat_3x3[1][0] * mat_3x3[0][2];
  mat_3x3[2][2] -=
    mat_3x3[2][0] * mat_3x3[0][2] + mat_3x3[2][1] * mat_3x3[1][2];
  index_3[2] = 2;
}

function LUSolve3x3(mat_3x3, index_3, x_3) {
  // forward substitution
  let sum = x_3[index_3[0]];
  x_3[index_3[0]] = x_3[0];
  x_3[0] = sum;

  sum = x_3[index_3[1]];
  x_3[index_3[1]] = x_3[1];
  x_3[1] = sum - mat_3x3[1][0] * x_3[0];

  sum = x_3[index_3[2]];
  x_3[index_3[2]] = x_3[2];
  x_3[2] = sum - mat_3x3[2][0] * x_3[0] - mat_3x3[2][1] * x_3[1];

  // back substitution
  x_3[2] /= mat_3x3[2][2];
  x_3[1] = (x_3[1] - mat_3x3[1][2] * x_3[2]) / mat_3x3[1][1];
  x_3[0] =
    (x_3[0] - mat_3x3[0][1] * x_3[1] - mat_3x3[0][2] * x_3[2]) / mat_3x3[0][0];
}

function linearSolve3x3(mat_3x3, x_3, y_3) {
  const a1 = mat_3x3[0][0];
  const b1 = mat_3x3[0][1];
  const c1 = mat_3x3[0][2];
  const a2 = mat_3x3[1][0];
  const b2 = mat_3x3[1][1];
  const c2 = mat_3x3[1][2];
  const a3 = mat_3x3[2][0];
  const b3 = mat_3x3[2][1];
  const c3 = mat_3x3[2][2];

  // Compute the adjoint
  const d1 = +determinant2x2(b2, b3, c2, c3);
  const d2 = -determinant2x2(a2, a3, c2, c3);
  const d3 = +determinant2x2(a2, a3, b2, b3);

  const e1 = -determinant2x2(b1, b3, c1, c3);
  const e2 = +determinant2x2(a1, a3, c1, c3);
  const e3 = -determinant2x2(a1, a3, b1, b3);

  const f1 = +determinant2x2(b1, b2, c1, c2);
  const f2 = -determinant2x2(a1, a2, c1, c2);
  const f3 = +determinant2x2(a1, a2, b1, b2);

  // Compute the determinant
  const det = a1 * d1 + b1 * d2 + c1 * d3;

  // Multiply by the adjoint
  const v1 = d1 * x_3[0] + e1 * x_3[1] + f1 * x_3[2];
  const v2 = d2 * x_3[0] + e2 * x_3[1] + f2 * x_3[2];
  const v3 = d3 * x_3[0] + e3 * x_3[1] + f3 * x_3[2];

  // Divide by the determinant
  y_3[0] = v1 / det;
  y_3[1] = v2 / det;
  y_3[2] = v3 / det;
}

function multiply3x3_vect3(mat_3x3, in_3, out_3) {
  const x =
    mat_3x3[0][0] * in_3[0] + mat_3x3[0][1] * in_3[1] + mat_3x3[0][2] * in_3[2];
  const y =
    mat_3x3[1][0] * in_3[0] + mat_3x3[1][1] * in_3[1] + mat_3x3[1][2] * in_3[2];
  const z =
    mat_3x3[2][0] * in_3[0] + mat_3x3[2][1] * in_3[1] + mat_3x3[2][2] * in_3[2];

  out_3[0] = x;
  out_3[1] = y;
  out_3[2] = z;
}

function multiply3x3_mat3(a_3x3, b_3x3, out_3x3) {
  const tmp = [
    [0, 0, 0],
    [0, 0, 0],
    [0, 0, 0],
  ];

  for (let i = 0; i < 3; i++) {
    tmp[0][i] =
      a_3x3[0][0] * b_3x3[0][i] +
      a_3x3[0][1] * b_3x3[1][i] +
      a_3x3[0][2] * b_3x3[2][i];
    tmp[1][i] =
      a_3x3[1][0] * b_3x3[0][i] +
      a_3x3[1][1] * b_3x3[1][i] +
      a_3x3[1][2] * b_3x3[2][i];
    tmp[2][i] =
      a_3x3[2][0] * b_3x3[0][i] +
      a_3x3[2][1] * b_3x3[1][i] +
      a_3x3[2][2] * b_3x3[2][i];
  }

  for (let j = 0; j < 3; j++) {
    out_3x3[j][0] = tmp[j][0];
    out_3x3[j][1] = tmp[j][1];
    out_3x3[j][2] = tmp[j][2];
  }
}

function multiplyMatrix(a, b, rowA, colA, rowB, colB, out_rowXcol) {
  // we need colA == rowB
  if (colA !== rowB) {
    vtkErrorMacro('Number of columns of A must match number of rows of B.');
  }

  // output matrix is rowA*colB
  // output row
  for (let i = 0; i < rowA; i++) {
    // output col
    for (let j = 0; j < colB; j++) {
      out_rowXcol[i][j] = 0;
      // sum for this point
      for (let k = 0; k < colA; k++) {
        out_rowXcol[i][j] += a[i][k] * b[k][j];
      }
    }
  }
}

function transpose3x3(in_3x3, outT_3x3) {
  let tmp;
  tmp = in_3x3[1][0];
  outT_3x3[1][0] = in_3x3[0][1];
  outT_3x3[0][1] = tmp;
  tmp = in_3x3[2][0];
  outT_3x3[2][0] = in_3x3[0][2];
  outT_3x3[0][2] = tmp;
  tmp = in_3x3[2][1];
  outT_3x3[2][1] = in_3x3[1][2];
  outT_3x3[1][2] = tmp;

  outT_3x3[0][0] = in_3x3[0][0];
  outT_3x3[1][1] = in_3x3[1][1];
  outT_3x3[2][2] = in_3x3[2][2];
}

function invert3x3(in_3x3, outI_3x3) {
  const a1 = in_3x3[0][0];
  const b1 = in_3x3[0][1];
  const c1 = in_3x3[0][2];
  const a2 = in_3x3[1][0];
  const b2 = in_3x3[1][1];
  const c2 = in_3x3[1][2];
  const a3 = in_3x3[2][0];
  const b3 = in_3x3[2][1];
  const c3 = in_3x3[2][2];

  // Compute the adjoint
  const d1 = +determinant2x2(b2, b3, c2, c3);
  const d2 = -determinant2x2(a2, a3, c2, c3);
  const d3 = +determinant2x2(a2, a3, b2, b3);

  const e1 = -determinant2x2(b1, b3, c1, c3);
  const e2 = +determinant2x2(a1, a3, c1, c3);
  const e3 = -determinant2x2(a1, a3, b1, b3);

  const f1 = +determinant2x2(b1, b2, c1, c2);
  const f2 = -determinant2x2(a1, a2, c1, c2);
  const f3 = +determinant2x2(a1, a2, b1, b2);

  // Divide by the determinant
  const det = a1 * d1 + b1 * d2 + c1 * d3;

  outI_3x3[0][0] = d1 / det;
  outI_3x3[1][0] = d2 / det;
  outI_3x3[2][0] = d3 / det;

  outI_3x3[0][1] = e1 / det;
  outI_3x3[1][1] = e2 / det;
  outI_3x3[2][1] = e3 / det;

  outI_3x3[0][2] = f1 / det;
  outI_3x3[1][2] = f2 / det;
  outI_3x3[2][2] = f3 / det;
}

function identity3x3(mat_3x3) {
  for (let i = 0; i < 3; i++) {
    mat_3x3[i][0] = mat_3x3[i][1] = mat_3x3[i][2] = 0;
    mat_3x3[i][i] = 1;
  }
}

function determinant3x3(mat_3x3) {
  return (
    mat_3x3[0][0] * mat_3x3[1][1] * mat_3x3[2][2] +
    mat_3x3[1][0] * mat_3x3[2][1] * mat_3x3[0][2] +
    mat_3x3[2][0] * mat_3x3[0][1] * mat_3x3[1][2] -
    mat_3x3[0][0] * mat_3x3[2][1] * mat_3x3[1][2] -
    mat_3x3[1][0] * mat_3x3[0][1] * mat_3x3[2][2] -
    mat_3x3[2][0] * mat_3x3[1][1] * mat_3x3[0][2]
  );
}

function quaternionToMatrix3x3(quat_4, mat_3x3) {
  const ww = quat_4[0] * quat_4[0];
  const wx = quat_4[0] * quat_4[1];
  const wy = quat_4[0] * quat_4[2];
  const wz = quat_4[0] * quat_4[3];

  const xx = quat_4[1] * quat_4[1];
  const yy = quat_4[2] * quat_4[2];
  const zz = quat_4[3] * quat_4[3];

  const xy = quat_4[1] * quat_4[2];
  const xz = quat_4[1] * quat_4[3];
  const yz = quat_4[2] * quat_4[3];

  const rr = xx + yy + zz;
  // normalization factor, just in case quaternion was not normalized
  let f = 1 / (ww + rr);
  const s = (ww - rr) * f;
  f *= 2;

  mat_3x3[0][0] = xx * f + s;
  mat_3x3[1][0] = (xy + wz) * f;
  mat_3x3[2][0] = (xz - wy) * f;

  mat_3x3[0][1] = (xy - wz) * f;
  mat_3x3[1][1] = yy * f + s;
  mat_3x3[2][1] = (yz + wx) * f;

  mat_3x3[0][2] = (xz + wy) * f;
  mat_3x3[1][2] = (yz - wx) * f;
  mat_3x3[2][2] = zz * f + s;
}

/**
 * Returns true if elements of both arrays are equals.
 * @param {Array} a an array of numbers (vector, point, matrix...)
 * @param {Array} b an array of numbers (vector, point, matrix...)
 * @param {Number} eps tolerance
 */
function areEquals(a, b, eps = 1e-6) {
  if (!a.length === b.length) {
    return false;
  }

  function isEqual(element, index) {
    return Math.abs(element - b[index]) < eps;
  }
  return a.every(isEqual);
}

const areMatricesEqual = areEquals;

function jacobiN(a, n, w, v) {
  let i;
  let j;
  let k;
  let iq;
  let ip;
  let numPos;
  let tresh;
  let theta;
  let t;
  let tau;
  let sm;
  let s;
  let h;
  let g;
  let c;
  let tmp;
  const b = createArray(n);
  const z = createArray(n);

  const vtkROTATE = (aa, ii, jj, kk, ll) => {
    g = aa[ii][jj];
    h = aa[kk][ll];
    aa[ii][jj] = g - s * (h + g * tau);
    aa[kk][ll] = h + s * (g - h * tau);
  };

  // initialize
  for (ip = 0; ip < n; ip++) {
    for (iq = 0; iq < n; iq++) {
      v[ip][iq] = 0.0;
    }
    v[ip][ip] = 1.0;
  }
  for (ip = 0; ip < n; ip++) {
    b[ip] = w[ip] = a[ip][ip];
    z[ip] = 0.0;
  }

  // begin rotation sequence
  for (i = 0; i < VTK_MAX_ROTATIONS; i++) {
    sm = 0.0;
    for (ip = 0; ip < n - 1; ip++) {
      for (iq = ip + 1; iq < n; iq++) {
        sm += Math.abs(a[ip][iq]);
      }
    }
    if (sm === 0.0) {
      break;
    }

    // first 3 sweeps
    if (i < 3) {
      tresh = (0.2 * sm) / (n * n);
    } else {
      tresh = 0.0;
    }

    for (ip = 0; ip < n - 1; ip++) {
      for (iq = ip + 1; iq < n; iq++) {
        g = 100.0 * Math.abs(a[ip][iq]);

        // after 4 sweeps
        if (
          i > 3 &&
          Math.abs(w[ip]) + g === Math.abs(w[ip]) &&
          Math.abs(w[iq]) + g === Math.abs(w[iq])
        ) {
          a[ip][iq] = 0.0;
        } else if (Math.abs(a[ip][iq]) > tresh) {
          h = w[iq] - w[ip];
          if (Math.abs(h) + g === Math.abs(h)) {
            t = a[ip][iq] / h;
          } else {
            theta = (0.5 * h) / a[ip][iq];
            t = 1.0 / (Math.abs(theta) + Math.sqrt(1.0 + theta * theta));
            if (theta < 0.0) {
              t = -t;
            }
          }
          c = 1.0 / Math.sqrt(1 + t * t);
          s = t * c;
          tau = s / (1.0 + c);
          h = t * a[ip][iq];
          z[ip] -= h;
          z[iq] += h;
          w[ip] -= h;
          w[iq] += h;
          a[ip][iq] = 0.0;

          // ip already shifted left by 1 unit
          for (j = 0; j <= ip - 1; j++) {
            vtkROTATE(a, j, ip, j, iq);
          }
          // ip and iq already shifted left by 1 unit
          for (j = ip + 1; j <= iq - 1; j++) {
            vtkROTATE(a, ip, j, j, iq);
          }
          // iq already shifted left by 1 unit
          for (j = iq + 1; j < n; j++) {
            vtkROTATE(a, ip, j, iq, j);
          }
          for (j = 0; j < n; j++) {
            vtkROTATE(v, j, ip, j, iq);
          }
        }
      }
    }

    for (ip = 0; ip < n; ip++) {
      b[ip] += z[ip];
      w[ip] = b[ip];
      z[ip] = 0.0;
    }
  }

  // this is NEVER called
  if (i >= VTK_MAX_ROTATIONS) {
    vtkWarningMacro('vtkMath::Jacobi: Error extracting eigenfunctions');
    return 0;
  }

  // sort eigenfunctions: these changes do not affect accuracy
  for (j = 0; j < n - 1; j++) {
    // boundary incorrect
    k = j;
    tmp = w[k];
    for (i = j + 1; i < n; i++) {
      // boundary incorrect, shifted already
      if (w[i] >= tmp) {
        // why exchange if same?
        k = i;
        tmp = w[k];
      }
    }
    if (k !== j) {
      w[k] = w[j];
      w[j] = tmp;
      for (i = 0; i < n; i++) {
        tmp = v[i][j];
        v[i][j] = v[i][k];
        v[i][k] = tmp;
      }
    }
  }
  // ensure eigenvector consistency (i.e., Jacobi can compute vectors that
  // are negative of one another (.707,.707,0) and (-.707,-.707,0). This can
  // reek havoc in hyperstreamline/other stuff. We will select the most
  // positive eigenvector.
  const ceil_half_n = (n >> 1) + (n & 1);
  for (j = 0; j < n; j++) {
    for (numPos = 0, i = 0; i < n; i++) {
      if (v[i][j] >= 0.0) {
        numPos++;
      }
    }
    //    if ( numPos < ceil(double(n)/double(2.0)) )
    if (numPos < ceil_half_n) {
      for (i = 0; i < n; i++) {
        v[i][j] *= -1.0;
      }
    }
  }
  return 1;
}

function matrix3x3ToQuaternion(mat_3x3, quat_4) {
  const tmp = [
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
  ];

  // on-diagonal elements
  tmp[0][0] = mat_3x3[0][0] + mat_3x3[1][1] + mat_3x3[2][2];
  tmp[1][1] = mat_3x3[0][0] - mat_3x3[1][1] - mat_3x3[2][2];
  tmp[2][2] = -mat_3x3[0][0] + mat_3x3[1][1] - mat_3x3[2][2];
  tmp[3][3] = -mat_3x3[0][0] - mat_3x3[1][1] + mat_3x3[2][2];

  // off-diagonal elements
  tmp[0][1] = tmp[1][0] = mat_3x3[2][1] - mat_3x3[1][2];
  tmp[0][2] = tmp[2][0] = mat_3x3[0][2] - mat_3x3[2][0];
  tmp[0][3] = tmp[3][0] = mat_3x3[1][0] - mat_3x3[0][1];

  tmp[1][2] = tmp[2][1] = mat_3x3[1][0] + mat_3x3[0][1];
  tmp[1][3] = tmp[3][1] = mat_3x3[0][2] + mat_3x3[2][0];
  tmp[2][3] = tmp[3][2] = mat_3x3[2][1] + mat_3x3[1][2];

  const eigenvectors = [
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
  ];
  const eigenvalues = [0, 0, 0, 0];

  // convert into format that JacobiN can use,
  // then use Jacobi to find eigenvalues and eigenvectors
  const NTemp = [0, 0, 0, 0];
  const eigenvectorsTemp = [0, 0, 0, 0];
  for (let i = 0; i < 4; i++) {
    NTemp[i] = tmp[i];
    eigenvectorsTemp[i] = eigenvectors[i];
  }
  jacobiN(NTemp, 4, eigenvalues, eigenvectorsTemp);

  // the first eigenvector is the one we want
  quat_4[0] = eigenvectors[0][0];
  quat_4[1] = eigenvectors[1][0];
  quat_4[2] = eigenvectors[2][0];
  quat_4[3] = eigenvectors[3][0];
}

function multiplyQuaternion(quat_1, quat_2, quat_out) {
  const ww = quat_1[0] * quat_2[0];
  const wx = quat_1[0] * quat_2[1];
  const wy = quat_1[0] * quat_2[2];
  const wz = quat_1[0] * quat_2[3];

  const xw = quat_1[1] * quat_2[0];
  const xx = quat_1[1] * quat_2[1];
  const xy = quat_1[1] * quat_2[2];
  const xz = quat_1[1] * quat_2[3];

  const yw = quat_1[2] * quat_2[0];
  const yx = quat_1[2] * quat_2[1];
  const yy = quat_1[2] * quat_2[2];
  const yz = quat_1[2] * quat_2[3];

  const zw = quat_1[3] * quat_2[0];
  const zx = quat_1[3] * quat_2[1];
  const zy = quat_1[3] * quat_2[2];
  const zz = quat_1[3] * quat_2[3];

  quat_out[0] = ww - xx - yy - zz;
  quat_out[1] = wx + xw + yz - zy;
  quat_out[2] = wy - xz + yw + zx;
  quat_out[3] = wz + xy - yx + zw;
}

function orthogonalize3x3(a_3x3, out_3x3) {
  // copy the matrix
  for (let i = 0; i < 3; i++) {
    out_3x3[0][i] = a_3x3[0][i];
    out_3x3[1][i] = a_3x3[1][i];
    out_3x3[2][i] = a_3x3[2][i];
  }

  // Pivot the matrix to improve accuracy
  const scale = createArray(3);
  const index = createArray(3);
  let largest;

  // Loop over rows to get implicit scaling information
  for (let i = 0; i < 3; i++) {
    const x1 = Math.abs(out_3x3[i][0]);
    const x2 = Math.abs(out_3x3[i][1]);
    const x3 = Math.abs(out_3x3[i][2]);
    largest = x2 > x1 ? x2 : x1;
    largest = x3 > largest ? x3 : largest;
    scale[i] = 1;
    if (largest !== 0) {
      scale[i] /= largest;
    }
  }

  // first column
  const x1 = Math.abs(out_3x3[0][0]) * scale[0];
  const x2 = Math.abs(out_3x3[1][0]) * scale[1];
  const x3 = Math.abs(out_3x3[2][0]) * scale[2];
  index[0] = 0;
  largest = x1;
  if (x2 >= largest) {
    largest = x2;
    index[0] = 1;
  }
  if (x3 >= largest) {
    index[0] = 2;
  }
  if (index[0] !== 0) {
    vtkSwapVectors3(out_3x3[index[0]], out_3x3[0]);
    scale[index[0]] = scale[0];
  }

  // second column
  const y2 = Math.abs(out_3x3[1][1]) * scale[1];
  const y3 = Math.abs(out_3x3[2][1]) * scale[2];
  index[1] = 1;
  largest = y2;
  if (y3 >= largest) {
    index[1] = 2;
    vtkSwapVectors3(out_3x3[2], out_3x3[1]);
  }

  // third column
  index[2] = 2;

  // A quaternion can only describe a pure rotation, not
  // a rotation with a flip, therefore the flip must be
  // removed before the matrix is converted to a quaternion.
  let flip = 0;
  if (determinant3x3(out_3x3) < 0) {
    flip = 1;
    for (let i = 0; i < 3; i++) {
      out_3x3[0][i] = -out_3x3[0][i];
      out_3x3[1][i] = -out_3x3[1][i];
      out_3x3[2][i] = -out_3x3[2][i];
    }
  }

  // Do orthogonalization using a quaternion intermediate
  // (this, essentially, does the orthogonalization via
  // diagonalization of an appropriately constructed symmetric
  // 4x4 matrix rather than by doing SVD of the 3x3 matrix)
  const quat = createArray(4);
  matrix3x3ToQuaternion(out_3x3, quat);
  quaternionToMatrix3x3(quat, out_3x3);

  // Put the flip back into the orthogonalized matrix.
  if (flip) {
    for (let i = 0; i < 3; i++) {
      out_3x3[0][i] = -out_3x3[0][i];
      out_3x3[1][i] = -out_3x3[1][i];
      out_3x3[2][i] = -out_3x3[2][i];
    }
  }

  // Undo the pivoting
  if (index[1] !== 1) {
    vtkSwapVectors3(out_3x3[index[1]], out_3x3[1]);
  }
  if (index[0] !== 0) {
    vtkSwapVectors3(out_3x3[index[0]], out_3x3[0]);
  }
}

function diagonalize3x3(a_3x3, w_3, v_3x3) {
  let i;
  let j;
  let k;
  let maxI;
  let tmp;
  let maxVal;

  // do the matrix[3][3] to **matrix conversion for Jacobi
  const C = [createArray(3), createArray(3), createArray(3)];
  const ATemp = createArray(3);
  const VTemp = createArray(3);
  for (i = 0; i < 3; i++) {
    C[i][0] = a_3x3[i][0];
    C[i][1] = a_3x3[i][1];
    C[i][2] = a_3x3[i][2];
    ATemp[i] = C[i];
    VTemp[i] = v_3x3[i];
  }

  // diagonalize using Jacobi
  jacobiN(ATemp, 3, w_3, VTemp);

  // if all the eigenvalues are the same, return identity matrix
  if (w_3[0] === w_3[1] && w_3[0] === w_3[2]) {
    identity3x3(v_3x3);
    return;
  }

  // transpose temporarily, it makes it easier to sort the eigenvectors
  transpose3x3(v_3x3, v_3x3);

  // if two eigenvalues are the same, re-orthogonalize to optimally line
  // up the eigenvectors with the x, y, and z axes
  for (i = 0; i < 3; i++) {
    // two eigenvalues are the same
    if (w_3[(i + 1) % 3] === w_3[(i + 2) % 3]) {
      // find maximum element of the independent eigenvector
      maxVal = Math.abs(v_3x3[i][0]);
      maxI = 0;
      for (j = 1; j < 3; j++) {
        if (maxVal < (tmp = Math.abs(v_3x3[i][j]))) {
          maxVal = tmp;
          maxI = j;
        }
      }
      // swap the eigenvector into its proper position
      if (maxI !== i) {
        tmp = w_3[maxI];
        w_3[maxI] = w_3[i];
        w_3[i] = tmp;
        vtkSwapVectors3(v_3x3[i], v_3x3[maxI]);
      }
      // maximum element of eigenvector should be positive
      if (v_3x3[maxI][maxI] < 0) {
        v_3x3[maxI][0] = -v_3x3[maxI][0];
        v_3x3[maxI][1] = -v_3x3[maxI][1];
        v_3x3[maxI][2] = -v_3x3[maxI][2];
      }

      // re-orthogonalize the other two eigenvectors
      j = (maxI + 1) % 3;
      k = (maxI + 2) % 3;

      v_3x3[j][0] = 0.0;
      v_3x3[j][1] = 0.0;
      v_3x3[j][2] = 0.0;
      v_3x3[j][j] = 1.0;
      cross(v_3x3[maxI], v_3x3[j], v_3x3[k]);
      normalize(v_3x3[k]);
      cross(v_3x3[k], v_3x3[maxI], v_3x3[j]);

      // transpose vectors back to columns
      transpose3x3(v_3x3, v_3x3);
      return;
    }
  }

  // the three eigenvalues are different, just sort the eigenvectors
  // to align them with the x, y, and z axes

  // find the vector with the largest x element, make that vector
  // the first vector
  maxVal = Math.abs(v_3x3[0][0]);
  maxI = 0;
  for (i = 1; i < 3; i++) {
    if (maxVal < (tmp = Math.abs(v_3x3[i][0]))) {
      maxVal = tmp;
      maxI = i;
    }
  }
  // swap eigenvalue and eigenvector
  if (maxI !== 0) {
    tmp = w_3[maxI];
    w_3[maxI] = w_3[0];
    w_3[0] = tmp;
    vtkSwapVectors3(v_3x3[maxI], v_3x3[0]);
  }
  // do the same for the y element
  if (Math.abs(v_3x3[1][1]) < Math.abs(v_3x3[2][1])) {
    tmp = w_3[2];
    w_3[2] = w_3[1];
    w_3[1] = tmp;
    vtkSwapVectors3(v_3x3[2], v_3x3[1]);
  }

  // ensure that the sign of the eigenvectors is correct
  for (i = 0; i < 2; i++) {
    if (v_3x3[i][i] < 0) {
      v_3x3[i][0] = -v_3x3[i][0];
      v_3x3[i][1] = -v_3x3[i][1];
      v_3x3[i][2] = -v_3x3[i][2];
    }
  }
  // set sign of final eigenvector to ensure that determinant is positive
  if (determinant3x3(v_3x3) < 0) {
    v_3x3[2][0] = -v_3x3[2][0];
    v_3x3[2][1] = -v_3x3[2][1];
    v_3x3[2][2] = -v_3x3[2][2];
  }

  // transpose the eigenvectors back again
  transpose3x3(v_3x3, v_3x3);
}

function singularValueDecomposition3x3(a_3x3, u_3x3, w_3, vT_3x3) {
  let i;
  const B = [createArray(3), createArray(3), createArray(3)];

  // copy so that A can be used for U or VT without risk
  for (i = 0; i < 3; i++) {
    B[0][i] = a_3x3[0][i];
    B[1][i] = a_3x3[1][i];
    B[2][i] = a_3x3[2][i];
  }

  // temporarily flip if determinant is negative
  const d = determinant3x3(B);
  if (d < 0) {
    for (i = 0; i < 3; i++) {
      B[0][i] = -B[0][i];
      B[1][i] = -B[1][i];
      B[2][i] = -B[2][i];
    }
  }

  // orthogonalize, diagonalize, etc.
  orthogonalize3x3(B, u_3x3);
  transpose3x3(B, B);
  multiply3x3_mat3(B, u_3x3, vT_3x3);
  diagonalize3x3(vT_3x3, w_3, vT_3x3);
  multiply3x3_mat3(u_3x3, vT_3x3, u_3x3);
  transpose3x3(vT_3x3, vT_3x3);

  // re-create the flip
  if (d < 0) {
    w_3[0] = -w_3[0];
    w_3[1] = -w_3[1];
    w_3[2] = -w_3[2];
  }
}

function luFactorLinearSystem(A, index, size) {
  let i;
  let j;
  let k;
  let largest;
  let maxI = 0;
  let sum;
  let temp1;
  let temp2;
  const scale = createArray(size);

  //
  // Loop over rows to get implicit scaling information
  //
  for (i = 0; i < size; i++) {
    for (largest = 0.0, j = 0; j < size; j++) {
      if ((temp2 = Math.abs(A[i][j])) > largest) {
        largest = temp2;
      }
    }

    if (largest === 0.0) {
      vtkWarningMacro('Unable to factor linear system');
      return 0;
    }
    scale[i] = 1.0 / largest;
  }
  //
  // Loop over all columns using Crout's method
  //
  for (j = 0; j < size; j++) {
    for (i = 0; i < j; i++) {
      sum = A[i][j];
      for (k = 0; k < i; k++) {
        sum -= A[i][k] * A[k][j];
      }
      A[i][j] = sum;
    }
    //
    // Begin search for largest pivot element
    //
    for (largest = 0.0, i = j; i < size; i++) {
      sum = A[i][j];
      for (k = 0; k < j; k++) {
        sum -= A[i][k] * A[k][j];
      }
      A[i][j] = sum;

      if ((temp1 = scale[i] * Math.abs(sum)) >= largest) {
        largest = temp1;
        maxI = i;
      }
    }
    //
    // Check for row interchange
    //
    if (j !== maxI) {
      for (k = 0; k < size; k++) {
        temp1 = A[maxI][k];
        A[maxI][k] = A[j][k];
        A[j][k] = temp1;
      }
      scale[maxI] = scale[j];
    }
    //
    // Divide by pivot element and perform elimination
    //
    index[j] = maxI;

    if (Math.abs(A[j][j]) <= VTK_SMALL_NUMBER) {
      vtkWarningMacro('Unable to factor linear system');
      return 0;
    }

    if (j !== size - 1) {
      temp1 = 1.0 / A[j][j];
      for (i = j + 1; i < size; i++) {
        A[i][j] *= temp1;
      }
    }
  }
  return 1;
}

function luSolveLinearSystem(A, index, x, size) {
  let i;
  let j;
  let ii;
  let idx;
  let sum;
  //
  // Proceed with forward and backsubstitution for L and U
  // matrices.  First, forward substitution.
  //
  for (ii = -1, i = 0; i < size; i++) {
    idx = index[i];
    sum = x[idx];
    x[idx] = x[i];

    if (ii >= 0) {
      for (j = ii; j <= i - 1; j++) {
        sum -= A[i][j] * x[j];
      }
    } else if (sum !== 0.0) {
      ii = i;
    }

    x[i] = sum;
  }
  //
  // Now, back substitution
  //
  for (i = size - 1; i >= 0; i--) {
    sum = x[i];
    for (j = i + 1; j < size; j++) {
      sum -= A[i][j] * x[j];
    }
    x[i] = sum / A[i][i];
  }
}

function solveLinearSystem(A, x, size) {
  // if we solving something simple, just solve it
  if (size === 2) {
    const y = createArray(2);
    const det = determinant2x2(A[0][0], A[0][1], A[1][0], A[1][1]);

    if (det === 0.0) {
      // Unable to solve linear system
      return 0;
    }

    y[0] = (A[1][1] * x[0] - A[0][1] * x[1]) / det;
    y[1] = (-(A[1][0] * x[0]) + A[0][0] * x[1]) / det;

    x[0] = y[0];
    x[1] = y[1];
    return 1;
  }

  if (size === 1) {
    if (A[0][0] === 0.0) {
      // Unable to solve linear system
      return 0;
    }

    x[0] /= A[0][0];
    return 1;
  }

  //
  // System of equations is not trivial, use Crout's method
  //

  // Check on allocation of working vectors
  const index = createArray(size);

  // Factor and solve matrix
  if (luFactorLinearSystem(A, index, size) === 0) {
    return 0;
  }
  luSolveLinearSystem(A, index, x, size);

  return 1;
}

function invertMatrix(A, AI, size, index = null, column = null) {
  const tmp1Size = index || createArray(size);
  const tmp2Size = column || createArray(size);

  // Factor matrix; then begin solving for inverse one column at a time.
  // Note: tmp1Size returned value is used later, tmp2Size is just working
  // memory whose values are not used in LUSolveLinearSystem
  if (luFactorLinearSystem(A, tmp1Size, size, tmp2Size) === 0) {
    return 0;
  }

  for (let j = 0; j < size; j++) {
    for (let i = 0; i < size; i++) {
      tmp2Size[i] = 0.0;
    }
    tmp2Size[j] = 1.0;

    luSolveLinearSystem(A, tmp1Size, tmp2Size, size);

    for (let i = 0; i < size; i++) {
      AI[i][j] = tmp2Size[i];
    }
  }

  return 1;
}

function estimateMatrixCondition(A, size) {
  let minValue = +Number.MAX_VALUE;
  let maxValue = -Number.MAX_VALUE;

  // find the maximum value
  for (let i = 0; i < size; i++) {
    for (let j = i; j < size; j++) {
      if (Math.abs(A[i][j]) > max) {
        maxValue = Math.abs(A[i][j]);
      }
    }
  }

  // find the minimum diagonal value
  for (let i = 0; i < size; i++) {
    if (Math.abs(A[i][i]) < min) {
      minValue = Math.abs(A[i][i]);
    }
  }

  if (minValue === 0.0) {
    return Number.MAX_VALUE;
  }
  return maxValue / minValue;
}

function jacobi(a_3x3, w, v) {
  return jacobiN(a_3x3, 3, w, v);
}

function solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt) {
  // check dimensional consistency
  if (numberOfSamples < xOrder) {
    vtkWarningMacro('Insufficient number of samples. Underdetermined.');
    return 0;
  }

  let i;
  let j;
  let k;

  // set up intermediate variables
  // Allocate matrix to hold X times transpose of X
  const XXt = createArray(xOrder); // size x by x
  // Allocate the array of eigenvalues and eigenvectors
  const eigenvals = createArray(xOrder);
  const eigenvecs = createArray(xOrder);

  // Clear the upper triangular region (and btw, allocate the eigenvecs as well)
  for (i = 0; i < xOrder; i++) {
    eigenvecs[i] = createArray(xOrder);
    XXt[i] = createArray(xOrder);
    for (j = 0; j < xOrder; j++) {
      XXt[i][j] = 0.0;
    }
  }

  // Calculate XXt upper half only, due to symmetry
  for (k = 0; k < numberOfSamples; k++) {
    for (i = 0; i < xOrder; i++) {
      for (j = i; j < xOrder; j++) {
        XXt[i][j] += xt[k][i] * xt[k][j];
      }
    }
  }

  // now fill in the lower half of the XXt matrix
  for (i = 0; i < xOrder; i++) {
    for (j = 0; j < i; j++) {
      XXt[i][j] = XXt[j][i];
    }
  }

  // Compute the eigenvectors and eigenvalues
  jacobiN(XXt, xOrder, eigenvals, eigenvecs);

  // Smallest eigenval is at the end of the list (xOrder-1), and solution is
  // corresponding eigenvec.
  for (i = 0; i < xOrder; i++) {
    mt[i][0] = eigenvecs[i][xOrder - 1];
  }

  return 1;
}

function solveLeastSquares(
  numberOfSamples,
  xt,
  xOrder,
  yt,
  yOrder,
  mt,
  checkHomogeneous = true
) {
  // check dimensional consistency
  if (numberOfSamples < xOrder || numberOfSamples < yOrder) {
    vtkWarningMacro('Insufficient number of samples. Underdetermined.');
    return 0;
  }

  const homogenFlags = createArray(yOrder);
  let allHomogeneous = 1;
  let hmt;
  let homogRC = 0;
  let i;
  let j;
  let k;
  let someHomogeneous = 0;

  // Ok, first init some flags check and see if all the systems are homogeneous
  if (checkHomogeneous) {
    // If Y' is zero, it's a homogeneous system and can't be solved via
    // the pseudoinverse method. Detect this case, warn the user, and
    // invoke SolveHomogeneousLeastSquares instead. Note that it doesn't
    // really make much sense for yOrder to be greater than one in this case,
    // since that's just yOrder occurrences of a 0 vector on the RHS, but
    // we allow it anyway. N

    // Initialize homogeneous flags on a per-right-hand-side basis
    for (j = 0; j < yOrder; j++) {
      homogenFlags[j] = 1;
    }
    for (i = 0; i < numberOfSamples; i++) {
      for (j = 0; j < yOrder; j++) {
        if (Math.abs(yt[i][j]) > VTK_SMALL_NUMBER) {
          allHomogeneous = 0;
          homogenFlags[j] = 0;
        }
      }
    }

    // If we've got one system, and it's homogeneous, do it and bail out quickly.
    if (allHomogeneous && yOrder === 1) {
      vtkWarningMacro(
        'Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()'
      );
      return solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, mt);
    }

    // Ok, we've got more than one system of equations.
    // Figure out if we need to calculate the homogeneous equation solution for
    // any of them.
    if (allHomogeneous) {
      someHomogeneous = 1;
    } else {
      for (j = 0; j < yOrder; j++) {
        if (homogenFlags[j]) {
          someHomogeneous = 1;
        }
      }
    }
  }

  // If necessary, solve the homogeneous problem
  if (someHomogeneous) {
    // hmt is the homogeneous equation version of mt, the general solution.
    hmt = createArray(xOrder);
    for (j = 0; j < xOrder; j++) {
      // Only allocate 1 here, not yOrder, because here we're going to solve
      // just the one homogeneous equation subset of the entire problem
      hmt[j] = [0];
    }

    // Ok, solve the homogeneous problem
    homogRC = solveHomogeneousLeastSquares(numberOfSamples, xt, xOrder, hmt);
  }

  // set up intermediate variables
  const XXt = createArray(xOrder); // size x by x
  const XXtI = createArray(xOrder); // size x by x
  const XYt = createArray(xOrder); // size x by y
  for (i = 0; i < xOrder; i++) {
    XXt[i] = createArray(xOrder);
    XXtI[i] = createArray(xOrder);

    for (j = 0; j < xOrder; j++) {
      XXt[i][j] = 0.0;
      XXtI[i][j] = 0.0;
    }

    XYt[i] = createArray(yOrder);
    for (j = 0; j < yOrder; j++) {
      XYt[i][j] = 0.0;
    }
  }

  // first find the pseudoinverse matrix
  for (k = 0; k < numberOfSamples; k++) {
    for (i = 0; i < xOrder; i++) {
      // first calculate the XXt matrix, only do the upper half (symmetrical)
      for (j = i; j < xOrder; j++) {
        XXt[i][j] += xt[k][i] * xt[k][j];
      }

      // now calculate the XYt matrix
      for (j = 0; j < yOrder; j++) {
        XYt[i][j] += xt[k][i] * yt[k][j];
      }
    }
  }

  // now fill in the lower half of the XXt matrix
  for (i = 0; i < xOrder; i++) {
    for (j = 0; j < i; j++) {
      XXt[i][j] = XXt[j][i];
    }
  }

  const successFlag = invertMatrix(XXt, XXtI, xOrder);

  // next get the inverse of XXt
  if (successFlag) {
    for (i = 0; i < xOrder; i++) {
      for (j = 0; j < yOrder; j++) {
        mt[i][j] = 0.0;
        for (k = 0; k < xOrder; k++) {
          mt[i][j] += XXtI[i][k] * XYt[k][j];
        }
      }
    }
  }

  // Fix up any of the solutions that correspond to the homogeneous equation
  // problem.
  if (someHomogeneous) {
    for (j = 0; j < yOrder; j++) {
      if (homogenFlags[j]) {
        // Fix this one
        for (i = 0; i < xOrder; i++) {
          mt[i][j] = hmt[i][0];
        }
      }
    }
  }

  if (someHomogeneous) {
    return homogRC && successFlag;
  }

  return successFlag;
}

function hex2float(hexStr, outFloatArray = [0, 0.5, 1]) {
  switch (hexStr.length) {
    case 3: // abc => #aabbcc
      outFloatArray[0] = (parseInt(hexStr[0], 16) * 17) / 255;
      outFloatArray[1] = (parseInt(hexStr[1], 16) * 17) / 255;
      outFloatArray[2] = (parseInt(hexStr[2], 16) * 17) / 255;
      return outFloatArray;
    case 4: // #abc => #aabbcc
      outFloatArray[0] = (parseInt(hexStr[1], 16) * 17) / 255;
      outFloatArray[1] = (parseInt(hexStr[2], 16) * 17) / 255;
      outFloatArray[2] = (parseInt(hexStr[3], 16) * 17) / 255;
      return outFloatArray;
    case 6: // ab01df => #ab01df
      outFloatArray[0] = parseInt(hexStr.substr(0, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(2, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(4, 2), 16) / 255;
      return outFloatArray;
    case 7: // #ab01df
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      return outFloatArray;
    case 9: // #ab01df00
      outFloatArray[0] = parseInt(hexStr.substr(1, 2), 16) / 255;
      outFloatArray[1] = parseInt(hexStr.substr(3, 2), 16) / 255;
      outFloatArray[2] = parseInt(hexStr.substr(5, 2), 16) / 255;
      outFloatArray[3] = parseInt(hexStr.substr(7, 2), 16) / 255;
      return outFloatArray;
    default:
      return outFloatArray;
  }
}

function rgb2hsv(rgb, hsv) {
  let h;
  let s;
  const [r, g, b] = rgb;
  const onethird = 1.0 / 3.0;
  const onesixth = 1.0 / 6.0;
  const twothird = 2.0 / 3.0;

  let cmax = r;
  let cmin = r;

  if (g > cmax) {
    cmax = g;
  } else if (g < cmin) {
    cmin = g;
  }
  if (b > cmax) {
    cmax = b;
  } else if (b < cmin) {
    cmin = b;
  }
  const v = cmax;

  if (v > 0.0) {
    s = (cmax - cmin) / cmax;
  } else {
    s = 0.0;
  }
  if (s > 0) {
    if (r === cmax) {
      h = (onesixth * (g - b)) / (cmax - cmin);
    } else if (g === cmax) {
      h = onethird + (onesixth * (b - r)) / (cmax - cmin);
    } else {
      h = twothird + (onesixth * (r - g)) / (cmax - cmin);
    }
    if (h < 0.0) {
      h += 1.0;
    }
  } else {
    h = 0.0;
  }

  // Set the values back to the array
  hsv[0] = h;
  hsv[1] = s;
  hsv[2] = v;
}

function hsv2rgb(hsv, rgb) {
  const [h, s, v] = hsv;
  const onethird = 1.0 / 3.0;
  const onesixth = 1.0 / 6.0;
  const twothird = 2.0 / 3.0;
  const fivesixth = 5.0 / 6.0;
  let r;
  let g;
  let b;

  // compute RGB from HSV
  if (h > onesixth && h <= onethird) {
    // green/red
    g = 1.0;
    r = (onethird - h) / onesixth;
    b = 0.0;
  } else if (h > onethird && h <= 0.5) {
    // green/blue
    g = 1.0;
    b = (h - onethird) / onesixth;
    r = 0.0;
  } else if (h > 0.5 && h <= twothird) {
    // blue/green
    b = 1.0;
    g = (twothird - h) / onesixth;
    r = 0.0;
  } else if (h > twothird && h <= fivesixth) {
    // blue/red
    b = 1.0;
    r = (h - twothird) / onesixth;
    g = 0.0;
  } else if (h > fivesixth && h <= 1.0) {
    // red/blue
    r = 1.0;
    b = (1.0 - h) / onesixth;
    g = 0.0;
  } else {
    // red/green
    r = 1.0;
    g = h / onesixth;
    b = 0.0;
  }

  // add Saturation to the equation.
  r = s * r + (1.0 - s);
  g = s * g + (1.0 - s);
  b = s * b + (1.0 - s);

  r *= v;
  g *= v;
  b *= v;

  // Assign back to the array
  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
}

function lab2xyz(lab, xyz) {
  // LAB to XYZ
  const [L, a, b] = lab;
  let var_Y = (L + 16) / 116;
  let var_X = a / 500 + var_Y;
  let var_Z = var_Y - b / 200;

  if (var_Y ** 3 > 0.008856) {
    var_Y **= 3;
  } else {
    var_Y = (var_Y - 16.0 / 116.0) / 7.787;
  }

  if (var_X ** 3 > 0.008856) {
    var_X **= 3;
  } else {
    var_X = (var_X - 16.0 / 116.0) / 7.787;
  }

  if (var_Z ** 3 > 0.008856) {
    var_Z **= 3;
  } else {
    var_Z = (var_Z - 16.0 / 116.0) / 7.787;
  }
  const ref_X = 0.9505;
  const ref_Y = 1.0;
  const ref_Z = 1.089;
  xyz[0] = ref_X * var_X; // ref_X = 0.9505  Observer= 2 deg Illuminant= D65
  xyz[1] = ref_Y * var_Y; // ref_Y = 1.000
  xyz[2] = ref_Z * var_Z; // ref_Z = 1.089
}

function xyz2lab(xyz, lab) {
  const [x, y, z] = xyz;
  const ref_X = 0.9505;
  const ref_Y = 1.0;
  const ref_Z = 1.089;
  let var_X = x / ref_X; // ref_X = 0.9505  Observer= 2 deg, Illuminant= D65
  let var_Y = y / ref_Y; // ref_Y = 1.000
  let var_Z = z / ref_Z; // ref_Z = 1.089

  if (var_X > 0.008856) var_X **= 1.0 / 3.0;
  else var_X = 7.787 * var_X + 16.0 / 116.0;
  if (var_Y > 0.008856) var_Y **= 1.0 / 3.0;
  else var_Y = 7.787 * var_Y + 16.0 / 116.0;
  if (var_Z > 0.008856) var_Z **= 1.0 / 3.0;
  else var_Z = 7.787 * var_Z + 16.0 / 116.0;

  lab[0] = 116 * var_Y - 16;
  lab[1] = 500 * (var_X - var_Y);
  lab[2] = 200 * (var_Y - var_Z);
}

function xyz2rgb(xyz, rgb) {
  const [x, y, z] = xyz;
  let r = x * 3.2406 + y * -1.5372 + z * -0.4986;
  let g = x * -0.9689 + y * 1.8758 + z * 0.0415;
  let b = x * 0.0557 + y * -0.204 + z * 1.057;

  // The following performs a "gamma correction" specified by the sRGB color
  // space.  sRGB is defined by a canonical definition of a display monitor and
  // has been standardized by the International Electrotechnical Commission (IEC
  // 61966-2-1).  The nonlinearity of the correction is designed to make the
  // colors more perceptually uniform.  This color space has been adopted by
  // several applications including Adobe Photoshop and Microsoft Windows color
  // management.  OpenGL is agnostic on its RGB color space, but it is reasonable
  // to assume it is close to this one.
  if (r > 0.0031308) r = 1.055 * r ** (1 / 2.4) - 0.055;
  else r *= 12.92;
  if (g > 0.0031308) g = 1.055 * g ** (1 / 2.4) - 0.055;
  else g *= 12.92;
  if (b > 0.0031308) b = 1.055 * b ** (1 / 2.4) - 0.055;
  else b *= 12.92;

  // Clip colors. ideally we would do something that is perceptually closest
  // (since we can see colors outside of the display gamut), but this seems to
  // work well enough.
  let maxVal = r;
  if (maxVal < g) maxVal = g;
  if (maxVal < b) maxVal = b;
  if (maxVal > 1.0) {
    r /= maxVal;
    g /= maxVal;
    b /= maxVal;
  }
  if (r < 0) r = 0;
  if (g < 0) g = 0;
  if (b < 0) b = 0;

  // Push values back to array
  rgb[0] = r;
  rgb[1] = g;
  rgb[2] = b;
}

function rgb2xyz(rgb, xyz) {
  let [r, g, b] = rgb;
  // The following performs a "gamma correction" specified by the sRGB color
  // space.  sRGB is defined by a canonical definition of a display monitor and
  // has been standardized by the International Electrotechnical Commission (IEC
  // 61966-2-1).  The nonlinearity of the correction is designed to make the
  // colors more perceptually uniform.  This color space has been adopted by
  // several applications including Adobe Photoshop and Microsoft Windows color
  // management.  OpenGL is agnostic on its RGB color space, but it is reasonable
  // to assume it is close to this one.
  if (r > 0.04045) r = ((r + 0.055) / 1.055) ** 2.4;
  else r /= 12.92;
  if (g > 0.04045) g = ((g + 0.055) / 1.055) ** 2.4;
  else g /= 12.92;
  if (b > 0.04045) b = ((b + 0.055) / 1.055) ** 2.4;
  else b /= 12.92;

  // Observer. = 2 deg, Illuminant = D65
  xyz[0] = r * 0.4124 + g * 0.3576 + b * 0.1805;
  xyz[1] = r * 0.2126 + g * 0.7152 + b * 0.0722;
  xyz[2] = r * 0.0193 + g * 0.1192 + b * 0.9505;
}

function rgb2lab(rgb, lab) {
  const xyz = [0, 0, 0];
  rgb2xyz(rgb, xyz);
  xyz2lab(xyz, lab);
}

function lab2rgb(lab, rgb) {
  const xyz = [0, 0, 0];
  lab2xyz(lab, xyz);
  xyz2rgb(xyz, rgb);
}

function uninitializeBounds(bounds) {
  bounds[0] = 1.0;
  bounds[1] = -1.0;
  bounds[2] = 1.0;
  bounds[3] = -1.0;
  bounds[4] = 1.0;
  bounds[5] = -1.0;
}

function areBoundsInitialized(bounds) {
  return !(bounds[1] - bounds[0] < 0.0);
}

function computeBoundsFromPoints(point1, point2, bounds) {
  bounds[0] = Math.min(point1[0], point2[0]);
  bounds[1] = Math.max(point1[0], point2[0]);
  bounds[2] = Math.min(point1[1], point2[1]);
  bounds[3] = Math.max(point1[1], point2[1]);
  bounds[4] = Math.min(point1[2], point2[2]);
  bounds[5] = Math.max(point1[2], point2[2]);
}

function clampValue(value, minValue, maxValue) {
  if (value < minValue) {
    return minValue;
  }
  if (value > maxValue) {
    return maxValue;
  }
  return value;
}

function clampVector(vector, minVector, maxVector, out = []) {
  out[0] = clampValue(vector[0], minVector[0], maxVector[0]);
  out[1] = clampValue(vector[1], minVector[1], maxVector[1]);
  out[2] = clampValue(vector[2], minVector[2], maxVector[2]);

  return out;
}

function roundVector(vector, out = []) {
  out[0] = Math.round(vector[0]);
  out[1] = Math.round(vector[1]);
  out[2] = Math.round(vector[2]);

  return out;
}

function clampAndNormalizeValue(value, range) {
  let result = 0;
  if (range[0] !== range[1]) {
    // clamp
    if (value < range[0]) {
      result = range[0];
    } else if (value > range[1]) {
      result = range[1];
    } else {
      result = value;
    }
    // normalize
    result = (result - range[0]) / (range[1] - range[0]);
  }

  return result;
}

const getScalarTypeFittingRange = notImplemented(
  'GetScalarTypeFittingRange'
);
const getAdjustedScalarRange = notImplemented('GetAdjustedScalarRange');

function extentIsWithinOtherExtent(extent1, extent2) {
  if (!extent1 || !extent2) {
    return 0;
  }

  for (let i = 0; i < 6; i += 2) {
    if (
      extent1[i] < extent2[i] ||
      extent1[i] > extent2[i + 1] ||
      extent1[i + 1] < extent2[i] ||
      extent1[i + 1] > extent2[i + 1]
    ) {
      return 0;
    }
  }

  return 1;
}

function boundsIsWithinOtherBounds(bounds1_6, bounds2_6, delta_3) {
  if (!bounds1_6 || !bounds2_6) {
    return 0;
  }
  for (let i = 0; i < 6; i += 2) {
    if (
      bounds1_6[i] + delta_3[i / 2] < bounds2_6[i] ||
      bounds1_6[i] - delta_3[i / 2] > bounds2_6[i + 1] ||
      bounds1_6[i + 1] + delta_3[i / 2] < bounds2_6[i] ||
      bounds1_6[i + 1] - delta_3[i / 2] > bounds2_6[i + 1]
    ) {
      return 0;
    }
  }
  return 1;
}

function pointIsWithinBounds(point_3, bounds_6, delta_3) {
  if (!point_3 || !bounds_6 || !delta_3) {
    return 0;
  }
  for (let i = 0; i < 3; i++) {
    if (
      point_3[i] + delta_3[i] < bounds_6[2 * i] ||
      point_3[i] - delta_3[i] > bounds_6[2 * i + 1]
    ) {
      return 0;
    }
  }
  return 1;
}

function solve3PointCircle(p1, p2, p3, center) {
  const v21 = createArray(3);
  const v32 = createArray(3);
  const v13 = createArray(3);
  const v12 = createArray(3);
  const v23 = createArray(3);
  const v31 = createArray(3);

  for (let i = 0; i < 3; ++i) {
    v21[i] = p1[i] - p2[i];
    v32[i] = p2[i] - p3[i];
    v13[i] = p3[i] - p1[i];
    v12[i] = -v21[i];
    v23[i] = -v32[i];
    v31[i] = -v13[i];
  }

  const norm12 = norm(v12);
  const norm23 = norm(v23);
  const norm13 = norm(v13);

  const crossv21v32 = createArray(3);
  cross(v21, v32, crossv21v32);
  const normCross = norm(crossv21v32);

  const radius = (norm12 * norm23 * norm13) / (2 * normCross);

  const normCross22 = 2 * normCross * normCross;
  const alpha = (norm23 * norm23 * dot(v21, v31)) / normCross22;
  const beta = (norm13 * norm13 * dot(v12, v32)) / normCross22;
  const gamma = (norm12 * norm12 * dot(v13, v23)) / normCross22;

  for (let i = 0; i < 3; ++i) {
    center[i] = alpha * p1[i] + beta * p2[i] + gamma * p3[i];
  }
  return radius;
}

const inf = Infinity;
const negInf = -Infinity;

const isInf = (value) => !Number.isFinite(value);
const { isFinite, isNaN } = Number;
const isNan = isNaN;

// JavaScript - add-on ----------------------

function createUninitializedBounds() {
  return [].concat([
    Number.MAX_VALUE,
    -Number.MAX_VALUE, // X
    Number.MAX_VALUE,
    -Number.MAX_VALUE, // Y
    Number.MAX_VALUE,
    -Number.MAX_VALUE, // Z
  ]);
}

function getMajorAxisIndex(vector) {
  let maxValue = -1;
  let axisIndex = -1;
  for (let i = 0; i < vector.length; i++) {
    const value = Math.abs(vector[i]);
    if (value > maxValue) {
      axisIndex = i;
      maxValue = value;
    }
  }

  return axisIndex;
}

function floatToHex2(value) {
  const integer = Math.floor(value * 255);
  if (integer > 15) {
    return integer.toString(16);
  }
  return `0${integer.toString(16)}`;
}

function floatRGB2HexCode(rgbArray, prefix = '#') {
  return `${prefix}${rgbArray.map(floatToHex2).join('')}`;
}

function floatToChar(f) {
  return Math.round(f * 255);
}

function float2CssRGBA(rgbArray) {
  if (rgbArray.length === 3) {
    return `rgb(${rgbArray.map(floatToChar).join(', ')})`;
  }
  return `rgba(${floatToChar(rgbArray[0] || 0)}, ${floatToChar(
    rgbArray[1] || 0
  )}, ${floatToChar(rgbArray[2] || 0)}, ${rgbArray[3] || 0})`;
}

function rotateVector(vectorToBeRotated, axis, angle) {
  const rotatedVector = [...vectorToBeRotated];
  vtk_js_Sources_Common_Core_MatrixBuilder__WEBPACK_IMPORTED_MODULE_2__["default"]
    .buildFromRadian()
    .identity()
    .rotate(angle, axis)
    .apply(rotatedVector);
  return rotatedVector;
}

// ----------------------------------------------------------------------------
// Only Static API
// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({
  Pi,
  radiansFromDegrees,
  degreesFromRadians,
  round,
  floor,
  ceil,
  ceilLog2,
  min,
  max,
  arrayMin,
  arrayMax,
  arrayRange,
  isPowerOfTwo,
  nearestPowerOfTwo,
  factorial,
  binomial,
  beginCombination,
  nextCombination,
  randomSeed,
  getSeed,
  random,
  gaussian,
  add,
  subtract,
  multiplyScalar,
  multiplyScalar2D,
  multiplyAccumulate,
  multiplyAccumulate2D,
  dot,
  outer,
  cross,
  norm,
  normalize,
  perpendiculars,
  projectVector,
  projectVector2D,
  distance2BetweenPoints,
  angleBetweenVectors,
  gaussianAmplitude,
  gaussianWeight,
  dot2D,
  outer2D,
  norm2D,
  normalize2D,
  determinant2x2,
  LUFactor3x3,
  LUSolve3x3,
  linearSolve3x3,
  multiply3x3_vect3,
  multiply3x3_mat3,
  multiplyMatrix,
  transpose3x3,
  invert3x3,
  identity3x3,
  determinant3x3,
  quaternionToMatrix3x3,
  areEquals,
  areMatricesEqual,
  matrix3x3ToQuaternion,
  multiplyQuaternion,
  orthogonalize3x3,
  diagonalize3x3,
  singularValueDecomposition3x3,
  solveLinearSystem,
  invertMatrix,
  luFactorLinearSystem,
  luSolveLinearSystem,
  estimateMatrixCondition,
  jacobi,
  jacobiN,
  solveHomogeneousLeastSquares,
  solveLeastSquares,
  hex2float,
  rgb2hsv,
  hsv2rgb,
  lab2xyz,
  xyz2lab,
  xyz2rgb,
  rgb2xyz,
  rgb2lab,
  lab2rgb,
  uninitializeBounds,
  areBoundsInitialized,
  computeBoundsFromPoints,
  clampValue,
  clampVector,
  clampAndNormalizeValue,
  getScalarTypeFittingRange,
  getAdjustedScalarRange,
  extentIsWithinOtherExtent,
  boundsIsWithinOtherBounds,
  pointIsWithinBounds,
  solve3PointCircle,
  inf,
  negInf,
  isInf,
  isNan: isNaN,
  isNaN,
  isFinite,

  // JS add-on
  createUninitializedBounds,
  getMajorAxisIndex,
  floatToHex2,
  floatRGB2HexCode,
  float2CssRGBA,
  rotateVector,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/Core/MatrixBuilder/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/Core/MatrixBuilder/index.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");


// eslint-disable-next-line import/no-cycle


const NoOp = (v) => v;

const IDENTITY = new Float64Array(16);
gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(IDENTITY);

const EPSILON = 1e-6;

class Transform {
  constructor(useDegree = false) {
    this.matrix = new Float64Array(16);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(this.matrix);
    this.tmp = new Float64Array(3);
    this.angleConv = useDegree ? gl_matrix__WEBPACK_IMPORTED_MODULE_0__["glMatrix"].toRadian : NoOp;
  }

  rotateFromDirections(originDirection, targetDirection) {
    const src = new Float64Array(3);
    const dst = new Float64Array(3);
    const transf = new Float64Array(16);

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(src, originDirection[0], originDirection[1], originDirection[2]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(dst, targetDirection[0], targetDirection[1], targetDirection[2]);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].normalize(src, src);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].normalize(dst, dst);
    const cosAlpha = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].dot(src, dst);
    if (cosAlpha >= 1) {
      return this;
    }

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].cross(this.tmp, src, dst);
    if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].length(this.tmp) < EPSILON) {
      // cross product is 0, so pick arbitrary axis perpendicular
      // to originDirection.
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].cross(this.tmp, [1, 0, 0], originDirection);
      if (gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].length(this.tmp) < EPSILON) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].cross(this.tmp, [0, 1, 0], originDirection);
      }
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].fromRotation(transf, Math.acos(cosAlpha), this.tmp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(this.matrix, this.matrix, transf);

    return this;
  }

  rotate(angle, axis) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(this.tmp, ...axis);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].normalize(this.tmp, this.tmp);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotate(this.matrix, this.matrix, this.angleConv(angle), this.tmp);
    return this;
  }

  rotateX(angle) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotateX(this.matrix, this.matrix, this.angleConv(angle));
    return this;
  }

  rotateY(angle) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotateY(this.matrix, this.matrix, this.angleConv(angle));
    return this;
  }

  rotateZ(angle) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotateZ(this.matrix, this.matrix, this.angleConv(angle));
    return this;
  }

  translate(x, y, z) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(this.tmp, x, y, z);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(this.matrix, this.matrix, this.tmp);
    return this;
  }

  scale(sx, sy, sz) {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(this.tmp, sx, sy, sz);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].scale(this.matrix, this.matrix, this.tmp);
    return this;
  }

  identity() {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(this.matrix);
    return this;
  }

  //-----------

  apply(typedArray, offset = 0, nbIterations = -1) {
    if (Object(vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["areMatricesEqual"])(IDENTITY, this.matrix)) {
      // Make sure we can chain apply...
      return this;
    }

    const size =
      nbIterations === -1 ? typedArray.length : offset + nbIterations * 3;
    for (let i = offset; i < size; i += 3) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(this.tmp, typedArray[i], typedArray[i + 1], typedArray[i + 2]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(this.tmp, this.tmp, this.matrix);
      typedArray[i] = this.tmp[0];
      typedArray[i + 1] = this.tmp[1];
      typedArray[i + 2] = this.tmp[2];
    }

    // Make sure we can chain apply...
    return this;
  }

  getMatrix() {
    return this.matrix;
  }

  setMatrix(mat4x4) {
    if (!!mat4x4 && mat4x4.length === 16) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(this.matrix, mat4x4);
    }
    return this;
  }
}

function buildFromDegree() {
  return new Transform(true);
}

function buildFromRadian() {
  return new Transform(false);
}

/* harmony default export */ __webpack_exports__["default"] = ({
  buildFromDegree,
  buildFromRadian,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/Core/Points/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/Core/Points/index.js ***!
  \*****************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray/Constants */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/Constants.js");




const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

const INVALID_BOUNDS = [1, -1, 1, -1, 1, -1];

// ----------------------------------------------------------------------------
// vtkPoints methods
// ----------------------------------------------------------------------------

function vtkPoints(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPoints');

  // Forwarding methods
  publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;

  publicAPI.setNumberOfPoints = (nbPoints, dimension = 3) => {
    if (publicAPI.getNumberOfPoints() !== nbPoints) {
      model.size = nbPoints * dimension;
      model.values = new window[model.dataType](model.size);
      publicAPI.setNumberOfComponents(dimension);
      publicAPI.modified();
    }
  };

  publicAPI.setPoint = (idx, ...xyz) => {
    const offset = idx * model.numberOfComponents;
    for (let i = 0; i < model.numberOfComponents; i++) {
      model.values[offset + i] = xyz[i];
    }
  };

  publicAPI.getPoint = publicAPI.getTuple;

  publicAPI.getBounds = () => {
    if (publicAPI.getNumberOfComponents() === 3) {
      const xRange = publicAPI.getRange(0);
      model.bounds[0] = xRange[0];
      model.bounds[1] = xRange[1];
      const yRange = publicAPI.getRange(1);
      model.bounds[2] = yRange[0];
      model.bounds[3] = yRange[1];
      const zRange = publicAPI.getRange(2);
      model.bounds[4] = zRange[0];
      model.bounds[5] = zRange[1];
      return model.bounds;
    }

    if (publicAPI.getNumberOfComponents() !== 2) {
      vtkErrorMacro(`getBounds called on an array with components of
        ${publicAPI.getNumberOfComponents()}`);
      return INVALID_BOUNDS;
    }

    const xRange = publicAPI.getRange(0);
    model.bounds[0] = xRange[0];
    model.bounds[1] = xRange[1];
    const yRange = publicAPI.getRange(1);
    model.bounds[2] = yRange[0];
    model.bounds[3] = yRange[1];
    model.bounds[4] = 0;
    model.bounds[5] = 0;

    return model.bounds;
  };

  // Trigger the computation of bounds
  publicAPI.computeBounds = publicAPI.getBounds;

  // Initialize
  publicAPI.setNumberOfComponents(
    model.numberOfComponents < 2 ? 3 : model.numberOfComponents
  );
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  empty: true,
  numberOfComponents: 3,
  dataType: vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_2__["VtkDataTypes"].FLOAT,
  bounds: [1, -1, 1, -1, 1, -1],
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_1__["default"].extend(publicAPI, model, initialValues);
  vtkPoints(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkPoints');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/Core/ScalarsToColors/Constants.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/Core/ScalarsToColors/Constants.js ***!
  \******************************************************************************/
/*! exports provided: VectorMode, ScalarMappingTarget, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorMode", function() { return VectorMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScalarMappingTarget", function() { return ScalarMappingTarget; });
const VectorMode = {
  MAGNITUDE: 0,
  COMPONENT: 1,
  RGBCOLORS: 2,
};

const ScalarMappingTarget = {
  LUMINANCE: 1,
  LUMINANCE_ALPHA: 2,
  RGB: 3,
  RGBA: 4,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  VectorMode,
  ScalarMappingTarget,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/Core/ScalarsToColors/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/Core/ScalarsToColors/index.js ***!
  \**************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_ScalarsToColors_Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/ScalarsToColors/Constants */ "./node_modules/vtk.js/Sources/Common/Core/ScalarsToColors/Constants.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Mapper_Constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Mapper/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/Mapper/Constants.js");



 // Need to go inside Constants otherwise dependency loop

const { ScalarMappingTarget, VectorMode } = vtk_js_Sources_Common_Core_ScalarsToColors_Constants__WEBPACK_IMPORTED_MODULE_2__["default"];
const { VtkDataTypes } = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_1__["default"];
const { ColorMode } = vtk_js_Sources_Rendering_Core_Mapper_Constants__WEBPACK_IMPORTED_MODULE_3__["default"];
const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// Add module-level functions or api that you want to expose statically via
// the next section...

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

function intColorToUChar(c) {
  return c;
}
function floatColorToUChar(c) {
  return Math.floor(c * 255.0 + 0.5);
}

// ----------------------------------------------------------------------------
// vtkScalarsToColors methods
// ----------------------------------------------------------------------------

function vtkScalarsToColors(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkScalarsToColors');

  publicAPI.setVectorModeToMagnitude = () =>
    publicAPI.setVectorMode(VectorMode.MAGNITUDE);
  publicAPI.setVectorModeToComponent = () =>
    publicAPI.setVectorMode(VectorMode.COMPONENT);
  publicAPI.setVectorModeToRGBColors = () =>
    publicAPI.setVectorMode(VectorMode.RGBCOLORS);

  publicAPI.build = () => {};

  publicAPI.isOpaque = () => true;

  //----------------------------------------------------------------------------
  publicAPI.setAnnotations = (values, annotations) => {
    if ((values && !annotations) || (!values && annotations)) {
      return;
    }

    if (values && annotations && values.length !== annotations.length) {
      vtkErrorMacro(
        'Values and annotations do not have the same number of tuples so ignoring'
      );
      return;
    }

    model.annotationArray = [];

    if (annotations && values) {
      const num = annotations.length;
      for (let i = 0; i < num; i++) {
        model.annotationArray.push({
          value: values[i],
          annotation: String(annotations[i]),
        });
      }
    }

    publicAPI.updateAnnotatedValueMap();
    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  publicAPI.setAnnotation = (value, annotation) => {
    let i = publicAPI.checkForAnnotatedValue(value);
    let modified = false;
    if (i >= 0) {
      if (model.annotationArray[i].annotation !== annotation) {
        model.annotationArray[i].annotation = annotation;
        modified = true;
      }
    } else {
      model.annotationArray.push({ value, annotation });
      i = model.annotationArray.length - 1;
      modified = true;
    }
    if (modified) {
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return i;
  };

  //----------------------------------------------------------------------------
  publicAPI.getNumberOfAnnotatedValues = () => model.annotationArray.length;

  //----------------------------------------------------------------------------
  publicAPI.getAnnotatedValue = (idx) => {
    if (idx < 0 || idx >= model.annotationArray.length) {
      return null;
    }
    return model.annotationArray[idx].value;
  };

  //----------------------------------------------------------------------------
  publicAPI.getAnnotation = (idx) => {
    if (model.annotationArray[idx] === undefined) {
      return null;
    }
    return model.annotationArray[idx].annotation;
  };

  //----------------------------------------------------------------------------
  publicAPI.getAnnotatedValueIndex = (val) =>
    model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;

  //----------------------------------------------------------------------------
  publicAPI.removeAnnotation = (value) => {
    const i = publicAPI.checkForAnnotatedValue(value);
    const needToRemove = i >= 0;
    if (needToRemove) {
      model.annotationArray.splice(i, 1);
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return needToRemove;
  };

  //----------------------------------------------------------------------------
  publicAPI.resetAnnotations = () => {
    model.annotationArray = [];
    model.annotatedValueMap = [];
    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  publicAPI.getAnnotationColor = (val, rgba) => {
    if (model.indexedLookup) {
      const i = publicAPI.getAnnotatedValueIndex(val);
      publicAPI.getIndexedColor(i, rgba);
    } else {
      publicAPI.getColor(parseFloat(val), rgba);
      rgba[3] = 1.0;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.checkForAnnotatedValue = (value) =>
    publicAPI.getAnnotatedValueIndexInternal(value);

  //----------------------------------------------------------------------------
  // An unsafe version of vtkScalarsToColors::CheckForAnnotatedValue for
  // internal use (no pointer checks performed)
  publicAPI.getAnnotatedValueIndexInternal = (value) => {
    if (model.annotatedValueMap[value] !== undefined) {
      const na = model.annotationArray.length;
      return model.annotatedValueMap[value] % na;
    }
    // Treat as a NaN
    return -1;
  };

  //----------------------------------------------------------------------------
  publicAPI.getIndexedColor = (val, rgba) => {
    rgba[0] = 0.0;
    rgba[1] = 0.0;
    rgba[2] = 0.0;
    rgba[3] = 0.0;
  };

  //----------------------------------------------------------------------------
  publicAPI.updateAnnotatedValueMap = () => {
    model.annotatedValueMap = [];

    const na = model.annotationArray.length;
    for (let i = 0; i < na; i++) {
      model.annotatedValueMap[model.annotationArray[i].value] = i;
    }
  };

  // Description:
  // Internal methods that map a data array into a 4-component,
  // unsigned char RGBA array. The color mode determines the behavior
  // of mapping. If ColorMode.DEFAULT is set, then unsigned char
  // data arrays are treated as colors (and converted to RGBA if
  // necessary); If ColorMode.DIRECT_SCALARS is set, then all arrays
  // are treated as colors (integer types are clamped in the range 0-255,
  // floating point arrays are clamped in the range 0.0-1.0. Note 'char' does
  // not have enough values to represent a color so mapping this type is
  // considered an error);
  // otherwise, the data is mapped through this instance
  // of ScalarsToColors. The component argument is used for data
  // arrays with more than one component; it indicates which component
  // to use to do the blending.  When the component argument is -1,
  // then the this object uses its own selected technique to change a
  // vector into a scalar to map.
  publicAPI.mapScalars = (scalars, colorMode, componentIn) => {
    const numberOfComponents = scalars.getNumberOfComponents();

    let newColors = null;

    // map scalars through lookup table only if needed
    if (
      (colorMode === ColorMode.DEFAULT &&
        scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR) ||
      (colorMode === ColorMode.DIRECT_SCALARS && scalars)
    ) {
      newColors = publicAPI.convertToRGBA(
        scalars,
        numberOfComponents,
        scalars.getNumberOfTuples()
      );
    } else {
      const newscalars = {
        type: 'vtkDataArray',
        name: 'temp',
        numberOfComponents: 4,
        dataType: VtkDataTypes.UNSIGNED_CHAR,
      };

      const s = new window[newscalars.dataType](
        4 * scalars.getNumberOfTuples()
      );
      newscalars.values = s;
      newscalars.size = s.length;
      newColors = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(newscalars);

      let component = componentIn;

      // If mapper did not specify a component, use the VectorMode
      if (component < 0 && numberOfComponents > 1) {
        publicAPI.mapVectorsThroughTable(
          scalars,
          newColors,
          ScalarMappingTarget.RGBA,
          -1,
          -1
        );
      } else {
        if (component < 0) {
          component = 0;
        }
        if (component >= numberOfComponents) {
          component = numberOfComponents - 1;
        }

        // Map the scalars to colors
        publicAPI.mapScalarsThroughTable(
          scalars,
          newColors,
          ScalarMappingTarget.RGBA,
          component
        );
      }
    }

    return newColors;
  };

  publicAPI.mapVectorsToMagnitude = (input, output, compsToUse) => {
    const length = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();

    const outputV = output.getData();
    const inputV = input.getData();

    for (let i = 0; i < length; i++) {
      let sum = 0.0;
      for (let j = 0; j < compsToUse; j++) {
        sum += inputV[i * inIncr + j] * inputV[i * inIncr + j];
      }
      outputV[i] = Math.sqrt(sum);
    }
  };

  //----------------------------------------------------------------------------
  // Map a set of vector values through the table
  publicAPI.mapVectorsThroughTable = (
    input,
    output,
    outputFormat,
    vectorComponentIn,
    vectorSizeIn
  ) => {
    let vectorMode = publicAPI.getVectorMode();
    let vectorSize = vectorSizeIn;
    let vectorComponent = vectorComponentIn;
    const inComponents = input.getNumberOfComponents();

    if (vectorMode === VectorMode.COMPONENT) {
      // make sure vectorComponent is within allowed range
      if (vectorComponent === -1) {
        // if set to -1, use default value provided by table
        vectorComponent = publicAPI.getVectorComponent();
      }
      if (vectorComponent < 0) {
        vectorComponent = 0;
      }
      if (vectorComponent >= inComponents) {
        vectorComponent = inComponents - 1;
      }
    } else {
      // make sure vectorSize is within allowed range
      if (vectorSize === -1) {
        // if set to -1, use default value provided by table
        vectorSize = publicAPI.getVectorSize();
      }
      if (vectorSize <= 0) {
        vectorComponent = 0;
        vectorSize = inComponents;
      } else {
        if (vectorComponent < 0) {
          vectorComponent = 0;
        }
        if (vectorComponent >= inComponents) {
          vectorComponent = inComponents - 1;
        }
        if (vectorComponent + vectorSize > inComponents) {
          vectorSize = inComponents - vectorComponent;
        }
      }

      if (
        vectorMode === VectorMode.MAGNITUDE &&
        (inComponents === 1 || vectorSize === 1)
      ) {
        vectorMode = VectorMode.COMPONENT;
      }
    }

    // increment input pointer to the first component to map
    let inputOffset = 0;
    if (vectorComponent > 0) {
      inputOffset = vectorComponent;
    }

    // map according to the current vector mode
    switch (vectorMode) {
      case VectorMode.COMPONENT: {
        publicAPI.mapScalarsThroughTable(
          input,
          output,
          outputFormat,
          inputOffset
        );
        break;
      }

      default:
      case VectorMode.MAGNITUDE: {
        const magValues = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance({
          numberOfComponents: 1,
          values: new Float32Array(input.getNumberOfTuples()),
        });

        publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);
        publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);
        break;
      }

      case VectorMode.RGBCOLORS: {
        // publicAPI.mapColorsToColors(
        //   input, output, inComponents, vectorSize,
        //   outputFormat);
        break;
      }
    }
  };

  publicAPI.luminanceToRGBA = (newColors, colors, alpha, convtFun) => {
    const a = convtFun(alpha);

    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 1;

    let count = 0;
    for (let i = component; i < size; i += tuple) {
      const l = convtFun(values[i]);
      newValues[count * 4] = l;
      newValues[count * 4 + 1] = l;
      newValues[count * 4 + 2] = l;
      newValues[count * 4 + 3] = a;
      count++;
    }
  };

  publicAPI.luminanceAlphaToRGBA = (newColors, colors, alpha, convtFun) => {
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 2;

    let count = 0;
    for (let i = component; i < size; i += tuple) {
      const l = convtFun(values[i]);
      newValues[count] = l;
      newValues[count + 1] = l;
      newValues[count + 2] = l;
      newValues[count + 3] = convtFun(values[i + 1]) * alpha;
      count += 4;
    }
  };

  publicAPI.rGBToRGBA = (newColors, colors, alpha, convtFun) => {
    const a = floatColorToUChar(alpha);

    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 3;

    let count = 0;
    for (let i = component; i < size; i += tuple) {
      newValues[count * 4] = convtFun(values[i]);
      newValues[count * 4 + 1] = convtFun(values[i + 1]);
      newValues[count * 4 + 2] = convtFun(values[i + 2]);
      newValues[count * 4 + 3] = a;
      count++;
    }
  };

  publicAPI.rGBAToRGBA = (newColors, colors, alpha, convtFun) => {
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 4;

    let count = 0;
    for (let i = component; i < size; i += tuple) {
      newValues[count * 4] = convtFun(values[i]);
      newValues[count * 4 + 1] = convtFun(values[i + 1]);
      newValues[count * 4 + 2] = convtFun(values[i + 2]);
      newValues[count * 4 + 3] = convtFun(values[i + 3]) * alpha;
      count++;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.convertToRGBA = (colors, numComp, numTuples) => {
    let { alpha } = model;
    if (
      numComp === 4 &&
      alpha >= 1.0 &&
      colors.getDataType() === VtkDataTypes.UNSIGNED_CHAR
    ) {
      return colors;
    }

    const newColors = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance({
      numberOfComponents: 4,
      empty: true,
      size: 4 * numTuples,
      dataType: VtkDataTypes.UNSIGNED_CHAR,
    });

    if (numTuples <= 0) {
      return newColors;
    }

    alpha = alpha > 0 ? alpha : 0;
    alpha = alpha < 1 ? alpha : 1;

    let convtFun = intColorToUChar;
    if (
      colors.getDataType() === VtkDataTypes.FLOAT ||
      colors.getDataType() === VtkDataTypes.DOUBLE
    ) {
      convtFun = floatColorToUChar;
    }

    switch (numComp) {
      case 1:
        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);
        break;

      case 2:
        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);
        break;

      case 3:
        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);
        break;

      case 4:
        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);
        break;

      default:
        vtkErrorMacro('Cannot convert colors');
        return null;
    }

    return newColors;
  };

  publicAPI.usingLogScale = () => false;

  publicAPI.getNumberOfAvailableColors = () => 256 * 256 * 256;

  publicAPI.setRange = (min, max) => publicAPI.setMappingRange(min, max);
  publicAPI.getRange = (min, max) => publicAPI.getMappingRange();
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  alpha: 1.0,
  vectorComponent: 0,
  vectorSize: -1,
  vectorMode: VectorMode.COMPONENT,
  mappingRange: null,
  annotationArray: null,
  annotatedValueMap: null,
  indexedLookup: false,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);

  model.mappingRange = [0, 255];
  model.annotationArray = [];
  model.annotatedValueMap = [];

  // Create get-set macros
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'vectorSize',
    'vectorComponent',
    'vectorMode',
    'alpha',
    'indexedLookup',
  ]);

  // Create set macros for array (needs to know size)
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setArray(publicAPI, model, ['mappingRange'], 2);

  // Create get macros for array
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].getArray(publicAPI, model, ['mappingRange']);

  // For more macro methods, see "Sources/macro.js"

  // Object specific methods
  vtkScalarsToColors(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkScalarsToColors');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...vtk_js_Sources_Common_Core_ScalarsToColors_Constants__WEBPACK_IMPORTED_MODULE_2__["default"] });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/BoundingBox/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/BoundingBox/index.js ***!
  \***************************************************************************/
/*! exports provided: STATIC, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATIC", function() { return STATIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/Plane */ "./node_modules/vtk.js/Sources/Common/DataModel/Plane/index.js");




const INIT_BOUNDS = [
  Number.MAX_VALUE,
  -Number.MAX_VALUE, // X
  Number.MAX_VALUE,
  -Number.MAX_VALUE, // Y
  Number.MAX_VALUE,
  -Number.MAX_VALUE, // Z
];

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

function isValid(bounds) {
  return (
    bounds[0] <= bounds[1] && bounds[2] <= bounds[3] && bounds[4] <= bounds[5]
  );
}

function getCenter(bounds) {
  return [
    0.5 * (bounds[0] + bounds[1]),
    0.5 * (bounds[2] + bounds[3]),
    0.5 * (bounds[4] + bounds[5]),
  ];
}

function getLength(bounds, index) {
  return bounds[index * 2 + 1] - bounds[index * 2];
}

function getLengths(bounds) {
  return [getLength(bounds, 0), getLength(bounds, 1), getLength(bounds, 2)];
}

function getXRange(bounds) {
  return bounds.slice(0, 2);
}

function getYRange(bounds) {
  return bounds.slice(2, 4);
}

function getZRange(bounds) {
  return bounds.slice(4, 6);
}

function getMaxLength(bounds) {
  const l = getLengths(bounds);
  if (l[0] > l[1]) {
    if (l[0] > l[2]) {
      return l[0];
    }
    return l[2];
  }

  if (l[1] > l[2]) {
    return l[1];
  }

  return l[2];
}

function getDiagonalLength(bounds) {
  if (isValid(bounds)) {
    const l = getLengths(bounds);
    return Math.sqrt(l[0] * l[0] + l[1] * l[1] + l[2] * l[2]);
  }
  return null;
}

function oppositeSign(a, b) {
  return (a <= 0 && b >= 0) || (a >= 0 && b <= 0);
}

function getCorners(bounds, corners) {
  let count = 0;
  for (let ix = 0; ix < 2; ix++) {
    for (let iy = 2; iy < 4; iy++) {
      for (let iz = 4; iz < 6; iz++) {
        corners[count] = [bounds[ix], bounds[iy], bounds[iz]];
        count++;
      }
    }
  }
}

// Computes the two corners with minimal and miximal coordinates
function computeCornerPoints(point1, point2, bounds) {
  point1[0] = bounds[0];
  point1[1] = bounds[2];
  point1[2] = bounds[4];

  point2[0] = bounds[1];
  point2[1] = bounds[3];
  point2[2] = bounds[5];
}

function computeScale3(bounds, scale3 = []) {
  const center = getCenter(bounds);
  scale3[0] = bounds[1] - center[0];
  scale3[1] = bounds[3] - center[1];
  scale3[2] = bounds[5] - center[2];

  return scale3;
}

/**
 * Compute local bounds.
 * Not as fast as vtkPoints.getBounds() if u, v, w form a natural basis.
 * @param {vtkPoints} points
 * @param {array} u first vector
 * @param {array} v second vector
 * @param {array} w third vector
 */
function computeLocalBounds(points, u, v, w) {
  const bounds = [].concat(INIT_BOUNDS);
  const pointsData = points.getData();
  for (let i = 0; i < pointsData.length; i += 3) {
    const point = [pointsData[i], pointsData[i + 1], pointsData[i + 2]];
    const du = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["dot"](point, u);
    bounds[0] = Math.min(du, bounds[0]);
    bounds[1] = Math.max(du, bounds[1]);
    const dv = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["dot"](point, v);
    bounds[2] = Math.min(dv, bounds[2]);
    bounds[3] = Math.max(dv, bounds[3]);
    const dw = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["dot"](point, w);
    bounds[4] = Math.min(dw, bounds[4]);
    bounds[5] = Math.max(dw, bounds[5]);
  }
  return bounds;
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  isValid,
  getCenter,
  getLength,
  getLengths,
  getMaxLength,
  getDiagonalLength,
  getXRange,
  getYRange,
  getZRange,
  getCorners,
  computeCornerPoints,
  computeLocalBounds,
  computeScale3,
  INIT_BOUNDS,
};

// ----------------------------------------------------------------------------
// vtkBoundingBox methods
// ----------------------------------------------------------------------------

function vtkBoundingBox(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkBoundingBox');

  publicAPI.clone = () => {
    const bounds = [].concat(model.bounds);
    /* eslint-disable no-use-before-define */
    return newInstance({ bounds });
    /* eslint-enable no-use-before-define */
  };

  publicAPI.equals = (other) => {
    const a = model.bounds;
    const b = other.getBounds();
    return (
      a[0] === b[0] &&
      a[1] === b[1] &&
      a[2] === b[2] &&
      a[3] === b[3] &&
      a[4] === b[4] &&
      a[5] === b[5]
    );
  };

  publicAPI.setMinPoint = (x, y, z) => {
    const [xMin, xMax, yMin, yMax, zMin, zMax] = model.bounds;
    model.bounds = [
      x,
      x > xMax ? x : xMax,
      y,
      y > yMax ? y : yMax,
      z,
      z > zMax ? z : zMax,
    ];

    return xMin !== x || yMin !== y || zMin !== z;
  };

  publicAPI.setMaxPoint = (x, y, z) => {
    const [xMin, xMax, yMin, yMax, zMin, zMax] = model.bounds;
    model.bounds = [
      x < xMin ? x : xMin,
      x,
      y < yMin ? y : yMin,
      y,
      z < zMin ? z : zMin,
      z,
    ];

    return xMax !== x || yMax !== y || zMax !== z;
  };

  publicAPI.addPoint = (...xyz) => {
    model.bounds = model.bounds.map((value, index) => {
      if (index % 2 === 0) {
        const idx = index / 2;
        return value < xyz[idx] ? value : xyz[idx];
      }
      const idx = (index - 1) / 2;
      return value > xyz[idx] ? value : xyz[idx];
    });
  };

  publicAPI.addBounds = (xMin, xMax, yMin, yMax, zMin, zMax) => {
    const [_xMin, _xMax, _yMin, _yMax, _zMin, _zMax] = model.bounds;
    if (zMax === undefined) {
      model.bounds = [
        Math.min(xMin[0], _xMin),
        Math.max(xMin[1], _xMax),
        Math.min(xMin[2], _yMin),
        Math.max(xMin[3], _yMax),
        Math.min(xMin[4], _zMin),
        Math.max(xMin[5], _zMax),
      ];
    } else {
      model.bounds = [
        Math.min(xMin, _xMin),
        Math.max(xMax, _xMax),
        Math.min(yMin, _yMin),
        Math.max(yMax, _yMax),
        Math.min(zMin, _zMin),
        Math.max(zMax, _zMax),
      ];
    }
  };

  publicAPI.addBox = (other) => {
    publicAPI.addBounds(other.getBounds());
  };

  publicAPI.isValid = () => isValid(model.bounds);

  publicAPI.intersect = (bbox) => {
    if (!(publicAPI.isValid() && bbox.isValid())) {
      return false;
    }

    const newBounds = [0, 0, 0, 0, 0, 0];
    const bBounds = bbox.getBounds();
    let intersects;
    for (let i = 0; i < 3; i++) {
      intersects = false;
      if (
        bBounds[i * 2] >= model.bounds[i * 2] &&
        bBounds[i * 2] <= model.bounds[i * 2 + 1]
      ) {
        intersects = true;
        newBounds[i * 2] = bBounds[i * 2];
      } else if (
        model.bounds[i * 2] >= bBounds[i * 2] &&
        model.bounds[i * 2] <= bBounds[i * 2 + 1]
      ) {
        intersects = true;
        newBounds[i * 2] = model.bounds[i * 2];
      }

      if (
        bBounds[i * 2 + 1] >= model.bounds[i * 2] &&
        bBounds[i * 2 + 1] <= model.bounds[i * 2 + 1]
      ) {
        intersects = true;
        newBounds[i * 2 + 1] = bbox.MaxPnt[i];
      } else if (
        model.bounds[i * 2 + 1] >= bbox.MinPnt[i * 2] &&
        model.bounds[i * 2 + 1] <= bbox.MaxPnt[i * 2 + 1]
      ) {
        intersects = true;
        newBounds[i * 2 + 1] = model.bounds[i * 2 + 1];
      }

      if (!intersects) {
        return false;
      }
    }

    // OK they did intersect - set the box to be the result
    model.bounds = newBounds;
    return true;
  };

  publicAPI.intersects = (bbox) => {
    if (!(publicAPI.isValid() && bbox.isValid())) {
      return false;
    }
    const bBounds = bbox.getBounds();
    /* eslint-disable no-continue */
    for (let i = 0; i < 3; i++) {
      if (
        bBounds[i * 2] >= model.bounds[i * 2] &&
        bBounds[i * 2] <= model.bounds[i * 2 + 1]
      ) {
        continue;
      } else if (
        model.bounds[i * 2] >= bBounds[i * 2] &&
        model.bounds[i * 2] <= bBounds[i * 2 + 1]
      ) {
        continue;
      }

      if (
        bBounds[i * 2 + 1] >= model.bounds[i * 2] &&
        bBounds[i * 2 + 1] <= model.bounds[i * 2 + 1]
      ) {
        continue;
      } else if (
        model.bounds[i * 2 + 1] >= bbox.MinPnt[i * 2] &&
        model.bounds[i * 2 + 1] <= bbox.MaxPnt[i * 2 + 1]
      ) {
        continue;
      }
      return false;
    }
    /* eslint-enable no-continue */

    return true;
  };

  /**
   * Returns true if plane intersects bounding box.
   * If so, the box is cut by the plane
   * @param {array} origin
   * @param {array} normal
   */
  publicAPI.intersectPlane = (origin, normal) => {
    // Index[0..2] represents the order of traversing the corners of a cube
    // in (x,y,z), (y,x,z) and (z,x,y) ordering, respectively
    const index = [
      [0, 1, 2, 3, 4, 5, 6, 7],
      [0, 1, 4, 5, 2, 3, 6, 7],
      [0, 2, 4, 6, 1, 3, 5, 7],
    ];

    // stores the signed distance to a plane
    const d = [0, 0, 0, 0, 0, 0, 0, 0];
    let idx = 0;
    for (let ix = 0; ix < 2; ix++) {
      for (let iy = 2; iy < 4; iy++) {
        for (let iz = 4; iz < 6; iz++) {
          const x = [model.bounds[ix], model.bounds[iy], model.bounds[iz]];
          d[idx++] = vtk_js_Sources_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_2__["default"].evaluate(normal, origin, x);
        }
      }
    }

    let dir = 2;
    while (dir--) {
      // in each direction, we test if the vertices of two orthogonal faces
      // are on either side of the plane
      if (
        oppositeSign(d[index[dir][0]], d[index[dir][4]]) &&
        oppositeSign(d[index[dir][1]], d[index[dir][5]]) &&
        oppositeSign(d[index[dir][2]], d[index[dir][6]]) &&
        oppositeSign(d[index[dir][3]], d[index[dir][7]])
      ) {
        break;
      }
    }

    if (dir < 0) {
      return false;
    }

    const sign = Math.sign(normal[dir]);
    const size = Math.abs(
      (model.bounds[dir * 2 + 1] - model.bounds[dir * 2]) * normal[dir]
    );
    let t = sign > 0 ? 1 : 0;
    /* eslint-disable no-continue */
    for (let i = 0; i < 4; i++) {
      if (size === 0) {
        continue; // shouldn't happen
      }
      const ti = Math.abs(d[index[dir][i]]) / size;
      if (sign > 0 && ti < t) {
        t = ti;
      }

      if (sign < 0 && ti > t) {
        t = ti;
      }
    }
    /* eslint-enable no-continue */
    const bound =
      (1.0 - t) * model.bounds[dir * 2] + t * model.bounds[dir * 2 + 1];

    if (sign > 0) {
      model.bounds[dir * 2] = bound;
    } else {
      model.bounds[dir * 2 + 1] = bound;
    }

    return true;
  };

  publicAPI.containsPoint = (x, y, z) => {
    if (x < model.bounds[0] || x > model.bounds[1]) {
      return false;
    }

    if (y < model.bounds[2] || y > model.bounds[3]) {
      return false;
    }

    if (z < model.bounds[4] || z > model.bounds[5]) {
      return false;
    }

    return true;
  };

  publicAPI.getMinPoint = () => [
    model.bounds[0],
    model.bounds[2],
    model.bounds[4],
  ];
  publicAPI.getMaxPoint = () => [
    model.bounds[1],
    model.bounds[3],
    model.bounds[5],
  ];
  publicAPI.getBound = (index) => model.bound[index];

  publicAPI.contains = (bbox) => {
    // if either box is not valid or they don't intersect
    if (!publicAPI.intersects(bbox)) {
      return false;
    }

    if (!publicAPI.containsPoint(...bbox.getMinPoint())) {
      return false;
    }

    if (!publicAPI.containsPoint(...bbox.getMaxPoint())) {
      return 0;
    }

    return true;
  };

  publicAPI.getCenter = () => getCenter(model.bounds);
  publicAPI.getLength = (index) => getLength(model.bounds, index);
  publicAPI.getLengths = () => getLengths(model.bounds);
  publicAPI.getMaxLength = () => getMaxLength(model.bounds);
  publicAPI.getDiagonalLength = () => getDiagonalLength(model.bounds);

  publicAPI.reset = () => publicAPI.setBounds([].concat(INIT_BOUNDS));

  publicAPI.inflate = (delta) => {
    model.bounds = model.bounds.map((value, index) => {
      if (index % 2 === 0) {
        return value - delta;
      }
      return value + delta;
    });
  };

  publicAPI.getCorners = () => {
    getCorners(model.bounds, model.corners);
    return model.corners;
  };

  publicAPI.scale = (sx, sy, sz) => {
    if (publicAPI.isValid()) {
      const newBounds = [].concat(model.bounds);
      if (sx >= 0.0) {
        newBounds[0] *= sx;
        newBounds[1] *= sx;
      } else {
        newBounds[0] = sx * model.bounds[1];
        newBounds[1] = sx * model.bounds[0];
      }

      if (sy >= 0.0) {
        newBounds[2] *= sy;
        newBounds[3] *= sy;
      } else {
        newBounds[2] = sy * model.bounds[3];
        newBounds[3] = sy * model.bounds[2];
      }

      if (sz >= 0.0) {
        newBounds[4] *= sz;
        newBounds[5] *= sz;
      } else {
        newBounds[4] = sz * model.bounds[5];
        newBounds[5] = sz * model.bounds[4];
      }

      model.bounds = newBounds;
      return true;
    }
    return false;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  type: 'vtkBoundingBox',
  bounds: [].concat(INIT_BOUNDS),
  corners: [],
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(publicAPI, model);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGet(publicAPI, model, ['bounds']);
  vtkBoundingBox(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend, 'vtkBoundingBox');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...STATIC });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/Cell/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/Cell/index.js ***!
  \********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Points__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Points */ "./node_modules/vtk.js/Sources/Common/Core/Points/index.js");




// ----------------------------------------------------------------------------
// vtkCell methods
// ----------------------------------------------------------------------------

function vtkCell(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCell');

  publicAPI.initialize = (points, pointIdsList = null) => {
    if (!pointIdsList) {
      model.points = points;
      model.pointsIds = new Array(points.getNumberOfPoints());
      for (let i = points.getNumberOfPoints() - 1; i >= 0; --i) {
        model.pointsIds[i] = i;
      }
    } else {
      model.pointsIds = pointIdsList;
      let triangleData = model.points.getData();
      if (triangleData.length !== 3 * model.pointsIds.length) {
        triangleData = new window[points.getDataType()](
          3 * model.pointsIds.length
        );
      }
      const pointsData = points.getData();
      model.pointsIds.forEach((pointId, index) => {
        // const start = 3 * pointId;
        // pointsData.set(p.subarray(start, start + 3), 3 * index);
        let pointOffset = 3 * pointId;
        let trianglePointOffset = 3 * index;
        triangleData[trianglePointOffset] = pointsData[pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
      });
      model.points.setData(triangleData);
    }
  };

  publicAPI.getBounds = () => {
    const nbPoints = model.points.getNumberOfPoints();
    const x = [];
    if (nbPoints) {
      model.points.getPoint(0, x);
      model.bounds[0] = x[0];
      model.bounds[1] = x[0];
      model.bounds[2] = x[1];
      model.bounds[3] = x[1];
      model.bounds[4] = x[2];
      model.bounds[5] = x[2];

      for (let i = 1; i < nbPoints; i++) {
        model.points.getPoint(i, x);
        model.bounds[0] = x[0] < model.bounds[0] ? x[0] : model.bounds[0];
        model.bounds[1] = x[0] > model.bounds[1] ? x[0] : model.bounds[1];
        model.bounds[2] = x[1] < model.bounds[2] ? x[1] : model.bounds[2];
        model.bounds[3] = x[1] > model.bounds[3] ? x[1] : model.bounds[3];
        model.bounds[4] = x[2] < model.bounds[4] ? x[2] : model.bounds[4];
        model.bounds[5] = x[2] > model.bounds[5] ? x[2] : model.bounds[5];
      }
    } else {
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["uninitializeBounds"](model.bounds);
    }
    return model.bounds;
  };

  publicAPI.getLength2 = () => {
    publicAPI.getBounds();
    let length = 0.0;
    let diff = 0;
    for (let i = 0; i < 3; i++) {
      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];
      length += diff * diff;
    }
    return length;
  };

  publicAPI.getParametricDistance = (pcoords) => {
    let pDist;
    let pDistMax = 0.0;

    for (let i = 0; i < 3; i++) {
      if (pcoords[i] < 0.0) {
        pDist = -pcoords[i];
      } else if (pcoords[i] > 1.0) {
        pDist = pcoords[i] - 1.0;
      } else {
        // inside the cell in the parametric direction
        pDist = 0.0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };

  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();

  publicAPI.deepCopy = (cell) => {
    cell.initialize(model.points, model.pointsIds);
  };

  publicAPI.getCellDimension = () => {}; // virtual
  publicAPI.intersectWithLine = (p1, p2, tol, t, x, pcoords, subId) => {}; // virtual
  publicAPI.evaluatePosition = (
    x,
    closestPoint,
    subId,
    pcoords,
    dist2,
    weights
  ) => {}; // virtual
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  bounds: [-1, -1, -1, -1, -1, -1],
  pointsIds: [],
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);

  if (!model.points) {
    model.points = vtk_js_Sources_Common_Core_Points__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
  }

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['points', 'pointsIds']);

  vtkCell(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkCell');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/CellLinks/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/CellLinks/index.js ***!
  \*************************************************************************/
/*! exports provided: InitLink, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InitLink", function() { return InitLink; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/Cell */ "./node_modules/vtk.js/Sources/Common/DataModel/Cell/index.js");



// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------
const InitLink = {
  ncells: 0,
  cells: null,
};

function resize(model, sz) {
  let newSize = sz;
  if (sz >= model.array.length) {
    newSize += model.array.length;
  }

  while (newSize > model.array.length)
    model.array.push({
      ncells: 0,
      cells: null,
    });
  model.array.length = newSize;
}

// ----------------------------------------------------------------------------
// vtkCellLinks methods
// ----------------------------------------------------------------------------

function vtkCellLinks(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCellLinks');

  /**
   * Build the link list array. All subclasses of vtkAbstractCellLinks
   * must support this method.
   */
  publicAPI.buildLinks = (data) => {
    const numPts = data.getPoints().getNumberOfPoints();
    const numCells = data.getNumberOfCells();

    // fill out lists with number of references to cells
    const linkLoc = new Uint32Array(numPts);

    // Use fast path if polydata
    if (data.isA('vtkPolyData')) {
      // traverse data to determine number of uses of each point
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const { cellPointIds } = data.getCellPoints(cellId);
        cellPointIds.forEach((cellPointId) => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }

      // now allocate storage for the links
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;

      for (let cellId = 0; cellId < numCells; ++cellId) {
        const { cellPointIds } = data.getCellPoints(cellId);
        cellPointIds.forEach((cellPointId) => {
          publicAPI.insertCellReference(
            cellPointId,
            linkLoc[cellPointId]++,
            cellId
          );
        });
      }
    } // any other type of dataset
    else {
      // traverse data to determine number of uses of each point
      for (let cellId = 0; cellId < numCells; cellId++) {
        // TODO: Currently not supported: const cell = data.getCell(cellId);
        const cell = vtk_js_Sources_Common_DataModel_Cell__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
        cell.getPointsIds().forEach((cellPointId) => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }

      // now allocate storage for the links
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;

      for (let cellId = 0; cellId < numCells; ++cellId) {
        // TODO: Currently not supported: const cell = data.getCell(cellId);
        const cell = vtk_js_Sources_Common_DataModel_Cell__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
        cell.getPointsIds().forEach((cellPointId) => {
          publicAPI.insertCellReference(
            cellPointId,
            linkLoc[cellPointId]++,
            cellId
          );
        });
      }
    } // end else
  };

  /**
   * Build the link list array with a provided connectivity array.
   */
  // publicAPI.buildLinks = (data, connectivity) => {};

  /**
   * Allocate the specified number of links (i.e., number of points) that
   * will be built.
   */
  publicAPI.allocate = (numLinks, ext = 1000) => {
    model.array = Array(numLinks)
      .fill()
      .map(() => ({
        ncells: 0,
        cells: null,
      }));
    model.extend = ext;
    model.maxId = -1;
  };

  publicAPI.initialize = () => {
    model.array = null;
  };

  /**
   * Get a link structure given a point id.
   */
  publicAPI.getLink = (ptId) => model.array[ptId];

  /**
   * Get the number of cells using the point specified by ptId.
   */
  publicAPI.getNcells = (ptId) => model.array[ptId].ncells;

  /**
   * Return a list of cell ids using the point.
   */
  publicAPI.getCells = (ptId) => model.array[ptId].cells;

  /**
   * Insert a new point into the cell-links data structure. The size parameter
   * is the initial size of the list.
   */
  publicAPI.insertNextPoint = (numLinks) => {
    model.array.push({ ncells: numLinks, cells: Array(numLinks) });
    ++model.maxId;
  };

  /**
   * Insert a cell id into the list of cells (at the end) using the cell id
   * provided. (Make sure to extend the link list (if necessary) using the
   * method resizeCellList().)
   */
  publicAPI.insertNextCellReference = (ptId, cellId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };

  /**
   * Delete point (and storage) by destroying links to using cells.
   */
  publicAPI.deletePoint = (ptId) => {
    model.array[ptId].ncells = 0;
    model.array[ptId].cells = null;
  };

  /**
   * Delete the reference to the cell (cellId) from the point (ptId). This
   * removes the reference to the cellId from the cell list, but does not
   * resize the list (recover memory with resizeCellList(), if necessary).
   */
  publicAPI.removeCellReference = (cellId, ptId) => {
    model.array[ptId].cells = model.array[ptId].cells.filter(
      (cell) => cell !== cellId
    );
    model.array[ptId].ncells = model.array[ptId].cells.length;
  };

  /**
   * Add the reference to the cell (cellId) from the point (ptId). This
   * adds a reference to the cellId from the cell list, but does not resize
   * the list (extend memory with resizeCellList(), if necessary).
   */
  publicAPI.addCellReference = (cellId, ptId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };

  /**
   * Change the length of a point's link list (i.e., list of cells using a
   * point) by the size specified.
   */
  publicAPI.resizeCellList = (ptId, size) => {
    model.array[ptId].cells.length = size;
  };

  /**
   * Reclaim any unused memory.
   */
  publicAPI.squeeze = () => {
    resize(model, model.maxId + 1);
  };

  /**
   * Reset to a state of no entries without freeing the memory.
   */
  publicAPI.reset = () => {
    model.maxId = -1;
  };

  /**
   * Standard DeepCopy method.  Since this object contains no reference
   * to other objects, there is no ShallowCopy.
   */
  publicAPI.deepCopy = (src) => {
    model.array = [...src.array];
    model.extend = src.extend;
    model.maxId = src.maxId;
  };

  /**
   * Increment the count of the number of cells using the point.
   */
  publicAPI.incrementLinkCount = (ptId) => {
    ++model.array[ptId].ncells;
  };

  publicAPI.allocateLinks = (n) => {
    for (let i = 0; i < n; ++i) {
      model.array[i].cells = new Array(model.array[i].ncells);
    }
  };

  /**
   * Insert a cell id into the list of cells using the point.
   */
  publicAPI.insertCellReference = (ptId, pos, cellId) => {
    model.array[ptId].cells[pos] = cellId;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  array: null, // pointer to data
  maxId: 0, // maximum index inserted thus far
  extend: 0, // grow array by this point
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);

  vtkCellLinks(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkCellLinks');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/CellTypes/Constants.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/CellTypes/Constants.js ***!
  \*****************************************************************************/
/*! exports provided: CellType, CellTypesStrings, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CellType", function() { return CellType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CellTypesStrings", function() { return CellTypesStrings; });
const CellType = {
  // Linear cells
  VTK_EMPTY_CELL: 0,
  VTK_VERTEX: 1,
  VTK_POLY_VERTEX: 2,
  VTK_LINE: 3,
  VTK_POLY_LINE: 4,
  VTK_TRIANGLE: 5,
  VTK_TRIANGLE_STRIP: 6,
  VTK_POLYGON: 7,
  VTK_PIXEL: 8,
  VTK_QUAD: 9,
  VTK_TETRA: 10,
  VTK_VOXEL: 11,
  VTK_HEXAHEDRON: 12,
  VTK_WEDGE: 13,
  VTK_PYRAMID: 14,
  VTK_PENTAGONAL_PRISM: 15,
  VTK_HEXAGONAL_PRISM: 16,

  // Quadratic, isoparametric cells
  VTK_QUADRATIC_EDGE: 21,
  VTK_QUADRATIC_TRIANGLE: 22,
  VTK_QUADRATIC_QUAD: 23,
  VTK_QUADRATIC_POLYGON: 36,
  VTK_QUADRATIC_TETRA: 24,
  VTK_QUADRATIC_HEXAHEDRON: 25,
  VTK_QUADRATIC_WEDGE: 26,
  VTK_QUADRATIC_PYRAMID: 27,
  VTK_BIQUADRATIC_QUAD: 28,
  VTK_TRIQUADRATIC_HEXAHEDRON: 29,
  VTK_QUADRATIC_LINEAR_QUAD: 30,
  VTK_QUADRATIC_LINEAR_WEDGE: 31,
  VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,
  VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,
  VTK_BIQUADRATIC_TRIANGLE: 34,

  // Cubic, isoparametric cell
  VTK_CUBIC_LINE: 35,

  // Special class of cells formed by convex group of points
  VTK_CONVEX_POINT_SET: 41,

  // Polyhedron cell (consisting of polygonal faces)
  VTK_POLYHEDRON: 42,

  // Higher order cells in parametric form
  VTK_PARAMETRIC_CURVE: 51,
  VTK_PARAMETRIC_SURFACE: 52,
  VTK_PARAMETRIC_TRI_SURFACE: 53,
  VTK_PARAMETRIC_QUAD_SURFACE: 54,
  VTK_PARAMETRIC_TETRA_REGION: 55,
  VTK_PARAMETRIC_HEX_REGION: 56,

  // Higher order cells
  VTK_HIGHER_ORDER_EDGE: 60,
  VTK_HIGHER_ORDER_TRIANGLE: 61,
  VTK_HIGHER_ORDER_QUAD: 62,
  VTK_HIGHER_ORDER_POLYGON: 63,
  VTK_HIGHER_ORDER_TETRAHEDRON: 64,
  VTK_HIGHER_ORDER_WEDGE: 65,
  VTK_HIGHER_ORDER_PYRAMID: 66,
  VTK_HIGHER_ORDER_HEXAHEDRON: 67,

  // Arbitrary order Lagrange elements (formulated separated from generic higher order cells)
  VTK_LAGRANGE_CURVE: 68,
  VTK_LAGRANGE_TRIANGLE: 69,
  VTK_LAGRANGE_QUADRILATERAL: 70,
  VTK_LAGRANGE_TETRAHEDRON: 71,
  VTK_LAGRANGE_HEXAHEDRON: 72,
  VTK_LAGRANGE_WEDGE: 73,
  VTK_LAGRANGE_PYRAMID: 74,

  VTK_NUMBER_OF_CELL_TYPES: 75,
};

// This list should contain the cell class names in
// the same order as in CellType.
const CellTypesStrings = [
  'vtkEmptyCell',
  'vtkVertex',
  'vtkPolyVertex',
  'vtkLine',
  'vtkPolyLine',
  'vtkTriangle',
  'vtkTriangleStrip',
  'vtkPolygon',
  'vtkPixel',
  'vtkQuad',
  'vtkTetra',
  'vtkVoxel',
  'vtkHexahedron',
  'vtkWedge',
  'vtkPyramid',
  'vtkPentagonalPrism',
  'vtkHexagonalPrism',
  'UnknownClass',
  'UnknownClass',
  'UnknownClass',
  'UnknownClass',
  'vtkQuadraticEdge',
  'vtkQuadraticTriangle',
  'vtkQuadraticQuad',
  'vtkQuadraticTetra',
  'vtkQuadraticHexahedron',
  'vtkQuadraticWedge',
  'vtkQuadraticPyramid',
  'vtkBiQuadraticQuad',
  'vtkTriQuadraticHexahedron',
  'vtkQuadraticLinearQuad',
  'vtkQuadraticLinearWedge',
  'vtkBiQuadraticQuadraticWedge',
  'vtkBiQuadraticQuadraticHexahedron',
  'vtkBiQuadraticTriangle',
  'vtkCubicLine',
  'vtkQuadraticPolygon',
  'UnknownClass',
  'UnknownClass',
  'UnknownClass',
  'UnknownClass',
  'vtkConvexPointSet',
  'UnknownClass',
  'UnknownClass',
  'UnknownClass',
  'UnknownClass',
  'UnknownClass',
  'UnknownClass',
  'UnknownClass',
  'UnknownClass',
  'UnknownClass',
  'vtkParametricCurve',
  'vtkParametricSurface',
  'vtkParametricTriSurface',
  'vtkParametricQuadSurface',
  'vtkParametricTetraRegion',
  'vtkParametricHexRegion',
  'UnknownClass',
  'UnknownClass',
  'UnknownClass',
  'vtkHigherOrderEdge',
  'vtkHigherOrderTriangle',
  'vtkHigherOrderQuad',
  'vtkHigherOrderPolygon',
  'vtkHigherOrderTetrahedron',
  'vtkHigherOrderWedge',
  'vtkHigherOrderPyramid',
  'vtkHigherOrderHexahedron',
];

/* harmony default export */ __webpack_exports__["default"] = ({
  CellType,
  CellTypesStrings,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/CellTypes/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/CellTypes/index.js ***!
  \*************************************************************************/
/*! exports provided: STATIC, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATIC", function() { return STATIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/CellTypes/Constants */ "./node_modules/vtk.js/Sources/Common/DataModel/CellTypes/Constants.js");



// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

/**
 * Given an int (as defined in vtkCellType.h) identifier for a class
 * return it's classname.
 */
function getClassNameFromTypeId(typeId) {
  return typeId < vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_1__["CellTypesStrings"].length
    ? vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_1__["CellTypesStrings"][typeId]
    : 'UnknownClass';
}

/**
 * Given a data object classname, return it's int identified (as
 * defined in vtkCellType.h)
 */
function getTypeIdFromClassName(cellTypeString) {
  return vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_1__["CellTypesStrings"].findIndex(cellTypeString);
}

/**
 * This convenience method is a fast check to determine if a cell type
 * represents a linear or nonlinear cell.  This is generally much more
 * efficient than getting the appropriate vtkCell and checking its IsLinear
 * method.
 */
function isLinear(type) {
  return (
    type < vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_1__["CellType"].VTK_QUADRATIC_EDGE ||
    type === vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_1__["CellType"].VTK_CONVEX_POINT_SET ||
    type === vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_1__["CellType"].VTK_POLYHEDRON
  );
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  getClassNameFromTypeId,
  getTypeIdFromClassName,
  isLinear,
};

// ----------------------------------------------------------------------------
// vtkCellTypes methods
// ----------------------------------------------------------------------------

function vtkCellTypes(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCellTypes');

  /**
   * Allocate memory for this array. Delete old storage only if necessary.
   */
  publicAPI.allocate = (sz = 512, ext = 1000) => {
    model.size = sz > 0 ? sz : 1;
    model.extend = ext > 0 ? ext : 1;
    model.maxId = -1;
    model.typeArray = new Uint8Array(sz);
    model.locationArray = new Uint32Array(sz);
  };

  /**
   * Add a cell at specified id.
   */
  publicAPI.insertCell = (cellId, type, loc) => {
    model.typeArray[cellId] = type;
    model.locationArray[cellId] = loc;

    if (cellId > model.maxId) {
      model.maxId = cellId;
    }
  };

  /**
   * Add a cell to the object in the next available slot.
   */
  publicAPI.insertNextCell = (type, loc) => {
    publicAPI.insertCell(++model.maxId, type, loc);
    return model.maxId;
  };

  /**
   * Specify a group of cell types. This version is provided to maintain
   * backwards compatibility and does a copy of the cellLocations
   */
  publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {
    model.size = ncells;

    model.typeArray = cellTypes;
    model.locationArray = cellLocations;

    model.maxId = ncells - 1;
  };

  /**
   * Return the location of the cell in the associated vtkCellArray.
   */
  publicAPI.getCellLocation = (cellId) => model.locationArray[cellId];

  /**
   * Delete cell by setting to nullptr cell type.
   */
  publicAPI.deleteCell = (cellId) => {
    model.typeArray[cellId] = vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_1__["CellType"].VTK_EMPTY_CELL;
  };

  /**
   * Return the number of types in the list.
   */
  publicAPI.getNumberOfTypes = () => model.maxId + 1;

  /**
   * Return true if type specified is contained in list; false otherwise.
   */
  publicAPI.isType = (type) => {
    const numTypes = publicAPI.getNumberOfTypes();

    for (let i = 0; i < numTypes; ++i) {
      if (type === publicAPI.getCellType(i)) {
        return true;
      }
    }
    return false;
  };

  /**
   * Add the type specified to the end of the list. Range checking is performed.
   */
  publicAPI.insertNextType = (type) => publicAPI.insertNextCell(type, -1);

  /**
   * Return the type of cell.
   */
  publicAPI.getCellType = (cellId) => model.typeArray[cellId];

  /**
   * Reclaim any extra memory.
   */
  // TODO: publicAPI.squeeze = () =>  {};

  /**
   * Initialize object without releasing memory.
   */
  publicAPI.reset = () => {
    model.maxId = -1;
  };

  /**
   * Standard DeepCopy method.  Since this object contains no reference
   * to other objects, there is no ShallowCopy.
   */
  publicAPI.deepCopy = (src) => {
    publicAPI.allocate(src.getSize(), src.getExtend());
    model.typeArray.set(src.getTypeArray());
    model.locationArray.set(src.getLocationArray());
    model.maxId = src.getMaxId();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // typeArray: null, // pointer to types array
  // locationArray: null;   // pointer to array of offsets
  size: 0, // allocated size of data
  maxId: -1, // maximum index inserted thus far
  extend: 1000, // grow array by this point
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['size', 'maxId', 'extend']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].getArray(publicAPI, model, ['typeArray', 'locationArray']);

  vtkCellTypes(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkCellTypes');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...STATIC });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/DataSet/Constants.js":
/*!***************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/DataSet/Constants.js ***!
  \***************************************************************************/
/*! exports provided: FieldDataTypes, FieldAssociations, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FieldDataTypes", function() { return FieldDataTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FieldAssociations", function() { return FieldAssociations; });
// Specify how data arrays can be used by data objects
const FieldDataTypes = {
  UNIFORM: 0, // data that does not vary over points/cells/etc.
  DATA_OBJECT_FIELD: 0, // to match VTK

  COORDINATE: 1, // data that specifies the location of each point
  POINT_DATA: 1, // to match VTK

  POINT: 2, // data defined at each point, but that does not specify the point location
  POINT_FIELD_DATA: 2, // to match VTK

  CELL: 3, // data defined at each cell, but that does not specify the cell
  CELL_FIELD_DATA: 3, // to match VTK

  VERTEX: 4, // data defined at each graph vertex, but that does not specify the graph vertex
  VERTEX_FIELD_DATA: 4, // to match VTK

  EDGE: 5, // data defined at each graph edge, but that does not specify the graph edge
  EDGE_FIELD_DATA: 5, // to match VTK

  ROW: 6, // data specifying a table row
  ROW_DATA: 6, // to match VTK
};

const FieldAssociations = {
  FIELD_ASSOCIATION_POINTS: 0,
  FIELD_ASSOCIATION_CELLS: 1,
  FIELD_ASSOCIATION_NONE: 2,
  FIELD_ASSOCIATION_POINTS_THEN_CELLS: 3,
  FIELD_ASSOCIATION_VERTICES: 4,
  FIELD_ASSOCIATION_EDGES: 5,
  FIELD_ASSOCIATION_ROWS: 6,
  NUMBER_OF_ASSOCIATIONS: 7,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  FieldDataTypes,
  FieldAssociations,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/DataSet/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/DataSet/index.js ***!
  \***********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_vtk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/vtk */ "./node_modules/vtk.js/Sources/vtk.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_DataSetAttributes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/DataSetAttributes */ "./node_modules/vtk.js/Sources/Common/DataModel/DataSetAttributes/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_DataSet_Constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/DataSet/Constants */ "./node_modules/vtk.js/Sources/Common/DataModel/DataSet/Constants.js");





// import vtkBoundingBox from '../BoundingBox';
// import * as vtkMath from '../../Core/Math';
//
// function getBounds(dataset) {
//   if (dataset.bounds) {
//     return dataset.bounds;
//   }
//   if (dataset.type && dataset[dataset.type]) {
//     const ds = dataset[dataset.type];
//     if (ds.bounds) {
//       return ds.bounds;
//     }
//     if (ds.Points && ds.Points.bounds) {
//       return ds.Points.bounds;
//     }

//     if (ds.Points && ds.Points.values) {
//       const array = ds.Points.values;
//       const bbox = vtkBoundingBox.newInstance();
//       const size = array.length;
//       const delta = ds.Points.numberOfComponents ? ds.Points.numberOfComponents : 3;
//       for (let idx = 0; idx < size; idx += delta) {
//         bbox.addPoint(array[idx * delta], array[(idx * delta) + 1], array[(idx * delta) + 2]);
//       }
//       ds.Points.bounds = bbox.getBounds();
//       return ds.Points.bounds;
//     }
//   }
//   return vtkMath.createUninitializedBounds();
// }

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

const DATASET_FIELDS = ['pointData', 'cellData', 'fieldData'];

// ----------------------------------------------------------------------------
// vtkDataSet methods
// ----------------------------------------------------------------------------

function vtkDataSet(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkDataSet');

  // Add dataset attributes
  DATASET_FIELDS.forEach((fieldName) => {
    if (!model[fieldName]) {
      model[fieldName] = vtk_js_Sources_Common_DataModel_DataSetAttributes__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
    } else {
      model[fieldName] = Object(vtk_js_Sources_vtk__WEBPACK_IMPORTED_MODULE_1__["default"])(model[fieldName]);
    }
  });

  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = (other, debug = false) => {
    superShallowCopy(other, debug);
    DATASET_FIELDS.forEach((fieldName) => {
      model[fieldName] = vtk_js_Sources_Common_DataModel_DataSetAttributes__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
      model[fieldName].shallowCopy(other.getReferenceByName(fieldName));
    });
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // pointData: null,
  // cellData: null,
  // fieldData: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, DATASET_FIELDS);

  // Object specific methods
  vtkDataSet(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkDataSet');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...vtk_js_Sources_Common_DataModel_DataSet_Constants__WEBPACK_IMPORTED_MODULE_3__["default"] });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/DataSetAttributes/Constants.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/DataSetAttributes/Constants.js ***!
  \*************************************************************************************/
/*! exports provided: AttributeTypes, AttributeLimitTypes, CellGhostTypes, PointGhostTypes, AttributeCopyOperations, ghostArrayName, DesiredOutputPrecision, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttributeTypes", function() { return AttributeTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttributeLimitTypes", function() { return AttributeLimitTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CellGhostTypes", function() { return CellGhostTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointGhostTypes", function() { return PointGhostTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AttributeCopyOperations", function() { return AttributeCopyOperations; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ghostArrayName", function() { return ghostArrayName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DesiredOutputPrecision", function() { return DesiredOutputPrecision; });
const AttributeTypes = {
  SCALARS: 0,
  VECTORS: 1,
  NORMALS: 2,
  TCOORDS: 3,
  TENSORS: 4,
  GLOBALIDS: 5,
  PEDIGREEIDS: 6,
  EDGEFLAG: 7,
  NUM_ATTRIBUTES: 8,
};

const AttributeLimitTypes = {
  MAX: 0,
  EXACT: 1,
  NOLIMIT: 2,
};

const CellGhostTypes = {
  DUPLICATECELL: 1, // the cell is present on multiple processors
  HIGHCONNECTIVITYCELL: 2, // the cell has more neighbors than in a regular mesh
  LOWCONNECTIVITYCELL: 4, // the cell has less neighbors than in a regular mesh
  REFINEDCELL: 8, // other cells are present that refines it.
  EXTERIORCELL: 16, // the cell is on the exterior of the data set
  HIDDENCELL: 32, // the cell is needed to maintain connectivity, but the data values should be ignored.
};

const PointGhostTypes = {
  DUPLICATEPOINT: 1, // the cell is present on multiple processors
  HIDDENPOINT: 2, // the point is needed to maintain connectivity, but the data values should be ignored.
};

const AttributeCopyOperations = {
  COPYTUPLE: 0,
  INTERPOLATE: 1,
  PASSDATA: 2,
  ALLCOPY: 3, // all of the above
};

const ghostArrayName = 'vtkGhostType';

const DesiredOutputPrecision = {
  DEFAULT: 0, // use the point type that does not truncate any data
  SINGLE: 1, // use Float32Array
  DOUBLE: 2, // use Float64Array
};

/* harmony default export */ __webpack_exports__["default"] = ({
  AttributeCopyOperations,
  AttributeLimitTypes,
  AttributeTypes,
  CellGhostTypes,
  DesiredOutputPrecision,
  PointGhostTypes,
  ghostArrayName,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/DataSetAttributes/FieldData.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/DataSetAttributes/FieldData.js ***!
  \*************************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_vtk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/vtk */ "./node_modules/vtk.js/Sources/vtk.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/index.js");




// ----------------------------------------------------------------------------
// vtkFieldData methods
// ----------------------------------------------------------------------------

function vtkFieldData(publicAPI, model) {
  model.classHierarchy.push('vtkFieldData');
  const superGetState = publicAPI.getState;

  // Decode serialized data if any
  if (model.arrays) {
    model.arrays = model.arrays.map((item) => ({ data: Object(vtk_js_Sources_vtk__WEBPACK_IMPORTED_MODULE_0__["default"])(item.data) }));
  }

  publicAPI.initialize = () => {
    publicAPI.initializeFields();
    publicAPI.copyAllOn();
    publicAPI.clearFieldFlags();
  };

  publicAPI.initializeFields = () => {
    model.arrays = [];
    model.copyFieldFlags = {};
    publicAPI.modified();
  };

  publicAPI.copyStructure = (other) => {
    publicAPI.initializeFields();
    model.copyFieldFlags = other.getCopyFieldFlags().map((x) => x); // Deep-copy
    model.arrays = other.arrays().map((x) => ({ array: x })); // Deep-copy
    // TODO: Copy array information objects (once we support information objects)
  };

  publicAPI.getNumberOfArrays = () => model.arrays.length;
  publicAPI.getNumberOfActiveArrays = () => model.arrays.length;
  publicAPI.addArray = (arr) => {
    model.arrays = [].concat(model.arrays, { data: arr });
    return model.arrays.length - 1;
  };
  publicAPI.removeAllArrays = () => {
    model.arrays = [];
  };
  publicAPI.removeArray = (arrayName) => {
    model.arrays = model.arrays.filter(
      (entry) => arrayName !== entry.data.getName()
    );
  };
  publicAPI.removeArrayByIndex = (arrayIdx) => {
    model.arrays = model.arrays.filter((entry, idx) => idx !== arrayIdx);
  };
  publicAPI.getArrays = () => model.arrays.map((entry) => entry.data);
  publicAPI.getArray = (arraySpec) =>
    typeof arraySpec === 'number'
      ? publicAPI.getArrayByIndex(arraySpec)
      : publicAPI.getArrayByName(arraySpec);
  publicAPI.getArrayByName = (arrayName) =>
    model.arrays.reduce(
      (a, b, i) => (b.data.getName() === arrayName ? b.data : a),
      null
    );
  publicAPI.getArrayWithIndex = (arrayName) =>
    model.arrays.reduce(
      (a, b, i) =>
        b.data && b.data.getName() === arrayName
          ? { array: b.data, index: i }
          : a,
      { array: null, index: -1 }
    );
  publicAPI.getArrayByIndex = (idx) =>
    idx >= 0 && idx < model.arrays.length ? model.arrays[idx].data : null;
  publicAPI.hasArray = (arrayName) =>
    publicAPI.getArrayWithIndex(arrayName).index >= 0;
  publicAPI.getArrayName = (idx) => {
    const arr = model.arrays[idx];
    return arr ? arr.data.getName() : '';
  };
  publicAPI.getCopyFieldFlags = () => model.copyFieldFlags;
  publicAPI.getFlag = (arrayName) => model.copyFieldFlags[arrayName];
  publicAPI.passData = (other, fromId = -1, toId = -1) => {
    other.getArrays().forEach((arr) => {
      const copyFlag = publicAPI.getFlag(arr.getName());
      if (
        copyFlag !== false &&
        !(model.doCopyAllOff && copyFlag !== true) &&
        arr
      ) {
        let destArr = publicAPI.getArrayByName(arr.getName());
        if (!destArr) {
          if (fromId < 0 || fromId > arr.getNumberOfTuples()) {
            publicAPI.addArray(arr);
          } else {
            const ncomps = arr.getNumberOfComponents();
            let newSize = arr.getNumberOfValues();
            const tId = toId > -1 ? toId : fromId;
            if (newSize < tId * ncomps) {
              newSize = (tId + 1) * ncomps;
            }
            destArr = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance({
              name: arr.getName(),
              dataType: arr.getDataType(),
              numberOfComponents: arr.getNumberOfComponents(),
              size: newSize,
            });
            destArr.setTuple(tId, arr.getTuple(fromId));
            publicAPI.addArray(destArr);
          }
        } else if (
          arr.getNumberOfComponents() === destArr.getNumberOfComponents()
        ) {
          if (fromId > -1 && fromId < arr.getNumberOfTuples()) {
            const tId = toId > -1 ? toId : fromId;
            destArr.setTuple(tId, arr.getTuple(fromId));
          } else {
            // if fromId and not provided, just copy all (or as much possible)
            // of arr to destArr.
            for (let i = 0; i < arr.getNumberOfTuples(); ++i) {
              destArr.setTuple(i, arr.getTuple(i));
            }
          }
        }
      }
    });
  };
  publicAPI.copyFieldOn = (arrayName) => {
    model.copyFieldFlags[arrayName] = true;
  };
  publicAPI.copyFieldOff = (arrayName) => {
    model.copyFieldFlags[arrayName] = false;
  };
  publicAPI.copyAllOn = () => {
    if (!model.doCopyAllOn || model.doCopyAllOff) {
      model.doCopyAllOn = true;
      model.doCopyAllOff = false;
      publicAPI.modified();
    }
  };
  publicAPI.copyAllOff = () => {
    if (model.doCopyAllOn || !model.doCopyAllOff) {
      model.doCopyAllOn = false;
      model.doCopyAllOff = true;
      publicAPI.modified();
    }
  };
  publicAPI.clearFieldFlags = () => {
    model.copyFieldFlags = {};
  };
  publicAPI.deepCopy = (other) => {
    model.arrays = other.getArrays().map((arr) => {
      const arrNew = arr.newClone();
      arrNew.deepCopy(arr);
      return { data: arrNew };
    });
  };
  publicAPI.copyFlags = (other) => other.getCopyFieldFlags().map((x) => x);
  // TODO: publicAPI.squeeze = () => model.arrays.forEach(entry => entry.data.squeeze());
  publicAPI.reset = () => model.arrays.forEach((entry) => entry.data.reset());
  // TODO: getActualMemorySize
  publicAPI.getMTime = () =>
    model.arrays.reduce(
      (a, b) => (b.data.getMTime() > a ? b.data.getMTime() : a),
      model.mtime
    );
  // TODO: publicAPI.getField = (ids, other) => { copy ids from other into this model's arrays }
  // TODO: publicAPI.getArrayContainingComponent = (component) => ...
  publicAPI.getNumberOfComponents = () =>
    model.arrays.reduce((a, b) => a + b.data.getNumberOfComponents(), 0);
  publicAPI.getNumberOfTuples = () =>
    model.arrays.length > 0 ? model.arrays[0].getNumberOfTuples() : 0;

  publicAPI.getState = () => {
    const result = superGetState();
    result.arrays = model.arrays.map((item) => ({
      data: item.data.getState(),
    }));
    return result;
  };
}

const DEFAULT_VALUES = {
  arrays: [],
  copyFieldFlags: [], // fields not to copy
  doCopyAllOn: true,
  doCopyAllOff: false,
};

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(publicAPI, model);

  vtkFieldData(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend, 'vtkFieldData');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/DataSetAttributes/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/DataSetAttributes/index.js ***!
  \*********************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_DataSetAttributes_FieldData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/DataSetAttributes/FieldData */ "./node_modules/vtk.js/Sources/Common/DataModel/DataSetAttributes/FieldData.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_DataSetAttributes_Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/DataSetAttributes/Constants */ "./node_modules/vtk.js/Sources/Common/DataModel/DataSetAttributes/Constants.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/index.js");





const { AttributeTypes, AttributeCopyOperations } = vtk_js_Sources_Common_DataModel_DataSetAttributes_Constants__WEBPACK_IMPORTED_MODULE_2__["default"];
const { vtkWarningMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

// ----------------------------------------------------------------------------
// vtkDataSetAttributes methods
// ----------------------------------------------------------------------------

function vtkDataSetAttributes(publicAPI, model) {
  const attrTypes = [
    'Scalars',
    'Vectors',
    'Normals',
    'TCoords',
    'Tensors',
    'GlobalIds',
    'PedigreeIds',
  ];

  function cleanAttributeType(attType) {
    // Given an integer or string, convert the result to one of the
    // strings in the "attrTypes" array above or null (if
    // no match is found)
    let cleanAttType = attrTypes.find(
      (ee) =>
        AttributeTypes[ee.toUpperCase()] === attType ||
        (typeof attType !== 'number' &&
          ee.toLowerCase() === attType.toLowerCase())
    );
    if (typeof cleanAttType === 'undefined') {
      cleanAttType = null;
    }
    return cleanAttType;
  }

  // Set our className
  model.classHierarchy.push('vtkDataSetAttributes');

  publicAPI.checkNumberOfComponents = (x) => true; // TODO

  publicAPI.setAttribute = (arr, uncleanAttType) => {
    const attType = cleanAttributeType(uncleanAttType);
    if (
      arr &&
      attType.toUpperCase() === 'PEDIGREEIDS' &&
      !arr.isA('vtkDataArray')
    ) {
      vtkWarningMacro(
        `Cannot set attribute ${attType}. The attribute must be a vtkDataArray.`
      );
      return -1;
    }
    if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {
      vtkWarningMacro(
        `Cannot set attribute ${attType}. Incorrect number of components.`
      );
      return -1;
    }
    let currentAttribute = model[`active${attType}`];
    if (currentAttribute >= 0 && currentAttribute < model.arrays.length) {
      if (model.arrays[currentAttribute] === arr) {
        return currentAttribute;
      }
      publicAPI.removeArrayByIndex(currentAttribute);
    }

    if (arr) {
      currentAttribute = publicAPI.addArray(arr);
      model[`active${attType}`] = currentAttribute;
    } else {
      model[`active${attType}`] = -1;
    }
    publicAPI.modified();
    return model[`active${attType}`];
  };

  publicAPI.setActiveAttributeByName = (arrayName, attType) =>
    publicAPI.setActiveAttributeByIndex(
      publicAPI.getArrayWithIndex(arrayName).index,
      attType
    );

  publicAPI.setActiveAttributeByIndex = (arrayIdx, uncleanAttType) => {
    const attType = cleanAttributeType(uncleanAttType);
    if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {
      if (attType.toUpperCase() !== 'PEDIGREEIDS') {
        const arr = publicAPI.getArrayByIndex(arrayIdx);
        if (!arr.isA('vtkDataArray')) {
          vtkWarningMacro(
            `Cannot set attribute ${attType}. Only vtkDataArray subclasses can be set as active attributes.`
          );
          return -1;
        }
        if (!publicAPI.checkNumberOfComponents(arr, attType)) {
          vtkWarningMacro(
            `Cannot set attribute ${attType}. Incorrect number of components.`
          );
          return -1;
        }
      }
      model[`active${attType}`] = arrayIdx;
      publicAPI.modified();
      return arrayIdx;
    }

    if (arrayIdx === -1) {
      model[`active${attType}`] = arrayIdx;
      publicAPI.modified();
    }

    return -1;
  };

  publicAPI.getActiveAttribute = (attType) => {
    // Given an integer enum value or a string (with random capitalization),
    // find the matching string in attrTypes.
    const cleanAttType = cleanAttributeType(attType);
    return publicAPI[`get${cleanAttType}`]();
  };

  // Override to allow proper handling of active attributes
  publicAPI.removeAllArrays = () => {
    model.arrays = [];
    attrTypes.forEach((attType) => {
      model[`active${attType}`] = -1;
    });
  };

  // Override to allow proper handling of active attributes
  publicAPI.removeArray = (arrayName) => {
    model.arrays = model.arrays.filter((entry, idx) => {
      if (arrayName === entry.data.getName()) {
        // Found the array to remove, but is it an active attribute?
        attrTypes.forEach((attType) => {
          if (idx === model[`active${attType}`]) {
            model[`active${attType}`] = -1;
          }
        });
        return false;
      }
      return true;
    });
  };

  // Override to allow proper handling of active attributes
  publicAPI.removeArrayByIndex = (arrayIdx) => {
    model.arrays = model.arrays.filter((entry, idx) => idx !== arrayIdx);
    attrTypes.forEach((attType) => {
      if (arrayIdx === model[`active${attType}`]) {
        model[`active${attType}`] = -1;
      }
    });
  };

  attrTypes.forEach((value) => {
    const activeVal = `active${value}`;
    publicAPI[`get${value}`] = () =>
      publicAPI.getArrayByIndex(model[activeVal]);
    publicAPI[`set${value}`] = (da) => publicAPI.setAttribute(da, value);
    publicAPI[`setActive${value}`] = (arrayName) =>
      publicAPI.setActiveAttributeByIndex(
        publicAPI.getArrayWithIndex(arrayName).index,
        value
      );
    publicAPI[`copy${value}Off`] = () => {
      const attType = value.toUpperCase();
      model.copyAttributeFlags[AttributeCopyOperations.PASSDATA][
        AttributeTypes[attType]
      ] = false;
    };
  });

  publicAPI.initializeAttributeCopyFlags = () => {
    // Default to copying all attributes in every circumstance:
    model.copyAttributeFlags = [];
    Object.keys(AttributeCopyOperations)
      .filter((op) => op !== 'ALLCOPY')
      .forEach((attCopyOp) => {
        model.copyAttributeFlags[
          AttributeCopyOperations[attCopyOp]
        ] = Object.keys(AttributeTypes)
          .filter((ty) => ty !== 'NUM_ATTRIBUTES')
          .reduce((a, b) => {
            a[AttributeTypes[b]] = true;
            return a;
          }, []);
      });
    // Override some operations where we don't want to copy:
    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][
      AttributeTypes.GLOBALIDS
    ] = false;
    model.copyAttributeFlags[AttributeCopyOperations.INTERPOLATE][
      AttributeTypes.GLOBALIDS
    ] = false;
    model.copyAttributeFlags[AttributeCopyOperations.COPYTUPLE][
      AttributeTypes.PEDIGREEIDS
    ] = false;
  };

  publicAPI.initialize = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].chain(
    publicAPI.initialize,
    publicAPI.initializeAttributeCopyFlags
  );

  // Process dataArrays if any
  if (model.dataArrays && Object.keys(model.dataArrays).length) {
    Object.keys(model.dataArrays).forEach((name) => {
      if (
        !model.dataArrays[name].ref &&
        model.dataArrays[name].type === 'vtkDataArray'
      ) {
        publicAPI.addArray(vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance(model.dataArrays[name]));
      }
    });
  }

  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = (other, debug) => {
    superShallowCopy(other, debug);
    model.arrays = other.getArrays().map((arr) => {
      const arrNew = arr.newClone();
      arrNew.shallowCopy(arr, debug);
      return { data: arrNew };
    });
  };

  publicAPI.initializeAttributeCopyFlags();
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  activeScalars: -1,
  activeVectors: -1,
  activeTensors: -1,
  activeNormals: -1,
  activeTCoords: -1,
  activeGlobalIds: -1,
  activePedigreeIds: -1,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  vtk_js_Sources_Common_DataModel_DataSetAttributes_FieldData__WEBPACK_IMPORTED_MODULE_1__["default"].extend(publicAPI, model, initialValues);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'activeScalars',
    'activeNormals',
    'activeTCoords',
    'activeVectors',
    'activeTensors',
    'activeGlobalIds',
    'activePedigreeIds',
  ]);

  if (!model.arrays) {
    model.arrays = {};
  }

  // Object specific methods
  vtkDataSetAttributes(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkDataSetAttributes');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...vtk_js_Sources_Common_DataModel_DataSetAttributes_Constants__WEBPACK_IMPORTED_MODULE_2__["default"] });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/ImageData/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/ImageData/index.js ***!
  \*************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/BoundingBox */ "./node_modules/vtk.js/Sources/Common/DataModel/BoundingBox/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_DataSet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/DataSet */ "./node_modules/vtk.js/Sources/Common/DataModel/DataSet/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_StructuredData__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/StructuredData */ "./node_modules/vtk.js/Sources/Common/DataModel/StructuredData/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_StructuredData_Constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/StructuredData/Constants */ "./node_modules/vtk.js/Sources/Common/DataModel/StructuredData/Constants.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");








const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

// ----------------------------------------------------------------------------
// vtkImageData methods
// ----------------------------------------------------------------------------

function vtkImageData(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkImageData');

  publicAPI.setExtent = (...inExtent) => {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return false;
    }

    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;

    if (extentArray.length !== 6) {
      return false;
    }

    let changeDetected = false;
    model.extent.forEach((item, index) => {
      if (item !== extentArray[index]) {
        if (changeDetected) {
          return;
        }
        changeDetected = true;
      }
    });

    if (changeDetected) {
      model.extent = extentArray.slice();
      model.dataDescription = vtk_js_Sources_Common_DataModel_StructuredData__WEBPACK_IMPORTED_MODULE_4__["default"].getDataDescriptionFromExtent(
        model.extent
      );
      publicAPI.modified();
    }
    return changeDetected;
  };

  publicAPI.setDimensions = (...dims) => {
    let i;
    let j;
    let k;

    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }

    if (dims.length === 1) {
      const array = dims[0];
      i = array[0];
      j = array[1];
      k = array[2];
    } else if (dims.length === 3) {
      i = dims[0];
      j = dims[1];
      k = dims[2];
    } else {
      vtkErrorMacro('Bad dimension specification');
      return;
    }

    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);
  };

  publicAPI.getDimensions = () => [
    model.extent[1] - model.extent[0] + 1,
    model.extent[3] - model.extent[2] + 1,
    model.extent[5] - model.extent[4] + 1,
  ];

  publicAPI.getNumberOfCells = () => {
    const dims = publicAPI.getDimensions();
    let nCells = 1;

    for (let i = 0; i < 3; i++) {
      if (dims[i] === 0) {
        return 0;
      }
      if (dims[i] > 1) {
        nCells *= dims[i] - 1;
      }
    }

    return nCells;
  };

  publicAPI.getNumberOfPoints = () => {
    const dims = publicAPI.getDimensions();
    return dims[0] * dims[1] * dims[2];
  };

  publicAPI.getPoint = (index) => {
    const dims = publicAPI.getDimensions();
    const ijk = gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].fromValues(0, 0, 0);
    const coords = [0, 0, 0];

    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {
      vtkErrorMacro('Requesting a point from an empty image.');
      return null;
    }

    switch (model.dataDescription) {
      case vtk_js_Sources_Common_DataModel_StructuredData_Constants__WEBPACK_IMPORTED_MODULE_5__["StructuredType"].EMPTY:
        return null;

      case vtk_js_Sources_Common_DataModel_StructuredData_Constants__WEBPACK_IMPORTED_MODULE_5__["StructuredType"].SINGLE_POINT:
        break;

      case vtk_js_Sources_Common_DataModel_StructuredData_Constants__WEBPACK_IMPORTED_MODULE_5__["StructuredType"].X_LINE:
        ijk[0] = index;
        break;

      case vtk_js_Sources_Common_DataModel_StructuredData_Constants__WEBPACK_IMPORTED_MODULE_5__["StructuredType"].Y_LINE:
        ijk[1] = index;
        break;

      case vtk_js_Sources_Common_DataModel_StructuredData_Constants__WEBPACK_IMPORTED_MODULE_5__["StructuredType"].Z_LINE:
        ijk[2] = index;
        break;

      case vtk_js_Sources_Common_DataModel_StructuredData_Constants__WEBPACK_IMPORTED_MODULE_5__["StructuredType"].XY_PLANE:
        ijk[0] = index % dims[0];
        ijk[1] = index / dims[0];
        break;

      case vtk_js_Sources_Common_DataModel_StructuredData_Constants__WEBPACK_IMPORTED_MODULE_5__["StructuredType"].YZ_PLANE:
        ijk[1] = index % dims[1];
        ijk[2] = index / dims[1];
        break;

      case vtk_js_Sources_Common_DataModel_StructuredData_Constants__WEBPACK_IMPORTED_MODULE_5__["StructuredType"].XZ_PLANE:
        ijk[0] = index % dims[0];
        ijk[2] = index / dims[0];
        break;

      case vtk_js_Sources_Common_DataModel_StructuredData_Constants__WEBPACK_IMPORTED_MODULE_5__["StructuredType"].XYZ_GRID:
        ijk[0] = index % dims[0];
        ijk[1] = (index / dims[0]) % dims[1];
        ijk[2] = index / (dims[0] * dims[1]);
        break;

      default:
        vtkErrorMacro('Invalid dataDescription');
        break;
    }

    const vout = gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].create();
    publicAPI.indexToWorldVec3(ijk, vout);
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].copy(coords, vout);
    return coords;
  };

  // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;
  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;
  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;
  // virtual vtkIdType FindPoint(double x, double y, double z)
  // {
  //   return this->vtkDataSet::FindPoint(x, y, z);
  // }
  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;
  // vtkIdType FindCell(
  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,
  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;
  // vtkIdType FindCell(
  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,
  //   vtkIdType cellId, double tol2, int& subId,
  //   double pcoords[3], double *weights) VTK_OVERRIDE;
  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,
  //                                 double tol2, int& subId, double pcoords[3],
  //                                 double *weights) VTK_OVERRIDE;
  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;
  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE
  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,
  //                                     this->GetDimensions());}
  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE
  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}
  // void ComputeBounds() VTK_OVERRIDE;
  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest

  publicAPI.getBounds = () => publicAPI.extentToBounds(model.extent);

  publicAPI.extentToBounds = (ex) => {
    // prettier-ignore
    const corners = [
      ex[0], ex[2], ex[4],
      ex[1], ex[2], ex[4],
      ex[0], ex[3], ex[4],
      ex[1], ex[3], ex[4],
      ex[0], ex[2], ex[5],
      ex[1], ex[2], ex[5],
      ex[0], ex[3], ex[5],
      ex[1], ex[3], ex[5]];

    const idx = gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].fromValues(corners[0], corners[1], corners[2]);
    const vout = gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].create();
    publicAPI.indexToWorldVec3(idx, vout);
    const bounds = [vout[0], vout[0], vout[1], vout[1], vout[2], vout[2]];
    for (let i = 3; i < 24; i += 3) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].set(idx, corners[i], corners[i + 1], corners[i + 2]);
      publicAPI.indexToWorldVec3(idx, vout);
      if (vout[0] < bounds[0]) {
        bounds[0] = vout[0];
      }
      if (vout[1] < bounds[2]) {
        bounds[2] = vout[1];
      }
      if (vout[2] < bounds[4]) {
        bounds[4] = vout[2];
      }
      if (vout[0] > bounds[1]) {
        bounds[1] = vout[0];
      }
      if (vout[1] > bounds[3]) {
        bounds[3] = vout[1];
      }
      if (vout[2] > bounds[5]) {
        bounds[5] = vout[2];
      }
    }

    return bounds;
  };

  // Internal, shouldn't need to call this manually.
  publicAPI.computeTransforms = () => {
    const trans = gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].fromValues(
      model.origin[0],
      model.origin[1],
      model.origin[2]
    );
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__["mat4"].fromTranslation(model.indexToWorld, trans);

    model.indexToWorld[0] = model.direction[0];
    model.indexToWorld[1] = model.direction[1];
    model.indexToWorld[2] = model.direction[2];

    model.indexToWorld[4] = model.direction[3];
    model.indexToWorld[5] = model.direction[4];
    model.indexToWorld[6] = model.direction[5];

    model.indexToWorld[8] = model.direction[6];
    model.indexToWorld[9] = model.direction[7];
    model.indexToWorld[10] = model.direction[8];

    const scale = gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].fromValues(
      model.spacing[0],
      model.spacing[1],
      model.spacing[2]
    );
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__["mat4"].scale(model.indexToWorld, model.indexToWorld, scale);

    gl_matrix__WEBPACK_IMPORTED_MODULE_6__["mat4"].invert(model.worldToIndex, model.indexToWorld);
  };

  //
  // The direction matrix is a 3x3 basis for the I, J, K axes
  // of the image. The rows of the matrix correspond to the
  // axes directions in world coordinates. Direction must
  // form an orthonormal basis, results are undefined if
  // it is not.
  //
  publicAPI.setDirection = (...args) => {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return false;
    }

    let array = args;
    // allow an array passed as a single arg.
    if (
      array.length === 1 &&
      (Array.isArray(array[0]) ||
        array[0].constructor === Float32Array ||
        array[0].constructor === Float64Array)
    ) {
      array = array[0];
    }

    if (array.length !== 9) {
      throw new RangeError('Invalid number of values for array setter');
    }
    let changeDetected = false;
    model.direction.forEach((item, index) => {
      if (item !== array[index]) {
        if (changeDetected) {
          return;
        }
        changeDetected = true;
      }
    });

    if (changeDetected) {
      for (let i = 0; i < 9; ++i) {
        model.direction[i] = array[i];
      }
      publicAPI.modified();
    }
    return true;
  };

  // this is the fast version, requires vec3 arguments
  publicAPI.indexToWorldVec3 = (vin, vout) => {
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].transformMat4(vout, vin, model.indexToWorld);
    return vout;
  };

  // slow version for generic arrays
  publicAPI.indexToWorld = (ain, aout = []) => {
    const vin = gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].fromValues(ain[0], ain[1], ain[2]);
    const vout = gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].transformMat4(vout, vin, model.indexToWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].copy(aout, vout);
    return aout;
  };

  // this is the fast version, requires vec3 arguments
  publicAPI.worldToIndexVec3 = (vin, vout) => {
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].transformMat4(vout, vin, model.worldToIndex);
    return vout;
  };

  // slow version for generic arrays
  publicAPI.worldToIndex = (ain, aout = []) => {
    const vin = gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].fromValues(ain[0], ain[1], ain[2]);
    const vout = gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].transformMat4(vout, vin, model.worldToIndex);
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].copy(aout, vout);
    return aout;
  };

  publicAPI.indexToWorldBounds = (bin, bout = []) => {
    const in1 = [0, 0, 0];
    const in2 = [0, 0, 0];
    vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_2__["default"].computeCornerPoints(in1, in2, bin);

    const out1 = [0, 0, 0];
    const out2 = [0, 0, 0];
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].transformMat4(out1, in1, model.indexToWorld);
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].transformMat4(out2, in2, model.indexToWorld);

    vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["computeBoundsFromPoints"](out1, out2, bout);

    return bout;
  };

  publicAPI.worldToIndexBounds = (bin, bout = []) => {
    const in1 = [0, 0, 0];
    const in2 = [0, 0, 0];
    vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_2__["default"].computeCornerPoints(in1, in2, bin);

    const out1 = [0, 0, 0];
    const out2 = [0, 0, 0];
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].transformMat4(out1, in1, model.worldToIndex);
    gl_matrix__WEBPACK_IMPORTED_MODULE_6__["vec3"].transformMat4(out2, in2, model.worldToIndex);

    vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["computeBoundsFromPoints"](out1, out2, bout);

    return bout;
  };

  // Make sure the transform is correct
  publicAPI.onModified(publicAPI.computeTransforms);
  publicAPI.computeTransforms();

  publicAPI.getCenter = () => {
    const bounds = publicAPI.getBounds();
    const center = [];

    for (let i = 0; i < 3; i++) {
      center[i] = (bounds[2 * i + 1] + bounds[2 * i]) / 2;
    }

    return center;
  };

  publicAPI.computeHistogram = (worldBounds, voxelFunc = null) => {
    const bounds = [0, 0, 0, 0, 0, 0];
    publicAPI.worldToIndexBounds(worldBounds, bounds);

    const point1 = [0, 0, 0];
    const point2 = [0, 0, 0];
    vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_2__["default"].computeCornerPoints(point1, point2, bounds);

    vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["roundVector"](point1, point1);
    vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["roundVector"](point2, point2);

    const dimensions = publicAPI.getDimensions();

    vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["clampVector"](
      point1,
      [0, 0, 0],
      [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1],
      point1
    );
    vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["clampVector"](
      point2,
      [0, 0, 0],
      [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1],
      point2
    );

    const yStride = dimensions[0];
    const zStride = dimensions[0] * dimensions[1];

    const pixels = publicAPI.getPointData().getScalars().getData();

    let maximum = -Infinity;
    let minimum = Infinity;
    let sumOfSquares = 0;
    let isum = 0;
    let inum = 0;

    for (let z = point1[2]; z <= point2[2]; z++) {
      for (let y = point1[1]; y <= point2[1]; y++) {
        let index = point1[0] + y * yStride + z * zStride;
        for (let x = point1[0]; x <= point2[0]; x++) {
          if (!voxelFunc || voxelFunc([x, y, z], bounds)) {
            const pixel = pixels[index];

            if (pixel > maximum) maximum = pixel;
            if (pixel < minimum) minimum = pixel;
            sumOfSquares += pixel * pixel;
            isum += pixel;
            inum += 1;
          }

          ++index;
        }
      }
    }

    const average = inum > 0 ? isum / inum : 0;
    const variance = sumOfSquares - average * average;
    const sigma = Math.sqrt(variance);

    return {
      minimum,
      maximum,
      average,
      variance,
      sigma,
    };
  };

  // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).
  // Scalar data could be tuples for color information?
  publicAPI.computeIncrements = (extent, numberOfComponents = 1) => {
    const increments = [];
    let incr = numberOfComponents;

    // Calculate array increment offsets
    // similar to c++ vtkImageData::ComputeIncrements
    for (let idx = 0; idx < 3; ++idx) {
      increments[idx] = incr;
      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;
    }
    return increments;
  };

  /**
   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.
   * @return {Number} the corresponding flattened index in the scalar array
   */
  publicAPI.computeOffsetIndex = ([i, j, k]) => {
    const extent = publicAPI.getExtent();
    const numberOfComponents = publicAPI
      .getPointData()
      .getScalars()
      .getNumberOfComponents();
    const increments = publicAPI.computeIncrements(extent, numberOfComponents);
    // Use the array increments to find the pixel index
    // similar to c++ vtkImageData::GetArrayPointer
    // Math.floor to catch "practically 0" e^-15 scenarios.
    return Math.floor(
      (Math.round(i) - extent[0]) * increments[0] +
        (Math.round(j) - extent[2]) * increments[1] +
        (Math.round(k) - extent[4]) * increments[2]
    );
  };

  /**
   * @param {Number[]} xyz the [x,y,z] Array in world coordinates
   * @return {Number|NaN} the corresponding pixel's index in the scalar array
   */
  publicAPI.getOffsetIndexFromWorld = (xyz) => {
    const extent = publicAPI.getExtent();
    const index = publicAPI.worldToIndex(xyz);

    // Confirm indexed i,j,k coords are within the bounds of the volume
    for (let idx = 0; idx < 3; ++idx) {
      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {
        vtkErrorMacro(
          `GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`
        );
        return NaN;
      }
    }

    // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream
    return publicAPI.computeOffsetIndex(index);
  };
  /**
   * @param {Number[]} xyz the [x,y,z] Array in world coordinates
   * @param {Number?} comp the scalar component index for multi-component scalars
   * @return {Number|NaN} the corresponding pixel's scalar value
   */
  publicAPI.getScalarValueFromWorld = (xyz, comp = 0) => {
    const numberOfComponents = publicAPI
      .getPointData()
      .getScalars()
      .getNumberOfComponents();
    if (comp < 0 || comp >= numberOfComponents) {
      vtkErrorMacro(
        `GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`
      );
      return NaN;
    }
    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);
    if (Number.isNaN(offsetIndex)) {
      // VTK Error Macro will have been tripped already, no need to do it again,
      return offsetIndex;
    }

    return publicAPI
      .getPointData()
      .getScalars()
      .getComponent(offsetIndex, comp);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  direction: null, // a mat3
  indexToWorld: null, // a mat4
  worldToIndex: null, // a mat4
  spacing: [1.0, 1.0, 1.0],
  origin: [0.0, 0.0, 0.0],
  extent: [0, -1, 0, -1, 0, -1],
  dataDescription: vtk_js_Sources_Common_DataModel_StructuredData_Constants__WEBPACK_IMPORTED_MODULE_5__["StructuredType"].EMPTY,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Common_DataModel_DataSet__WEBPACK_IMPORTED_MODULE_3__["default"].extend(publicAPI, model, initialValues);

  if (!model.direction) {
    model.direction = gl_matrix__WEBPACK_IMPORTED_MODULE_6__["mat3"].create();
  } else if (Array.isArray(model.direction)) {
    const dvals = model.direction.slice(0);
    model.direction = gl_matrix__WEBPACK_IMPORTED_MODULE_6__["mat3"].create();
    for (let i = 0; i < 9; ++i) {
      model.direction[i] = dvals[i];
    }
  }

  model.indexToWorld = new Float64Array(16);
  model.worldToIndex = new Float64Array(16);

  // Set/Get methods
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['direction', 'indexToWorld', 'worldToIndex']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGetArray(publicAPI, model, ['origin', 'spacing'], 3);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].getArray(publicAPI, model, ['extent'], 6);

  // Object specific methods
  vtkImageData(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkImageData');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/Line/Constants.js":
/*!************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/Line/Constants.js ***!
  \************************************************************************/
/*! exports provided: IntersectionState, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntersectionState", function() { return IntersectionState; });
const IntersectionState = {
  NO_INTERSECTION: 0,
  YES_INTERSECTION: 1,
  ON_LINE: 2,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  IntersectionState,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/Line/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/Line/index.js ***!
  \********************************************************************/
/*! exports provided: STATIC, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATIC", function() { return STATIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_Line_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/Line/Constants */ "./node_modules/vtk.js/Sources/Common/DataModel/Line/Constants.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_Cell__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/Cell */ "./node_modules/vtk.js/Sources/Common/DataModel/Cell/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");





const { IntersectionState } = vtk_js_Sources_Common_DataModel_Line_Constants__WEBPACK_IMPORTED_MODULE_1__["default"];

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------
function distanceToLine(x, p1, p2, closestPoint = null) {
  const outObj = { t: Number.MIN_VALUE, distance: 0 };
  const p21 = [];
  let closest;
  // Determine appropriate vector
  p21[0] = p2[0] - p1[0];
  p21[1] = p2[1] - p1[1];
  p21[2] = p2[2] - p1[2];

  // Get parametric location
  const num =
    p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);
  const denom = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["dot"](p21, p21);

  // trying to avoid an expensive fabs
  let tolerance = 1e-5 * num;
  if (denom !== 0.0) {
    outObj.t = num / denom;
  }
  if (tolerance < 0.0) {
    tolerance = -tolerance;
  }
  if (-tolerance < denom && denom < tolerance) {
    closest = p1;
  } else if (denom <= 0.0 || outObj.t < 0.0) {
    // If parametric coordinate is within 0<=p<=1, then the point is closest to
    // the line.  Otherwise, it's closest to a point at the end of the line.
    closest = p1;
  } else if (outObj.t > 1.0) {
    closest = p2;
  } else {
    closest = p21;
    p21[0] = p1[0] + outObj.t * p21[0];
    p21[1] = p1[1] + outObj.t * p21[1];
    p21[2] = p1[2] + outObj.t * p21[2];
  }

  if (closestPoint) {
    closestPoint[0] = closest[0];
    closestPoint[1] = closest[1];
    closestPoint[2] = closest[2];
  }
  outObj.distance = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["distance2BetweenPoints"](closest, x);
  return outObj;
}

function intersection(a1, a2, b1, b2, u, v) {
  const a21 = [];
  const b21 = [];
  const b1a1 = [];

  u[0] = 0.0;
  v[0] = 0.0;

  // Determine line vectors.
  a21[0] = a2[0] - a1[0];
  a21[1] = a2[1] - a1[1];
  a21[2] = a2[2] - a1[2];
  b21[0] = b2[0] - b1[0];
  b21[1] = b2[1] - b1[1];
  b21[2] = b2[2] - b1[2];
  b1a1[0] = b1[0] - a1[0];
  b1a1[1] = b1[1] - a1[1];
  b1a1[2] = b1[2] - a1[2];

  // Compute the system (least squares) matrix.
  const A = [];
  A[0] = [vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["dot"](a21, a21), -vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["dot"](a21, b21)];
  A[1] = [A[0][1], vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["dot"](b21, b21)];

  // Compute the least squares system constant term.
  const c = [];
  c[0] = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["dot"](a21, b1a1);
  c[1] = -vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["dot"](b21, b1a1);

  // Solve the system of equations
  if (vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["solveLinearSystem"](A, c, 2) === 0) {
    // The lines are colinear. Therefore, one of the four endpoints is the
    // point of closest approach
    let minDist = Number.MAX_VALUE;
    const p = [a1, a2, b1, b2];
    const l1 = [b1, b1, a1, a1];
    const l2 = [b2, b2, a2, a2];
    const uv1 = [v[0], v[0], u[0], u[0]];
    const uv2 = [u[0], u[0], v[0], v[0]];
    let obj;
    for (let i = 0; i < 4; i++) {
      obj = distanceToLine(p[i], l1[i], l2[i]);
      if (obj.distance < minDist) {
        minDist = obj.distance;
        uv1[i] = obj.t;
        uv2[i] = i % 2;
      }
    }
    return IntersectionState.ON_LINE;
  }
  u[0] = c[0];
  v[0] = c[1];

  // Check parametric coordinates for intersection.
  if (u[0] >= 0.0 && u[0] <= 1.0 && v[0] >= 0.0 && v[0] <= 1.0) {
    return IntersectionState.YES_INTERSECTION;
  }

  return IntersectionState.NO_INTERSECTION;
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  distanceToLine,
  intersection,
};

// ----------------------------------------------------------------------------
// vtkLine methods
// ----------------------------------------------------------------------------

function vtkLine(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkLine');

  publicAPI.getCellDimension = () => 1;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    const outObj = { intersect: 0, t: Number.MIN_VALUE, subId: 0 };
    pcoords[1] = 0.0;
    pcoords[2] = 0.0;
    const projXYZ = [];

    const a1 = [];
    const a2 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a2);

    const u = [];
    const v = [];
    const intersect = intersection(p1, p2, a1, a2, u, v);
    outObj.t = u[0];
    pcoords[0] = v[0];

    if (intersect === IntersectionState.YES_INTERSECTION) {
      // make sure we are within tolerance
      for (let i = 0; i < 3; i++) {
        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);
      }
      if (vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["distance2BetweenPoints"](x, projXYZ) <= tol * tol) {
        outObj.intersect = 1;
        return outObj;
      }
    } else {
      let outDistance;
      // check to see if it lies within tolerance
      // one of the parametric coords must be outside 0-1
      if (outObj.t < 0.0) {
        outObj.t = 0.0;
        outDistance = distanceToLine(p1, a1, a2, x);
        pcoords[0] = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
      if (outObj.t > 1.0) {
        outObj.t = 1.0;
        outDistance = distanceToLine(p2, a1, a2, x);
        pcoords[0] = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] < 0.0) {
        pcoords[0] = 0.0;
        outDistance = distanceToLine(a1, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[1] > 1.0) {
        pcoords[1] = 1.0;
        outDistance = distanceToLine(a2, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
    }
    return outObj;
  };
  publicAPI.evaluatePosition = (
    x,
    closestPoint,
    subId,
    pcoords,
    dist2,
    weights
  ) => {}; // virtual
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  vtk_js_Sources_Common_DataModel_Cell__WEBPACK_IMPORTED_MODULE_2__["default"].extend(publicAPI, model, initialValues);

  vtkLine(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkLine');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...STATIC, ...vtk_js_Sources_Common_DataModel_Line_Constants__WEBPACK_IMPORTED_MODULE_1__["default"] });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/Plane/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/Plane/index.js ***!
  \*********************************************************************/
/*! exports provided: STATIC, vtkPlane, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATIC", function() { return STATIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vtkPlane", function() { return vtkPlane; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");



const PLANE_TOLERANCE = 1.0e-6;
const COINCIDE = 'coincide';
const DISJOINT = 'disjoint';

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

function evaluate(normal, origin, x) {
  return (
    normal[0] * (x[0] - origin[0]) +
    normal[1] * (x[1] - origin[1]) +
    normal[2] * (x[2] - origin[2])
  );
}

function distanceToPlane(x, origin, normal) {
  const distance =
    normal[0] * (x[0] - origin[0]) +
    normal[1] * (x[1] - origin[1]) +
    normal[2] * (x[2] - origin[2]);

  return Math.abs(distance);
}

function projectPoint(x, origin, normal, xproj) {
  const xo = [];
  vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["subtract"](x, origin, xo);

  const t = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["dot"](normal, xo);

  xproj[0] = x[0] - t * normal[0];
  xproj[1] = x[1] - t * normal[1];
  xproj[2] = x[2] - t * normal[2];
}

function projectVector(v, normal, vproj) {
  const t = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["dot"](v, normal);

  let n2 = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["dot"](normal, normal);
  if (n2 === 0) {
    n2 = 1.0;
  }

  vproj[0] = v[0] - (t * normal[0]) / n2;
  vproj[1] = v[1] - (t * normal[1]) / n2;
  vproj[2] = v[2] - (t * normal[2]) / n2;
}

function generalizedProjectPoint(x, origin, normal, xproj) {
  const xo = [];
  vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["subtract"](x, origin, xo);

  const t = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["dot"](normal, xo);
  const n2 = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["dot"](normal, normal);

  if (n2 !== 0) {
    xproj[0] = x[0] - (t * normal[0]) / n2;
    xproj[1] = x[1] - (t * normal[1]) / n2;
    xproj[2] = x[2] - (t * normal[2]) / n2;
  } else {
    xproj[0] = x[0];
    xproj[1] = x[1];
    xproj[2] = x[2];
  }
}

function intersectWithLine(p1, p2, origin, normal) {
  const outObj = {
    intersection: false,
    betweenPoints: false,
    t: Number.MAX_VALUE,
    x: [],
  };

  const p21 = [];
  const p1Origin = [];
  // Compute line vector
  vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["subtract"](p2, p1, p21);
  vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["subtract"](origin, p1, p1Origin);

  // Compute denominator.  If ~0, line and plane are parallel.
  // const num = vtkMath.dot(normal, origin) - vtkMath.dot(normal, p1);
  const num = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["dot"](normal, p1Origin);
  const den = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["dot"](normal, p21);

  // If denominator with respect to numerator is "zero", then the line and
  // plane are considered parallel.
  let fabsden;
  let fabstolerance;

  // Trying to avoid an expensive call to fabs()
  if (den < 0.0) {
    fabsden = -den;
  } else {
    fabsden = den;
  }
  if (num < 0.0) {
    fabstolerance = -num * PLANE_TOLERANCE;
  } else {
    fabstolerance = num * PLANE_TOLERANCE;
  }
  if (fabsden <= fabstolerance) {
    return outObj;
  }

  // Where on the line between p1 and p2 is the intersection
  // If between 0 and 1, it is between the two points. If < 0 it's before p1, if > 1 it's after p2
  outObj.t = num / den;

  outObj.x[0] = p1[0] + outObj.t * p21[0];
  outObj.x[1] = p1[1] + outObj.t * p21[1];
  outObj.x[2] = p1[2] + outObj.t * p21[2];

  outObj.intersection = true;
  outObj.betweenPoints = outObj.t >= 0.0 && outObj.t <= 1.0;
  return outObj;
}

function intersectWithPlane(
  plane1Origin,
  plane1Normal,
  plane2Origin,
  plane2Normal
) {
  const outObj = {
    intersection: false,
    l0: [],
    l1: [],
    error: null,
  };

  const cross = [];
  vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["cross"](plane1Normal, plane2Normal, cross);
  const absCross = cross.map((n) => Math.abs(n));

  // test if the two planes are parallel
  if (absCross[0] + absCross[1] + absCross[2] < PLANE_TOLERANCE) {
    // test if disjoint or coincide
    const v = [];
    vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["subtract"](plane1Origin, plane2Origin, v);
    if (vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["dot"](plane1Normal, v) === 0) {
      outObj.error = COINCIDE;
    } else {
      outObj.error = DISJOINT;
    }
    return outObj;
  }

  // Plane1 and Plane2 intersect in a line
  // first determine max abs coordinate of the cross product
  let maxc;
  if (absCross[0] > absCross[1] && absCross[0] > absCross[2]) {
    maxc = 'x';
  } else if (absCross[1] > absCross[2]) {
    maxc = 'y';
  } else {
    maxc = 'z';
  }

  // To get a point on the intersect line, zero the max coord, and solve for the other two
  const iP = []; // intersectionPoint
  // the constants in the 2 plane equations
  const d1 = -vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["dot"](plane1Normal, plane1Origin);
  const d2 = -vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["dot"](plane2Normal, plane2Origin);

  // eslint-disable-next-line default-case
  switch (maxc) {
    case 'x': // intersect with x=0
      iP[0] = 0;
      iP[1] = (d2 * plane1Normal[2] - d1 * plane2Normal[2]) / cross[0];
      iP[2] = (d1 * plane2Normal[1] - d2 * plane1Normal[1]) / cross[0];
      break;
    case 'y': // intersect with y=0
      iP[0] = (d1 * plane2Normal[2] - d2 * plane1Normal[2]) / cross[1];
      iP[1] = 0;
      iP[2] = (d2 * plane1Normal[0] - d1 * plane2Normal[0]) / cross[1];
      break;
    case 'z': // intersect with z=0
      iP[0] = (d2 * plane1Normal[1] - d1 * plane2Normal[1]) / cross[2];
      iP[1] = (d1 * plane2Normal[0] - d2 * plane1Normal[0]) / cross[2];
      iP[2] = 0;
      break;
  }

  outObj.l0 = iP;
  vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_0__["add"](iP, cross, outObj.l1);
  outObj.intersection = true;

  return outObj;
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  evaluate,
  distanceToPlane,
  projectPoint,
  projectVector,
  generalizedProjectPoint,
  intersectWithLine,
  intersectWithPlane,
  DISJOINT,
  COINCIDE,
};

// ----------------------------------------------------------------------------
// vtkPlane methods
// ----------------------------------------------------------------------------

function vtkPlane(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPlane');

  publicAPI.distanceToPlane = (x) =>
    distanceToPlane(x, model.origin, model.normal);

  publicAPI.projectPoint = (x, xproj) => {
    projectPoint(x, model.origin, model.normal, xproj);
  };

  publicAPI.projectVector = (v, vproj) => {
    projectVector(v, model.normal, vproj);
  };

  publicAPI.push = (distance) => {
    if (distance === 0.0) {
      return;
    }
    for (let i = 0; i < 3; i++) {
      model.origin[i] += distance * model.normal[i];
    }
  };

  publicAPI.generalizedProjectPoint = (x, xproj) => {
    generalizedProjectPoint(x, model.origin, model.normal, xproj);
  };

  publicAPI.evaluateFunction = (x, y, z) => {
    if (!Array.isArray(x)) {
      return (
        model.normal[0] * (x - model.origin[0]) +
        model.normal[1] * (y - model.origin[1]) +
        model.normal[2] * (z - model.origin[2])
      );
    }
    return (
      model.normal[0] * (x[0] - model.origin[0]) +
      model.normal[1] * (x[1] - model.origin[1]) +
      model.normal[2] * (x[2] - model.origin[2])
    );
  };

  publicAPI.evaluateGradient = (xyz) => {
    const retVal = [model.normal[0], model.normal[1], model.normal[2]];
    return retVal;
  };

  publicAPI.intersectWithLine = (p1, p2) =>
    intersectWithLine(p1, p2, model.origin, model.normal);

  publicAPI.intersectWithPlane = (planeOrigin, planeNormal) =>
    intersectWithPlane(planeOrigin, planeNormal, model.origin, model.normal);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  normal: [0.0, 0.0, 1.0],
  origin: [0.0, 0.0, 0.0],
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(publicAPI, model);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGetArray(publicAPI, model, ['normal', 'origin'], 3);

  vtkPlane(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend, 'vtkPlane');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...STATIC });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/PointSet/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/PointSet/index.js ***!
  \************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_vtk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/vtk */ "./node_modules/vtk.js/Sources/vtk.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_DataSet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/DataSet */ "./node_modules/vtk.js/Sources/Common/DataModel/DataSet/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Points__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Points */ "./node_modules/vtk.js/Sources/Common/Core/Points/index.js");





// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// vtkPointSet methods
// ----------------------------------------------------------------------------

function vtkPointSet(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPointSet');

  // Create empty points
  if (!model.points) {
    model.points = vtk_js_Sources_Common_Core_Points__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
  } else {
    model.points = Object(vtk_js_Sources_vtk__WEBPACK_IMPORTED_MODULE_0__["default"])(model.points);
  }

  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();

  publicAPI.getBounds = () => model.points.getBounds();

  publicAPI.computeBounds = () => {
    publicAPI.getBounds();
  };

  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = (other, debug = false) => {
    superShallowCopy(other, debug);
    model.points = vtk_js_Sources_Common_Core_Points__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
    model.points.shallowCopy(other.getPoints());
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // points: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Common_DataModel_DataSet__WEBPACK_IMPORTED_MODULE_2__["default"].extend(publicAPI, model, initialValues);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGet(publicAPI, model, ['points']);

  // Object specific methods
  vtkPointSet(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend, 'vtkPointSet');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/PolyData/Constants.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/PolyData/Constants.js ***!
  \****************************************************************************/
/*! exports provided: POLYDATA_FIELDS, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "POLYDATA_FIELDS", function() { return POLYDATA_FIELDS; });
const POLYDATA_FIELDS = ['verts', 'lines', 'polys', 'strips'];

/* harmony default export */ __webpack_exports__["default"] = ({
  POLYDATA_FIELDS,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/PolyData/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/PolyData/index.js ***!
  \************************************************************************/
/*! exports provided: CELL_FACTORY, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CELL_FACTORY", function() { return CELL_FACTORY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_vtk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/vtk */ "./node_modules/vtk.js/Sources/vtk.js");
/* harmony import */ var vtk_js_Sources_Common_Core_CellArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/CellArray */ "./node_modules/vtk.js/Sources/Common/Core/CellArray/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_CellLinks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/CellLinks */ "./node_modules/vtk.js/Sources/Common/DataModel/CellLinks/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_CellTypes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/CellTypes */ "./node_modules/vtk.js/Sources/Common/DataModel/CellTypes/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_Line__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/Line */ "./node_modules/vtk.js/Sources/Common/DataModel/Line/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_PointSet__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/PointSet */ "./node_modules/vtk.js/Sources/Common/DataModel/PointSet/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_Triangle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/Triangle */ "./node_modules/vtk.js/Sources/Common/DataModel/Triangle/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/CellTypes/Constants */ "./node_modules/vtk.js/Sources/Common/DataModel/CellTypes/Constants.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_PolyData_Constants__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/PolyData/Constants */ "./node_modules/vtk.js/Sources/Common/DataModel/PolyData/Constants.js");












const { vtkWarningMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

const CELL_FACTORY = {
  [vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_LINE]: vtk_js_Sources_Common_DataModel_Line__WEBPACK_IMPORTED_MODULE_5__["default"],
  [vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_POLY_LINE]: vtk_js_Sources_Common_DataModel_Line__WEBPACK_IMPORTED_MODULE_5__["default"],
  [vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_TRIANGLE]: vtk_js_Sources_Common_DataModel_Triangle__WEBPACK_IMPORTED_MODULE_7__["default"],
};

// ----------------------------------------------------------------------------
// vtkPolyData methods
// ----------------------------------------------------------------------------

function vtkPolyData(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkPolyData');

  function camelize(str) {
    return str
      .replace(/(?:^\w|[A-Z]|\b\w)/g, (letter) => letter.toUpperCase())
      .replace(/\s+/g, '');
  }

  // build empty cell arrays and set methods
  vtk_js_Sources_Common_DataModel_PolyData_Constants__WEBPACK_IMPORTED_MODULE_9__["POLYDATA_FIELDS"].forEach((type) => {
    publicAPI[`getNumberOf${camelize(type)}`] = () =>
      model[type].getNumberOfCells();
    if (!model[type]) {
      model[type] = vtk_js_Sources_Common_Core_CellArray__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
    } else {
      model[type] = Object(vtk_js_Sources_vtk__WEBPACK_IMPORTED_MODULE_1__["default"])(model[type]);
    }
  });

  publicAPI.getNumberOfCells = () =>
    vtk_js_Sources_Common_DataModel_PolyData_Constants__WEBPACK_IMPORTED_MODULE_9__["POLYDATA_FIELDS"].reduce(
      (num, cellType) => num + model[cellType].getNumberOfCells(),
      0
    );

  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = (other, debug = false) => {
    superShallowCopy(other, debug);
    vtk_js_Sources_Common_DataModel_PolyData_Constants__WEBPACK_IMPORTED_MODULE_9__["POLYDATA_FIELDS"].forEach((type) => {
      model[type] = vtk_js_Sources_Common_Core_CellArray__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
      model[type].shallowCopy(other.getReferenceByName(type));
    });
  };

  publicAPI.buildCells = () => {
    // here are the number of cells we have
    const nVerts = publicAPI.getNumberOfVerts();
    const nLines = publicAPI.getNumberOfLines();
    const nPolys = publicAPI.getNumberOfPolys();
    const nStrips = publicAPI.getNumberOfStrips();

    // pre-allocate the space we need
    const nCells = nVerts + nLines + nPolys + nStrips;

    const types = new Uint8Array(nCells);
    let pTypes = types;
    const locs = new Uint32Array(nCells);
    let pLocs = locs;

    // record locations and type of each cell.
    // verts
    if (nVerts) {
      let nextCellPts = 0;
      model.verts.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        pTypes[index] =
          numCellPts > 1 ? vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_POLY_VERTEX : vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_VERTEX;
        nextCellPts += numCellPts + 1;
      });

      pLocs = pLocs.subarray(nVerts);
      pTypes = pTypes.subarray(nVerts);
    }

    // lines
    if (nLines) {
      let nextCellPts = 0;
      model.lines.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        pTypes[index] =
          numCellPts > 2 ? vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_POLY_LINE : vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_LINE;
        if (numCellPts === 1) {
          vtkWarningMacro(
            'Building VTK_LINE ',
            index,
            ' with only one point, but VTK_LINE needs at least two points. Check the input.'
          );
        }
        nextCellPts += numCellPts + 1;
      });

      pLocs = pLocs.subarray(nLines);
      pTypes = pTypes.subarray(nLines);
    }

    // polys
    if (nPolys) {
      let nextCellPts = 0;
      model.polys.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        switch (numCellPts) {
          case 3:
            pTypes[index] = vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_TRIANGLE;
            break;
          case 4:
            pTypes[index] = vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_QUAD;
            break;
          default:
            pTypes[index] = vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_POLYGON;
            break;
        }
        if (numCellPts < 3) {
          vtkWarningMacro(
            'Building VTK_TRIANGLE ',
            index,
            ' with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.'
          );
        }
        nextCellPts += numCellPts + 1;
      });

      pLocs += pLocs.subarray(nPolys);
      pTypes += pTypes.subarray(nPolys);
    }

    // strips
    if (nStrips) {
      let nextCellPts = 0;
      pTypes.fill(vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_TRIANGLE_STRIP, 0, nStrips);

      model.strips.getCellSizes().forEach((numCellPts, index) => {
        pLocs[index] = nextCellPts;
        nextCellPts += numCellPts + 1;
      });
    }

    // set up the cell types data structure
    model.cells = vtk_js_Sources_Common_DataModel_CellTypes__WEBPACK_IMPORTED_MODULE_4__["default"].newInstance();
    model.cells.setCellTypes(nCells, types, locs);
  };

  /**
   * Create upward links from points to cells that use each point. Enables
   * topologically complex queries.
   */
  publicAPI.buildLinks = (initialSize = 0) => {
    if (model.cells === undefined) {
      publicAPI.buildCells();
    }

    model.links = vtk_js_Sources_Common_DataModel_CellLinks__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
    if (initialSize > 0) {
      model.links.allocate(initialSize);
    } else {
      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());
    }

    model.links.buildLinks(publicAPI);
  };

  // Returns an object made of the cellType and a subarray `cellPointIds` of
  // the cell points.
  publicAPI.getCellPoints = (cellId) => {
    const cellType = model.cells.getCellType(cellId);
    let cells = null;
    switch (cellType) {
      case vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_VERTEX:
      case vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_POLY_VERTEX:
        cells = model.verts;
        break;

      case vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_LINE:
      case vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_POLY_LINE:
        cells = model.lines;
        break;

      case vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_TRIANGLE:
      case vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_QUAD:
      case vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_POLYGON:
        cells = model.polys;
        break;

      case vtk_js_Sources_Common_DataModel_CellTypes_Constants__WEBPACK_IMPORTED_MODULE_8__["CellType"].VTK_TRIANGLE_STRIP:
        cells = model.strips;
        break;

      default:
        cells = null;
        return { type: 0, cellPointIds: null };
    }
    const loc = model.cells.getCellLocation(cellId);
    const cellPointIds = cells.getCell(loc);
    return { cellType, cellPointIds };
  };

  publicAPI.getPointCells = (ptId) => model.links.getCells(ptId);

  publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {
    const link1 = model.links.getLink(point1);
    const link2 = model.links.getLink(point2);

    return link1.cells.filter(
      (cell) => cell !== cellId && link2.cells.indexOf(cell) !== -1
    );
  };

  /**
   * If you know the type of cell, you may provide it to improve performances.
   */
  publicAPI.getCell = (cellId, cellHint = null) => {
    const cellInfo = publicAPI.getCellPoints(cellId);
    const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();
    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);
    return cell;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // verts: null,
  // lines: null,
  // polys: null,
  // strips: null,
  // cells: null,
  // links: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Common_DataModel_PointSet__WEBPACK_IMPORTED_MODULE_6__["default"].extend(publicAPI, model, initialValues);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['cells', 'links']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, ['verts', 'lines', 'polys', 'strips']);

  // Object specific methods
  vtkPolyData(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkPolyData');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/SelectionNode/Constants.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/SelectionNode/Constants.js ***!
  \*********************************************************************************/
/*! exports provided: SelectionContent, SelectionField, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectionContent", function() { return SelectionContent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SelectionField", function() { return SelectionField; });
/**
 * The (primary) property that describes the content of a selection
 * node's data. Other auxiliary description properties follow.
 * GLOBALIDS means that the selection list contains values from the
 * vtkDataSetAttribute array of the same name.
 * PEDIGREEIDS means that the selection list contains values from the
 * vtkDataSetAttribute array of the same name.
 * VALUES means the the selection list contains values from an
 * arbitrary attribute array (ignores any globalids attribute)
 * INDICES means that the selection list contains indexes into the
 * cell or point arrays.
 * FRUSTUM means the set of points and cells inside a frustum
 * LOCATIONS means the set of points and cells near a set of positions
 * THRESHOLDS means the points and cells with values within a set of ranges
 * getContentType() returns -1 if the content type is not set.
 */

// Specify how data arrays can be used by data objects
const SelectionContent = {
  GLOBALIDS: 0,
  PEDIGREEIDS: 1,
  VALUES: 2,
  INDICES: 3,
  FRUSTUM: 4,
  LOCATIONS: 5,
  THRESHOLDS: 6,
  BLOCKS: 7,
  QUERY: 8,
};

const SelectionField = {
  CELL: 0,
  POINT: 1,
  FIELD: 2,
  VERTEX: 3,
  EDGE: 4,
  ROW: 5,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  SelectionContent,
  SelectionField,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/SelectionNode/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/SelectionNode/index.js ***!
  \*****************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_SelectionNode_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/SelectionNode/Constants */ "./node_modules/vtk.js/Sources/Common/DataModel/SelectionNode/Constants.js");



// ----------------------------------------------------------------------------
// vtkSelectionNode methods
// ----------------------------------------------------------------------------

function vtkSelectionNode(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkSelectionNode');

  publicAPI.getBounds = () => model.points.getBounds();
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  contentType: -1,
  fieldType: -1,
  properties: null,
  selectionList: [],
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);
  model.properties = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'contentType',
    'fieldType',
    'properties',
    'selectionList',
  ]);

  // Object specific methods
  vtkSelectionNode(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkSelectionNode');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...vtk_js_Sources_Common_DataModel_SelectionNode_Constants__WEBPACK_IMPORTED_MODULE_1__["default"] });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/StructuredData/Constants.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/StructuredData/Constants.js ***!
  \**********************************************************************************/
/*! exports provided: StructuredType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StructuredType", function() { return StructuredType; });
const StructuredType = {
  UNCHANGED: 0,
  SINGLE_POINT: 1,
  X_LINE: 2,
  Y_LINE: 3,
  Z_LINE: 4,
  XY_PLANE: 5,
  YZ_PLANE: 6,
  XZ_PLANE: 7,
  XYZ_GRID: 8,
  EMPTY: 9,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  StructuredType,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/StructuredData/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/StructuredData/index.js ***!
  \******************************************************************************/
/*! exports provided: getDataDescriptionFromExtent, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDataDescriptionFromExtent", function() { return getDataDescriptionFromExtent; });
/* harmony import */ var vtk_js_Sources_Common_DataModel_StructuredData_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/StructuredData/Constants */ "./node_modules/vtk.js/Sources/Common/DataModel/StructuredData/Constants.js");


const { StructuredType } = vtk_js_Sources_Common_DataModel_StructuredData_Constants__WEBPACK_IMPORTED_MODULE_0__["default"];

function getDataDescriptionFromExtent(inExt) {
  let dataDim = 0;
  for (let i = 0; i < 3; ++i) {
    if (inExt[i * 2] < inExt[i * 2 + 1]) {
      dataDim++;
    }
  }

  if (inExt[0] > inExt[1] || inExt[2] > inExt[3] || inExt[4] > inExt[5]) {
    return StructuredType.EMPTY;
  }

  if (dataDim === 3) {
    return StructuredType.XYZ_GRID;
  }

  if (dataDim === 2) {
    if (inExt[0] === inExt[1]) {
      return StructuredType.YZ_PLANE;
    }

    if (inExt[2] === inExt[3]) {
      return StructuredType.XZ_PLANE;
    }
    return StructuredType.XY_PLANE;
  }

  if (dataDim === 1) {
    if (inExt[0] < inExt[1]) {
      return StructuredType.X_LINE;
    }

    if (inExt[2] < inExt[3]) {
      return StructuredType.Y_LINE;
    }

    return StructuredType.Z_LINE;
  }

  return StructuredType.SINGLE_POINT;
}

/* harmony default export */ __webpack_exports__["default"] = ({ getDataDescriptionFromExtent, ...vtk_js_Sources_Common_DataModel_StructuredData_Constants__WEBPACK_IMPORTED_MODULE_0__["default"] });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Common/DataModel/Triangle/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Common/DataModel/Triangle/index.js ***!
  \************************************************************************/
/*! exports provided: STATIC, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATIC", function() { return STATIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_Cell__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/Cell */ "./node_modules/vtk.js/Sources/Common/DataModel/Cell/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_Line__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/Line */ "./node_modules/vtk.js/Sources/Common/DataModel/Line/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/Plane */ "./node_modules/vtk.js/Sources/Common/DataModel/Plane/index.js");






// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

function computeNormalDirection(v1, v2, v3, n) {
  // order is important!!! maintain consistency with triangle vertex order
  const ax = v3[0] - v2[0];
  const ay = v3[1] - v2[1];
  const az = v3[2] - v2[2];
  const bx = v1[0] - v2[0];
  const by = v1[1] - v2[1];
  const bz = v1[2] - v2[2];

  n[0] = ay * bz - az * by;
  n[1] = az * bx - ax * bz;
  n[2] = ax * by - ay * bx;
}

function computeNormal(v1, v2, v3, n) {
  computeNormalDirection(v1, v2, v3, n);
  const length = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
  if (length !== 0.0) {
    n[0] /= length;
    n[1] /= length;
    n[2] /= length;
  }
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {
  computeNormalDirection,
  computeNormal,
};

// ----------------------------------------------------------------------------
// vtkTriangle methods
// ----------------------------------------------------------------------------

function vtkTriangle(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkTriangle');

  publicAPI.getCellDimension = () => 2;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    const outObj = { subId: 0, t: 0, intersect: -1 };
    pcoords[2] = 0.0;
    const closestPoint = [];
    const tol2 = tol * tol;

    // Get normal for triangle
    const pt1 = [];
    const pt2 = [];
    const pt3 = [];
    model.points.getPoint(0, pt1);
    model.points.getPoint(1, pt2);
    model.points.getPoint(2, pt3);
    const n = [];
    const weights = [];
    computeNormal(pt1, pt2, pt3, n);
    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {
      // Intersect plane of triangle with line
      const plane = vtk_js_Sources_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_4__["default"].intersectWithLine(p1, p2, pt1, n);
      outObj.t = plane.t;
      x[0] = plane.x[0];
      x[1] = plane.x[1];
      x[2] = plane.x[2];
      if (!plane.intersection) {
        pcoords[0] = 0.0;
        pcoords[1] = 0.0;
        outObj.intersect = 0;
        return outObj;
      }

      // Evaluate position
      const inside = publicAPI.evaluatePosition(
        x,
        closestPoint,
        pcoords,
        weights
      );
      if (inside.evaluation >= 0) {
        if (inside.dist2 <= tol2) {
          outObj.intersect = 1;
          return outObj;
        }
        outObj.intersect = inside.evaluation;
        return outObj;
      }
    }

    // Normals are null, so the triangle is degenerated and
    // we still need to check intersection between line and
    // the longest edge.
    const dist2Pt1Pt2 = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["distance2BetweenPoints"](pt1, pt2);
    const dist2Pt2Pt3 = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["distance2BetweenPoints"](pt2, pt3);
    const dist2Pt3Pt1 = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["distance2BetweenPoints"](pt3, pt1);
    if (!model.line) {
      model.line = vtk_js_Sources_Common_DataModel_Line__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
    }
    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {
      model.line.getPoints().setPoint(0, pt1);
      model.line.getPoints().setPoint(1, pt2);
    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {
      model.line.getPoints().setPoint(0, pt2);
      model.line.getPoints().setPoint(1, pt3);
    } else {
      model.line.getPoints().setPoint(0, pt3);
      model.line.getPoints().setPoint(1, pt1);
    }

    const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);
    if (intersectLine.intersect) {
      const pt3Pt1 = [];
      const pt3Pt2 = [];
      const pt3X = [];
      // Compute r and s manually, using dot and norm.
      for (let i = 0; i < 3; i++) {
        pt3Pt1[i] = pt1[i] - pt3[i];
        pt3Pt2[i] = pt2[i] - pt3[i];
        pt3X[i] = x[i] - pt3[i];
      }
      pcoords[0] = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["dot"](pt3X, pt3Pt1) / dist2Pt3Pt1;
      pcoords[1] = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["dot"](pt3X, pt3Pt2) / dist2Pt2Pt3;
      outObj.evaluation = 1;
      return outObj;
    }

    pcoords[0] = 0.0;
    pcoords[1] = 0.0;
    outObj.evaluation = 0;
    return outObj;
  };

  publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {
    // will return obj
    const outObj = { subId: 0, dist2: 0, evaluation: -1 };
    let i;
    let j;
    const pt1 = [];
    const pt2 = [];
    const pt3 = [];
    const n = [];
    let fabsn;
    const rhs = [];
    const c1 = [];
    const c2 = [];
    let det = 0;
    let idx = 0;
    const indices = [];
    let dist2Point;
    let dist2Line1;
    let dist2Line2;
    let closest = [];
    const closestPoint1 = [];
    const closestPoint2 = [];
    const cp = [];

    outObj.subId = 0;
    pcoords[2] = 0.0;

    // Get normal for triangle, only the normal direction is needed, i.e. the
    // normal need not be normalized (unit length)
    //
    model.points.getPoint(1, pt1);
    model.points.getPoint(2, pt2);
    model.points.getPoint(0, pt3);

    computeNormalDirection(pt1, pt2, pt3, n);

    // Project point to plane
    vtk_js_Sources_Common_DataModel_Plane__WEBPACK_IMPORTED_MODULE_4__["default"].generalizedProjectPoint(x, pt1, n, cp);

    // Construct matrices.  Since we have over determined system, need to find
    // which 2 out of 3 equations to use to develop equations. (Any 2 should
    // work since we've projected point to plane.)
    let maxComponent = 0.0;
    for (i = 0; i < 3; i++) {
      // trying to avoid an expensive call to fabs()
      if (n[i] < 0) {
        fabsn = -n[i];
      } else {
        fabsn = n[i];
      }
      if (fabsn > maxComponent) {
        maxComponent = fabsn;
        idx = i;
      }
    }

    for (j = 0, i = 0; i < 3; i++) {
      if (i !== idx) {
        indices[j++] = i;
      }
    }

    for (i = 0; i < 2; i++) {
      rhs[i] = cp[indices[i]] - pt3[indices[i]];
      c1[i] = pt1[indices[i]] - pt3[indices[i]];
      c2[i] = pt2[indices[i]] - pt3[indices[i]];
    }
    det = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["determinant2x2"](c1, c2);
    if (det === 0.0) {
      pcoords[0] = 0.0;
      pcoords[1] = 0.0;
      outObj.evaluation = -1;
      return outObj;
    }

    pcoords[0] = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["determinant2x2"](rhs, c2) / det;
    pcoords[1] = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["determinant2x2"](c1, rhs) / det;

    // Okay, now find closest point to element
    weights[0] = 1 - (pcoords[0] + pcoords[1]);
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];

    if (
      weights[0] >= 0.0 &&
      weights[0] <= 1.0 &&
      weights[1] >= 0.0 &&
      weights[1] <= 1.0 &&
      weights[2] >= 0.0 &&
      weights[2] <= 1.0
    ) {
      // projection distance
      if (closestPoint) {
        outObj.dist2 = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["distance2BetweenPoints"](cp, x);
        closestPoint[0] = cp[0];
        closestPoint[1] = cp[1];
        closestPoint[2] = cp[2];
      }
      outObj.evaluation = 1;
    } else {
      let t;
      if (closestPoint) {
        if (weights[1] < 0.0 && weights[2] < 0.0) {
          dist2Point = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["distance2BetweenPoints"](x, pt3);
          dist2Line1 = vtk_js_Sources_Common_DataModel_Line__WEBPACK_IMPORTED_MODULE_3__["default"].distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = vtk_js_Sources_Common_DataModel_Line__WEBPACK_IMPORTED_MODULE_3__["default"].distanceToLine(x, pt3, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt3;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[2] < 0.0 && weights[0] < 0.0) {
          dist2Point = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["distance2BetweenPoints"](x, pt1);
          dist2Line1 = vtk_js_Sources_Common_DataModel_Line__WEBPACK_IMPORTED_MODULE_3__["default"].distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = vtk_js_Sources_Common_DataModel_Line__WEBPACK_IMPORTED_MODULE_3__["default"].distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt1;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[1] < 0.0 && weights[0] < 0.0) {
          dist2Point = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["distance2BetweenPoints"](x, pt2);
          dist2Line1 = vtk_js_Sources_Common_DataModel_Line__WEBPACK_IMPORTED_MODULE_3__["default"].distanceToLine(x, pt2, pt3, t, closestPoint1);
          dist2Line2 = vtk_js_Sources_Common_DataModel_Line__WEBPACK_IMPORTED_MODULE_3__["default"].distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt2;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[0] < 0.0) {
          const lineDistance = vtk_js_Sources_Common_DataModel_Line__WEBPACK_IMPORTED_MODULE_3__["default"].distanceToLine(
            x,
            pt1,
            pt2,
            closestPoint
          );
          outObj.dist2 = lineDistance.distance;
        } else if (weights[1] < 0.0) {
          const lineDistance = vtk_js_Sources_Common_DataModel_Line__WEBPACK_IMPORTED_MODULE_3__["default"].distanceToLine(
            x,
            pt2,
            pt3,
            closestPoint
          );
          outObj.dist2 = lineDistance.distance;
        } else if (weights[2] < 0.0) {
          const lineDistance = vtk_js_Sources_Common_DataModel_Line__WEBPACK_IMPORTED_MODULE_3__["default"].distanceToLine(
            x,
            pt1,
            pt3,
            closestPoint
          );
          outObj.dist2 = lineDistance.distance;
        }
      }
      outObj.evaluation = 0;
    }

    return outObj;
  };

  publicAPI.evaluateLocation = (pcoords, x, weights) => {
    const p0 = [];
    const p1 = [];
    const p2 = [];
    model.points.getPoint(0, p0);
    model.points.getPoint(1, p1);
    model.points.getPoint(2, p2);
    const u3 = 1.0 - pcoords[0] - pcoords[1];

    for (let i = 0; i < 3; i++) {
      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];
    }

    weights[0] = u3;
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
  };

  publicAPI.getParametricDistance = (pcoords) => {
    let pDist;
    let pDistMax = 0.0;
    const pc = [];
    pc[0] = pcoords[0];
    pc[1] = pcoords[1];
    pc[2] = 1.0 - pcoords[0] - pcoords[1];

    for (let i = 0; i < 3; i++) {
      if (pc[i] < 0.0) {
        pDist = -pc[i];
      } else if (pc[i] > 1.0) {
        pDist = pc[i] - 1.0;
      } else {
        // inside the cell in the parametric direction
        pDist = 0.0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  vtk_js_Sources_Common_DataModel_Cell__WEBPACK_IMPORTED_MODULE_1__["default"].extend(publicAPI, model, initialValues);

  vtkTriangle(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkTriangle');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...STATIC });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Interaction/Style/InteractorStyleTrackballCamera/index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Interaction/Style/InteractorStyleTrackballCamera/index.js ***!
  \***********************************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_InteractorStyle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/InteractorStyle */ "./node_modules/vtk.js/Sources/Rendering/Core/InteractorStyle/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_InteractorStyle_Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/InteractorStyle/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/InteractorStyle/Constants.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_RenderWindowInteractor_Constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/RenderWindowInteractor/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/RenderWindowInteractor/Constants.js");






const { States } = vtk_js_Sources_Rendering_Core_InteractorStyle_Constants__WEBPACK_IMPORTED_MODULE_2__["default"];

/* eslint-disable no-lonely-if */

// ----------------------------------------------------------------------------
// vtkInteractorStyleTrackballCamera methods
// ----------------------------------------------------------------------------

function vtkInteractorStyleTrackballCamera(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkInteractorStyleTrackballCamera');

  // Public API methods
  publicAPI.handleMouseMove = (callData) => {
    const pos = callData.position;
    const renderer = callData.pokedRenderer;

    switch (model.state) {
      case States.IS_ROTATE:
        publicAPI.handleMouseRotate(renderer, pos);
        publicAPI.invokeInteractionEvent({ type: 'InteractionEvent' });
        break;

      case States.IS_PAN:
        publicAPI.handleMousePan(renderer, pos);
        publicAPI.invokeInteractionEvent({ type: 'InteractionEvent' });
        break;

      case States.IS_DOLLY:
        publicAPI.handleMouseDolly(renderer, pos);
        publicAPI.invokeInteractionEvent({ type: 'InteractionEvent' });
        break;

      case States.IS_SPIN:
        publicAPI.handleMouseSpin(renderer, pos);
        publicAPI.invokeInteractionEvent({ type: 'InteractionEvent' });
        break;

      default:
        break;
    }

    model.previousPosition = pos;
  };

  //----------------------------------------------------------------------------
  publicAPI.handleButton3D = (ed) => {
    if (
      ed &&
      ed.pressed &&
      ed.device === vtk_js_Sources_Rendering_Core_RenderWindowInteractor_Constants__WEBPACK_IMPORTED_MODULE_4__["Device"].RightController &&
      ed.input === vtk_js_Sources_Rendering_Core_RenderWindowInteractor_Constants__WEBPACK_IMPORTED_MODULE_4__["Input"].TrackPad
    ) {
      publicAPI.startCameraPose();
      return;
    }
    if (
      ed &&
      !ed.pressed &&
      ed.device === vtk_js_Sources_Rendering_Core_RenderWindowInteractor_Constants__WEBPACK_IMPORTED_MODULE_4__["Device"].RightController &&
      ed.input === vtk_js_Sources_Rendering_Core_RenderWindowInteractor_Constants__WEBPACK_IMPORTED_MODULE_4__["Input"].TrackPad &&
      model.state === States.IS_CAMERA_POSE
    ) {
      publicAPI.endCameraPose();
      // return;
    }
  };

  publicAPI.handleMove3D = (ed) => {
    switch (model.state) {
      case States.IS_CAMERA_POSE:
        publicAPI.updateCameraPose(ed);
        break;
      default:
    }
  };

  publicAPI.updateCameraPose = (ed) => {
    // move the world in the direction of the
    // controller
    const camera = ed.pokedRenderer.getActiveCamera();
    const oldTrans = camera.getPhysicalTranslation();

    // look at the y axis to determine how fast / what direction to move
    const speed = ed.gamepad.axes[1];

    // 0.05 meters / frame movement
    const pscale = (speed * 0.05) / camera.getPhysicalScale();

    // convert orientation to world coordinate direction
    const dir = camera.physicalOrientationToWorldDirection(ed.orientation);

    camera.setPhysicalTranslation(
      oldTrans[0] + dir[0] * pscale,
      oldTrans[1] + dir[1] * pscale,
      oldTrans[2] + dir[2] * pscale
    );
  };

  //----------------------------------------------------------------------------
  publicAPI.handleLeftButtonPress = (callData) => {
    const pos = callData.position;
    model.previousPosition = pos;

    if (callData.shiftKey) {
      if (callData.controlKey || callData.altKey) {
        publicAPI.startDolly();
      } else {
        publicAPI.startPan();
      }
    } else {
      if (callData.controlKey || callData.altKey) {
        publicAPI.startSpin();
      } else {
        publicAPI.startRotate();
      }
    }
  };

  //--------------------------------------------------------------------------
  publicAPI.handleLeftButtonRelease = () => {
    switch (model.state) {
      case States.IS_DOLLY:
        publicAPI.endDolly();
        break;
      case States.IS_PAN:
        publicAPI.endPan();
        break;
      case States.IS_SPIN:
        publicAPI.endSpin();
        break;
      case States.IS_ROTATE:
        publicAPI.endRotate();
        break;

      default:
        break;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.handleStartMouseWheel = (callData) => {
    publicAPI.startDolly();
    publicAPI.handleMouseWheel(callData);
  };

  //--------------------------------------------------------------------------
  publicAPI.handleEndMouseWheel = () => {
    publicAPI.endDolly();
  };

  //----------------------------------------------------------------------------
  publicAPI.handleStartPinch = (callData) => {
    model.previousScale = callData.scale;
    publicAPI.startDolly();
  };

  //--------------------------------------------------------------------------
  publicAPI.handleEndPinch = () => {
    publicAPI.endDolly();
  };

  //----------------------------------------------------------------------------
  publicAPI.handleStartRotate = (callData) => {
    model.previousRotation = callData.rotation;
    publicAPI.startRotate();
  };

  //--------------------------------------------------------------------------
  publicAPI.handleEndRotate = () => {
    publicAPI.endRotate();
  };

  //----------------------------------------------------------------------------
  publicAPI.handleStartPan = (callData) => {
    model.previousTranslation = callData.translation;
    publicAPI.startPan();
  };

  //--------------------------------------------------------------------------
  publicAPI.handleEndPan = () => {
    publicAPI.endPan();
  };

  //----------------------------------------------------------------------------
  publicAPI.handlePinch = (callData) => {
    publicAPI.dollyByFactor(
      callData.pokedRenderer,
      callData.scale / model.previousScale
    );
    model.previousScale = callData.scale;
  };

  //----------------------------------------------------------------------------
  publicAPI.handlePan = (callData) => {
    const camera = callData.pokedRenderer.getActiveCamera();

    // Calculate the focal depth since we'll be using it a lot
    let viewFocus = camera.getFocalPoint();

    viewFocus = publicAPI.computeWorldToDisplay(
      callData.pokedRenderer,
      viewFocus[0],
      viewFocus[1],
      viewFocus[2]
    );
    const focalDepth = viewFocus[2];

    const trans = callData.translation;
    const lastTrans = model.previousTranslation;
    const newPickPoint = publicAPI.computeDisplayToWorld(
      callData.pokedRenderer,
      viewFocus[0] + trans[0] - lastTrans[0],
      viewFocus[1] + trans[1] - lastTrans[1],
      focalDepth
    );

    // Has to recalc old mouse point since the viewport has moved,
    // so can't move it outside the loop
    const oldPickPoint = publicAPI.computeDisplayToWorld(
      callData.pokedRenderer,
      viewFocus[0],
      viewFocus[1],
      focalDepth
    );

    // Camera motion is reversed
    const motionVector = [];
    motionVector[0] = oldPickPoint[0] - newPickPoint[0];
    motionVector[1] = oldPickPoint[1] - newPickPoint[1];
    motionVector[2] = oldPickPoint[2] - newPickPoint[2];

    viewFocus = camera.getFocalPoint();
    const viewPoint = camera.getPosition();
    camera.setFocalPoint(
      motionVector[0] + viewFocus[0],
      motionVector[1] + viewFocus[1],
      motionVector[2] + viewFocus[2]
    );

    camera.setPosition(
      motionVector[0] + viewPoint[0],
      motionVector[1] + viewPoint[1],
      motionVector[2] + viewPoint[2]
    );

    if (model.interactor.getLightFollowCamera()) {
      callData.pokedRenderer.updateLightsGeometryToFollowCamera();
    }

    camera.orthogonalizeViewUp();

    model.previousTranslation = callData.translation;
  };

  //----------------------------------------------------------------------------
  publicAPI.handleRotate = (callData) => {
    const camera = callData.pokedRenderer.getActiveCamera();
    camera.roll(callData.rotation - model.previousRotation);
    camera.orthogonalizeViewUp();
    model.previousRotation = callData.rotation;
  };

  //--------------------------------------------------------------------------
  publicAPI.handleMouseRotate = (renderer, position) => {
    const rwi = model.interactor;

    const dx = position.x - model.previousPosition.x;
    const dy = position.y - model.previousPosition.y;

    const size = rwi.getView().getViewportSize(renderer);

    let deltaElevation = -0.1;
    let deltaAzimuth = -0.1;
    if (size[0] && size[1]) {
      deltaElevation = -20.0 / size[1];
      deltaAzimuth = -20.0 / size[0];
    }

    const rxf = dx * deltaAzimuth * model.motionFactor;
    const ryf = dy * deltaElevation * model.motionFactor;

    const camera = renderer.getActiveCamera();
    if (!Number.isNaN(rxf) && !Number.isNaN(ryf)) {
      camera.azimuth(rxf);
      camera.elevation(ryf);
      camera.orthogonalizeViewUp();
    }

    if (model.autoAdjustCameraClippingRange) {
      renderer.resetCameraClippingRange();
    }

    if (rwi.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };

  //--------------------------------------------------------------------------
  publicAPI.handleMouseSpin = (renderer, position) => {
    const rwi = model.interactor;
    const camera = renderer.getActiveCamera();
    const center = rwi.getView().getViewportCenter(renderer);

    const oldAngle = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["degreesFromRadians"](
      Math.atan2(
        model.previousPosition.y - center[1],
        model.previousPosition.x - center[0]
      )
    );
    const newAngle =
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["degreesFromRadians"](
        Math.atan2(position.y - center[1], position.x - center[0])
      ) - oldAngle;

    if (!Number.isNaN(newAngle)) {
      camera.roll(newAngle);
      camera.orthogonalizeViewUp();
    }
  };

  //--------------------------------------------------------------------------
  publicAPI.handleMousePan = (renderer, position) => {
    const camera = renderer.getActiveCamera();

    // Calculate the focal depth since we'll be using it a lot
    let viewFocus = camera.getFocalPoint();
    viewFocus = publicAPI.computeWorldToDisplay(
      renderer,
      viewFocus[0],
      viewFocus[1],
      viewFocus[2]
    );
    const focalDepth = viewFocus[2];

    const newPickPoint = publicAPI.computeDisplayToWorld(
      renderer,
      position.x,
      position.y,
      focalDepth
    );

    // Has to recalc old mouse point since the viewport has moved,
    // so can't move it outside the loop
    const oldPickPoint = publicAPI.computeDisplayToWorld(
      renderer,
      model.previousPosition.x,
      model.previousPosition.y,
      focalDepth
    );

    // Camera motion is reversed
    const motionVector = [];
    motionVector[0] = oldPickPoint[0] - newPickPoint[0];
    motionVector[1] = oldPickPoint[1] - newPickPoint[1];
    motionVector[2] = oldPickPoint[2] - newPickPoint[2];

    viewFocus = camera.getFocalPoint();
    const viewPoint = camera.getPosition();
    camera.setFocalPoint(
      motionVector[0] + viewFocus[0],
      motionVector[1] + viewFocus[1],
      motionVector[2] + viewFocus[2]
    );

    camera.setPosition(
      motionVector[0] + viewPoint[0],
      motionVector[1] + viewPoint[1],
      motionVector[2] + viewPoint[2]
    );

    if (model.interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.handleMouseDolly = (renderer, position) => {
    const dy = position.y - model.previousPosition.y;
    const rwi = model.interactor;
    const center = rwi.getView().getViewportCenter(renderer);
    const dyf = (model.motionFactor * dy) / center[1];

    publicAPI.dollyByFactor(renderer, 1.1 ** dyf);
  };

  //----------------------------------------------------------------------------
  publicAPI.handleMouseWheel = (callData) => {
    const dyf = 1 - callData.spinY / 10; // divide by 10 to lower the zoom factor
    publicAPI.dollyByFactor(callData.pokedRenderer, dyf);
  };

  //----------------------------------------------------------------------------
  publicAPI.dollyByFactor = (renderer, factor) => {
    if (Number.isNaN(factor)) {
      return;
    }

    const camera = renderer.getActiveCamera();
    if (camera.getParallelProjection()) {
      camera.setParallelScale(camera.getParallelScale() / factor);
    } else {
      camera.dolly(factor);
      if (model.autoAdjustCameraClippingRange) {
        renderer.resetCameraClippingRange();
      }
    }

    if (model.interactor.getLightFollowCamera()) {
      renderer.updateLightsGeometryToFollowCamera();
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  motionFactor: 10.0,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_Core_InteractorStyle__WEBPACK_IMPORTED_MODULE_1__["default"].extend(publicAPI, model, initialValues);

  // Create get-set macros
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, ['motionFactor']);

  // For more macro methods, see "Sources/macro.js"

  // Object specific methods
  vtkInteractorStyleTrackballCamera(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(
  extend,
  'vtkInteractorStyleTrackballCamera'
);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/AbstractMapper/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/AbstractMapper/index.js ***!
  \****************************************************************************/
/*! exports provided: extend, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");


// ----------------------------------------------------------------------------
// vtkAbstractMapper methods
// ----------------------------------------------------------------------------

function vtkAbstractMapper(publicAPI, model) {
  publicAPI.update = () => {
    publicAPI.getInputData();
  };

  publicAPI.addClippingPlane = (plane) => {
    if (plane.getClassName() !== 'vtkPlane') {
      return;
    }
    model.clippingPlanes.push(plane);
  };

  publicAPI.getNumberOfClippingPlanes = () => model.clippingPlanes.length;

  publicAPI.removeAllClippingPlanes = () => {
    model.clippingPlanes.length = 0;
  };

  publicAPI.removeClippingPlane = (i) => {
    if (i < 0 || i >= 6) {
      return;
    }
    model.clippingPlanes.splice(i, 1);
  };

  publicAPI.getClippingPlanes = () => model.clippingPlanes;

  publicAPI.setClippingPlanes = (planes) => {
    if (!planes) {
      return;
    }
    if (!Array.isArray(planes)) {
      publicAPI.addClippingPlane(planes);
    } else {
      const nbPlanes = planes.length;
      for (let i = 0; i < nbPlanes && i < 6; i++) {
        publicAPI.addClippingPlane(planes[i]);
      }
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  clippingPlanes: [],
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].algo(publicAPI, model, 1, 0);

  if (!model.clippingPlanes) {
    model.clippingPlanes = [];
  }

  vtkAbstractMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------
/* harmony default export */ __webpack_exports__["default"] = ({ extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/AbstractMapper3D/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/AbstractMapper3D/index.js ***!
  \******************************************************************************/
/*! exports provided: extend, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_AbstractMapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/AbstractMapper */ "./node_modules/vtk.js/Sources/Rendering/Core/AbstractMapper/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");




// ----------------------------------------------------------------------------
// vtkAbstractMapper methods
// ----------------------------------------------------------------------------

function vtkAbstractMapper3D(publicAPI, model) {
  publicAPI.getBounds = () => 0;

  publicAPI.getBounds = (bounds) => {
    publicAPI.getBounds();
    for (let i = 0; i < 6; i++) {
      bounds[i] = model.bounds[i];
    }
  };

  publicAPI.getCenter = () => {
    publicAPI.getBounds();
    for (let i = 0; i < 3; i++) {
      model.center[i] = (model.bounds[2 * i + 1] + model.bounds[2 * i]) / 2.0;
    }
    return model.center.slice();
  };

  publicAPI.getLength = () => {
    let diff = 0.0;
    let l = 0.0;
    publicAPI.getBounds();
    for (let i = 0; i < 3; i++) {
      diff = model.bounds[2 * i + 1] - model.bounds[2 * i];
      l += diff * diff;
    }

    return Math.sqrt(l);
  };

  publicAPI.getClippingPlaneInDataCoords = (propMatrix, i, hnormal) => {
    const clipPlanes = model.clippingPlanes;
    const mat = propMatrix;

    if (clipPlanes) {
      const n = clipPlanes.length;
      if (i >= 0 && i < n) {
        // Get the plane
        const plane = clipPlanes[i];
        const normal = plane.getNormal();
        const origin = plane.getOrigin();

        // Compute the plane equation
        const v1 = normal[0];
        const v2 = normal[1];
        const v3 = normal[2];
        const v4 = -(v1 * origin[0] + v2 * origin[1] + v3 * origin[2]);

        // Transform normal from world to data coords
        hnormal[0] = v1 * mat[0] + v2 * mat[4] + v3 * mat[8] + v4 * mat[12];
        hnormal[1] = v1 * mat[1] + v2 * mat[5] + v3 * mat[9] + v4 * mat[13];
        hnormal[2] = v1 * mat[2] + v2 * mat[6] + v3 * mat[10] + v4 * mat[14];
        hnormal[3] = v1 * mat[3] + v2 * mat[7] + v3 * mat[11] + v4 * mat[15];

        return;
      }
    }
    vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].vtkErrorMacro(`Clipping plane index ${i} is out of range.`);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  bounds: [1, -1, 1, -1, 1, -1],
  center: [0, 0, 0],
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);
  // Inheritance
  vtk_js_Sources_Rendering_Core_AbstractMapper__WEBPACK_IMPORTED_MODULE_1__["default"].extend(publicAPI, model, initialValues);

  if (!model.bounds) {
    vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["uninitializeBounds"](model.bounds);
  }

  if (!model.center) {
    model.center = [0.0, 0.0, 0.0];
  }

  vtkAbstractMapper3D(publicAPI, model);
}

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/Actor/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/Actor/index.js ***!
  \*******************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Prop3D__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Prop3D */ "./node_modules/vtk.js/Sources/Rendering/Core/Prop3D/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Property__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Property */ "./node_modules/vtk.js/Sources/Rendering/Core/Property/index.js");





const { vtkDebugMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"];

// ----------------------------------------------------------------------------
// vtkActor methods
// ----------------------------------------------------------------------------

function vtkActor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkActor');

  // Capture 'parentClass' api for internal use
  const superClass = { ...publicAPI };

  publicAPI.getActors = () => publicAPI;

  publicAPI.getIsOpaque = () => {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    // make sure we have a property
    if (!model.property) {
      // force creation of a property
      publicAPI.getProperty();
    }

    let isOpaque = model.property.getOpacity() >= 1.0;

    // are we using an opaque texture, if any?
    isOpaque = isOpaque && (!model.texture || !model.texture.isTranslucent());

    // are we using an opaque scalar array, if any?
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());

    return isOpaque;
  };

  publicAPI.hasTranslucentPolygonalGeometry = () => {
    if (model.mapper === null) {
      return false;
    }
    // make sure we have a property
    if (model.property === null) {
      // force creation of a property
      publicAPI.setProperty(publicAPI.makeProperty());
    }

    // is this actor opaque ?
    return !publicAPI.getIsOpaque();
  };

  publicAPI.makeProperty = vtk_js_Sources_Rendering_Core_Property__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance;

  publicAPI.getProperty = () => {
    if (model.property === null) {
      model.property = publicAPI.makeProperty();
    }
    return model.property;
  };

  publicAPI.getBounds = () => {
    if (model.mapper === null) {
      return model.bounds;
    }

    // Check for the special case when the mapper's bounds are unknown
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }

    // Check for the special case when the actor is empty.
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds.concat(); // copy the mapper's bounds
      model.bounds = [1, -1, 1, -1, 1, -1];
      model.boundsMTime.modified();
      return bds;
    }

    // Check if we have cached values for these bounds - we cache the
    // values returned by model.mapper.getBounds() and we store the time
    // of caching. If the values returned this time are different, or
    // the modified time of this class is newer than the cached time,
    // then we need to rebuild.
    if (
      !model.mapperBounds ||
      bds[0] !== model.mapperBounds[0] ||
      bds[1] !== model.mapperBounds[1] ||
      bds[2] !== model.mapperBounds[2] ||
      bds[3] !== model.mapperBounds[3] ||
      bds[4] !== model.mapperBounds[4] ||
      bds[5] !== model.mapperBounds[5] ||
      publicAPI.getMTime() > model.boundsMTime.getMTime()
    ) {
      vtkDebugMacro('Recomputing bounds...');
      model.mapperBounds = bds.concat(); // copy the mapper's bounds
      const bbox = [
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(bds[1], bds[3], bds[5]),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(bds[1], bds[2], bds[5]),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(bds[0], bds[2], bds[5]),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(bds[0], bds[3], bds[5]),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(bds[1], bds[3], bds[4]),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(bds[1], bds[2], bds[4]),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(bds[0], bds[2], bds[4]),
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(bds[0], bds[3], bds[4]),
      ];

      publicAPI.computeMatrix();
      const tmp4 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(tmp4, model.matrix);
      bbox.forEach((pt) => gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(pt, pt, tmp4));

      /* eslint-disable no-multi-assign */
      model.bounds[0] = model.bounds[2] = model.bounds[4] = Number.MAX_VALUE;
      model.bounds[1] = model.bounds[3] = model.bounds[5] = -Number.MAX_VALUE;
      /* eslint-enable no-multi-assign */

      model.bounds = model.bounds.map((d, i) =>
        i % 2 === 0
          ? bbox.reduce((a, b) => (a > b[i / 2] ? b[i / 2] : a), d)
          : bbox.reduce((a, b) => (a < b[(i - 1) / 2] ? b[(i - 1) / 2] : a), d)
      );

      model.boundsMTime.modified();
    }
    return model.bounds;
  };

  publicAPI.getMTime = () => {
    let mt = superClass.getMTime();
    if (model.property !== null) {
      const time = model.property.getMTime();
      mt = time > mt ? time : mt;
    }

    if (model.backfaceProperty !== null) {
      const time = model.backfaceProperty.getMTime();
      mt = time > mt ? time : mt;
    }

    return mt;
  };

  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time = model.mapper.getMTime();
      mt = time > mt ? time : mt;
      if (model.mapper.getInput() !== null) {
        // FIXME !!! getInputAlgorithm / getInput
        model.mapper.getInputAlgorithm().update();
        time = model.mapper.getInput().getMTime();
        mt = time > mt ? time : mt;
      }
    }
    return mt;
  };

  publicAPI.getSupportsSelection = () =>
    model.mapper ? model.mapper.getSupportsSelection() : false;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  mapper: null,
  property: null,
  backfaceProperty: null,

  forceOpaque: false,
  forceTranslucent: false,

  bounds: [1, -1, 1, -1, 1, -1],
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_Core_Prop3D__WEBPACK_IMPORTED_MODULE_2__["default"].extend(publicAPI, model, initialValues);

  // vtkTimeStamp
  model.boundsMTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(model.boundsMTime);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].set(publicAPI, model, ['property']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGet(publicAPI, model, [
    'backfaceProperty',
    'forceOpaque',
    'forceTranslucent',
    'mapper',
  ]);

  // Object methods
  vtkActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend, 'vtkActor');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/Camera/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/Camera/index.js ***!
  \********************************************************************/
/*! exports provided: DEFAULT_VALUES, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_VALUES", function() { return DEFAULT_VALUES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");





const { vtkDebugMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"];

/* eslint-disable new-cap */

/*
 * Convenience function to access elements of a gl-matrix.  If it turns
 * out I have rows and columns swapped everywhere, then I'll just change
 * the order of 'row' and 'col' parameters in this function
 */
// function getMatrixElement(matrix, row, col) {
//   const idx = (row * 4) + col;
//   return matrix[idx];
// }

// ----------------------------------------------------------------------------
// vtkCamera methods
// ----------------------------------------------------------------------------

function vtkCamera(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkCamera');

  // Set up private variables and methods
  const origin = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
  const dopbasis = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(0.0, 0.0, -1.0);
  const upbasis = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(0.0, 1.0, 0.0);
  const tmpMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
  const tmpvec1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
  const tmpvec2 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
  const tmpvec3 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();

  const rotateMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
  const trans = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
  const newPosition = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
  const newFocalPoint = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();

  // Internal Functions that don't need to be public
  function computeViewPlaneNormal() {
    // VPN is -DOP
    model.viewPlaneNormal[0] = -model.directionOfProjection[0];
    model.viewPlaneNormal[1] = -model.directionOfProjection[1];
    model.viewPlaneNormal[2] = -model.directionOfProjection[2];
  }

  publicAPI.orthogonalizeViewUp = () => {
    const vt = publicAPI.getViewMatrix();
    model.viewUp[0] = vt[4];
    model.viewUp[1] = vt[5];
    model.viewUp[2] = vt[6];

    publicAPI.modified();
  };

  publicAPI.setPosition = (x, y, z) => {
    if (
      x === model.position[0] &&
      y === model.position[1] &&
      z === model.position[2]
    ) {
      return;
    }

    model.position[0] = x;
    model.position[1] = y;
    model.position[2] = z;

    // recompute the focal distance
    publicAPI.computeDistance();

    publicAPI.modified();
  };

  publicAPI.setFocalPoint = (x, y, z) => {
    if (
      x === model.focalPoint[0] &&
      y === model.focalPoint[1] &&
      z === model.focalPoint[2]
    ) {
      return;
    }

    model.focalPoint[0] = x;
    model.focalPoint[1] = y;
    model.focalPoint[2] = z;

    // recompute the focal distance
    publicAPI.computeDistance();

    publicAPI.modified();
  };

  publicAPI.setDistance = (d) => {
    if (model.distance === d) {
      return;
    }

    model.distance = d;

    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro('Distance is set to minimum.');
    }

    // we want to keep the camera pointing in the same direction
    const vec = model.directionOfProjection;

    // recalculate FocalPoint
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;

    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  // This method must be called when the focal point or camera position changes
  publicAPI.computeDistance = () => {
    const dx = model.focalPoint[0] - model.position[0];
    const dy = model.focalPoint[1] - model.position[1];
    const dz = model.focalPoint[2] - model.position[2];

    model.distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

    if (model.distance < 1e-20) {
      model.distance = 1e-20;
      vtkDebugMacro('Distance is set to minimum.');

      const vec = model.directionOfProjection;

      // recalculate FocalPoint
      model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
      model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
      model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    }

    model.directionOfProjection[0] = dx / model.distance;
    model.directionOfProjection[1] = dy / model.distance;
    model.directionOfProjection[2] = dz / model.distance;

    computeViewPlaneNormal();
  };

  //----------------------------------------------------------------------------
  // Move the position of the camera along the view plane normal. Moving
  // towards the focal point (e.g., > 1) is a dolly-in, moving away
  // from the focal point (e.g., < 1) is a dolly-out.
  publicAPI.dolly = (amount) => {
    if (amount <= 0.0) {
      return;
    }

    // dolly moves the camera towards the focus
    const d = model.distance / amount;

    publicAPI.setPosition(
      model.focalPoint[0] - d * model.directionOfProjection[0],
      model.focalPoint[1] - d * model.directionOfProjection[1],
      model.focalPoint[2] - d * model.directionOfProjection[2]
    );
  };

  publicAPI.roll = (angle) => {
    const eye = model.position;
    const at = model.focalPoint;
    const up = model.viewUp;
    const viewUpVec4 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].fromValues(up[0], up[1], up[2], 0.0);

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(rotateMatrix);
    const viewDir = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(
      at[0] - eye[0],
      at[1] - eye[1],
      at[2] - eye[2]
    );
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotate(
      rotateMatrix,
      rotateMatrix,
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["radiansFromDegrees"](angle),
      viewDir
    );
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].transformMat4(viewUpVec4, viewUpVec4, rotateMatrix);

    model.viewUp[0] = viewUpVec4[0];
    model.viewUp[1] = viewUpVec4[1];
    model.viewUp[2] = viewUpVec4[2];

    publicAPI.modified();
  };

  publicAPI.azimuth = (angle) => {
    const fp = model.focalPoint;

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(trans);

    // translate the focal point to the origin,
    // rotate about view up,
    // translate back again
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(trans, trans, gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(fp[0], fp[1], fp[2]));
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotate(
      trans,
      trans,
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["radiansFromDegrees"](angle),
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(model.viewUp[0], model.viewUp[1], model.viewUp[2])
    );
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(trans, trans, gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(-fp[0], -fp[1], -fp[2]));

    // apply the transform to the position
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(
      newPosition,
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(model.position[0], model.position[1], model.position[2]),
      trans
    );
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };

  publicAPI.yaw = (angle) => {
    const position = model.position;

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(trans);

    // translate the camera to the origin,
    // rotate about axis,
    // translate back again
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(
      trans,
      trans,
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(position[0], position[1], position[2])
    );
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotate(
      trans,
      trans,
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["radiansFromDegrees"](angle),
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(model.viewUp[0], model.viewUp[1], model.viewUp[2])
    );
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(
      trans,
      trans,
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(-position[0], -position[1], -position[2])
    );

    // apply the transform to the position
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(
      newFocalPoint,
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(
        model.focalPoint[0],
        model.focalPoint[1],
        model.focalPoint[2]
      ),
      trans
    );
    publicAPI.setFocalPoint(
      newFocalPoint[0],
      newFocalPoint[1],
      newFocalPoint[2]
    );
  };

  publicAPI.elevation = (angle) => {
    const fp = model.focalPoint;

    // get the eye / camera position from the viewMatrix
    const vt = publicAPI.getViewMatrix();
    const axis = [-vt[0], -vt[1], -vt[2]];

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(trans);

    // translate the focal point to the origin,
    // rotate about view up,
    // translate back again
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(trans, trans, gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(fp[0], fp[1], fp[2]));
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotate(
      trans,
      trans,
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["radiansFromDegrees"](angle),
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(axis[0], axis[1], axis[2])
    );
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(trans, trans, gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(-fp[0], -fp[1], -fp[2]));

    // apply the transform to the position
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(
      newPosition,
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(model.position[0], model.position[1], model.position[2]),
      trans
    );
    publicAPI.setPosition(newPosition[0], newPosition[1], newPosition[2]);
  };

  publicAPI.pitch = (angle) => {
    const position = model.position;

    const vt = publicAPI.getViewMatrix();
    const axis = [vt[0], vt[1], vt[2]];

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(trans);

    // translate the camera to the origin,
    // rotate about axis,
    // translate back again
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(
      trans,
      trans,
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(position[0], position[1], position[2])
    );
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotate(
      trans,
      trans,
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["radiansFromDegrees"](angle),
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(axis[0], axis[1], axis[2])
    );
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(
      trans,
      trans,
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(-position[0], -position[1], -position[2])
    );

    // apply the transform to the focal point
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(
      newFocalPoint,
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(...model.focalPoint),
      trans
    );
    publicAPI.setFocalPoint(...newFocalPoint);
  };

  publicAPI.zoom = (factor) => {
    if (factor <= 0) {
      return;
    }
    if (model.parallelProjection) {
      model.parallelScale /= factor;
    } else {
      model.viewAngle /= factor;
    }
    publicAPI.modified();
  };

  publicAPI.translate = (x, y, z) => {
    const offset = [x, y, z];

    vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["add"](model.position, offset, model.position);
    vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["add"](model.focalPoint, offset, model.focalPoint);

    publicAPI.computeDistance();
    publicAPI.modified();
  };

  publicAPI.applyTransform = (transformMat4) => {
    const vuOld = [...model.viewUp, 1.0];
    const posNew = [];
    const fpNew = [];
    const vuNew = [];

    vuOld[0] += model.position[0];
    vuOld[1] += model.position[1];
    vuOld[2] += model.position[2];

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].transformMat4(posNew, [...model.position, 1.0], transformMat4);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].transformMat4(fpNew, [...model.focalPoint, 1.0], transformMat4);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].transformMat4(vuNew, vuOld, transformMat4);

    vuNew[0] -= posNew[0];
    vuNew[1] -= posNew[1];
    vuNew[2] -= posNew[2];

    publicAPI.setPosition(...posNew.slice(0, 3));
    publicAPI.setFocalPoint(...fpNew.slice(0, 3));
    publicAPI.setViewUp(...vuNew.slice(0, 3));
  };

  publicAPI.getThickness = () =>
    model.clippingRange[1] - model.clippingRange[0];

  publicAPI.setThickness = (thickness) => {
    let t = thickness;
    if (t < 1e-20) {
      t = 1e-20;
      vtkDebugMacro('Thickness is set to minimum.');
    }
    publicAPI.setClippingRange(
      model.clippingRange[0],
      model.clippingRange[0] + t
    );
  };

  publicAPI.setThicknessFromFocalPoint = (thickness) => {
    let t = thickness;
    if (t < 1e-20) {
      t = 1e-20;
      vtkDebugMacro('Thickness is set to minimum.');
    }
    publicAPI.setClippingRange(model.distance - t / 2, model.distance + t / 2);
  };

  // Unimplemented functions
  publicAPI.setRoll = (angle) => {}; // dependency on GetOrientation() and a model.ViewTransform object, see https://github.com/Kitware/VTK/blob/master/Common/Transforms/vtkTransform.cxx and https://vtk.org/doc/nightly/html/classvtkTransform.html
  publicAPI.getRoll = () => {};
  publicAPI.setObliqueAngles = (alpha, beta) => {};
  publicAPI.getOrientation = () => {};
  publicAPI.getOrientationWXYZ = () => {};
  publicAPI.getFrustumPlanes = (aspect) => {
    // Return array of 24 params (4 params for each of 6 plane equations)
  };
  publicAPI.getCameraLightTransformMatrix = () => {};
  publicAPI.deepCopy = (sourceCamera) => {};

  publicAPI.physicalOrientationToWorldDirection = (ori) => {
    // push the x axis through the orientation quat
    const oriq = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].fromValues(ori[0], ori[1], ori[2], ori[3]);
    const coriq = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].create();
    const qdir = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].fromValues(0.0, 0.0, 1.0, 0.0);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].conjugate(coriq, oriq);

    // rotate the z axis by the quat
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].multiply(qdir, oriq, qdir);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].multiply(qdir, qdir, coriq);

    // return the z axis in world coords
    return [qdir[0], qdir[1], qdir[2]];
  };

  publicAPI.getPhysicalToWorldMatrix = (result) => {
    publicAPI.getWorldToPhysicalMatrix(result);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].invert(result, result);
  };

  publicAPI.getWorldToPhysicalMatrix = (result) => {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(result);

    // now the physical to vtk world rotation tform
    const physVRight = [3];
    vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["cross"](model.physicalViewNorth, model.physicalViewUp, physVRight);
    result[0] = physVRight[0];
    result[1] = physVRight[1];
    result[2] = physVRight[2];
    result[4] = model.physicalViewUp[0];
    result[5] = model.physicalViewUp[1];
    result[6] = model.physicalViewUp[2];
    result[8] = -model.physicalViewNorth[0];
    result[9] = -model.physicalViewNorth[1];
    result[10] = -model.physicalViewNorth[2];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(result, result);

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(
      tmpvec1,
      1 / model.physicalScale,
      1 / model.physicalScale,
      1 / model.physicalScale
    );

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].scale(result, result, tmpvec1);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(result, result, model.physicalTranslation);
  };

  publicAPI.computeViewParametersFromViewMatrix = (vmat) => {
    // invert to get view to world
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].invert(tmpMatrix, vmat);

    // note with glmatrix operations happen in
    // the reverse order
    // mat.scale
    // mat.translate
    // will result in the translation then the scale
    // mat.mult(a,b)
    // results in perform the B transformation then A

    // then extract the params position, orientation
    // push 0,0,0 through to get a translation
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(tmpvec1, origin, tmpMatrix);
    publicAPI.computeDistance();
    const oldDist = model.distance;
    publicAPI.setPosition(tmpvec1[0], tmpvec1[1], tmpvec1[2]);

    // push basis vectors to get orientation
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(tmpvec2, dopbasis, tmpMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].subtract(tmpvec2, tmpvec2, tmpvec1);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].normalize(tmpvec2, tmpvec2);
    publicAPI.setDirectionOfProjection(tmpvec2[0], tmpvec2[1], tmpvec2[2]);

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(tmpvec3, upbasis, tmpMatrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].subtract(tmpvec3, tmpvec3, tmpvec1);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].normalize(tmpvec3, tmpvec3);
    publicAPI.setViewUp(tmpvec3[0], tmpvec3[1], tmpvec3[2]);

    publicAPI.setDistance(oldDist);
  };

  // the provided matrix should include
  // translation and orientation only
  // mat is physical to view
  publicAPI.computeViewParametersFromPhysicalMatrix = (mat) => {
    // get the WorldToPhysicalMatrix
    publicAPI.getWorldToPhysicalMatrix(tmpMatrix);

    // first convert the physical -> view matrix to be
    // world -> view
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(tmpMatrix, mat, tmpMatrix);

    publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
  };

  publicAPI.setViewMatrix = (mat) => {
    model.viewMatrix = mat;
    if (model.viewMatrix) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(tmpMatrix, model.viewMatrix);
      publicAPI.computeViewParametersFromViewMatrix(tmpMatrix);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(model.viewMatrix, model.viewMatrix);
    }
  };

  publicAPI.getViewMatrix = () => {
    if (model.viewMatrix) {
      return model.viewMatrix;
    }

    const result = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].lookAt(
      tmpMatrix,
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(...model.position), // eye
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(...model.focalPoint), // at
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(...model.viewUp) // up
    );

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(tmpMatrix, tmpMatrix);

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(result, tmpMatrix);
    return result;
  };

  publicAPI.setProjectionMatrix = (mat) => {
    model.projectionMatrix = mat;
  };

  publicAPI.getProjectionMatrix = (aspect, nearz, farz) => {
    const result = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();

    if (model.projectionMatrix) {
      const scale = 1 / model.physicalScale;
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].set(tmpvec1, scale, scale, scale);

      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(result, model.projectionMatrix);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].scale(result, result, tmpvec1);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(result, result);
      return result;
    }

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(tmpMatrix);

    // FIXME: Not sure what to do about adjust z buffer here
    // adjust Z-buffer range
    // this->ProjectionTransform->AdjustZBuffer( -1, +1, nearz, farz );
    const cWidth = model.clippingRange[1] - model.clippingRange[0];
    const cRange = [
      model.clippingRange[0] + ((nearz + 1) * cWidth) / 2.0,
      model.clippingRange[0] + ((farz + 1) * cWidth) / 2.0,
    ];

    if (model.parallelProjection) {
      // set up a rectangular parallelipiped
      const width = model.parallelScale * aspect;
      const height = model.parallelScale;

      const xmin = (model.windowCenter[0] - 1.0) * width;
      const xmax = (model.windowCenter[0] + 1.0) * width;
      const ymin = (model.windowCenter[1] - 1.0) * height;
      const ymax = (model.windowCenter[1] + 1.0) * height;

      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].ortho(tmpMatrix, xmin, xmax, ymin, ymax, cRange[0], cRange[1]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(tmpMatrix, tmpMatrix);
    } else if (model.useOffAxisProjection) {
      throw new Error('Off-Axis projection is not supported at this time');
    } else {
      const tmp = Math.tan(vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["radiansFromDegrees"](model.viewAngle) / 2.0);
      let width;
      let height;
      if (model.useHorizontalViewAngle === true) {
        width = model.clippingRange[0] * tmp;
        height = (model.clippingRange[0] * tmp) / aspect;
      } else {
        width = model.clippingRange[0] * tmp * aspect;
        height = model.clippingRange[0] * tmp;
      }

      const xmin = (model.windowCenter[0] - 1.0) * width;
      const xmax = (model.windowCenter[0] + 1.0) * width;
      const ymin = (model.windowCenter[1] - 1.0) * height;
      const ymax = (model.windowCenter[1] + 1.0) * height;
      const znear = cRange[0];
      const zfar = cRange[1];

      tmpMatrix[0] = (2.0 * znear) / (xmax - xmin);
      tmpMatrix[5] = (2.0 * znear) / (ymax - ymin);
      tmpMatrix[2] = (xmin + xmax) / (xmax - xmin);
      tmpMatrix[6] = (ymin + ymax) / (ymax - ymin);
      tmpMatrix[10] = -(znear + zfar) / (zfar - znear);
      tmpMatrix[14] = -1.0;
      tmpMatrix[11] = (-2.0 * znear * zfar) / (zfar - znear);
      tmpMatrix[15] = 0.0;
    }

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(result, tmpMatrix);

    return result;
  };

  publicAPI.getCompositeProjectionMatrix = (aspect, nearz, farz) => {
    const vMat = publicAPI.getViewMatrix();
    const pMat = publicAPI.getProjectionMatrix(aspect, nearz, farz);
    const result = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    // mats are transposed so the order is A then B
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(result, vMat, pMat);
    return result;
  };

  publicAPI.setDirectionOfProjection = (x, y, z) => {
    if (
      model.directionOfProjection[0] === x &&
      model.directionOfProjection[1] === y &&
      model.directionOfProjection[2] === z
    ) {
      return;
    }

    model.directionOfProjection[0] = x;
    model.directionOfProjection[1] = y;
    model.directionOfProjection[2] = z;

    const vec = model.directionOfProjection;

    // recalculate FocalPoint
    model.focalPoint[0] = model.position[0] + vec[0] * model.distance;
    model.focalPoint[1] = model.position[1] + vec[1] * model.distance;
    model.focalPoint[2] = model.position[2] + vec[2] * model.distance;
    computeViewPlaneNormal();
  };

  // used to handle convert js device orientation angles
  // when you use this method the camera will adjust to the
  // device orientation such that the physicalViewUp you set
  // in world coordinates looks up, and the physicalViewNorth
  // you set in world coorindates will (maybe) point north
  //
  // NOTE WARNING - much of the documentation out there on how
  // orientation works is seriously wrong. Even worse the Chrome
  // device orientation simulator is completely wrong and should
  // never be used. OMG it is so messed up.
  //
  // how it seems to work on iOS is that the device orientation
  // is specified in extrinsic angles with a alpha, beta, gamma
  // convention with axes of Z, X, Y (the code below substitutes
  // the physical coordinate system for these axes to get the right
  // modified coordinate system.
  publicAPI.setDeviceAngles = (alpha, beta, gamma, screen) => {
    const physVRight = [3];
    vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["cross"](model.physicalViewNorth, model.physicalViewUp, physVRight);

    const rotmat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create(); // phone to physical coordinates
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotate(
      rotmat,
      rotmat,
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["radiansFromDegrees"](alpha),
      model.physicalViewUp
    );
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotate(rotmat, rotmat, vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["radiansFromDegrees"](beta), physVRight);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotate(
      rotmat,
      rotmat,
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["radiansFromDegrees"](gamma),
      model.physicalViewNorth
    );

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotate(
      rotmat,
      rotmat,
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["radiansFromDegrees"](-screen),
      model.physicalViewUp
    );

    const dop = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(
      -model.physicalViewUp[0],
      -model.physicalViewUp[1],
      -model.physicalViewUp[2]
    );
    const vup = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(
      model.physicalViewNorth[0],
      model.physicalViewNorth[1],
      model.physicalViewNorth[2]
    );
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(dop, dop, rotmat);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(vup, vup, rotmat);

    publicAPI.setDirectionOfProjection(dop[0], dop[1], dop[2]);
    publicAPI.setViewUp(vup[0], vup[1], vup[2]);
    publicAPI.modified();
  };

  publicAPI.setOrientationWXYZ = (degrees, x, y, z) => {
    const quatMat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();

    if (degrees !== 0.0 && (x !== 0.0 || y !== 0.0 || z !== 0.0)) {
      // convert to radians
      const angle = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["radiansFromDegrees"](degrees);
      const q = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].create();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].setAxisAngle(q, [x, y, z], angle);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].fromQuat(quatMat, q);
    }

    const dop = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(0.0, 0.0, -1.0);
    const newdop = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(newdop, dop, quatMat);

    const vup = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(0.0, 1.0, 0.0);
    const newvup = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(newvup, vup, quatMat);

    publicAPI.setDirectionOfProjection(...newdop);
    publicAPI.setViewUp(...newvup);
    publicAPI.modified();
  };

  publicAPI.computeClippingRange = (bounds) => {
    let vn = null;
    let position = null;

    vn = model.viewPlaneNormal;
    position = model.position;

    const a = -vn[0];
    const b = -vn[1];
    const c = -vn[2];
    const d = -(a * position[0] + b * position[1] + c * position[2]);

    // Set the max near clipping plane and the min far clipping plane
    const range = [a * bounds[0] + b * bounds[2] + c * bounds[4] + d, 1e-18];

    // Find the closest / farthest bounding box vertex
    for (let k = 0; k < 2; k++) {
      for (let j = 0; j < 2; j++) {
        for (let i = 0; i < 2; i++) {
          const dist =
            a * bounds[i] + b * bounds[2 + j] + c * bounds[4 + k] + d;
          range[0] = dist < range[0] ? dist : range[0];
          range[1] = dist > range[1] ? dist : range[1];
        }
      }
    }

    return range;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  viewUp: [0, 1, 0],
  directionOfProjection: [0, 0, -1],
  parallelProjection: false,
  useHorizontalViewAngle: false,
  viewAngle: 30,
  parallelScale: 1,
  clippingRange: [0.01, 1000.01],
  windowCenter: [0, 0],
  viewPlaneNormal: [0, 0, 1],
  useOffAxisProjection: false,
  screenBottomLeft: [-0.5, -0.5, -0.5],
  screenBottomRight: [0.5, -0.5, -0.5],
  screenTopRight: [0.5, 0.5, -0.5],
  freezeFocalPoint: false,
  projectionMatrix: null,
  viewMatrix: null,

  // used for world to physical transformations
  physicalTranslation: [0, 0, 0],
  physicalScale: 1.0,
  physicalViewUp: [0, 1, 0],
  physicalViewNorth: [0, 0, -1],
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(publicAPI, model);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].get(publicAPI, model, ['distance']);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGet(publicAPI, model, [
    'parallelProjection',
    'useHorizontalViewAngle',
    'viewAngle',
    'parallelScale',
    'useOffAxisProjection',
    'freezeFocalPoint',
    'physicalScale',
  ]);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].getArray(publicAPI, model, [
    'directionOfProjection',
    'viewPlaneNormal',
    'position',
    'focalPoint',
  ]);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGetArray(publicAPI, model, ['clippingRange', 'windowCenter'], 2);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGetArray(
    publicAPI,
    model,
    [
      'viewUp',
      'screenBottomLeft',
      'screenBottomRight',
      'screenTopRight',
      'physicalTranslation',
      'physicalViewUp',
      'physicalViewNorth',
    ],
    3
  );

  // Object methods
  vtkCamera(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend, 'vtkCamera');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/ImageMapper/Constants.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/ImageMapper/Constants.js ***!
  \*****************************************************************************/
/*! exports provided: SlicingMode, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SlicingMode", function() { return SlicingMode; });
const SlicingMode = {
  NONE: -1,
  I: 0,
  J: 1,
  K: 2,
  X: 3,
  Y: 4,
  Z: 5,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  SlicingMode,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/ImageProperty/Constants.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/ImageProperty/Constants.js ***!
  \*******************************************************************************/
/*! exports provided: InterpolationType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolationType", function() { return InterpolationType; });
const InterpolationType = {
  NEAREST: 0,
  LINEAR: 1,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  InterpolationType,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/InteractorObserver/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/InteractorObserver/index.js ***!
  \********************************************************************************/
/*! exports provided: STATIC, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATIC", function() { return STATIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_RenderWindowInteractor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/RenderWindowInteractor */ "./node_modules/vtk.js/Sources/Rendering/Core/RenderWindowInteractor/index.js");



const { vtkErrorMacro, VOID } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Description:
// Transform from world to display coordinates.
function computeWorldToDisplay(renderer, x, y, z) {
  const view = renderer.getRenderWindow().getViews()[0];
  return view.worldToDisplay(x, y, z, renderer);
}

//----------------------------------------------------------------------------
// Description:
// Transform from display to world coordinates.
function computeDisplayToWorld(renderer, x, y, z) {
  const view = renderer.getRenderWindow().getViews()[0];
  return view.displayToWorld(x, y, z, renderer);
}

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------
const STATIC = {
  computeWorldToDisplay,
  computeDisplayToWorld,
};

// ----------------------------------------------------------------------------
// vtkInteractorObserver methods
// ----------------------------------------------------------------------------

function vtkInteractorObserver(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkInteractorObserver');

  const superClass = { ...publicAPI };

  //----------------------------------------------------------------------------
  function unsubscribeFromEvents() {
    while (model.subscribedEvents.length) {
      model.subscribedEvents.pop().unsubscribe();
    }
  }

  //----------------------------------------------------------------------------
  // Check what events we can handle and register callbacks
  function subscribeToEvents() {
    vtk_js_Sources_Rendering_Core_RenderWindowInteractor__WEBPACK_IMPORTED_MODULE_1__["default"].handledEvents.forEach((eventName) => {
      if (publicAPI[`handle${eventName}`]) {
        model.subscribedEvents.push(
          model.interactor[`on${eventName}`]((callData) => {
            if (model.processEvents) {
              return publicAPI[`handle${eventName}`](callData);
            }
            return VOID;
          }, model.priority)
        );
      }
    });
  }

  //----------------------------------------------------------------------------
  // Public API methods
  //----------------------------------------------------------------------------
  publicAPI.setInteractor = (i) => {
    if (i === model.interactor) {
      return;
    }

    unsubscribeFromEvents();

    model.interactor = i;

    if (i && model.enabled) {
      subscribeToEvents();
    }

    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  publicAPI.setEnabled = (enable) => {
    if (enable === model.enabled) {
      return;
    }

    unsubscribeFromEvents();

    if (enable) {
      if (model.interactor) {
        subscribeToEvents();
      } else {
        vtkErrorMacro(`
          The interactor must be set before subscribing to events
        `);
      }
    }

    model.enabled = enable;
    publicAPI.modified();
  };

  //----------------------------------------------------------------------------
  // Description:
  // Transform from display to world coordinates.
  publicAPI.computeDisplayToWorld = (renderer, x, y, z) => {
    if (!renderer) {
      return null;
    }

    return model.interactor.getView().displayToWorld(x, y, z, renderer);
  };

  //----------------------------------------------------------------------------
  // Description:
  // Transform from world to display coordinates.
  publicAPI.computeWorldToDisplay = (renderer, x, y, z) => {
    if (!renderer) {
      return null;
    }

    return model.interactor.getView().worldToDisplay(x, y, z, renderer);
  };

  //----------------------------------------------------------------------------

  publicAPI.setPriority = (priority) => {
    const modified = superClass.setPriority(priority);

    if (modified && model.interactor) {
      unsubscribeFromEvents();
      subscribeToEvents();
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  enabled: true,
  interactor: null,
  priority: 0.0,
  processEvents: true,
  subscribedEvents: [],
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].event(publicAPI, model, 'InteractionEvent');
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].event(publicAPI, model, 'StartInteractionEvent');
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].event(publicAPI, model, 'EndInteractionEvent');

  // Create get-only macros
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['interactor', 'enabled']);

  // Create get-set macros
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, ['priority', 'processEvents']);

  // For more macro methods, see "Sources/macro.js"

  // Object specific methods
  vtkInteractorObserver(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkInteractorObserver');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...STATIC });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/InteractorStyle/Constants.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/InteractorStyle/Constants.js ***!
  \*********************************************************************************/
/*! exports provided: States, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "States", function() { return States; });
const States = {
  IS_START: 0,
  IS_NONE: 0,

  IS_ROTATE: 1,
  IS_PAN: 2,
  IS_SPIN: 3,
  IS_DOLLY: 4,

  IS_CAMERA_POSE: 11,

  IS_WINDOW_LEVEL: 1024,
  IS_SLICE: 1025,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  States,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/InteractorStyle/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/InteractorStyle/index.js ***!
  \*****************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_InteractorObserver__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/InteractorObserver */ "./node_modules/vtk.js/Sources/Rendering/Core/InteractorObserver/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_InteractorStyle_Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/InteractorStyle/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/InteractorStyle/Constants.js");




const { States } = vtk_js_Sources_Rendering_Core_InteractorStyle_Constants__WEBPACK_IMPORTED_MODULE_2__["default"];

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// Add module-level functions or api that you want to expose statically via
// the next section...

const stateNames = {
  Rotate: States.IS_ROTATE,
  Pan: States.IS_PAN,
  Spin: States.IS_SPIN,
  Dolly: States.IS_DOLLY,
  CameraPose: States.IS_CAMERA_POSE,
  WindowLevel: States.IS_WINDOW_LEVEL,
  Slice: States.IS_SLICE,
};

// ----------------------------------------------------------------------------
// vtkInteractorStyle methods
// ----------------------------------------------------------------------------

function vtkInteractorStyle(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkInteractorStyle');

  // Public API methods
  // create bunch of Start/EndState methods
  Object.keys(stateNames).forEach((key) => {
    vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].event(publicAPI, model, `Start${key}Event`);
    publicAPI[`start${key}`] = () => {
      if (model.state !== States.IS_NONE) {
        return;
      }
      model.state = stateNames[key];
      model.interactor.requestAnimation(publicAPI);
      publicAPI.invokeStartInteractionEvent({ type: 'StartInteractionEvent' });
      publicAPI[`invokeStart${key}Event`]({ type: `Start${key}Event` });
    };
    vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].event(publicAPI, model, `End${key}Event`);
    publicAPI[`end${key}`] = () => {
      if (model.state !== stateNames[key]) {
        return;
      }
      model.state = States.IS_NONE;
      model.interactor.cancelAnimation(publicAPI);
      publicAPI.invokeEndInteractionEvent({ type: 'EndInteractionEvent' });
      publicAPI[`invokeEnd${key}Event`]({ type: `End${key}Event` });
      model.interactor.render();
    };
  });

  //----------------------------------------------------------------------------
  publicAPI.handleKeyPress = (callData) => {
    const rwi = model.interactor;
    let ac = null;
    switch (callData.key) {
      case 'r':
      case 'R':
        callData.pokedRenderer.resetCamera();
        rwi.render();
        break;

      case 'w':
      case 'W':
        ac = callData.pokedRenderer.getActors();
        ac.forEach((anActor) => {
          const prop = anActor.getProperty();
          if (prop.setRepresentationToWireframe) {
            prop.setRepresentationToWireframe();
          }
        });
        rwi.render();
        break;

      case 's':
      case 'S':
        ac = callData.pokedRenderer.getActors();
        ac.forEach((anActor) => {
          const prop = anActor.getProperty();
          if (prop.setRepresentationToSurface) {
            prop.setRepresentationToSurface();
          }
        });
        rwi.render();
        break;

      case 'v':
      case 'V':
        ac = callData.pokedRenderer.getActors();
        ac.forEach((anActor) => {
          const prop = anActor.getProperty();
          if (prop.setRepresentationToPoints) {
            prop.setRepresentationToPoints();
          }
        });
        rwi.render();
        break;

      default:
        break;
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  state: States.IS_NONE,
  handleObservers: 1,
  autoAdjustCameraClippingRange: 1,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_Core_InteractorObserver__WEBPACK_IMPORTED_MODULE_1__["default"].extend(publicAPI, model, initialValues);

  // Object specific methods
  vtkInteractorStyle(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkInteractorStyle');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...vtk_js_Sources_Rendering_Core_InteractorStyle_Constants__WEBPACK_IMPORTED_MODULE_2__["default"] });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/Light/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/Light/index.js ***!
  \*******************************************************************/
/*! exports provided: LIGHT_TYPES, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LIGHT_TYPES", function() { return LIGHT_TYPES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");



// ----------------------------------------------------------------------------

const LIGHT_TYPES = ['HeadLight', 'CameraLight', 'SceneLight'];

// ----------------------------------------------------------------------------
// vtkLight methods
// ----------------------------------------------------------------------------

function vtkLight(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkLight');

  publicAPI.getTransformedPosition = () => {
    if (model.transformMatrix) {
      return []; // FIXME !!!!
    }
    return [].concat(model.position);
  };

  publicAPI.getTransformedFocalPoint = () => {
    if (model.transformMatrix) {
      return []; // FIXME !!!!
    }
    return [].concat(model.focalPoint);
  };

  publicAPI.getDirection = () => {
    if (model.directionMTime < model.mtime) {
      model.direction[0] = model.focalPoint[0] - model.position[0];
      model.direction[1] = model.focalPoint[1] - model.position[1];
      model.direction[2] = model.focalPoint[2] - model.position[2];
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["normalize"](model.direction);
      model.directionMTime = model.mtime;
    }
    return model.direction;
  };

  publicAPI.setDirectionAngle = (elevation, azimuth) => {
    const elevationRadians = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["radiansFromDegrees"](elevation);
    const azimuthRadians = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["radiansFromDegrees"](azimuth);

    publicAPI.setPosition(
      Math.cos(elevationRadians) * Math.sin(azimuthRadians),
      Math.sin(elevationRadians),
      Math.cos(elevationRadians) * Math.cos(azimuthRadians)
    );

    publicAPI.setFocalPoint(0, 0, 0);
    publicAPI.setPositional(0);
  };

  publicAPI.setLightTypeToHeadLight = () => {
    publicAPI.setLightType('HeadLight');
  };

  publicAPI.setLightTypeToCameraLight = () => {
    publicAPI.setLightType('CameraLight');
  };

  publicAPI.setLightTypeToSceneLight = () => {
    publicAPI.setTransformMatrix(null);
    publicAPI.setLightType('SceneLight');
  };

  publicAPI.lightTypeIsHeadLight = () => model.lightType === 'HeadLight';

  publicAPI.lightTypeIsSceneLight = () => model.lightType === 'SceneLight';

  publicAPI.lightTypeIsCameraLight = () => model.lightType === 'CameraLight';
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  switch: true,
  intensity: 1,
  color: [1, 1, 1],
  position: [0, 0, 1],
  focalPoint: [0, 0, 0],
  positional: false,
  exponent: 1,
  coneAngle: 30,
  attenuationValues: [1, 0, 0],
  transformMatrix: null,
  lightType: 'SceneLight',
  shadowAttenuation: 1,
  direction: [0, 0, 0],
  directionMTime: 0,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'intensity',
    'switch',
    'positional',
    'exponent',
    'coneAngle',
    'transformMatrix',
    'lightType',
    'shadowAttenuation',
  ]);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGetArray(
    publicAPI,
    model,
    ['color', 'position', 'focalPoint', 'attenuationValues'],
    3
  );

  // Object methods
  vtkLight(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkLight');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, LIGHT_TYPES });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/Mapper/CoincidentTopologyHelper.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/Mapper/CoincidentTopologyHelper.js ***!
  \***************************************************************************************/
/*! exports provided: CATEGORIES, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CATEGORIES", function() { return CATEGORIES; });
/* harmony import */ var vtk_js_Sources_Rendering_Core_Mapper_Static__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Mapper/Static */ "./node_modules/vtk.js/Sources/Rendering/Core/Mapper/Static.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* eslint-disable arrow-body-style */



function addCoincidentTopologyMethods(publicAPI, model, nameList) {
  nameList.forEach((item) => {
    publicAPI[`get${item.method}`] = () => model[item.key];
    publicAPI[`set${item.method}`] = (factor, offset) => {
      model[item.key] = { factor, offset };
    };
  });
}

const CATEGORIES = ['Polygon', 'Line', 'Point'];

// CoincidentTopology static methods ------------------------------------------

const staticOffsetModel = {
  Polygon: { factor: 2, offset: 0 },
  Line: { factor: 1, offset: -1 },
  Point: { factor: 0, offset: -2 },
};
const staticOffsetAPI = {};

addCoincidentTopologyMethods(
  staticOffsetAPI,
  staticOffsetModel,
  CATEGORIES.map((key) => ({
    key,
    method: `ResolveCoincidentTopology${key}OffsetParameters`,
  }))
);

function implementCoincidentTopologyMethods(publicAPI, model) {
  if (model.resolveCoincidentTopology === undefined) {
    model.resolveCoincidentTopology = false;
  }

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGet(publicAPI, model, ['resolveCoincidentTopology']);

  // Relative methods
  model.topologyOffset = {
    Polygon: { factor: 0, offset: 0 },
    Line: { factor: 0, offset: 0 },
    Point: { factor: 0, offset: 0 },
  };

  // Add Static methods to our instance
  Object.keys(vtk_js_Sources_Rendering_Core_Mapper_Static__WEBPACK_IMPORTED_MODULE_0__["default"]).forEach((methodName) => {
    publicAPI[methodName] = vtk_js_Sources_Rendering_Core_Mapper_Static__WEBPACK_IMPORTED_MODULE_0__["default"][methodName];
  });
  Object.keys(staticOffsetAPI).forEach((methodName) => {
    publicAPI[methodName] = staticOffsetAPI[methodName];
  });

  addCoincidentTopologyMethods(
    publicAPI,
    model.topologyOffset,
    CATEGORIES.map((key) => ({
      key,
      method: `RelativeCoincidentTopology${key}OffsetParameters`,
    }))
  );

  publicAPI.getCoincidentTopologyPolygonOffsetParameters = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPolygonOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyPolygonOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset,
    };
  };

  publicAPI.getCoincidentTopologyLineOffsetParameters = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyLineOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyLineOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset,
    };
  };

  publicAPI.getCoincidentTopologyPointOffsetParameter = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPointOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyPointOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset,
    };
  };
}

/* harmony default export */ __webpack_exports__["default"] = ({
  implementCoincidentTopologyMethods,
  staticOffsetAPI,
  otherStaticMethods: vtk_js_Sources_Rendering_Core_Mapper_Static__WEBPACK_IMPORTED_MODULE_0__["default"],
  CATEGORIES,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/Mapper/Constants.js":
/*!************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/Mapper/Constants.js ***!
  \************************************************************************/
/*! exports provided: ColorMode, ScalarMode, GetArray, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorMode", function() { return ColorMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ScalarMode", function() { return ScalarMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GetArray", function() { return GetArray; });
const ColorMode = {
  DEFAULT: 0,
  MAP_SCALARS: 1,
  DIRECT_SCALARS: 2,
};

const ScalarMode = {
  DEFAULT: 0,
  USE_POINT_DATA: 1,
  USE_CELL_DATA: 2,
  USE_POINT_FIELD_DATA: 3,
  USE_CELL_FIELD_DATA: 4,
  USE_FIELD_DATA: 5,
};

const GetArray = {
  BY_ID: 0,
  BY_NAME: 1,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  ColorMode,
  GetArray,
  ScalarMode,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/Mapper/Static.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/Mapper/Static.js ***!
  \*********************************************************************/
/*! exports provided: RESOLVE_COINCIDENT_TOPOLOGY_MODE, getResolveCoincidentTopologyPolygonOffsetFaces, setResolveCoincidentTopologyPolygonOffsetFaces, getResolveCoincidentTopology, setResolveCoincidentTopology, setResolveCoincidentTopologyToDefault, setResolveCoincidentTopologyToOff, setResolveCoincidentTopologyToPolygonOffset, getResolveCoincidentTopologyAsString, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RESOLVE_COINCIDENT_TOPOLOGY_MODE", function() { return RESOLVE_COINCIDENT_TOPOLOGY_MODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getResolveCoincidentTopologyPolygonOffsetFaces", function() { return getResolveCoincidentTopologyPolygonOffsetFaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setResolveCoincidentTopologyPolygonOffsetFaces", function() { return setResolveCoincidentTopologyPolygonOffsetFaces; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getResolveCoincidentTopology", function() { return getResolveCoincidentTopology; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setResolveCoincidentTopology", function() { return setResolveCoincidentTopology; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setResolveCoincidentTopologyToDefault", function() { return setResolveCoincidentTopologyToDefault; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setResolveCoincidentTopologyToOff", function() { return setResolveCoincidentTopologyToOff; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setResolveCoincidentTopologyToPolygonOffset", function() { return setResolveCoincidentTopologyToPolygonOffset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getResolveCoincidentTopologyAsString", function() { return getResolveCoincidentTopologyAsString; });
let resolveCoincidentTopologyPolygonOffsetFaces = 1;
let resolveCoincidentTopology = 0;

const RESOLVE_COINCIDENT_TOPOLOGY_MODE = [
  'VTK_RESOLVE_OFF',
  'VTK_RESOLVE_POLYGON_OFFSET',
];

function getResolveCoincidentTopologyPolygonOffsetFaces() {
  return resolveCoincidentTopologyPolygonOffsetFaces;
}

function setResolveCoincidentTopologyPolygonOffsetFaces(value) {
  resolveCoincidentTopologyPolygonOffsetFaces = value;
}

function getResolveCoincidentTopology() {
  return resolveCoincidentTopology;
}

function setResolveCoincidentTopology(mode = 0) {
  resolveCoincidentTopology = mode;
}

function setResolveCoincidentTopologyToDefault() {
  setResolveCoincidentTopology(0); // VTK_RESOLVE_OFF
}

function setResolveCoincidentTopologyToOff() {
  setResolveCoincidentTopology(0); // VTK_RESOLVE_OFF
}

function setResolveCoincidentTopologyToPolygonOffset() {
  setResolveCoincidentTopology(1); // VTK_RESOLVE_POLYGON_OFFSET
}

function getResolveCoincidentTopologyAsString() {
  return RESOLVE_COINCIDENT_TOPOLOGY_MODE[resolveCoincidentTopology];
}

/* harmony default export */ __webpack_exports__["default"] = ({
  getResolveCoincidentTopologyAsString,
  getResolveCoincidentTopologyPolygonOffsetFaces,
  getResolveCoincidentTopology,
  setResolveCoincidentTopology,
  setResolveCoincidentTopologyPolygonOffsetFaces,
  setResolveCoincidentTopologyToDefault,
  setResolveCoincidentTopologyToOff,
  setResolveCoincidentTopologyToPolygonOffset,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/Mapper/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/Mapper/index.js ***!
  \********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_AbstractMapper3D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/AbstractMapper3D */ "./node_modules/vtk.js/Sources/Rendering/Core/AbstractMapper3D/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_ImageData__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/ImageData */ "./node_modules/vtk.js/Sources/Common/DataModel/ImageData/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_LookupTable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/LookupTable */ "./node_modules/vtk.js/Sources/Common/Core/LookupTable/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_ScalarsToColors_Constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/ScalarsToColors/Constants */ "./node_modules/vtk.js/Sources/Common/Core/ScalarsToColors/Constants.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Mapper_CoincidentTopologyHelper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Mapper/CoincidentTopologyHelper */ "./node_modules/vtk.js/Sources/Rendering/Core/Mapper/CoincidentTopologyHelper.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Mapper_Constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Mapper/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/Mapper/Constants.js");






 // Need to go inside Constants otherwise dependency loop




const { staticOffsetAPI, otherStaticMethods } = vtk_js_Sources_Rendering_Core_Mapper_CoincidentTopologyHelper__WEBPACK_IMPORTED_MODULE_7__["default"];

const { ColorMode, ScalarMode, GetArray } = vtk_js_Sources_Rendering_Core_Mapper_Constants__WEBPACK_IMPORTED_MODULE_8__["default"];
const { VectorMode } = vtk_js_Sources_Common_Core_ScalarsToColors_Constants__WEBPACK_IMPORTED_MODULE_6__["default"];
const { VtkDataTypes } = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__["default"];

// ----------------------------------------------------------------------------

function notImplemented(method) {
  return () => vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);
}

// ----------------------------------------------------------------------------
// vtkMapper methods
// ----------------------------------------------------------------------------

function vtkMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkMapper');

  publicAPI.getBounds = () => {
    const input = publicAPI.getInputData();
    if (!input) {
      model.bounds = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_5__["createUninitializedBounds"]();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };

  publicAPI.setForceCompileOnly = (v) => {
    model.forceCompileOnly = v;
    // make sure we do NOT call modified()
  };

  publicAPI.createDefaultLookupTable = () => {
    model.lookupTable = vtk_js_Sources_Common_Core_LookupTable__WEBPACK_IMPORTED_MODULE_4__["default"].newInstance();
  };

  publicAPI.getColorModeAsString = () =>
    vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].enumToString(ColorMode, model.colorMode);

  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);
  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);
  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);

  publicAPI.getScalarModeAsString = () =>
    vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].enumToString(ScalarMode, model.scalarMode);

  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);
  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);
  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);
  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);
  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);
  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);

  publicAPI.getAbstractScalars = (
    input,
    scalarMode,
    arrayAccessMode,
    arrayId,
    arrayName
  ) => {
    // make sure we have an input
    if (!input || !model.scalarVisibility) {
      return { scalars: null, cellFLag: false };
    }

    let scalars = null;
    let cellFlag = false;

    // get and scalar data according to scalar mode
    if (scalarMode === ScalarMode.DEFAULT) {
      scalars = input.getPointData().getScalars();
      if (!scalars) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      }
    } else if (scalarMode === ScalarMode.USE_POINT_DATA) {
      scalars = input.getPointData().getScalars();
    } else if (scalarMode === ScalarMode.USE_CELL_DATA) {
      scalars = input.getCellData().getScalars();
      cellFlag = true;
    } else if (scalarMode === ScalarMode.USE_POINT_FIELD_DATA) {
      const pd = input.getPointData();
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = pd.getArrayByIndex(arrayId);
      } else {
        scalars = pd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode.USE_CELL_FIELD_DATA) {
      const cd = input.getCellData();
      cellFlag = true;
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = cd.getArrayByIndex(arrayId);
      } else {
        scalars = cd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode.USE_FIELD_DATA) {
      const fd = input.getFieldData();
      if (arrayAccessMode === GetArray.BY_ID) {
        scalars = fd.getArrayByIndex(arrayId);
      } else {
        scalars = fd.getArrayByName(arrayName);
      }
    }

    return { scalars, cellFlag };
  };

  publicAPI.mapScalars = (input, alpha) => {
    const scalars = publicAPI.getAbstractScalars(
      input,
      model.scalarMode,
      model.arrayAccessMode,
      model.arrayId,
      model.colorByArrayName
    ).scalars;

    if (!scalars) {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      model.colorMapColors = null;
      return;
    }

    if (!model.useLookupTableScalarRange) {
      publicAPI
        .getLookupTable()
        .setRange(model.scalarRange[0], model.scalarRange[1]);
    }

    // Decide between texture color or vertex color.
    // Cell data always uses vertex color.
    // Only point data can use both texture and vertex coloring.
    if (publicAPI.canUseTextureMapForColoring(input)) {
      publicAPI.mapScalarsToTexture(scalars, alpha);
      return;
    }

    model.colorCoordinates = null;
    model.colorTextureMap = null;

    const lut = publicAPI.getLookupTable();
    if (lut) {
      // Ensure that the lookup table is built
      lut.build();
      model.colorMapColors = lut.mapScalars(scalars, model.colorMode, -1);
    }
  };

  //-----------------------------------------------------------------------------
  publicAPI.scalarToTextureCoordinate = (
    scalarValue, // Input scalar
    rangeMin, // range[0]
    invRangeWidth
  ) => {
    // 1/(range[1]-range[0])
    let texCoordS = 0.5; // Scalar value is arbitrary when NaN
    let texCoordT = 1.0; // 1.0 in t coordinate means NaN
    if (!vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_5__["isNan"](scalarValue)) {
      // 0.0 in t coordinate means not NaN.  So why am I setting it to 0.49?
      // Because when you are mapping scalars and you have a NaN adjacent to
      // anything else, the interpolation everywhere should be NaN.  Thus, I
      // want the NaN color everywhere except right on the non-NaN neighbors.
      // To simulate this, I set the t coord for the real numbers close to
      // the threshold so that the interpolation almost immediately looks up
      // the NaN value.
      texCoordT = 0.49;

      texCoordS = (scalarValue - rangeMin) * invRangeWidth;

      // Some implementations apparently don't handle relatively large
      // numbers (compared to the range [0.0, 1.0]) very well. In fact,
      // values above 1122.0f appear to cause texture wrap-around on
      // some systems even when edge clamping is enabled. Why 1122.0f? I
      // don't know. For safety, we'll clamp at +/- 1000. This will
      // result in incorrect images when the texture value should be
      // above or below 1000, but I don't have a better solution.
      if (texCoordS > 1000.0) {
        texCoordS = 1000.0;
      } else if (texCoordS < -1000.0) {
        texCoordS = -1000.0;
      }
    }
    return { texCoordS, texCoordT };
  };

  //-----------------------------------------------------------------------------
  publicAPI.createColorTextureCoordinates = (
    input,
    output,
    numScalars,
    numComps,
    component,
    range,
    tableRange,
    tableNumberOfColors,
    useLogScale
  ) => {
    // We have to change the range used for computing texture
    // coordinates slightly to accommodate the special above- and
    // below-range colors that are the first and last texels,
    // respectively.
    const scalarTexelWidth = (range[1] - range[0]) / tableNumberOfColors;

    const paddedRange = [];
    paddedRange[0] = range[0] - scalarTexelWidth;
    paddedRange[1] = range[1] + scalarTexelWidth;
    const invRangeWidth = 1.0 / (paddedRange[1] - paddedRange[0]);

    const outputV = output.getData();
    const inputV = input.getData();

    let count = 0;
    let outputCount = 0;
    if (component < 0 || component >= numComps) {
      for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {
        let sum = 0;
        for (let compIdx = 0; compIdx < numComps; ++compIdx) {
          sum += inputV[count] * inputV[count];
          count++;
        }
        let magnitude = Math.sqrt(sum);
        if (useLogScale) {
          magnitude = vtk_js_Sources_Common_Core_LookupTable__WEBPACK_IMPORTED_MODULE_4__["default"].applyLogScale(
            magnitude,
            tableRange,
            range
          );
        }
        const outputs = publicAPI.scalarToTextureCoordinate(
          magnitude,
          paddedRange[0],
          invRangeWidth
        );
        outputV[outputCount] = outputs.texCoordS;
        outputV[outputCount + 1] = outputs.texCoordT;
        outputCount += 2;
      }
    } else {
      count += component;
      for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {
        let inputValue = inputV[count];
        if (useLogScale) {
          inputValue = vtk_js_Sources_Common_Core_LookupTable__WEBPACK_IMPORTED_MODULE_4__["default"].applyLogScale(
            inputValue,
            tableRange,
            range
          );
        }
        const outputs = publicAPI.scalarToTextureCoordinate(
          inputValue,
          paddedRange[0],
          invRangeWidth
        );
        outputV[outputCount] = outputs.texCoordS;
        outputV[outputCount + 1] = outputs.texCoordT;
        outputCount += 2;
        count += numComps;
      }
    }
  };

  publicAPI.mapScalarsToTexture = (scalars, alpha) => {
    const range = model.lookupTable.getRange();
    const useLogScale = model.lookupTable.usingLogScale();
    if (useLogScale) {
      // convert range to log.
      vtk_js_Sources_Common_Core_LookupTable__WEBPACK_IMPORTED_MODULE_4__["default"].getLogRange(range, range);
    }

    const origAlpha = model.lookupTable.getAlpha();

    // Get rid of vertex color array.  Only texture or vertex coloring
    // can be active at one time.  The existence of the array is the
    // signal to use that technique.
    model.colorMapColors = null;

    // If the lookup table has changed, then recreate the color texture map.
    // Set a new lookup table changes this->MTime.
    if (
      model.colorTextureMap == null ||
      publicAPI.getMTime() > model.colorTextureMap.getMTime() ||
      model.lookupTable.getMTime() > model.colorTextureMap.getMTime() ||
      model.lookupTable.getAlpha() !== alpha
    ) {
      model.lookupTable.setAlpha(alpha);
      model.colorTextureMap = null;

      // Get the texture map from the lookup table.
      // Create a dummy ramp of scalars.
      // In the future, we could extend vtkScalarsToColors.
      model.lookupTable.build();
      let numberOfColors = model.lookupTable.getNumberOfAvailableColors();
      if (numberOfColors > 4094) {
        numberOfColors = 4094;
      }
      numberOfColors += 2;
      const k = (range[1] - range[0]) / (numberOfColors - 1 - 2);

      const newArray = new Float64Array(numberOfColors * 2);

      for (let i = 0; i < numberOfColors; ++i) {
        newArray[i] = range[0] + i * k - k; // minus k to start at below range color
        if (useLogScale) {
          newArray[i] = 10.0 ** newArray[i];
        }
      }
      // Dimension on NaN.
      for (let i = 0; i < numberOfColors; ++i) {
        newArray[i + numberOfColors] = NaN;
      }

      model.colorTextureMap = vtk_js_Sources_Common_DataModel_ImageData__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
      model.colorTextureMap.setExtent(0, numberOfColors - 1, 0, 1, 0, 0);

      const tmp = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance({
        numberOfComponents: 1,
        values: newArray,
      });

      model.colorTextureMap
        .getPointData()
        .setScalars(model.lookupTable.mapScalars(tmp, model.colorMode, 0));
      model.lookupTable.setAlpha(origAlpha);
    }

    // Create new coordinates if necessary.
    // Need to compare lookup table in case the range has changed.
    if (
      !model.colorCoordinates ||
      publicAPI.getMTime() > model.colorCoordinates.getMTime() ||
      publicAPI.getInputData(0).getMTime() >
        model.colorCoordinates.getMTime() ||
      model.lookupTable.getMTime() > model.colorCoordinates.getMTime()
    ) {
      // Get rid of old colors
      model.colorCoordinates = null;

      // Now create the color texture coordinates.
      const numComps = scalars.getNumberOfComponents();
      const num = scalars.getNumberOfTuples();

      // const fArray = new FloatArray(num * 2);
      model.colorCoordinates = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance({
        numberOfComponents: 2,
        values: new Float32Array(num * 2),
      });

      let scalarComponent = model.lookupTable.getVectorComponent();
      // Although I like the feature of applying magnitude to single component
      // scalars, it is not how the old MapScalars for vertex coloring works.
      if (
        model.lookupTable.getVectorMode() === VectorMode.MAGNITUDE &&
        scalars.getNumberOfComponents() > 1
      ) {
        scalarComponent = -1;
      }

      publicAPI.createColorTextureCoordinates(
        scalars,
        model.colorCoordinates,
        num,
        numComps,
        scalarComponent,
        range,
        model.lookupTable.getRange(),
        model.colorTextureMap.getPointData().getScalars().getNumberOfTuples() /
          2 -
          2,
        useLogScale
      );
    }
  };

  publicAPI.getIsOpaque = () => {
    const lut = publicAPI.getLookupTable();
    if (lut) {
      // Ensure that the lookup table is built
      lut.build();
      return lut.isOpaque();
    }
    return true;
  };

  publicAPI.canUseTextureMapForColoring = (input) => {
    if (!model.interpolateScalarsBeforeMapping) {
      return false; // user doesn't want us to use texture maps at all.
    }

    // index color does not use textures
    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {
      return false;
    }

    const gasResult = publicAPI.getAbstractScalars(
      input,
      model.scalarMode,
      model.arrayAccessMode,
      model.arrayId,
      model.colorByArrayName
    );
    const scalars = gasResult.scalars;

    if (!scalars) {
      // no scalars on this dataset, we don't care if texture is used at all.
      return false;
    }

    if (gasResult.cellFlag) {
      return false; // cell data colors, don't use textures.
    }

    if (
      (model.colorMode === ColorMode.DEFAULT &&
        scalars.getDataType() === VtkDataTypes.UNSIGNED_CHAR) ||
      model.colorMode === ColorMode.DIRECT_SCALARS
    ) {
      // Don't use texture is direct coloring using RGB unsigned chars is
      // requested.
      return false;
    }

    return true;
  };

  publicAPI.clearColorArrays = () => {
    model.colorMapColors = null;
    model.colorCoordinates = null;
    model.colorTextureMap = null;
  };

  publicAPI.getLookupTable = () => {
    if (!model.lookupTable) {
      publicAPI.createDefaultLookupTable();
    }
    return model.lookupTable;
  };

  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.lookupTable !== null) {
      const time = model.lookupTable.getMTime();
      mt = time > mt ? time : mt;
    }
    return mt;
  };

  publicAPI.getPrimitiveCount = () => {
    const input = publicAPI.getInputData();
    const pcount = {
      points: input.getPoints().getNumberOfValues() / 3,
      verts:
        input.getVerts().getNumberOfValues() -
        input.getVerts().getNumberOfCells(),
      lines:
        input.getLines().getNumberOfValues() -
        2 * input.getLines().getNumberOfCells(),
      triangles:
        input.getPolys().getNumberOfValues() -
        3 * input.getLines().getNumberOfCells(),
    };
    return pcount;
  };

  publicAPI.acquireInvertibleLookupTable = notImplemented(
    'AcquireInvertibleLookupTable'
  );
  publicAPI.valueToColor = notImplemented('ValueToColor');
  publicAPI.colorToValue = notImplemented('ColorToValue');
  publicAPI.useInvertibleColorFor = notImplemented('UseInvertibleColorFor');
  publicAPI.clearInvertibleColor = notImplemented('ClearInvertibleColor');
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  colorMapColors: null, // Same as this->Colors

  static: false,
  lookupTable: null,

  scalarVisibility: true,
  scalarRange: [0, 1],
  useLookupTableScalarRange: false,

  colorMode: 0,
  scalarMode: 0,
  arrayAccessMode: 1, // By_NAME

  renderTime: 0,

  colorByArrayName: null,

  fieldDataTupleId: -1,

  interpolateScalarsBeforeMapping: false,
  colorCoordinates: null,
  colorTextureMap: null,

  forceCompileOnly: 0,

  useInvertibleColors: false,
  invertibleScalars: null,

  viewSpecificProperties: null,

  customShaderAttributes: [],
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_Core_AbstractMapper3D__WEBPACK_IMPORTED_MODULE_1__["default"].extend(publicAPI, model, initialValues);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, [
    'colorCoordinates',
    'colorMapColors',
    'colorTextureMap',
  ]);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'colorByArrayName',
    'arrayAccessMode',
    'colorMode',
    'fieldDataTupleId',
    'interpolateScalarsBeforeMapping',
    'lookupTable',
    'renderTime',
    'scalarMode',
    'scalarVisibility',
    'static',
    'useLookupTableScalarRange',
    'viewSpecificProperties',
    'customShaderAttributes', // point data array names that will be transferred to the VBO
  ]);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGetArray(publicAPI, model, ['scalarRange'], 2);

  if (!model.viewSpecificProperties) {
    model.viewSpecificProperties = {};
  }

  vtk_js_Sources_Rendering_Core_Mapper_CoincidentTopologyHelper__WEBPACK_IMPORTED_MODULE_7__["default"].implementCoincidentTopologyMethods(publicAPI, model);

  // Object methods
  vtkMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkMapper');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({
  newInstance,
  extend,
  ...staticOffsetAPI,
  ...otherStaticMethods,
  ...vtk_js_Sources_Rendering_Core_Mapper_Constants__WEBPACK_IMPORTED_MODULE_8__["default"],
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/Prop/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/Prop/index.js ***!
  \******************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");


function notImplemented(method) {
  return () => vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].vtkErrorMacro(`vtkProp::${method} - NOT IMPLEMENTED`);
}

// ----------------------------------------------------------------------------
// vtkProp methods
// ----------------------------------------------------------------------------

function vtkProp(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkProp');

  publicAPI.getMTime = () => {
    let m1 = model.mtime;
    for (let index = 0; index < model.textures.length; ++index) {
      const m2 = model.textures[index].getMTime();
      if (m2 > m1) {
        m1 = m2;
      }
    }
    return m1;
  };

  publicAPI.getNestedProps = () => null;
  publicAPI.getActors = () => [];
  publicAPI.getActors2D = () => [];
  publicAPI.getVolumes = () => [];

  publicAPI.pick = notImplemented('pick');
  publicAPI.hasKey = notImplemented('hasKey');

  publicAPI.getRedrawMTime = () => model.mtime;

  publicAPI.setEstimatedRenderTime = (t) => {
    model.estimatedRenderTime = t;
    model.savedEstimatedRenderTime = t;
  };

  publicAPI.restoreEstimatedRenderTime = () => {
    model.estimatedRenderTime = model.savedEstimatedRenderTime;
  };

  publicAPI.addEstimatedRenderTime = (t) => {
    model.estimatedRenderTime += t;
  };

  publicAPI.setAllocatedRenderTime = (t) => {
    model.allocatedRenderTime = t;
    model.savedEstimatedRenderTime = model.estimatedRenderTime;
    model.estimatedRenderTime = 0;
  };

  publicAPI.getSupportsSelection = () => false;

  publicAPI.getTextures = () => model.textures;
  publicAPI.hasTexture = (texture) => model.textures.indexOf(texture) !== -1;
  publicAPI.addTexture = (texture) => {
    if (texture && !publicAPI.hasTexture(texture)) {
      model.textures = model.textures.concat(texture);
      publicAPI.modified();
    }
  };

  publicAPI.removeTexture = (texture) => {
    const newTextureList = model.textures.filter((item) => item !== texture);
    if (model.textures.length !== newTextureList.length) {
      model.textures = newTextureList;
      publicAPI.modified();
    }
  };

  publicAPI.removeAllTextures = () => {
    model.textures = [];
    publicAPI.modified();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  visibility: true,
  pickable: true,
  dragable: true,
  useBounds: true,
  allocatedRenderTime: 10,
  estimatedRenderTime: 0,
  savedEstimatedRenderTime: 0,
  renderTimeMultiplier: 1,
  paths: null,
  textures: [],
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['estimatedRenderTime', 'allocatedRenderTime']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'visibility',
    'pickable',
    'dragable',
    'useBounds',
    'renderTimeMultiplier',
  ]);

  // Object methods
  vtkProp(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkProp');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/Prop3D/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/Prop3D/index.js ***!
  \********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/BoundingBox */ "./node_modules/vtk.js/Sources/Common/DataModel/BoundingBox/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Prop__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Prop */ "./node_modules/vtk.js/Sources/Rendering/Core/Prop/index.js");







// ----------------------------------------------------------------------------
// vtkProp3D methods
// ----------------------------------------------------------------------------

function vtkProp3D(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkProp3D');

  publicAPI.addPosition = (deltaXYZ) => {
    model.position = model.position.map(
      (value, index) => value + deltaXYZ[index]
    );
    publicAPI.modified();
  };

  publicAPI.getOrientationWXYZ = () => {
    const q = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].getRotation(q, model.rotation);
    const oaxis = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
    const w = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].getAxisAngle(oaxis, q);
    return [vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["degreesFromRadians"](w), oaxis[0], oaxis[1], oaxis[2]];
  };

  publicAPI.rotateX = (val) => {
    if (val === 0.0) {
      return;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotateX(
      model.rotation,
      model.rotation,
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["radiansFromDegrees"](val)
    );
    publicAPI.modified();
  };

  publicAPI.rotateY = (val) => {
    if (val === 0.0) {
      return;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotateY(
      model.rotation,
      model.rotation,
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["radiansFromDegrees"](val)
    );
    publicAPI.modified();
  };

  publicAPI.rotateZ = (val) => {
    if (val === 0.0) {
      return;
    }
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotateZ(
      model.rotation,
      model.rotation,
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["radiansFromDegrees"](val)
    );
    publicAPI.modified();
  };

  publicAPI.rotateWXYZ = (degrees, x, y, z) => {
    if (degrees === 0.0 || (x === 0.0 && y === 0.0 && z === 0.0)) {
      return;
    }

    // convert to radians
    const angle = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["radiansFromDegrees"](degrees);

    const q = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].setAxisAngle(q, [x, y, z], angle);

    const quatMat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].fromQuat(quatMat, q);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(model.rotation, model.rotation, quatMat);
    publicAPI.modified();
  };

  publicAPI.setOrientation = (x, y, z) => {
    if (
      x === model.orientation[0] &&
      y === model.orientation[1] &&
      z === model.orientation[2]
    ) {
      return false;
    }
    model.orientation = [x, y, z];
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(model.rotation);
    publicAPI.rotateZ(z);
    publicAPI.rotateX(x);
    publicAPI.rotateY(y);
    publicAPI.modified();
    return true;
  };

  publicAPI.setUserMatrix = (matrix) => {
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(model.userMatrix, matrix);
    publicAPI.modified();
  };

  publicAPI.getMatrix = () => {
    publicAPI.computeMatrix();
    return model.matrix;
  };

  publicAPI.computeMatrix = () => {
    // check whether or not need to rebuild the matrix
    if (publicAPI.getMTime() > model.matrixMTime.getMTime()) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].identity(model.matrix);
      if (model.userMatrix) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(model.matrix, model.matrix, model.userMatrix);
      }
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(model.matrix, model.matrix, model.origin);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(model.matrix, model.matrix, model.position);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(model.matrix, model.matrix, model.rotation);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].scale(model.matrix, model.matrix, model.scale);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(model.matrix, model.matrix, [
        -model.origin[0],
        -model.origin[1],
        -model.origin[2],
      ]);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(model.matrix, model.matrix);

      // check for identity
      model.isIdentity = true;
      for (let i = 0; i < 4; ++i) {
        for (let j = 0; j < 4; ++j) {
          if ((i === j ? 1.0 : 0.0) !== model.matrix[i + j * 4]) {
            model.isIdentity = false;
          }
        }
      }
      model.matrixMTime.modified();
    }
  };

  publicAPI.getCenter = () => vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_2__["default"].getCenter(model.bounds);
  publicAPI.getLength = () => vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_2__["default"].getLength(model.bounds);
  publicAPI.getXRange = () => vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_2__["default"].getXRange(model.bounds);
  publicAPI.getYRange = () => vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_2__["default"].getYRange(model.bounds);
  publicAPI.getZRange = () => vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_2__["default"].getZRange(model.bounds);

  publicAPI.getUserMatrix = () => model.userMatrix;

  function updateIdentityFlag() {
    publicAPI.computeMatrix();
  }

  publicAPI.onModified(updateIdentityFlag);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  origin: [0, 0, 0],
  position: [0, 0, 0],
  orientation: [0, 0, 0],
  rotation: null,
  scale: [1, 1, 1],
  bounds: [1, -1, 1, -1, 1, -1],

  userMatrix: null,
  userMatrixMTime: null,

  cachedProp3D: null,
  isIdentity: true,
  matrixMTime: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_Core_Prop__WEBPACK_IMPORTED_MODULE_4__["default"].extend(publicAPI, model, initialValues);

  model.matrixMTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(model.matrixMTime);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].get(publicAPI, model, ['bounds', 'isIdentity']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].getArray(publicAPI, model, ['orientation']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGetArray(publicAPI, model, ['origin', 'position', 'scale'], 3);

  // Object internal instance
  model.matrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
  model.rotation = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
  model.userMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
  model.transform = null; // FIXME

  // Object methods
  vtkProp3D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend, 'vtkProp3D');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/Property/Constants.js":
/*!**************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/Property/Constants.js ***!
  \**************************************************************************/
/*! exports provided: Shading, Representation, Interpolation, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shading", function() { return Shading; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Representation", function() { return Representation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolation", function() { return Interpolation; });
const Shading = {
  FLAT: 0,
  GOURAUD: 1,
  PHONG: 2,
};

const Representation = {
  POINTS: 0,
  WIREFRAME: 1,
  SURFACE: 2,
};

const Interpolation = Shading;

/* harmony default export */ __webpack_exports__["default"] = ({
  Shading,
  Representation,
  Interpolation,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/Property/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/Property/index.js ***!
  \**********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Property_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Property/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/Property/Constants.js");



const { Representation, Interpolation } = vtk_js_Sources_Rendering_Core_Property_Constants__WEBPACK_IMPORTED_MODULE_1__["default"];

function notImplemented(method) {
  return () => vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].vtkErrorMacro(`vtkProperty::${method} - NOT IMPLEMENTED`);
}

// ----------------------------------------------------------------------------
// vtkProperty methods
// ----------------------------------------------------------------------------

function vtkProperty(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkProperty');

  publicAPI.setColor = (r, g, b) => {
    if (Array.isArray(r)) {
      if (
        model.color[0] !== r[0] ||
        model.color[1] !== r[1] ||
        model.color[2] !== r[2]
      ) {
        model.color[0] = r[0];
        model.color[1] = r[1];
        model.color[2] = r[2];
        publicAPI.modified();
      }
    } else if (
      model.color[0] !== r ||
      model.color[1] !== g ||
      model.color[2] !== b
    ) {
      model.color[0] = r;
      model.color[1] = g;
      model.color[2] = b;
      publicAPI.modified();
    }

    publicAPI.setDiffuseColor(model.color);
    publicAPI.setAmbientColor(model.color);
    publicAPI.setSpecularColor(model.color);
  };

  publicAPI.computeCompositeColor = notImplemented('ComputeCompositeColor');
  publicAPI.getColor = () => {
    // Inline computeCompositeColor
    let norm = 0.0;
    if (model.ambient + model.diffuse + model.specular > 0) {
      norm = 1.0 / (model.ambient + model.diffuse + model.specular);
    }

    for (let i = 0; i < 3; i++) {
      model.color[i] =
        norm *
        (model.ambient * model.ambientColor[i] +
          model.diffuse * model.diffuseColor[i] +
          model.specular * model.specularColor[i]);
    }

    return [].concat(model.color);
  };

  publicAPI.addShaderVariable = notImplemented('AddShaderVariable');

  publicAPI.setInterpolationToFlat = () =>
    publicAPI.setInterpolation(Interpolation.FLAT);
  publicAPI.setInterpolationToGouraud = () =>
    publicAPI.setInterpolation(Interpolation.GOURAUD);
  publicAPI.setInterpolationToPhong = () =>
    publicAPI.setInterpolation(Interpolation.PHONG);
  publicAPI.getInterpolationAsString = () =>
    vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].enumToString(Interpolation, model.interpolation);

  publicAPI.setRepresentationToWireframe = () =>
    publicAPI.setRepresentation(Representation.WIREFRAME);
  publicAPI.setRepresentationToSurface = () =>
    publicAPI.setRepresentation(Representation.SURFACE);
  publicAPI.setRepresentationToPoints = () =>
    publicAPI.setRepresentation(Representation.POINTS);
  publicAPI.getRepresentationAsString = () =>
    vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].enumToString(Representation, model.representation);
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  color: [1, 1, 1],
  ambientColor: [1, 1, 1],
  diffuseColor: [1, 1, 1],
  specularColor: [1, 1, 1],
  edgeColor: [0, 0, 0],

  ambient: 0,
  diffuse: 1,
  specular: 0,
  specularPower: 1,
  opacity: 1,
  interpolation: Interpolation.GOURAUD,
  representation: Representation.SURFACE,
  edgeVisibility: false,
  backfaceCulling: false,
  frontfaceCulling: false,
  pointSize: 1,
  lineWidth: 1,
  lighting: true,

  shading: false,
  materialName: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'lighting',
    'interpolation',
    'ambient',
    'diffuse',
    'specular',
    'specularPower',
    'opacity',
    'edgeVisibility',
    'lineWidth',
    'pointSize',
    'backfaceCulling',
    'frontfaceCulling',
    'representation',
  ]);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGetArray(
    publicAPI,
    model,
    ['ambientColor', 'specularColor', 'diffuseColor', 'edgeColor'],
    3
  );

  // Object methods
  vtkProperty(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkProperty');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...vtk_js_Sources_Rendering_Core_Property_Constants__WEBPACK_IMPORTED_MODULE_1__["default"] });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/RenderWindow/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/RenderWindow/index.js ***!
  \**************************************************************************/
/*! exports provided: DEFAULT_VALUES, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_VALUES", function() { return DEFAULT_VALUES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");


// ----------------------------------------------------------------------------
// vtkRenderWindow methods
// ----------------------------------------------------------------------------

function vtkRenderWindow(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkRenderWindow');

  // Add renderer
  publicAPI.addRenderer = (renderer) => {
    if (publicAPI.hasRenderer(renderer)) {
      return;
    }
    renderer.setRenderWindow(publicAPI);
    model.renderers.push(renderer);

    // for (this->Renderers->InitTraversal(rsit);
    //      (aren = this->Renderers->GetNextRenderer(rsit)); )
    //   {
    //   aren->SetAllocatedRenderTime
    //     (1.0/(this->DesiredUpdateRate*this->Renderers->GetNumberOfItems()));
    //   }

    publicAPI.modified();
  };

  // Remove renderer
  publicAPI.removeRenderer = (renderer) => {
    model.renderers = model.renderers.filter((r) => r !== renderer);
    publicAPI.modified();
  };

  publicAPI.hasRenderer = (ren) => model.renderers.indexOf(ren) !== -1;

  // Add renderer
  publicAPI.addView = (view) => {
    if (publicAPI.hasView(view)) {
      return;
    }
    view.setRenderable(publicAPI);
    model.views.push(view);
    publicAPI.modified();
  };

  // Remove renderer
  publicAPI.removeView = (view) => {
    model.views = model.views.filter((r) => r !== view);
    publicAPI.modified();
  };

  publicAPI.hasView = (view) => model.views.indexOf(view) !== -1;

  publicAPI.render = () => {
    if (model.interactor) {
      model.interactor.render();
    } else {
      model.views.forEach((view) => view.traverseAllPasses());
    }
  };

  publicAPI.getStatistics = () => {
    const results = { propCount: 0, invisiblePropCount: 0 };
    model.renderers.forEach((ren) => {
      const props = ren.getViewProps();
      props.forEach((prop) => {
        if (prop.getVisibility()) {
          results.propCount += 1;
          const mpr = prop.getMapper && prop.getMapper();
          if (mpr && mpr.getPrimitiveCount) {
            const pcount = mpr.getPrimitiveCount();
            Object.keys(pcount).forEach((keyName) => {
              if (!results[keyName]) {
                results[keyName] = 0;
              }
              results[keyName] += pcount[keyName];
            });
          }
        } else {
          results.invisiblePropCount += 1;
        }
      });
    });
    results.str = Object.keys(results)
      .map((keyName) => `${keyName}: ${results[keyName]}`)
      .join('\n');

    return results;
  };

  publicAPI.captureImages = (format = 'image/png') => {
    vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setImmediate(publicAPI.render);
    return model.views
      .map((view) =>
        view.captureNextImage ? view.captureNextImage(format) : undefined
      )
      .filter((i) => !!i);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  renderers: [],
  views: [],
  interactor: null,
  neverRendered: true,
  numberOfLayers: 1,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, ['interactor', 'numberOfLayers', 'views']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['neverRendered']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].getArray(publicAPI, model, ['renderers']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].event(publicAPI, model, 'completion');

  // Object methods
  vtkRenderWindow(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkRenderWindow');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/RenderWindowInteractor/Constants.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/RenderWindowInteractor/Constants.js ***!
  \****************************************************************************************/
/*! exports provided: Device, Input, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Device", function() { return Device; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Input", function() { return Input; });
const Device = {
  Unknown: 0,
  LeftController: 1,
  RightController: 2,
};

const Input = {
  Unknown: 0,
  Trigger: 1,
  TrackPad: 2,
  Grip: 3,
  ApplicationMenu: 4,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  Device,
  Input,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/RenderWindowInteractor/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/RenderWindowInteractor/index.js ***!
  \************************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_RenderWindowInteractor_Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/RenderWindowInteractor/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/RenderWindowInteractor/Constants.js");





const { Device, Input } = vtk_js_Sources_Rendering_Core_RenderWindowInteractor_Constants__WEBPACK_IMPORTED_MODULE_2__["default"];
const {
  vtkWarningMacro,
  vtkErrorMacro,
  normalizeWheel,
  vtkOnceErrorMacro,
} = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

const deviceInputMap = {
  'OpenVR Gamepad': [
    Input.TrackPad,
    Input.Trigger,
    Input.Grip,
    Input.ApplicationMenu,
  ],
};

const handledEvents = [
  'StartAnimation',
  'Animation',
  'EndAnimation',
  'StartMouseMove',
  'MouseMove',
  'EndMouseMove',
  'LeftButtonPress',
  'LeftButtonRelease',
  'MiddleButtonPress',
  'MiddleButtonRelease',
  'RightButtonPress',
  'RightButtonRelease',
  'KeyPress',
  'KeyDown',
  'KeyUp',
  'StartMouseWheel',
  'MouseWheel',
  'EndMouseWheel',
  'StartPinch',
  'Pinch',
  'EndPinch',
  'StartPan',
  'Pan',
  'EndPan',
  'StartRotate',
  'Rotate',
  'EndRotate',
  'Button3D',
  'Move3D',
  'StartPointerLock',
  'EndPointerLock',
  'StartInteractionEvent',
  'InteractionEvent',
  'EndInteractionEvent',
];

function preventDefault(event) {
  event.stopPropagation();
  event.preventDefault();
  return false;
}

// ----------------------------------------------------------------------------
// vtkRenderWindowInteractor methods
// ----------------------------------------------------------------------------

function vtkRenderWindowInteractor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkRenderWindowInteractor');

  // Initialize list of requesters
  const animationRequesters = new Set();

  // track active event listeners to handle simultaneous button tracking
  let activeListenerCount = 0;

  // Public API methods

  //----------------------------------------------------------------------
  publicAPI.start = () => {
    // Let the compositing handle the event loop if it wants to.
    // if (publicAPI.HasObserver(vtkCommand::StartEvent) && !publicAPI.HandleEventLoop) {
    //   publicAPI.invokeEvent({ type: 'StartEvent' });
    //   return;
    // }

    // As a convenience, initialize if we aren't initialized yet.
    if (!model.initialized) {
      publicAPI.initialize();
      if (!model.initialized) {
        return;
      }
    }
    // Pass execution to the subclass which will run the event loop,
    // this will not return until TerminateApp is called.
    publicAPI.startEventLoop();
  };

  //----------------------------------------------------------------------
  publicAPI.setRenderWindow = (aren) => {
    vtkErrorMacro(
      'you want to call setView(view) instead of setRenderWindow on a vtk.js interactor'
    );
  };

  //----------------------------------------------------------------------
  publicAPI.setInteractorStyle = (style) => {
    if (model.interactorStyle !== style) {
      if (model.interactorStyle != null) {
        model.interactorStyle.setInteractor(null);
      }
      model.interactorStyle = style;
      if (model.interactorStyle != null) {
        if (model.interactorStyle.getInteractor() !== publicAPI) {
          model.interactorStyle.setInteractor(publicAPI);
        }
      }
    }
  };

  //---------------------------------------------------------------------
  publicAPI.initialize = () => {
    model.initialized = true;
    publicAPI.enable();
    publicAPI.render();
  };

  publicAPI.enable = () => publicAPI.setEnabled(true);

  publicAPI.disable = () => publicAPI.setEnabled(false);

  publicAPI.startEventLoop = () => vtkWarningMacro('empty event loop');

  function updateCurrentRenderer(x, y) {
    model.currentRenderer = publicAPI.findPokedRenderer(x, y);
  }

  publicAPI.getCurrentRenderer = () => {
    if (model.currentRenderer) {
      return model.currentRenderer;
    }
    updateCurrentRenderer(0, 0);
    return model.currentRenderer;
  };

  function getScreenEventPositionFor(source) {
    const bounds = model.container.getBoundingClientRect();
    const canvas = model.view.getCanvas();
    const scaleX = canvas.width / bounds.width;
    const scaleY = canvas.height / bounds.height;
    const position = {
      x: scaleX * (source.clientX - bounds.left),
      y: scaleY * (bounds.height - source.clientY + bounds.top),
      z: 0,
    };
    updateCurrentRenderer(position.x, position.y);
    return position;
  }

  function getTouchEventPositionsFor(touches) {
    const positions = {};
    for (let i = 0; i < touches.length; i++) {
      const touch = touches[i];
      positions[touch.identifier] = getScreenEventPositionFor(touch);
    }
    return positions;
  }

  function getModifierKeysFor(event) {
    return {
      controlKey: event.ctrlKey,
      altKey: event.altKey,
      shiftKey: event.shiftKey,
    };
  }

  function getKeysFor(event) {
    const modifierKeys = getModifierKeysFor(event);
    const keys = {
      key: event.key,
      keyCode: event.charCode,
    };
    Object.assign(keys, modifierKeys);
    return keys;
  }

  function interactionRegistration(addListeners, force = false) {
    const rootElm = document;
    const method = addListeners ? 'addEventListener' : 'removeEventListener';
    const invMethod = addListeners ? 'removeEventListener' : 'addEventListener';

    if (!force && !addListeners && activeListenerCount > 0) {
      --activeListenerCount;
    }

    // only add/remove listeners when there are no registered listeners
    if (!activeListenerCount || force) {
      activeListenerCount = 0;

      if (model.container) {
        model.container[invMethod]('mousemove', publicAPI.handleMouseMove);
      }

      rootElm[method]('mouseup', publicAPI.handleMouseUp);
      // rootElm[method]('mouseleave', publicAPI.handleMouseUp);
      rootElm[method]('mousemove', publicAPI.handleMouseMove);
      rootElm[method]('touchend', publicAPI.handleTouchEnd, false);
      rootElm[method]('touchcancel', publicAPI.handleTouchEnd, false);
      rootElm[method]('touchmove', publicAPI.handleTouchMove, false);
    }

    if (!force && addListeners) {
      ++activeListenerCount;
    }
  }

  publicAPI.bindEvents = (container) => {
    model.container = container;
    container.addEventListener('contextmenu', preventDefault);
    // container.addEventListener('click', preventDefault); // Avoid stopping event propagation
    container.addEventListener('wheel', publicAPI.handleWheel);
    container.addEventListener('DOMMouseScroll', publicAPI.handleWheel);
    container.addEventListener('mousemove', publicAPI.handleMouseMove);
    container.addEventListener('mousedown', publicAPI.handleMouseDown);
    document
      .querySelector('body')
      .addEventListener('keypress', publicAPI.handleKeyPress);
    document
      .querySelector('body')
      .addEventListener('keydown', publicAPI.handleKeyDown);
    document
      .querySelector('body')
      .addEventListener('keyup', publicAPI.handleKeyUp);

    document.addEventListener(
      'pointerlockchange',
      publicAPI.handlePointerLockChange
    );

    container.addEventListener('touchstart', publicAPI.handleTouchStart, false);
  };

  publicAPI.unbindEvents = () => {
    // force unbinding listeners
    interactionRegistration(false, true);
    model.container.removeEventListener('contextmenu', preventDefault);
    // model.container.removeEventListener('click', preventDefault); // Avoid stopping event propagation
    model.container.removeEventListener('wheel', publicAPI.handleWheel);
    model.container.removeEventListener(
      'DOMMouseScroll',
      publicAPI.handleWheel
    );
    model.container.removeEventListener('mousemove', publicAPI.handleMouseMove);
    model.container.removeEventListener('mousedown', publicAPI.handleMouseDown);
    document
      .querySelector('body')
      .removeEventListener('keypress', publicAPI.handleKeyPress);
    document
      .querySelector('body')
      .removeEventListener('keydown', publicAPI.handleKeyDown);
    document
      .querySelector('body')
      .removeEventListener('keyup', publicAPI.handleKeyUp);
    document.removeEventListener(
      'pointerlockchange',
      publicAPI.handlePointerLockChange
    );
    model.container.removeEventListener(
      'touchstart',
      publicAPI.handleTouchStart
    );
    model.container = null;
  };

  publicAPI.handleKeyPress = (event) => {
    const data = getKeysFor(event);
    publicAPI.keyPressEvent(data);
  };

  publicAPI.handleKeyDown = (event) => {
    const data = getKeysFor(event);
    publicAPI.keyDownEvent(data);
  };

  publicAPI.handleKeyUp = (event) => {
    const data = getKeysFor(event);
    publicAPI.keyUpEvent(data);
  };

  publicAPI.handleMouseDown = (event) => {
    if (event.button > 2) {
      // ignore events from extra mouse buttons such as `back` and `forward`
      return;
    }

    interactionRegistration(true);
    event.stopPropagation();
    event.preventDefault();

    const callData = {
      position: getScreenEventPositionFor(event),
    };
    const keys = getModifierKeysFor(event);
    Object.assign(callData, keys);
    switch (event.button) {
      case 0:
        publicAPI.leftButtonPressEvent(callData);
        break;
      case 1:
        publicAPI.middleButtonPressEvent(callData);
        break;
      case 2:
        publicAPI.rightButtonPressEvent(callData);
        break;
      default:
        vtkErrorMacro(`Unknown mouse button pressed: ${event.button}`);
        break;
    }
  };

  //----------------------------------------------------------------------
  publicAPI.requestPointerLock = () => {
    const canvas = publicAPI.getView().getCanvas();
    canvas.requestPointerLock();
  };

  //----------------------------------------------------------------------
  publicAPI.exitPointerLock = () => document.exitPointerLock();

  //----------------------------------------------------------------------
  publicAPI.isPointerLocked = () => !!document.pointerLockElement;

  //----------------------------------------------------------------------
  publicAPI.handlePointerLockChange = () => {
    if (publicAPI.isPointerLocked()) {
      publicAPI.startPointerLockEvent();
    } else {
      publicAPI.endPointerLockEvent();
    }
  };

  //----------------------------------------------------------------------
  function forceRender() {
    if (model.view && model.enabled && model.enableRender) {
      model.inRender = true;
      model.view.traverseAllPasses();
      model.inRender = false;
    }
    // outside the above test so that third-party code can redirect
    // the render to the appropriate class
    publicAPI.invokeRenderEvent();
  }

  publicAPI.requestAnimation = (requestor) => {
    if (requestor === undefined) {
      vtkErrorMacro(`undefined requester, can not start animating`);
      return;
    }
    if (animationRequesters.has(requestor)) {
      vtkWarningMacro(`requester is already registered for animating`);
      return;
    }
    animationRequesters.add(requestor);
    if (animationRequesters.size === 1) {
      model.lastFrameTime = 0.1;
      model.lastFrameStart = Date.now();
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
      publicAPI.startAnimationEvent();
    }
  };

  publicAPI.isAnimating = () =>
    model.vrAnimation || model.animationRequest !== null;

  publicAPI.cancelAnimation = (requestor, skipWarning = false) => {
    if (!animationRequesters.has(requestor)) {
      if (!skipWarning) {
        const requestStr =
          requestor && requestor.getClassName
            ? requestor.getClassName()
            : requestor;
        vtkWarningMacro(`${requestStr} did not request an animation`);
      }

      return;
    }
    animationRequesters.delete(requestor);
    if (model.animationRequest && animationRequesters.size === 0) {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
      publicAPI.endAnimationEvent();
      publicAPI.render();
    }
  };

  publicAPI.switchToVRAnimation = () => {
    // cancel existing animation if any
    if (model.animationRequest) {
      cancelAnimationFrame(model.animationRequest);
      model.animationRequest = null;
    }
    model.vrAnimation = true;
  };

  publicAPI.returnFromVRAnimation = () => {
    model.vrAnimation = false;
    if (animationRequesters.size !== 0) {
      model.FrameTime = -1;
      model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
    }
  };

  publicAPI.updateGamepads = (displayId) => {
    const gamepads = navigator.getGamepads();

    // watch for when buttons change state and fire events
    for (let i = 0; i < gamepads.length; ++i) {
      const gp = gamepads[i];
      if (gp && gp.displayId === displayId) {
        if (!(gp.index in model.lastGamepadValues)) {
          model.lastGamepadValues[gp.index] = { buttons: {} };
        }
        for (let b = 0; b < gp.buttons.length; ++b) {
          if (!(b in model.lastGamepadValues[gp.index].buttons)) {
            model.lastGamepadValues[gp.index].buttons[b] = false;
          }
          if (
            model.lastGamepadValues[gp.index].buttons[b] !==
            gp.buttons[b].pressed
          ) {
            publicAPI.button3DEvent({
              gamepad: gp,
              position: gp.pose.position,
              orientation: gp.pose.orientation,
              pressed: gp.buttons[b].pressed,
              device:
                gp.hand === 'left'
                  ? Device.LeftController
                  : Device.RightController,
              input:
                deviceInputMap[gp.id] && deviceInputMap[gp.id][b]
                  ? deviceInputMap[gp.id][b]
                  : Input.Trigger,
            });
            model.lastGamepadValues[gp.index].buttons[b] =
              gp.buttons[b].pressed;
          }
          if (model.lastGamepadValues[gp.index].buttons[b]) {
            publicAPI.move3DEvent({
              gamepad: gp,
              position: gp.pose.position,
              orientation: gp.pose.orientation,
              device:
                gp.hand === 'left'
                  ? Device.LeftController
                  : Device.RightController,
            });
          }
        }
      }
    }
  };

  publicAPI.handleMouseMove = (event) => {
    // Do not consume event for move
    // event.stopPropagation();
    // event.preventDefault();

    const callData = {
      position: getScreenEventPositionFor(event),
    };
    const keys = getModifierKeysFor(event);
    Object.assign(callData, keys);

    if (model.moveTimeoutID === 0) {
      publicAPI.startMouseMoveEvent(callData);
    } else {
      publicAPI.mouseMoveEvent(callData);
      clearTimeout(model.moveTimeoutID);
    }

    // start a timer to keep us animating while we get mouse move events
    model.moveTimeoutID = setTimeout(() => {
      publicAPI.endMouseMoveEvent();
      model.moveTimeoutID = 0;
    }, 200);
  };

  publicAPI.handleAnimation = () => {
    const currTime = Date.now();
    if (model.FrameTime === -1.0) {
      model.lastFrameTime = 0.1;
    } else {
      model.lastFrameTime = (currTime - model.lastFrameStart) / 1000.0;
    }
    model.lastFrameTime = Math.max(0.01, model.lastFrameTime);
    model.lastFrameStart = currTime;
    publicAPI.animationEvent();
    forceRender();
    model.animationRequest = requestAnimationFrame(publicAPI.handleAnimation);
  };

  publicAPI.handleWheel = (event) => {
    event.stopPropagation();
    event.preventDefault();

    /**
     * wheel event values can vary significantly across browsers, platforms
     * and devices [1]. `normalizeWheel` uses facebook's solution from their
     * fixed-data-table repository [2].
     *
     * [1] https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel
     * [2] https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
     *
     * This code will return an object with properties:
     *
     *   spinX   -- normalized spin speed (use for zoom) - x plane
     *   spinY   -- " - y plane
     *   pixelX  -- normalized distance (to pixels) - x plane
     *   pixelY  -- " - y plane
     *
     */
    const callData = normalizeWheel(event);
    const keys = getModifierKeysFor(event);
    Object.assign(callData, keys);

    if (model.wheelTimeoutID === 0) {
      publicAPI.startMouseWheelEvent(callData);
    } else {
      publicAPI.mouseWheelEvent(callData);
      clearTimeout(model.wheelTimeoutID);
    }

    // start a timer to keep us animating while we get wheel events
    model.wheelTimeoutID = setTimeout(() => {
      publicAPI.endMouseWheelEvent();
      model.wheelTimeoutID = 0;
    }, 200);
  };

  publicAPI.handleMouseUp = (event) => {
    interactionRegistration(false);
    event.stopPropagation();
    event.preventDefault();

    const callData = {
      position: getScreenEventPositionFor(event),
    };
    const keys = getModifierKeysFor(event);
    Object.assign(callData, keys);
    switch (event.button) {
      case 0:
        publicAPI.leftButtonReleaseEvent(callData);
        break;
      case 1:
        publicAPI.middleButtonReleaseEvent(callData);
        break;
      case 2:
        publicAPI.rightButtonReleaseEvent(callData);
        break;
      default:
        vtkErrorMacro(`Unknown mouse button released: ${event.button}`);
        break;
    }
  };

  publicAPI.handleTouchStart = (event) => {
    interactionRegistration(true);
    event.stopPropagation();
    event.preventDefault();

    // If multitouch
    if (model.recognizeGestures && event.touches.length > 1) {
      const positions = getTouchEventPositionsFor(event.touches);
      // did we just transition to multitouch?
      if (event.touches.length === 2) {
        const touch = event.touches[0];
        const callData = {
          position: getScreenEventPositionFor(touch),
          shiftKey: false,
          altKey: false,
          controlKey: false,
        };
        publicAPI.leftButtonReleaseEvent(callData);
      }
      // handle the gesture
      publicAPI.recognizeGesture('TouchStart', positions);
    } else {
      const touch = event.touches[0];
      const callData = {
        position: getScreenEventPositionFor(touch),
        shiftKey: false,
        altKey: false,
        controlKey: false,
      };
      publicAPI.leftButtonPressEvent(callData);
    }
  };

  publicAPI.handleTouchMove = (event) => {
    event.stopPropagation();
    event.preventDefault();

    if (model.recognizeGestures && event.touches.length > 1) {
      const positions = getTouchEventPositionsFor(event.touches);
      publicAPI.recognizeGesture('TouchMove', positions);
    } else {
      const touch = event.touches[0];
      const callData = {
        position: getScreenEventPositionFor(touch),
        shiftKey: false,
        altKey: false,
        controlKey: false,
      };
      publicAPI.mouseMoveEvent(callData);
    }
  };

  publicAPI.handleTouchEnd = (event) => {
    event.stopPropagation();
    event.preventDefault();

    if (model.recognizeGestures) {
      // No more fingers down
      if (event.touches.length === 0) {
        // If just one finger released, consider as left button
        if (event.changedTouches.length === 1) {
          const touch = event.changedTouches[0];
          const callData = {
            position: getScreenEventPositionFor(touch),
            shiftKey: false,
            altKey: false,
            controlKey: false,
          };
          publicAPI.leftButtonReleaseEvent(callData);
          interactionRegistration(false);
        } else {
          // If more than one finger released, recognize touchend
          const positions = getTouchEventPositionsFor(event.changedTouches);
          publicAPI.recognizeGesture('TouchEnd', positions);
          interactionRegistration(false);
        }
      } else if (event.touches.length === 1) {
        // If one finger left, end touch and start button press
        const positions = getTouchEventPositionsFor(event.changedTouches);
        publicAPI.recognizeGesture('TouchEnd', positions);
        const touch = event.touches[0];
        const callData = {
          position: getScreenEventPositionFor(touch),
          shiftKey: false,
          altKey: false,
          controlKey: false,
        };
        publicAPI.leftButtonPressEvent(callData);
      } else {
        // If more than one finger left, keep touch move
        const positions = getTouchEventPositionsFor(event.touches);
        publicAPI.recognizeGesture('TouchMove', positions);
      }
    } else {
      const touch = event.changedTouches[0];
      const callData = {
        position: getScreenEventPositionFor(touch),
        shiftKey: false,
        altKey: false,
        controlKey: false,
      };
      publicAPI.leftButtonReleaseEvent(callData);
      interactionRegistration(false);
    }
  };

  publicAPI.setView = (val) => {
    if (model.view === val) {
      return;
    }
    model.view = val;
    model.view.getRenderable().setInteractor(publicAPI);
    publicAPI.modified();
  };

  publicAPI.findPokedRenderer = (x = 0, y = 0) => {
    if (!model.view) {
      return null;
    }
    const rc = model.view.getRenderable().getRenderersByReference();
    rc.sort((a, b) => a.getLayer() - b.getLayer());
    let interactiveren = null;
    let viewportren = null;
    let currentRenderer = null;

    let count = rc.length;
    while (count--) {
      const aren = rc[count];
      if (model.view.isInViewport(x, y, aren) && aren.getInteractive()) {
        currentRenderer = aren;
        break;
      }

      if (interactiveren === null && aren.getInteractive()) {
        // Save this renderer in case we can't find one in the viewport that
        // is interactive.
        interactiveren = aren;
      }
      if (viewportren === null && model.view.isInViewport(x, y, aren)) {
        // Save this renderer in case we can't find one in the viewport that
        // is interactive.
        viewportren = aren;
      }
    }

    // We must have a value.  If we found an interactive renderer before, that's
    // better than a non-interactive renderer.
    if (currentRenderer === null) {
      currentRenderer = interactiveren;
    }

    // We must have a value.  If we found a renderer that is in the viewport,
    // that is better than any old viewport (but not as good as an interactive
    // one).
    if (currentRenderer === null) {
      currentRenderer = viewportren;
    }

    // We must have a value - take anything.
    if (currentRenderer == null) {
      currentRenderer = rc[0];
    }

    return currentRenderer;
  };

  // only render if we are not animating. If we are animating
  // then renders will happen naturally anyhow and we definitely
  // do not want extra renders as the make the apparent interaction
  // rate slower.
  publicAPI.render = () => {
    if (model.animationRequest === null && !model.inRender) {
      forceRender();
    }
  };

  // create the generic Event methods
  handledEvents.forEach((eventName) => {
    const lowerFirst = eventName.charAt(0).toLowerCase() + eventName.slice(1);
    publicAPI[`${lowerFirst}Event`] = (arg) => {
      // Check that interactor enabled
      if (!model.enabled) {
        return;
      }

      // Check that a poked renderer exists
      const renderer = publicAPI.getCurrentRenderer();
      if (!renderer) {
        vtkOnceErrorMacro(`
          Can not forward events without a current renderer on the interactor.
        `);
        return;
      }

      // Pass the eventName and the poked renderer
      const callData = {
        type: eventName,
        pokedRenderer: model.currentRenderer,
      };

      // Add the arguments to the call data
      Object.assign(callData, arg);

      // Call invoke
      publicAPI[`invoke${eventName}`](callData);
    };
  });

  // we know we are in multitouch now, so start recognizing
  publicAPI.recognizeGesture = (event, positions) => {
    // more than two pointers we ignore
    if (Object.keys(positions).length > 2) {
      return;
    }

    if (!model.startingEventPositions) {
      model.startingEventPositions = {};
    }

    // store the initial positions
    if (event === 'TouchStart') {
      Object.keys(positions).forEach((key) => {
        model.startingEventPositions[key] = positions[key];
      });
      // we do not know what the gesture is yet
      model.currentGesture = 'Start';
      return;
    }

    // end the gesture if needed
    if (event === 'TouchEnd') {
      if (model.currentGesture === 'Pinch') {
        publicAPI.render();
        publicAPI.endPinchEvent();
      }
      if (model.currentGesture === 'Rotate') {
        publicAPI.render();
        publicAPI.endRotateEvent();
      }
      if (model.currentGesture === 'Pan') {
        publicAPI.render();
        publicAPI.endPanEvent();
      }
      model.currentGesture = 'Start';
      model.startingEventPositions = {};
      return;
    }

    // what are the two pointers we are working with
    let count = 0;
    const posVals = [];
    const startVals = [];
    Object.keys(positions).forEach((key) => {
      posVals[count] = positions[key];
      startVals[count] = model.startingEventPositions[key];
      count++;
    });

    // The meat of the algorithm
    // on move events we analyze them to determine what type
    // of movement it is and then deal with it.
    // calculate the distances
    const originalDistance = Math.sqrt(
      (startVals[0].x - startVals[1].x) * (startVals[0].x - startVals[1].x) +
        (startVals[0].y - startVals[1].y) * (startVals[0].y - startVals[1].y)
    );
    const newDistance = Math.sqrt(
      (posVals[0].x - posVals[1].x) * (posVals[0].x - posVals[1].x) +
        (posVals[0].y - posVals[1].y) * (posVals[0].y - posVals[1].y)
    );

    // calculate rotations
    let originalAngle = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["degreesFromRadians"](
      Math.atan2(
        startVals[1].y - startVals[0].y,
        startVals[1].x - startVals[0].x
      )
    );
    let newAngle = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_1__["degreesFromRadians"](
      Math.atan2(posVals[1].y - posVals[0].y, posVals[1].x - posVals[0].x)
    );

    // angles are cyclic so watch for that, 1 and 359 are only 2 apart :)
    let angleDeviation = newAngle - originalAngle;
    newAngle = newAngle + 180.0 >= 360.0 ? newAngle - 180.0 : newAngle + 180.0;
    originalAngle =
      originalAngle + 180.0 >= 360.0
        ? originalAngle - 180.0
        : originalAngle + 180.0;
    if (Math.abs(newAngle - originalAngle) < Math.abs(angleDeviation)) {
      angleDeviation = newAngle - originalAngle;
    }

    // calculate the translations
    const trans = [];
    trans[0] =
      (posVals[0].x - startVals[0].x + posVals[1].x - startVals[1].x) / 2.0;
    trans[1] =
      (posVals[0].y - startVals[0].y + posVals[1].y - startVals[1].y) / 2.0;

    if (event === 'TouchMove') {
      // OK we want to
      // - immediately respond to the user
      // - allow the user to zoom without panning (saves focal point)
      // - allow the user to rotate without panning (saves focal point)

      // do we know what gesture we are doing yet? If not
      // see if we can figure it out
      if (model.currentGesture === 'Start') {
        // pinch is a move to/from the center point
        // rotate is a move along the circumference
        // pan is a move of the center point
        // compute the distance along each of these axes in pixels
        // the first to break thresh wins
        let thresh =
          0.01 *
          Math.sqrt(
            model.container.clientWidth * model.container.clientWidth +
              model.container.clientHeight * model.container.clientHeight
          );
        if (thresh < 15.0) {
          thresh = 15.0;
        }
        const pinchDistance = Math.abs(newDistance - originalDistance);
        const rotateDistance =
          (newDistance * 3.1415926 * Math.abs(angleDeviation)) / 360.0;
        const panDistance = Math.sqrt(
          trans[0] * trans[0] + trans[1] * trans[1]
        );
        if (
          pinchDistance > thresh &&
          pinchDistance > rotateDistance &&
          pinchDistance > panDistance
        ) {
          model.currentGesture = 'Pinch';
          const callData = {
            scale: 1.0,
            touches: positions,
          };
          publicAPI.startPinchEvent(callData);
        } else if (rotateDistance > thresh && rotateDistance > panDistance) {
          model.currentGesture = 'Rotate';
          const callData = {
            rotation: 0.0,
            touches: positions,
          };
          publicAPI.startRotateEvent(callData);
        } else if (panDistance > thresh) {
          model.currentGesture = 'Pan';
          const callData = {
            translation: [0, 0],
            touches: positions,
          };
          publicAPI.startPanEvent(callData);
        }
      } else {
        // if we have found a specific type of movement then
        // handle it
        if (model.currentGesture === 'Rotate') {
          const callData = {
            rotation: angleDeviation,
            touches: positions,
          };
          publicAPI.rotateEvent(callData);
        }

        if (model.currentGesture === 'Pinch') {
          const callData = {
            scale: newDistance / originalDistance,
            touches: positions,
          };
          publicAPI.pinchEvent(callData);
        }

        if (model.currentGesture === 'Pan') {
          const callData = {
            translation: trans,
            touches: positions,
          };
          publicAPI.panEvent(callData);
        }
      }
    }
  };

  publicAPI.handleVisibilityChange = () => {
    model.lastFrameStart = Date.now();
  };

  // Stop animating if the renderWindowInteractor is deleted.
  const superDelete = publicAPI.delete;
  publicAPI.delete = () => {
    while (animationRequesters.size) {
      publicAPI.cancelAnimation(animationRequesters.values().next().value);
    }
    if (typeof document.hidden !== 'undefined') {
      document.removeEventListener(
        'visibilitychange',
        publicAPI.handleVisibilityChange
      );
    }
    superDelete();
  };

  // Use the Page Visibility API to detect when we switch away from or back to
  // this tab, and reset the lastFrameStart. When tabs are not active, browsers
  // will stop calling requestAnimationFrame callbacks.
  if (typeof document.hidden !== 'undefined') {
    document.addEventListener(
      'visibilitychange',
      publicAPI.handleVisibilityChange,
      false
    );
  }
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  renderWindow: null,
  interactorStyle: null,
  picker: null,
  pickingManager: null,
  initialized: false,
  enabled: false,
  enableRender: true,
  currentRenderer: null,
  lightFollowCamera: true,
  desiredUpdateRate: 30.0,
  stillUpdateRate: 2.0,
  container: null,
  view: null,
  recognizeGestures: true,
  currentGesture: 'Start',
  animationRequest: null,
  lastFrameTime: 0.1,
  wheelTimeoutID: 0,
  moveTimeoutID: 0,
  lastGamepadValues: {},
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].event(publicAPI, model, 'RenderEvent');
  handledEvents.forEach((eventName) =>
    vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].event(publicAPI, model, eventName)
  );

  // Create get-only macros
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, [
    'initialized',
    'container',
    'enabled',
    'enableRender',
    'interactorStyle',
    'lastFrameTime',
    'view',
  ]);

  // Create get-set macros
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'lightFollowCamera',
    'enabled',
    'recognizeGestures',
    'desiredUpdateRate',
    'stillUpdateRate',
    'picker',
  ]);

  // For more macro methods, see "Sources/macro.js"

  // Object specific methods
  vtkRenderWindowInteractor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(
  extend,
  'vtkRenderWindowInteractor'
);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, handledEvents, ...vtk_js_Sources_Rendering_Core_RenderWindowInteractor_Constants__WEBPACK_IMPORTED_MODULE_2__["default"] });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/Renderer/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/Renderer/index.js ***!
  \**********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Camera */ "./node_modules/vtk.js/Sources/Rendering/Core/Camera/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Light__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Light */ "./node_modules/vtk.js/Sources/Rendering/Core/Light/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Viewport__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Viewport */ "./node_modules/vtk.js/Sources/Rendering/Core/Viewport/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/BoundingBox */ "./node_modules/vtk.js/Sources/Common/DataModel/BoundingBox/index.js");









const { vtkDebugMacro, vtkErrorMacro, vtkWarningMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__;

function notImplemented(method) {
  return () => vtkErrorMacro(`vtkRenderer::${method} - NOT IMPLEMENTED`);
}

// ----------------------------------------------------------------------------
// vtkRenderer methods
// ----------------------------------------------------------------------------

function vtkRenderer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkRenderer');

  // make sure background has 4 entries. Default to opaque black
  if (!model.background) model.background = [0, 0, 0, 1];
  while (model.background.length < 3) model.background.push(0);
  if (model.background.length === 3) model.background.push(1);

  // Events
  const COMPUTE_VISIBLE_PROP_BOUNDS_EVENT = {
    type: 'ComputeVisiblePropBoundsEvent',
    renderer: publicAPI,
  };
  const RESET_CAMERA_CLIPPING_RANGE_EVENT = {
    type: 'ResetCameraClippingRangeEvent',
    renderer: publicAPI,
  };
  const RESET_CAMERA_EVENT = {
    type: 'ResetCameraEvent',
    renderer: publicAPI,
  };

  publicAPI.updateCamera = () => {
    if (!model.activeCamera) {
      vtkDebugMacro('No cameras are on, creating one.');
      // the get method will automagically create a camera
      // and reset it since one hasn't been specified yet.
      publicAPI.getActiveCameraAndResetIfCreated();
    }

    // update the viewing transformation
    model.activeCamera.render(publicAPI);

    return true;
  };

  publicAPI.updateLightsGeometryToFollowCamera = () => {
    // only update the light's geometry if this Renderer is tracking
    // this lights.  That allows one renderer to view the lights that
    // another renderer is setting up.
    const camera = publicAPI.getActiveCameraAndResetIfCreated();

    model.lights.forEach((light) => {
      if (light.lightTypeIsSceneLight() || light.lightTypeIsCameraLight()) {
        // Do nothing. Don't reset the transform matrix because applications
        // may have set a custom matrix. Only reset the transform matrix in
        // vtkLight::SetLightTypeToSceneLight()
      } else if (light.lightTypeIsHeadLight()) {
        // update position and orientation of light to match camera.
        light.setPositionFrom(camera.getPositionByReference());
        light.setFocalPointFrom(camera.getFocalPointByReference());
        light.modified(camera.getMTime());
      } else {
        vtkErrorMacro('light has unknown light type', light.get());
      }
    });
  };

  publicAPI.updateLightGeometry = () => {
    if (model.lightFollowCamera) {
      // only update the light's geometry if this Renderer is tracking
      // this lights.  That allows one renderer to view the lights that
      // another renderer is setting up.
      return publicAPI.updateLightsGeometryToFollowCamera();
    }
    return true;
  };

  publicAPI.allocateTime = notImplemented('allocateTime');
  publicAPI.updateGeometry = notImplemented('updateGeometry');

  publicAPI.getVTKWindow = () => model.renderWindow;

  publicAPI.setLayer = (layer) => {
    vtkDebugMacro(
      publicAPI.getClassName(),
      publicAPI,
      'setting Layer to ',
      layer
    );
    if (model.layer !== layer) {
      model.layer = layer;
      publicAPI.modified();
    }
    publicAPI.setPreserveColorBuffer(!!layer);
  };

  publicAPI.setActiveCamera = (camera) => {
    if (model.activeCamera === camera) {
      return false;
    }

    model.activeCamera = camera;
    publicAPI.modified();
    publicAPI.invokeEvent({ type: 'ActiveCameraEvent', camera });
    return true;
  };

  publicAPI.makeCamera = () => {
    const camera = vtk_js_Sources_Rendering_Core_Camera__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
    publicAPI.invokeEvent({ type: 'CreateCameraEvent', camera });
    return camera;
  };

  // Replace the set/get macro method
  publicAPI.getActiveCamera = () => {
    if (!model.activeCamera) {
      model.activeCamera = publicAPI.makeCamera();
    }
    return model.activeCamera;
  };

  publicAPI.getActiveCameraAndResetIfCreated = () => {
    if (!model.activeCamera) {
      publicAPI.getActiveCamera();
      publicAPI.resetCamera();
    }
    return model.activeCamera;
  };

  publicAPI.getActors = () => {
    model.actors = [];
    model.props.forEach((prop) => {
      model.actors = model.actors.concat(prop.getActors());
    });
    return model.actors;
  };
  publicAPI.addActor = publicAPI.addViewProp;
  publicAPI.removeActor = (actor) => {
    model.actors = model.actors.filter((a) => a !== actor);
    publicAPI.removeViewProp(actor);
    publicAPI.modified();
  };
  publicAPI.removeAllActors = () => {
    model.actors.forEach((actor) => {
      publicAPI.removeViewProp(actor);
    });
    model.actors = [];
    publicAPI.modified();
  };

  publicAPI.getVolumes = () => {
    model.volumes = [];
    model.props.forEach((prop) => {
      model.volumes = model.volumes.concat(prop.getVolumes());
    });
    return model.volumes;
  };
  publicAPI.addVolume = publicAPI.addViewProp;
  publicAPI.removeVolume = (volume) => {
    model.volumes = model.volumes.filter((v) => v !== volume);
    publicAPI.removeViewProp(volume);
    publicAPI.modified();
  };
  publicAPI.removeAllVolumes = () => {
    model.volumes.forEach((volume) => {
      publicAPI.removeViewProp(volume);
    });
    model.volumes = [];
    publicAPI.modified();
  };

  publicAPI.addLight = (light) => {
    model.lights = [].concat(model.lights, light);
    publicAPI.modified();
  };
  publicAPI.removeLight = (light) => {
    model.lights = model.lights.filter((l) => l !== light);
    publicAPI.modified();
  };
  publicAPI.removeAllLights = () => {
    model.lights = [];
    publicAPI.modified();
  };
  publicAPI.setLightCollection = (lights) => {
    model.lights = lights;
    publicAPI.modified();
  };

  publicAPI.makeLight = vtk_js_Sources_Rendering_Core_Light__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance;

  publicAPI.createLight = () => {
    if (!model.automaticLightCreation) {
      return;
    }

    if (model.createdLight) {
      publicAPI.removeLight(model.createdLight);
      model.createdLight.delete();
      model.createdLight = null;
    }

    model.createdLight = publicAPI.makeLight();
    publicAPI.addLight(model.createdLight);

    model.createdLight.setLightTypeToHeadLight();

    // set these values just to have a good default should LightFollowCamera
    // be turned off.
    model.createdLight.setPosition(publicAPI.getActiveCamera().getPosition());
    model.createdLight.setFocalPoint(
      publicAPI.getActiveCamera().getFocalPoint()
    );
  };

  // requires the aspect ratio of the viewport as X/Y
  publicAPI.normalizedDisplayToWorld = (x, y, z, aspect) => {
    let vpd = publicAPI.normalizedDisplayToProjection(x, y, z);
    vpd = publicAPI.projectionToView(vpd[0], vpd[1], vpd[2], aspect);

    return publicAPI.viewToWorld(vpd[0], vpd[1], vpd[2]);
  };

  // requires the aspect ratio of the viewport as X/Y
  publicAPI.worldToNormalizedDisplay = (x, y, z, aspect) => {
    let vpd = publicAPI.worldToView(x, y, z);
    vpd = publicAPI.viewToProjection(vpd[0], vpd[1], vpd[2], aspect);

    return publicAPI.projectionToNormalizedDisplay(vpd[0], vpd[1], vpd[2]);
  };

  // requires the aspect ratio of the viewport as X/Y
  publicAPI.viewToWorld = (x, y, z) => {
    if (model.activeCamera === null) {
      vtkErrorMacro(
        'ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0'
      );
      return [0, 0, 0];
    }

    // get the view matrix from the active camera
    const matrix = model.activeCamera.getViewMatrix();

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].invert(matrix, matrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(matrix, matrix);

    // Transform point to world coordinates
    const result = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(x, y, z);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(result, result, matrix);
    return [result[0], result[1], result[2]];
  };

  publicAPI.projectionToView = (x, y, z, aspect) => {
    if (model.activeCamera === null) {
      vtkErrorMacro(
        'ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0'
      );
      return [0, 0, 0];
    }

    // get the projection transformation from the active camera
    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);

    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].invert(matrix, matrix);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(matrix, matrix);

    // Transform point to world coordinates
    const result = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(x, y, z);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(result, result, matrix);
    return [result[0], result[1], result[2]];
  };

  // Convert world point coordinates to view coordinates.
  publicAPI.worldToView = (x, y, z) => {
    if (model.activeCamera === null) {
      vtkErrorMacro(
        'WorldToView: no active camera, cannot compute view to world, returning 0,0,0'
      );
      return [0, 0, 0];
    }

    // get the view transformation from the active camera
    const matrix = model.activeCamera.getViewMatrix();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(matrix, matrix);

    const result = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(x, y, z);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(result, result, matrix);
    return [result[0], result[1], result[2]];
  };

  // Convert world point coordinates to view coordinates.
  // requires the aspect ratio of the viewport as X/Y
  publicAPI.viewToProjection = (x, y, z, aspect) => {
    if (model.activeCamera === null) {
      vtkErrorMacro(
        'ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0'
      );
      return [0, 0, 0];
    }

    // get the projeciton transformation from the active camera
    const matrix = model.activeCamera.getProjectionMatrix(aspect, -1.0, 1.0);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(matrix, matrix);

    const result = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(x, y, z);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(result, result, matrix);
    return [result[0], result[1], result[2]];
  };

  publicAPI.computeVisiblePropBounds = () => {
    model.allBounds[0] = vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_6__["default"].INIT_BOUNDS[0];
    model.allBounds[1] = vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_6__["default"].INIT_BOUNDS[1];
    model.allBounds[2] = vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_6__["default"].INIT_BOUNDS[2];
    model.allBounds[3] = vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_6__["default"].INIT_BOUNDS[3];
    model.allBounds[4] = vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_6__["default"].INIT_BOUNDS[4];
    model.allBounds[5] = vtk_js_Sources_Common_DataModel_BoundingBox__WEBPACK_IMPORTED_MODULE_6__["default"].INIT_BOUNDS[5];
    let nothingVisible = true;

    publicAPI.invokeEvent(COMPUTE_VISIBLE_PROP_BOUNDS_EVENT);

    // loop through all props
    for (let index = 0; index < model.props.length; ++index) {
      const prop = model.props[index];
      if (prop.getVisibility() && prop.getUseBounds()) {
        const bounds = prop.getBounds();
        if (bounds && vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__["areBoundsInitialized"](bounds)) {
          nothingVisible = false;

          if (bounds[0] < model.allBounds[0]) {
            model.allBounds[0] = bounds[0];
          }
          if (bounds[1] > model.allBounds[1]) {
            model.allBounds[1] = bounds[1];
          }
          if (bounds[2] < model.allBounds[2]) {
            model.allBounds[2] = bounds[2];
          }
          if (bounds[3] > model.allBounds[3]) {
            model.allBounds[3] = bounds[3];
          }
          if (bounds[4] < model.allBounds[4]) {
            model.allBounds[4] = bounds[4];
          }
          if (bounds[5] > model.allBounds[5]) {
            model.allBounds[5] = bounds[5];
          }
        }
      }
    }

    if (nothingVisible) {
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__["uninitializeBounds"](model.allBounds);
      vtkDebugMacro("Can't compute bounds, no 3D props are visible");
    }

    return model.allBounds;
  };

  publicAPI.resetCamera = (bounds = null) => {
    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();
    const center = [0, 0, 0];

    if (!vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__["areBoundsInitialized"](boundsToUse)) {
      vtkDebugMacro('Cannot reset camera!');
      return false;
    }

    let vn = null;

    if (publicAPI.getActiveCamera()) {
      vn = model.activeCamera.getViewPlaneNormal();
    } else {
      vtkErrorMacro('Trying to reset non-existent camera');
      return false;
    }

    // Reset the perspective zoom factors, otherwise subsequent zooms will cause
    // the view angle to become very small and cause bad depth sorting.
    model.activeCamera.setViewAngle(30.0);

    center[0] = (boundsToUse[0] + boundsToUse[1]) / 2.0;
    center[1] = (boundsToUse[2] + boundsToUse[3]) / 2.0;
    center[2] = (boundsToUse[4] + boundsToUse[5]) / 2.0;

    let w1 = boundsToUse[1] - boundsToUse[0];
    let w2 = boundsToUse[3] - boundsToUse[2];
    let w3 = boundsToUse[5] - boundsToUse[4];
    w1 *= w1;
    w2 *= w2;
    w3 *= w3;
    let radius = w1 + w2 + w3;

    // If we have just a single point, pick a radius of 1.0
    radius = radius === 0 ? 1.0 : radius;

    // compute the radius of the enclosing sphere
    radius = Math.sqrt(radius) * 0.5;

    // default so that the bounding sphere fits within the view fustrum

    // compute the distance from the intersection of the view frustum with the
    // bounding sphere. Basically in 2D draw a circle representing the bounding
    // sphere in 2D then draw a horizontal line going out from the center of
    // the circle. That is the camera view. Then draw a line from the camera
    // position to the point where it intersects the circle. (it will be tangent
    // to the circle at this point, this is important, only go to the tangent
    // point, do not draw all the way to the view plane). Then draw the radius
    // from the tangent point to the center of the circle. You will note that
    // this forms a right triangle with one side being the radius, another being
    // the target distance for the camera, then just find the target dist using
    // a sin.
    const angle = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__["radiansFromDegrees"](model.activeCamera.getViewAngle());
    const parallelScale = radius;
    const distance = radius / Math.sin(angle * 0.5);

    // check view-up vector against view plane normal
    const vup = model.activeCamera.getViewUp();
    if (Math.abs(vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__["dot"](vup, vn)) > 0.999) {
      vtkWarningMacro('Resetting view-up since view plane normal is parallel');
      model.activeCamera.setViewUp(-vup[2], vup[0], vup[1]);
    }

    // update the camera
    model.activeCamera.setFocalPoint(center[0], center[1], center[2]);
    model.activeCamera.setPosition(
      center[0] + distance * vn[0],
      center[1] + distance * vn[1],
      center[2] + distance * vn[2]
    );

    publicAPI.resetCameraClippingRange(boundsToUse);

    // setup default parallel scale
    model.activeCamera.setParallelScale(parallelScale);

    // update reasonable world to physical values
    model.activeCamera.setPhysicalScale(radius);
    model.activeCamera.setPhysicalTranslation(
      -center[0],
      -center[1],
      -center[2]
    );

    // Here to let parallel/distributed compositing intercept
    // and do the right thing.
    publicAPI.invokeEvent(RESET_CAMERA_EVENT);

    return true;
  };

  publicAPI.resetCameraClippingRange = (bounds = null) => {
    const boundsToUse = bounds || publicAPI.computeVisiblePropBounds();

    if (!vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__["areBoundsInitialized"](boundsToUse)) {
      vtkDebugMacro('Cannot reset camera clipping range!');
      return false;
    }

    // Make sure we have an active camera
    publicAPI.getActiveCameraAndResetIfCreated();
    if (!model.activeCamera) {
      vtkErrorMacro('Trying to reset clipping range of non-existent camera');
      return false;
    }

    // Get the exact range for the bounds
    const range = model.activeCamera.computeClippingRange(boundsToUse);

    // do not let far - near be less than 0.1 of the window height
    // this is for cases such as 2D images which may have zero range
    let minGap = 0.0;
    if (model.activeCamera.getParallelProjection()) {
      minGap = 0.1 * model.activeCamera.getParallelScale();
    } else {
      const angle = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__["radiansFromDegrees"](
        model.activeCamera.getViewAngle()
      );
      minGap = 0.2 * Math.tan(angle / 2.0) * range[1];
    }

    if (range[1] - range[0] < minGap) {
      minGap = minGap - range[1] + range[0];
      range[1] += minGap / 2.0;
      range[0] -= minGap / 2.0;
    }

    // Do not let the range behind the camera throw off the calculation.
    if (range[0] < 0.0) {
      range[0] = 0.0;
    }

    // Give ourselves a little breathing room
    range[0] =
      0.99 * range[0] - (range[1] - range[0]) * model.clippingRangeExpansion;
    range[1] =
      1.01 * range[1] + (range[1] - range[0]) * model.clippingRangeExpansion;

    // Make sure near is not bigger than far
    range[0] = range[0] >= range[1] ? 0.01 * range[1] : range[0];

    // Make sure near is at least some fraction of far - this prevents near
    // from being behind the camera or too close in front. How close is too
    // close depends on the resolution of the depth buffer
    if (!model.nearClippingPlaneTolerance) {
      model.nearClippingPlaneTolerance = 0.01;
    }

    // make sure the front clipping range is not too far from the far clippnig
    // range, this is to make sure that the zbuffer resolution is effectively
    // used
    if (range[0] < model.nearClippingPlaneTolerance * range[1]) {
      range[0] = model.nearClippingPlaneTolerance * range[1];
    }
    model.activeCamera.setClippingRange(range[0], range[1]);

    // Here to let parallel/distributed compositing intercept
    // and do the right thing.
    publicAPI.invokeEvent(RESET_CAMERA_CLIPPING_RANGE_EVENT);
    return false;
  };

  publicAPI.setRenderWindow = (renderWindow) => {
    if (renderWindow !== model.renderWindow) {
      model.vtkWindow = renderWindow;
      model.renderWindow = renderWindow;
    }
  };

  publicAPI.visibleActorCount = () =>
    model.props.filter((prop) => prop.getVisibility()).length;
  publicAPI.visibleVolumeCount = publicAPI.visibleActorCount;

  publicAPI.getMTime = () => {
    let m1 = model.mtime;
    const m2 = model.activeCamera ? model.activeCamera.getMTime() : 0;
    if (m2 > m1) {
      m1 = m2;
    }
    const m3 = model.createdLight ? model.createdLight.getMTime() : 0;
    if (m3 > m1) {
      m1 = m3;
    }
    return m1;
  };

  publicAPI.getTransparent = () => !!model.preserveColorBuffer;

  publicAPI.isActiveCameraCreated = () => !!model.activeCamera;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  pickedProp: null,
  activeCamera: null,

  allBounds: [],
  ambient: [1, 1, 1],

  allocatedRenderTime: 100,
  timeFactor: 1,

  createdLight: null,
  automaticLightCreation: true,

  twoSidedLighting: true,
  lastRenderTimeInSeconds: -1,

  renderWindow: null,
  lights: [],
  actors: [],
  volumes: [],

  lightFollowCamera: true,

  numberOfPropsRendered: 0,

  propArray: null,

  pathArray: null,

  layer: 0,
  preserveColorBuffer: false,
  preserveDepthBuffer: false,

  computeVisiblePropBounds: vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__["createUninitializedBounds"](),

  interactive: true,

  nearClippingPlaneTolerance: 0,
  clippingRangeExpansion: 0.05,

  erase: true,
  draw: true,

  useShadows: false,

  useDepthPeeling: false,
  occlusionRatio: 0,
  maximumNumberOfPeels: 4,

  selector: null,
  delegate: null,

  texturedBackground: false,
  backgroundTexture: null,

  pass: 0,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_Core_Viewport__WEBPACK_IMPORTED_MODULE_5__["default"].extend(publicAPI, model, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["get"](publicAPI, model, [
    'renderWindow',

    'allocatedRenderTime',
    'timeFactor',

    'lastRenderTimeInSeconds',
    'numberOfPropsRendered',
    'lastRenderingUsedDepthPeeling',

    'selector',
  ]);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["setGet"](publicAPI, model, [
    'twoSidedLighting',
    'lightFollowCamera',
    'automaticLightCreation',
    'erase',
    'draw',
    'nearClippingPlaneTolerance',
    'clippingRangeExpansion',
    'backingStore',
    'interactive',
    'layer',
    'preserveColorBuffer',
    'preserveDepthBuffer',
    'useDepthPeeling',
    'occlusionRatio',
    'maximumNumberOfPeels',
    'delegate',
    'backgroundTexture',
    'texturedBackground',
    'useShadows',
    'pass',
  ]);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["getArray"](publicAPI, model, ['actors', 'volumes', 'lights']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["setGetArray"](publicAPI, model, ['background'], 4, 1.0);

  // Object methods
  vtkRenderer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["newInstance"](extend, 'vtkRenderer');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/Viewport/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/Viewport/index.js ***!
  \**********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");


const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

function notImplemented(method) {
  return () => vtkErrorMacro(`vtkViewport::${method} - NOT IMPLEMENTED`);
}

// ----------------------------------------------------------------------------
// vtkViewport methods
// ----------------------------------------------------------------------------

function vtkViewport(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkViewport');

  // Public API methods
  publicAPI.getViewProps = () => model.props;
  publicAPI.hasViewProp = (prop) =>
    !!model.props.filter((item) => item === prop).length;
  publicAPI.addViewProp = (prop) => {
    if (prop && !publicAPI.hasViewProp(prop)) {
      model.props = model.props.concat(prop);
    }
  };

  publicAPI.removeViewProp = (prop) => {
    const newPropList = model.props.filter((item) => item !== prop);
    if (model.props.length !== newPropList.length) {
      model.props = newPropList;
    }
  };

  publicAPI.removeAllViewProps = () => {
    model.props = [];
  };

  // this method get all the props including any nested props
  function gatherProps(prop, allProps = []) {
    allProps.push(prop);
    const children = prop.getNestedProps();
    if (children && children.length) {
      for (let i = 0; i < children.length; i++) {
        gatherProps(children[i], allProps);
      }
    }
    return allProps;
  }

  publicAPI.getViewPropsWithNestedProps = () => {
    const allPropsArray = [];
    for (let i = 0; i < model.props.length; i++) {
      gatherProps(model.props[i], allPropsArray);
    }
    return allPropsArray;
  };

  publicAPI.addActor2D = publicAPI.addViewProp;
  publicAPI.removeActor2D = (prop) => {
    // VTK way: model.actors2D.RemoveItem(prop);
    publicAPI.removeViewProp(prop);
  };

  publicAPI.getActors2D = () => {
    model.actors2D = [];
    model.props.forEach((prop) => {
      model.actors2D = model.actors2D.concat(prop.getActors2D());
    });
    return model.actors2D;
  };

  publicAPI.displayToView = () =>
    vtkErrorMacro('call displayToView on your view instead');
  publicAPI.viewToDisplay = () =>
    vtkErrorMacro('callviewtodisplay on your view instead');
  publicAPI.getSize = () => vtkErrorMacro('call getSize on your View instead');

  publicAPI.normalizedDisplayToProjection = (x, y, z) => {
    // first to normalized viewport
    const nvp = publicAPI.normalizedDisplayToNormalizedViewport(x, y, z);

    // then to view
    return publicAPI.normalizedViewportToProjection(nvp[0], nvp[1], nvp[2]);
  };

  publicAPI.normalizedDisplayToNormalizedViewport = (x, y, z) => {
    const scale = [
      model.viewport[2] - model.viewport[0],
      model.viewport[3] - model.viewport[1],
    ];
    return [
      (x - model.viewport[0]) / scale[0],
      (y - model.viewport[1]) / scale[1],
      z,
    ];
  };

  publicAPI.normalizedViewportToProjection = (x, y, z) => [
    x * 2.0 - 1.0,
    y * 2.0 - 1.0,
    z * 2.0 - 1.0,
  ];

  publicAPI.projectionToNormalizedDisplay = (x, y, z) => {
    // first to nvp
    const nvp = publicAPI.projectionToNormalizedViewport(x, y, z);

    // then to ndp
    return publicAPI.normalizedViewportToNormalizedDisplay(
      nvp[0],
      nvp[1],
      nvp[2]
    );
  };

  publicAPI.normalizedViewportToNormalizedDisplay = (x, y, z) => {
    const scale = [
      model.viewport[2] - model.viewport[0],
      model.viewport[3] - model.viewport[1],
    ];
    return [
      x * scale[0] + model.viewport[0],
      y * scale[1] + model.viewport[1],
      z,
    ];
  };

  publicAPI.projectionToNormalizedViewport = (x, y, z) => [
    (x + 1.0) * 0.5,
    (y + 1.0) * 0.5,
    (z + 1.0) * 0.5,
  ];

  publicAPI.PickPropFrom = notImplemented('PickPropFrom');
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  vtkWindow: null,
  background: [0, 0, 0],
  background2: [0.2, 0.2, 0.2],
  gradientBackground: false,
  viewport: [0, 0, 1, 1],
  aspect: [1, 1],
  pixelAspect: [1, 1],
  props: [],
  actors2D: [],
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].event(publicAPI, model, 'event');

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGetArray(publicAPI, model, ['viewport'], 4);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGetArray(publicAPI, model, ['background', 'background2'], 3);

  vtkViewport(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkViewport');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/VolumeMapper/Constants.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/VolumeMapper/Constants.js ***!
  \******************************************************************************/
/*! exports provided: BlendMode, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlendMode", function() { return BlendMode; });
const BlendMode = {
  COMPOSITE_BLEND: 0,
  MAXIMUM_INTENSITY_BLEND: 1,
  MINIMUM_INTENSITY_BLEND: 2,
  AVERAGE_INTENSITY_BLEND: 3,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  BlendMode,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/Core/VolumeProperty/Constants.js":
/*!********************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/Core/VolumeProperty/Constants.js ***!
  \********************************************************************************/
/*! exports provided: InterpolationType, OpacityMode, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolationType", function() { return InterpolationType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OpacityMode", function() { return OpacityMode; });
const InterpolationType = {
  NEAREST: 0,
  LINEAR: 1,
  FAST_LINEAR: 2,
};

const OpacityMode = {
  FRACTIONAL: 0,
  PROPORTIONAL: 1,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  InterpolationType,
  OpacityMode,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Actor/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/Actor/index.js ***!
  \*********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/ViewNode */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js");





// ----------------------------------------------------------------------------
// vtkOpenGLActor methods
// ----------------------------------------------------------------------------

function vtkOpenGLActor(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLActor');

  // Builds myself.
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.openGLRenderWindow = publicAPI.getFirstAncestorOfType(
        'vtkOpenGLRenderWindow'
      );
      model.openGLRenderer = publicAPI.getFirstAncestorOfType(
        'vtkOpenGLRenderer'
      );
      model.context = model.openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getTextures());
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();

      // we store textures and mapper
      model.ogltextures = null;
      model.activeTextures = null;
      for (let index = 0; index < model.children.length; index++) {
        const child = model.children[index];
        if (child.isA('vtkOpenGLTexture')) {
          if (!model.ogltextures) {
            model.ogltextures = [];
          }
          model.ogltextures.push(child);
        } else {
          model.oglmapper = child;
        }
      }
    }
  };

  publicAPI.traverseOpaqueZBufferPass = (renderPass) => {
    publicAPI.traverseOpaquePass(renderPass);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (
      !model.renderable ||
      !model.renderable.getVisibility() ||
      !model.renderable.getIsOpaque() ||
      (model.openGLRenderer.getSelector() && !model.renderable.getPickable())
    ) {
      return;
    }

    publicAPI.apply(renderPass, true);

    model.oglmapper.traverse(renderPass);

    publicAPI.apply(renderPass, false);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (
      !model.renderable ||
      !model.renderable.getVisibility() ||
      model.renderable.getIsOpaque() ||
      (model.openGLRenderer.getSelector() && !model.renderable.getPickable())
    ) {
      return;
    }

    publicAPI.apply(renderPass, true);

    model.oglmapper.traverse(renderPass);

    publicAPI.apply(renderPass, false);
  };

  publicAPI.activateTextures = () => {
    // always traverse textures first, then mapper
    if (!model.ogltextures) {
      return;
    }

    model.activeTextures = [];
    for (let index = 0; index < model.ogltextures.length; index++) {
      const child = model.ogltextures[index];
      child.render();
      if (child.getHandle()) {
        model.activeTextures.push(child);
      }
    }
  };

  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };

  publicAPI.opaqueZBufferPass = (prepass, renderPass) =>
    publicAPI.opaquePass(prepass, renderPass);

  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.openGLRenderWindow.enableDepthMask();
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };

  // Renders myself
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.openGLRenderWindow.disableDepthMask();
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index = 0; index < model.activeTextures.length; index++) {
        model.activeTextures[index].deactivate();
      }
    }
  };

  publicAPI.getKeyMatrices = () => {
    // has the actor changed?
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);

      if (model.renderable.getIsIdentity()) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].identity(model.keyMatrices.normalMatrix);
      } else {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.mcwc);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].invert(
          model.keyMatrices.normalMatrix,
          model.keyMatrices.normalMatrix
        );
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].transpose(
          model.keyMatrices.normalMatrix,
          model.keyMatrices.normalMatrix
        );
      }
      model.keyMatrixTime.modified();
    }

    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  keyMatrixTime: null,
  keyMatrices: null,
  activeTextures: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_2__["default"].extend(publicAPI, model, initialValues);

  model.keyMatrixTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(model.keyMatrixTime, { mtime: 0 });
  model.keyMatrices = {
    normalMatrix: gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].create(),
    mcwc: gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create(),
  };

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGet(publicAPI, model, ['context']);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].get(publicAPI, model, ['activeTextures']);

  // Object methods
  vtkOpenGLActor(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Actor2D/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/Actor2D/index.js ***!
  \***********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var _macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var _SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../SceneGraph/ViewNode */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js");



// ----------------------------------------------------------------------------
// vtkOpenGLActor methods
// ----------------------------------------------------------------------------

function vtkOpenGLActor2D(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLActor2D');

  // Builds myself.
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.openGLRenderer = publicAPI.getFirstAncestorOfType(
        'vtkOpenGLRenderer'
      );
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getTextures());
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (
      !model.renderable ||
      !model.renderable.getVisibility() ||
      !model.renderable.getIsOpaque() ||
      (model.openGLRenderer.getSelector() && !model.renderable.getPickable())
    ) {
      return;
    }

    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      if (!child.isA('vtkOpenGLTexture')) {
        child.traverse(renderPass);
      }
    });
    publicAPI.apply(renderPass, false);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (
      !model.renderable ||
      !model.renderable.getVisibility() ||
      model.renderable.getIsOpaque() ||
      (model.openGLRenderer.getSelector() && !model.renderable.getPickable())
    ) {
      return;
    }

    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      if (!child.isA('vtkOpenGLTexture')) {
        child.traverse(renderPass);
      }
    });
    publicAPI.apply(renderPass, false);
  };

  publicAPI.activateTextures = () => {
    // always traverse textures first, then mapper
    model.activeTextures = [];
    model.children.forEach((child) => {
      if (child.isA('vtkOpenGLTexture')) {
        child.render();
        if (child.getHandle()) {
          model.activeTextures.push(child);
        }
      }
    });
  };

  // Renders myself
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context = publicAPI
        .getFirstAncestorOfType('vtkOpenGLRenderWindow')
        .getContext();
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else {
      // deactivate textures
      model.activeTextures.forEach((child) => {
        child.deactivate();
      });
    }
  };

  // Renders myself
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.context = publicAPI
        .getFirstAncestorOfType('vtkOpenGLRenderWindow')
        .getContext();
      model.context.depthMask(false);
      publicAPI.activateTextures();
    } else {
      // deactivate textures
      model.activeTextures.forEach((child) => {
        child.deactivate();
      });
      model.context.depthMask(true);
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  activeTextures: [],
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_1__["default"].extend(publicAPI, model, initialValues);

  // Build VTK API
  _macro__WEBPACK_IMPORTED_MODULE_0__["setGet"](publicAPI, model, ['context']);

  _macro__WEBPACK_IMPORTED_MODULE_0__["get"](publicAPI, model, ['activeTextures']);

  // Object methods
  vtkOpenGLActor2D(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macro__WEBPACK_IMPORTED_MODULE_0__["newInstance"](extend);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants.js":
/*!********************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants.js ***!
  \********************************************************************************/
/*! exports provided: ObjectType, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectType", function() { return ObjectType; });
const ObjectType = {
  ARRAY_BUFFER: 0,
  ELEMENT_ARRAY_BUFFER: 1,
  TEXTURE_BUFFER: 2,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  ObjectType,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/BufferObject/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/BufferObject/index.js ***!
  \****************************************************************************/
/*! exports provided: STATIC, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATIC", function() { return STATIC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants.js");



const { ObjectType } = vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_1__["default"];

// ----------------------------------------------------------------------------
// Global methods
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// Static API
// ----------------------------------------------------------------------------

const STATIC = {};

// ----------------------------------------------------------------------------
// vtkOpenGLBufferObject methods
// ----------------------------------------------------------------------------

function vtkOpenGLBufferObject(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLBufferObject');

  // Class-specific private functions
  function convertType(type) {
    switch (type) {
      case ObjectType.ELEMENT_ARRAY_BUFFER:
        return model.context.ELEMENT_ARRAY_BUFFER;
      case ObjectType.TEXTURE_BUFFER:
        if ('TEXTURE_BUFFER' in model.context) {
          return model.context.TEXTURE_BUFFER;
        }
      /* eslint-disable no-fallthrough */
      // Intentional fallthrough in case there is no TEXTURE_BUFFER in WebGL
      default:
      /* eslint-enable no-fallthrough */
      case ObjectType.ARRAY_BUFFER:
        return model.context.ARRAY_BUFFER;
    }
  }

  let internalType = null;
  let internalHandle = null;
  let dirty = true;
  let error = '';

  // Public API methods
  publicAPI.getType = () => internalType;

  publicAPI.setType = (value) => {
    internalType = value;
  };

  publicAPI.getHandle = () => internalHandle;
  publicAPI.isReady = () => dirty === false;

  publicAPI.generateBuffer = (type) => {
    const objectTypeGL = convertType(type);
    if (internalHandle === null) {
      internalHandle = model.context.createBuffer();
      internalType = type;
    }
    return convertType(internalType) === objectTypeGL;
  };

  publicAPI.upload = (data, type) => {
    // buffer, size, type
    const alreadyGenerated = publicAPI.generateBuffer(type);
    if (!alreadyGenerated) {
      error = 'Trying to upload array buffer to incompatible buffer.';
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    model.context.bufferData(
      convertType(internalType),
      data,
      model.context.STATIC_DRAW
    );
    dirty = false;
    return true;
  };

  publicAPI.bind = () => {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    return true;
  };

  publicAPI.release = () => {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), null);
    return true;
  };

  publicAPI.releaseGraphicsResources = () => {
    if (internalHandle !== null) {
      model.context.bindBuffer(convertType(internalType), null);
      model.context.deleteBuffer(internalHandle);
      internalHandle = null;
    }
  };

  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model.openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model.openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model.openGLRenderWindow.getContext();
    }
  };

  publicAPI.getError = () => error;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  objectType: ObjectType.ARRAY_BUFFER,
  openGLRenderWindow: null,
  context: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Object methods
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['openGLRenderWindow']);

  vtkOpenGLBufferObject(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...STATIC, ...vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_1__["default"] });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Camera/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/Camera/index.js ***!
  \**********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var _macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var _SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../SceneGraph/ViewNode */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js");





// ----------------------------------------------------------------------------
// vtkOpenGLCamera methods
// ----------------------------------------------------------------------------

function vtkOpenGLCamera(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLCamera');

  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.openGLRenderer = publicAPI.getFirstAncestorOfType(
        'vtkOpenGLRenderer'
      );
      model.openGLRenderWindow = model.openGLRenderer.getParent();
      model.context = model.openGLRenderWindow.getContext();
    }
  };

  // Renders myself
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      const tsize = model.openGLRenderer.getTiledSizeAndOrigin();
      model.context.viewport(
        tsize.lowerLeftU,
        tsize.lowerLeftV,
        tsize.usize,
        tsize.vsize
      );
      model.context.scissor(
        tsize.lowerLeftU,
        tsize.lowerLeftV,
        tsize.usize,
        tsize.vsize
      );
    }
  };
  publicAPI.translucentPass = publicAPI.opaquePass;
  publicAPI.opaqueZBufferPass = publicAPI.opaquePass;
  publicAPI.volumePass = publicAPI.opaquePass;

  publicAPI.getKeyMatrices = (ren) => {
    // has the camera changed?
    if (
      ren !== model.lastRenderer ||
      model.openGLRenderWindow.getMTime() > model.keyMatrixTime.getMTime() ||
      publicAPI.getMTime() > model.keyMatrixTime.getMTime() ||
      ren.getMTime() > model.keyMatrixTime.getMTime() ||
      model.renderable.getMTime() > model.keyMatrixTime.getMTime()
    ) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(model.keyMatrices.wcvc, model.renderable.getViewMatrix());

      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.wcvc);
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].invert(
        model.keyMatrices.normalMatrix,
        model.keyMatrices.normalMatrix
      );
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(model.keyMatrices.wcvc, model.keyMatrices.wcvc);

      const aspectRatio = model.openGLRenderer.getAspectRatio();

      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(
        model.keyMatrices.vcpc,
        model.renderable.getProjectionMatrix(aspectRatio, -1, 1)
      );
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(model.keyMatrices.vcpc, model.keyMatrices.vcpc);

      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(
        model.keyMatrices.wcpc,
        model.keyMatrices.vcpc,
        model.keyMatrices.wcvc
      );

      model.keyMatrixTime.modified();
      model.lastRenderer = ren;
    }

    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  lastRenderer: null,
  keyMatrixTime: null,
  keyMatrices: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  _SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_2__["default"].extend(publicAPI, model, initialValues);

  model.keyMatrixTime = {};
  _macro__WEBPACK_IMPORTED_MODULE_1__["obj"](model.keyMatrixTime);

  model.keyMatrices = {
    normalMatrix: gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].create(),
    vcpc: gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create(),
    wcvc: gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create(),
    wcpc: gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create(),
  };

  // Build VTK API
  _macro__WEBPACK_IMPORTED_MODULE_1__["setGet"](publicAPI, model, ['context', 'keyMatrixTime']);

  // Object methods
  vtkOpenGLCamera(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = _macro__WEBPACK_IMPORTED_MODULE_1__["newInstance"](extend);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/CellArrayBufferObject/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/CellArrayBufferObject/index.js ***!
  \*************************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_BufferObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/BufferObject */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/BufferObject/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Property_Constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Property/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/Property/Constants.js");







const { vtkDebugMacro, vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"];

// ----------------------------------------------------------------------------
// Static functions
// ----------------------------------------------------------------------------

function computeInverseShiftAndScaleMatrix(coordShift, coordScale) {
  const inverseScale = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
  gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].inverse(inverseScale, coordScale);

  const matrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
  gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].fromRotationTranslationScale(
    matrix,
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["quat"].create(),
    coordShift,
    inverseScale
  );

  return matrix;
}

function shouldApplyCoordShiftAndScale(coordShift, coordScale) {
  if (coordShift === null || coordScale === null) {
    return false;
  }

  return !(
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].exactEquals(coordShift, [0, 0, 0]) &&
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].exactEquals(coordScale, [1, 1, 1])
  );
}

// ----------------------------------------------------------------------------
// vtkOpenGLCellArrayBufferObject methods
// ----------------------------------------------------------------------------

function vtkOpenGLCellArrayBufferObject(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLCellArrayBufferObject');

  publicAPI.setType(vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_3__["ObjectType"].ARRAY_BUFFER);

  publicAPI.createVBO = (cellArray, inRep, outRep, options) => {
    if (!cellArray.getData() || !cellArray.getData().length) {
      model.elementCount = 0;
      return 0;
    }

    // Figure out how big each block will be, currently 6 or 7 floats.
    model.blockSize = 3;
    model.vertexOffset = 0;
    model.normalOffset = 0;
    model.tCoordOffset = 0;
    model.tCoordComponents = 0;
    model.colorComponents = 0;
    model.colorOffset = 0;
    model.customData = [];

    const pointData = options.points.getData();
    let normalData = null;
    let tcoordData = null;
    let colorData = null;

    const colorComponents = options.colors
      ? options.colors.getNumberOfComponents()
      : 0;
    const textureComponents = options.tcoords
      ? options.tcoords.getNumberOfComponents()
      : 0;

    // the values of 4 below are because floats are 4 bytes

    if (options.normals) {
      model.normalOffset = 4 * model.blockSize;
      model.blockSize += 3;
      normalData = options.normals.getData();
    }

    if (options.customAttributes) {
      options.customAttributes.forEach((a) => {
        if (a) {
          model.customData.push({
            data: a.getData(),
            offset: 4 * model.blockSize,
            components: a.getNumberOfComponents(),
            name: a.getName(),
          });
          model.blockSize += a.getNumberOfComponents();
        }
      });
    }

    if (options.tcoords) {
      model.tCoordOffset = 4 * model.blockSize;
      model.tCoordComponents = textureComponents;
      model.blockSize += textureComponents;
      tcoordData = options.tcoords.getData();
    }

    if (options.colors) {
      model.colorComponents = options.colors.getNumberOfComponents();
      model.colorOffset = 0;
      colorData = options.colors.getData();
      if (!model.colorBO) {
        model.colorBO = vtk_js_Sources_Rendering_OpenGL_BufferObject__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
      }
      model.colorBO.setOpenGLRenderWindow(model.openGLRenderWindow);
    } else {
      model.colorBO = null;
    }
    model.stride = 4 * model.blockSize;

    let pointIdx = 0;
    let normalIdx = 0;
    let tcoordIdx = 0;
    let colorIdx = 0;
    let custIdx = 0;
    let cellCount = 0;
    let addAPoint;

    const cellBuilders = {
      // easy, every input point becomes an output point
      anythingToPoints(numPoints, cellPts, offset) {
        for (let i = 0; i < numPoints; ++i) {
          addAPoint(cellPts[offset + i]);
        }
      },
      linesToWireframe(numPoints, cellPts, offset) {
        // for lines we add a bunch of segments
        for (let i = 0; i < numPoints - 1; ++i) {
          addAPoint(cellPts[offset + i]);
          addAPoint(cellPts[offset + i + 1]);
        }
      },
      polysToWireframe(numPoints, cellPts, offset) {
        // for polys we add a bunch of segments and close it
        for (let i = 0; i < numPoints; ++i) {
          addAPoint(cellPts[offset + i]);
          addAPoint(cellPts[offset + ((i + 1) % numPoints)]);
        }
      },
      stripsToWireframe(numPoints, cellPts, offset) {
        // for strips we add a bunch of segments and close it
        for (let i = 0; i < numPoints - 1; ++i) {
          addAPoint(cellPts[offset + i]);
          addAPoint(cellPts[offset + i + 1]);
        }
        for (let i = 0; i < numPoints - 2; i++) {
          addAPoint(cellPts[offset + i]);
          addAPoint(cellPts[offset + i + 2]);
        }
      },
      polysToSurface(npts, cellPts, offset) {
        if (npts < 3) {
          // ignore degenerate triangles
          vtkDebugMacro('skipping degenerate triangle');
        } else {
          for (let i = 0; i < npts - 2; i++) {
            addAPoint(cellPts[offset + 0]);
            addAPoint(cellPts[offset + i + 1]);
            addAPoint(cellPts[offset + i + 2]);
          }
        }
      },
      stripsToSurface(npts, cellPts, offset) {
        for (let i = 0; i < npts - 2; i++) {
          addAPoint(cellPts[offset + i]);
          addAPoint(cellPts[offset + i + 1 + (i % 2)]);
          addAPoint(cellPts[offset + i + 1 + ((i + 1) % 2)]);
        }
      },
    };

    const cellCounters = {
      // easy, every input point becomes an output point
      anythingToPoints(numPoints, cellPts) {
        return numPoints;
      },
      linesToWireframe(numPoints, cellPts) {
        return (numPoints - 1) * 2;
      },
      polysToWireframe(numPoints, cellPts) {
        return numPoints * 2;
      },
      stripsToWireframe(numPoints, cellPts) {
        return numPoints * 4 - 6;
      },
      polysToSurface(npts, cellPts) {
        if (npts < 3) {
          return 0;
        }
        return (npts - 2) * 3;
      },
      stripsToSurface(npts, cellPts, offset) {
        return (npts - 2) * 3;
      },
    };

    let func = null;
    let countFunc = null;
    if (outRep === vtk_js_Sources_Rendering_Core_Property_Constants__WEBPACK_IMPORTED_MODULE_4__["Representation"].POINTS || inRep === 'verts') {
      func = cellBuilders.anythingToPoints;
      countFunc = cellCounters.anythingToPoints;
    } else if (outRep === vtk_js_Sources_Rendering_Core_Property_Constants__WEBPACK_IMPORTED_MODULE_4__["Representation"].WIREFRAME || inRep === 'lines') {
      func = cellBuilders[`${inRep}ToWireframe`];
      countFunc = cellCounters[`${inRep}ToWireframe`];
    } else {
      func = cellBuilders[`${inRep}ToSurface`];
      countFunc = cellCounters[`${inRep}ToSurface`];
    }

    const array = cellArray.getData();
    const size = array.length;
    let caboCount = 0;
    for (let index = 0; index < size; ) {
      caboCount += countFunc(array[index], array);
      index += array[index] + 1;
    }

    let packedUCVBO = null;
    const packedVBO = new Float32Array(caboCount * model.blockSize);
    if (colorData) {
      packedUCVBO = new Uint8Array(caboCount * 4);
    }
    let vboidx = 0;
    let ucidx = 0;

    // Find out if shift scale should be used
    // Compute squares of diagonal size and distance from the origin
    let diagSq = 0.0;
    let distSq = 0.0;
    for (let i = 0; i < 3; ++i) {
      const range = options.points.getRange(i);

      const delta = range[1] - range[0];
      diagSq += delta * delta;

      const distShift = 0.5 * (range[1] + range[0]);
      distSq += distShift * distShift;
    }

    const useShiftAndScale =
      diagSq > 0 &&
      (Math.abs(distSq) / diagSq > 1.0e6 || // If data is far from the origin relative to its size
        Math.abs(Math.log10(diagSq)) > 3.0 || // If the size is huge when not far from the origin
        (diagSq === 0 && distSq > 1.0e6)); // If data is a point, but far from the origin

    if (useShiftAndScale) {
      // Compute shift and scale vectors
      const coordShift = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
      const coordScale = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].create();
      for (let i = 0; i < 3; ++i) {
        const range = options.points.getRange(i);
        const delta = range[1] - range[0];

        coordShift[i] = 0.5 * (range[1] + range[0]);
        coordScale[i] = delta > 0 ? 1.0 / delta : 1.0;
      }
      publicAPI.setCoordShiftAndScale(coordShift, coordScale);
    } else if (model.coordShiftAndScaleEnabled === true) {
      // Make sure to reset
      publicAPI.setCoordShiftAndScale(null, null);
    }

    addAPoint = function addAPointFunc(i) {
      // Vertices
      pointIdx = i * 3;

      if (!model.coordShiftAndScaleEnabled) {
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
      } else {
        // Apply shift and scale
        packedVBO[vboidx++] =
          (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];
        packedVBO[vboidx++] =
          (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];
        packedVBO[vboidx++] =
          (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];
      }

      if (normalData !== null) {
        if (options.haveCellNormals) {
          normalIdx = (cellCount + options.cellOffset) * 3;
        } else {
          normalIdx = i * 3;
        }
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
      }

      model.customData.forEach((attr) => {
        custIdx = i * attr.components;
        for (let j = 0; j < attr.components; ++j) {
          packedVBO[vboidx++] = attr.data[custIdx++];
        }
      });

      if (tcoordData !== null) {
        tcoordIdx = i * textureComponents;
        for (let j = 0; j < textureComponents; ++j) {
          packedVBO[vboidx++] = tcoordData[tcoordIdx++];
        }
      }

      if (colorData !== null) {
        if (options.haveCellScalars) {
          colorIdx = (cellCount + options.cellOffset) * colorComponents;
        } else {
          colorIdx = i * colorComponents;
        }
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] =
          colorComponents === 4 ? colorData[colorIdx++] : 255;
      }
    };

    for (let index = 0; index < size; ) {
      func(array[index], array, index + 1);
      index += array[index] + 1;
      cellCount++;
    }
    model.elementCount = caboCount;
    publicAPI.upload(packedVBO, vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_3__["ObjectType"].ARRAY_BUFFER);
    if (model.colorBO) {
      model.colorBOStride = 4;
      model.colorBO.upload(packedUCVBO, vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_3__["ObjectType"].ARRAY_BUFFER);
    }
    return cellCount;
  };

  publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {
    if (
      coordShift !== null &&
      (coordShift.constructor !== Float32Array || coordShift.length !== 3)
    ) {
      vtkErrorMacro('Wrong type for coordShift, expected vec3 or null');
      return;
    }

    if (
      coordScale !== null &&
      (coordScale.constructor !== Float32Array || coordScale.length !== 3)
    ) {
      vtkErrorMacro('Wrong type for coordScale, expected vec3 or null');
      return;
    }

    if (
      model.coordShift === null ||
      coordShift === null ||
      !gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].equals(coordShift, model.coordShift)
    ) {
      model.coordShift = coordShift;
    }

    if (
      model.coordScale === null ||
      coordScale === null ||
      !gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].equals(coordScale, model.coordScale)
    ) {
      model.coordScale = coordScale;
    }

    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(
      model.coordShift,
      model.coordScale
    );

    if (model.coordShiftAndScaleEnabled) {
      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(
        model.coordShift,
        model.coordScale
      );
    } else {
      model.inverseShiftAndScaleMatrix = null;
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  elementCount: 0,
  stride: 0,
  colorBOStride: 0,
  vertexOffset: 0,
  normalOffset: 0,
  tCoordOffset: 0,
  tCoordComponents: 0,
  colorOffset: 0,
  colorComponents: 0,
  tcoordBO: null,
  customData: [],
  coordShift: null,
  coordScale: null,
  coordShiftAndScaleEnabled: false,
  inverseShiftAndScaleMatrix: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_OpenGL_BufferObject__WEBPACK_IMPORTED_MODULE_2__["default"].extend(publicAPI, model, initialValues);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGet(publicAPI, model, [
    'colorBO',
    'elementCount',
    'stride',
    'colorBOStride',
    'vertexOffset',
    'normalOffset',
    'tCoordOffset',
    'tCoordComponents',
    'colorOffset',
    'colorComponents',
    'customData',
  ]);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].get(publicAPI, model, [
    'coordShift',
    'coordScale',
    'coordShiftAndScaleEnabled',
    'inverseShiftAndScaleMatrix',
  ]);

  // Object specific methods
  vtkOpenGLCellArrayBufferObject(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ForwardPass/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/ForwardPass/index.js ***!
  \***************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Framebuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Framebuffer */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Framebuffer/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_RenderPass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/RenderPass */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/RenderPass/index.js");




// ----------------------------------------------------------------------------

function vtkForwardPass(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkForwardPass');

  // this pass implements a forward rendering pipeline
  // if both volumes and opaque geometry are present
  // it will mix the two together by capturing a zbuffer
  // first
  publicAPI.traverse = (viewNode, parent = null) => {
    if (model.deleted) {
      return;
    }

    // we just render our delegates in order
    model.currentParent = parent;

    // build
    publicAPI.setCurrentOperation('buildPass');
    viewNode.traverse(publicAPI);

    const numlayers = viewNode.getRenderable().getNumberOfLayers();

    // iterate over renderers
    const renderers = viewNode.getChildren();
    for (let i = 0; i < numlayers; i++) {
      for (let index = 0; index < renderers.length; index++) {
        const renNode = renderers[index];
        const ren = viewNode.getRenderable().getRenderers()[index];

        if (ren.getDraw() && ren.getLayer() === i) {
          // check for both opaque and volume actors
          model.opaqueActorCount = 0;
          model.translucentActorCount = 0;
          model.volumeCount = 0;
          publicAPI.setCurrentOperation('queryPass');

          renNode.traverse(publicAPI);

          // do we need to capture a zbuffer?
          if (
            (model.opaqueActorCount > 0 && model.volumeCount > 0) ||
            model.depthRequested
          ) {
            const size = viewNode.getFramebufferSize();
            // make sure the framebuffer is setup
            if (model.framebuffer === null) {
              model.framebuffer = vtk_js_Sources_Rendering_OpenGL_Framebuffer__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
            }
            model.framebuffer.setOpenGLRenderWindow(viewNode);
            model.framebuffer.saveCurrentBindingsAndBuffers();
            const fbSize = model.framebuffer.getSize();
            if (
              fbSize === null ||
              fbSize[0] !== size[0] ||
              fbSize[1] !== size[1]
            ) {
              model.framebuffer.create(size[0], size[1]);
              model.framebuffer.populateFramebuffer();
            }
            model.framebuffer.bind();
            publicAPI.setCurrentOperation('opaqueZBufferPass');
            renNode.traverse(publicAPI);
            model.framebuffer.restorePreviousBindingsAndBuffers();
          }

          publicAPI.setCurrentOperation('cameraPass');
          renNode.traverse(publicAPI);
          if (model.opaqueActorCount > 0) {
            publicAPI.setCurrentOperation('opaquePass');
            renNode.traverse(publicAPI);
          }
          if (model.translucentActorCount > 0) {
            publicAPI.setCurrentOperation('translucentPass');
            renNode.traverse(publicAPI);
          }
          if (model.volumeCount > 0) {
            publicAPI.setCurrentOperation('volumePass');
            renNode.traverse(publicAPI);
          }
        }
      }
    }
  };

  publicAPI.getZBufferTexture = () => {
    if (model.framebuffer) {
      return model.framebuffer.getColorTexture();
    }
    return null;
  };

  publicAPI.incrementOpaqueActorCount = () => model.opaqueActorCount++;
  publicAPI.incrementTranslucentActorCount = () =>
    model.translucentActorCount++;
  publicAPI.incrementVolumeCount = () => model.volumeCount++;
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  opaqueActorCount: 0,
  translucentActorCount: 0,
  volumeCount: 0,
  framebuffer: null,
  depthRequested: false,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtk_js_Sources_Rendering_SceneGraph_RenderPass__WEBPACK_IMPORTED_MODULE_2__["default"].extend(publicAPI, model, initialValues);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['framebuffer']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, ['depthRequested']);

  // Object methods
  vtkForwardPass(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkForwardPass');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Framebuffer/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/Framebuffer/index.js ***!
  \***************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Texture */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray/Constants */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/Constants.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Texture/Constants */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/Constants.js");





// ----------------------------------------------------------------------------
// vtkFramebuffer methods
// ----------------------------------------------------------------------------
function vtkFramebuffer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkFramebuffer');

  publicAPI.getBothMode = () => model.context.FRAMEBUFFER;
  // publicAPI.getDrawMode = () => model.context.DRAW_FRAMEBUFFER;
  // publicAPI.getReadMode = () => model.context.READ_FRAMEBUFFER;

  publicAPI.saveCurrentBindingsAndBuffers = (modeIn) => {
    const mode =
      typeof modeIn !== 'undefined' ? modeIn : publicAPI.getBothMode();
    publicAPI.saveCurrentBindings(mode);
    publicAPI.saveCurrentBuffers(mode);
  };

  publicAPI.saveCurrentBindings = (modeIn) => {
    const gl = model.context;
    model.previousDrawBinding = gl.getParameter(
      model.context.FRAMEBUFFER_BINDING
    );
    model.previousActiveFramebuffer = model.openGLRenderWindow.getActiveFramebuffer();
  };

  publicAPI.saveCurrentBuffers = (modeIn) => {
    // noop on webgl 1
  };

  publicAPI.restorePreviousBindingsAndBuffers = (modeIn) => {
    const mode =
      typeof modeIn !== 'undefined' ? modeIn : publicAPI.getBothMode();
    publicAPI.restorePreviousBindings(mode);
    publicAPI.restorePreviousBuffers(mode);
  };

  publicAPI.restorePreviousBindings = (modeIn) => {
    const gl = model.context;
    gl.bindFramebuffer(gl.FRAMEBUFFER, model.previousDrawBinding);
    model.openGLRenderWindow.setActiveFramebuffer(
      model.previousActiveFramebuffer
    );
  };

  publicAPI.restorePreviousBuffers = (modeIn) => {
    // currently a noop on webgl1
  };

  publicAPI.bind = () => {
    model.context.bindFramebuffer(
      model.context.FRAMEBUFFER,
      model.glFramebuffer
    );
    if (model.colorTexture) {
      model.colorTexture.bind();
    }
    model.openGLRenderWindow.setActiveFramebuffer(publicAPI);
  };

  publicAPI.create = (width, height) => {
    model.glFramebuffer = model.context.createFramebuffer();
    model.glFramebuffer.width = width;
    model.glFramebuffer.height = height;
  };

  publicAPI.setColorBuffer = (texture, attachment = 0) => {
    const gl = model.context;

    let glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model.openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["vtkErrorMacro"](
          'Using multiple framebuffer attachments requires WebGL 2'
        );
        return;
      }
    }
    model.colorTexture = texture;
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      glAttachment,
      gl.TEXTURE_2D,
      texture.getHandle(),
      0
    );
  };

  publicAPI.removeColorBuffer = (attachment = 0) => {
    const gl = model.context;

    let glAttachment = gl.COLOR_ATTACHMENT0;
    if (attachment > 0) {
      if (model.openGLRenderWindow.getWebgl2()) {
        glAttachment += attachment;
      } else {
        vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["vtkErrorMacro"](
          'Using multiple framebuffer attachments requires WebGL 2'
        );
        return;
      }
    }

    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      glAttachment,
      gl.TEXTURE_2D,
      null,
      0
    );
  };

  publicAPI.setDepthBuffer = (texture) => {
    if (model.openGLRenderWindow.getWebgl2()) {
      const gl = model.context;
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.DEPTH_ATTACHMENT,
        gl.TEXTURE_2D,
        texture.getHandle(),
        0
      );
    } else {
      vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["vtkErrorMacro"](
        'Attaching depth buffer textures to fbo requires WebGL 2'
      );
    }
  };

  publicAPI.removeDepthBuffer = () => {
    if (model.openGLRenderWindow.getWebgl2()) {
      const gl = model.context;
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.DEPTH_ATTACHMENT,
        gl.TEXTURE_2D,
        null,
        0
      );
    } else {
      vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["vtkErrorMacro"](
        'Attaching depth buffer textures to framebuffers requires WebGL 2'
      );
    }
  };

  publicAPI.getGLFramebuffer = () => model.glFramebuffer;

  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model.openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model.openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model.openGLRenderWindow.getContext();
    }
  };

  publicAPI.releaseGraphicsResources = () => {
    if (model.glFramebuffer) {
      model.context.deleteFramebuffer(model.glFramebuffer);
    }
    if (model.colorTexture) {
      model.colorTexture.releaseGraphicsResources();
    }
  };

  publicAPI.getSize = () => {
    const size = [0, 0];
    if (model.glFramebuffer !== null) {
      size[0] = model.glFramebuffer.width;
      size[1] = model.glFramebuffer.height;
    }
    return size;
  };

  publicAPI.populateFramebuffer = () => {
    publicAPI.bind();
    const gl = model.context;

    const texture = vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
    texture.setOpenGLRenderWindow(model.openGLRenderWindow);
    texture.setMinificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_3__["Filter"].LINEAR);
    texture.setMagnificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_3__["Filter"].LINEAR);
    texture.create2DFromRaw(
      model.glFramebuffer.width,
      model.glFramebuffer.height,
      4,
      vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_2__["VtkDataTypes"].UNSIGNED_CHAR,
      null
    );
    publicAPI.setColorBuffer(texture);

    // for now do not count on having a depth buffer texture
    // as they are not standard webgl 1
    model.depthTexture = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, model.depthTexture);
    gl.renderbufferStorage(
      gl.RENDERBUFFER,
      gl.DEPTH_COMPONENT16,
      model.glFramebuffer.width,
      model.glFramebuffer.height
    );
    gl.framebufferRenderbuffer(
      gl.FRAMEBUFFER,
      gl.DEPTH_ATTACHMENT,
      gl.RENDERBUFFER,
      model.depthTexture
    );
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------
const DEFAULT_VALUES = {
  openGLRenderWindow: null,
  glFramebuffer: null,
  colorTexture: null,
  depthTexture: null,
  previousDrawBinding: 0,
  previousReadBinding: 0,
  previousDrawBuffer: 0,
  previousReadBuffer: 0,
  previousActiveFramebuffer: null,
};

// ----------------------------------------------------------------------------
function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["obj"](publicAPI, model);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["setGet"](publicAPI, model, ['colorTexture']);

  // For more macro methods, see "Sources/macro.js"
  // Object specific methods
  vtkFramebuffer(publicAPI, model);
}

// ----------------------------------------------------------------------------
const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["newInstance"](extend, 'vtkFramebuffer');

// ----------------------------------------------------------------------------
/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Glyph3DMapper/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/Glyph3DMapper/index.js ***!
  \*****************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_BufferObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/BufferObject */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/BufferObject/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_HardwareSelector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/HardwareSelector */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/HardwareSelector/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Property__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Property */ "./node_modules/vtk.js/Sources/Rendering/Core/Property/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_PolyDataMapper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/PolyDataMapper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/PolyDataMapper/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ShaderProgram */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderProgram/index.js");










const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"];
const { Representation } = vtk_js_Sources_Rendering_Core_Property__WEBPACK_IMPORTED_MODULE_4__["default"];
const { ObjectType } = vtk_js_Sources_Rendering_OpenGL_BufferObject__WEBPACK_IMPORTED_MODULE_2__["default"];
const { PassTypes } = vtk_js_Sources_Rendering_OpenGL_HardwareSelector__WEBPACK_IMPORTED_MODULE_3__["default"];

const StartEvent = { type: 'StartEvent' };
const EndEvent = { type: 'EndEvent' };

// ----------------------------------------------------------------------------
// vtkOpenGLSphereMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLGlyph3DMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLGlyph3DMapper');

  // Capture 'parentClass' api for internal use
  const superClass = { ...publicAPI };

  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent(StartEvent);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData(1);
    publicAPI.invokeEvent(EndEvent);

    if (!model.currentInput) {
      vtkErrorMacro('No input!');
      return;
    }

    // if there are no points then we are done
    if (
      !model.currentInput.getPoints ||
      !model.currentInput.getPoints().getNumberOfValues()
    ) {
      return;
    }

    // apply faceCulling
    const gl = model.context;
    if (model.openGLRenderWindow.getWebgl2()) {
      model.hardwareSupport = true;
      model.extension = null;
    } else if (!model.extension) {
      model.extension = model.context.getExtension('ANGLE_instanced_arrays');
      model.hardwareSupport = !!model.extension;
    }
    // to test without extension support uncomment the next two lines
    // model.extension = null;
    // model.hardwareSupport = !!model.extension;

    const backfaceCulling = actor.getProperty().getBackfaceCulling();
    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();
    if (!backfaceCulling && !frontfaceCulling) {
      model.openGLRenderWindow.disableCullFace();
    } else if (frontfaceCulling) {
      model.openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.FRONT);
    } else {
      model.openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.BACK);
    }

    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };

  publicAPI.multiply4x4WithOffset = (out, a, b, off) => {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];

    // Cache only the current line of the second matrix
    let b0 = b[off];
    let b1 = b[off + 1];
    let b2 = b[off + 2];
    let b3 = b[off + 3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[off + 4];
    b1 = b[off + 5];
    b2 = b[off + 6];
    b3 = b[off + 7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[off + 8];
    b1 = b[off + 9];
    b2 = b[off + 10];
    b3 = b[off + 11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

    b0 = b[off + 12];
    b1 = b[off + 13];
    b2 = b[off + 14];
    b3 = b[off + 15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  };

  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      const lastLightComplexity = model.lastBoundBO.getReferenceByName(
        'lastLightComplexity'
      );

      if (lastLightComplexity > 0) {
        let VSSource = shaders.Vertex;

        if (model.lastBoundBO.getCABO().getNormalOffset()) {
          VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(
            VSSource,
            '//VTK::Normal::Dec',
            [
              'attribute vec3 normalMC;',
              'attribute mat3 gNormal;',
              'uniform mat3 normalMatrix;',
              'varying vec3 normalVCVSOutput;',
            ]
          ).result;
          VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(
            VSSource,
            '//VTK::Normal::Impl',
            ['normalVCVSOutput = normalMatrix * gNormal * normalMC;']
          ).result;
        }
        shaders.Vertex = VSSource;
      }
    }
    superClass.replaceShaderNormal(shaders, ren, actor);
  };

  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    if (model.hardwareSupport && model.renderable.getColorArray()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;

      const lastLightComplexity = model.lastBoundBO.getReferenceByName(
        'lastLightComplexity'
      );

      // create the material/color property declarations, and VS implementation
      // these are always defined
      let colorDec = [
        'uniform float ambient;',
        'uniform float diffuse;',
        'uniform float specular;',
        'uniform float opacityUniform; // the fragment opacity',
      ];
      // add more for specular
      if (lastLightComplexity) {
        colorDec = colorDec.concat([
          'uniform vec3 specularColorUniform;',
          'uniform float specularPowerUniform;',
        ]);
      }

      // now handle the more complex fragment shader implementation
      // the following are always defined variables.  We start
      // by assigning a default value from the uniform
      let colorImpl = [
        'vec3 ambientColor;',
        '  vec3 diffuseColor;',
        '  float opacity;',
      ];
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat([
          '  vec3 specularColor;',
          '  float specularPower;',
        ]);
      }
      colorImpl = colorImpl.concat(['  opacity = opacityUniform;']);
      if (lastLightComplexity) {
        colorImpl = colorImpl.concat([
          '  specularColor = specularColorUniform;',
          '  specularPower = specularPowerUniform;',
        ]);
      }

      if (!model.drawingEdges) {
        colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);
        VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(VSSource, '//VTK::Color::Dec', [
          'attribute vec4 gColor;',
          'varying vec4 vertexColorVSOutput;',
        ]).result;
        VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(VSSource, '//VTK::Color::Impl', [
          'vertexColorVSOutput = gColor;',
        ]).result;
        GSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(GSSource, '//VTK::Color::Dec', [
          'in vec4 vertexColorVSOutput[];',
          'out vec4 vertexColorGSOutput;',
        ]).result;
        GSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(GSSource, '//VTK::Color::Impl', [
          'vertexColorGSOutput = vertexColorVSOutput[i];',
        ]).result;

        colorImpl = colorImpl.concat([
          '  diffuseColor = vertexColorVSOutput.rgb;',
          '  ambientColor = vertexColorVSOutput.rgb;',
          '  opacity = opacity*vertexColorVSOutput.a;',
        ]);
      }

      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(
        FSSource,
        '//VTK::Color::Impl',
        colorImpl
      ).result;

      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(
        FSSource,
        '//VTK::Color::Dec',
        colorDec
      ).result;

      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
    superClass.replaceShaderColor(shaders, ren, actor);
  };

  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      let VSSource = shaders.Vertex;

      // do we need the vertex in the shader in View Coordinates
      const lastLightComplexity = model.lastBoundBO.getReferenceByName(
        'lastLightComplexity'
      );
      if (lastLightComplexity > 0) {
        VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(
          VSSource,
          '//VTK::PositionVC::Impl',
          [
            'vec4 gVertexMC = gMatrix * vertexMC;',
            'vertexVCVSOutput = MCVCMatrix * gVertexMC;',
            '  gl_Position = MCPCMatrix * gVertexMC;',
          ]
        ).result;
        VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(VSSource, '//VTK::Camera::Dec', [
          'attribute mat4 gMatrix;',
          'uniform mat4 MCPCMatrix;',
          'uniform mat4 MCVCMatrix;',
        ]).result;
      } else {
        VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(VSSource, '//VTK::Camera::Dec', [
          'attribute mat4 gMatrix;',
          'uniform mat4 MCPCMatrix;',
        ]).result;
        VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(
          VSSource,
          '//VTK::PositionVC::Impl',
          [
            'vec4 gVertexMC = gMatrix * vertexMC;',
            '  gl_Position = MCPCMatrix * gVertexMC;',
          ]
        ).result;
      }
      shaders.Vertex = VSSource;
    }
    superClass.replaceShaderPositionVC(shaders, ren, actor);
  };

  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    if (model.hardwareSupport) {
      let FSSource = shaders.Fragment;
      let VSSource = shaders.Vertex;
      VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(VSSource, '//VTK::Picking::Dec', [
        'attribute vec3 mapperIndexVS;',
        'varying vec3 mapperIndexVSOutput;',
      ]).result;
      VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(
        VSSource,
        '//VTK::Picking::Impl',
        '  mapperIndexVSOutput = mapperIndexVS;'
      ).result;
      shaders.Vertex = VSSource;
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(FSSource, '//VTK::Picking::Dec', [
        'varying vec3 mapperIndexVSOutput;',
        'uniform vec3 mapperIndex;',
        'uniform int picking;',
      ]).result;
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(FSSource, '//VTK::Picking::Impl', [
        '  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);',
        '  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];',
      ]).result;
      shaders.Fragment = FSSource;
    } else {
      superClass.replaceShaderPicking(shaders, ren, actor);
    }
  };

  publicAPI.updateGlyphShaderParameters = (
    normalMatrixUsed,
    mcvcMatrixUsed,
    cellBO,
    carray,
    garray,
    narray,
    p,
    selector
  ) => {
    const program = cellBO.getProgram();

    if (normalMatrixUsed) {
      const a = model.normalMatrix;
      const b = narray;
      const ofs = p * 9;
      const out = model.tmpMat3;

      const a00 = a[0];
      const a01 = a[1];
      const a02 = a[2];
      const a10 = a[3];
      const a11 = a[4];
      const a12 = a[5];
      const a20 = a[6];
      const a21 = a[7];
      const a22 = a[8];

      const b00 = b[ofs];
      const b01 = b[ofs + 1];
      const b02 = b[ofs + 2];
      const b10 = b[ofs + 3];
      const b11 = b[ofs + 4];
      const b12 = b[ofs + 5];
      const b20 = b[ofs + 6];
      const b21 = b[ofs + 7];
      const b22 = b[ofs + 8];

      out[0] = b00 * a00 + b01 * a10 + b02 * a20;
      out[1] = b00 * a01 + b01 * a11 + b02 * a21;
      out[2] = b00 * a02 + b01 * a12 + b02 * a22;

      out[3] = b10 * a00 + b11 * a10 + b12 * a20;
      out[4] = b10 * a01 + b11 * a11 + b12 * a21;
      out[5] = b10 * a02 + b11 * a12 + b12 * a22;

      out[6] = b20 * a00 + b21 * a10 + b22 * a20;
      out[7] = b20 * a01 + b21 * a11 + b22 * a21;
      out[8] = b20 * a02 + b21 * a12 + b22 * a22;

      program.setUniformMatrix3x3('normalMatrix', model.tmpMat3);
    }
    publicAPI.multiply4x4WithOffset(
      model.tmpMat4,
      model.mcpcMatrix,
      garray,
      p * 16
    );
    program.setUniformMatrix('MCPCMatrix', model.tmpMat4);
    if (mcvcMatrixUsed) {
      publicAPI.multiply4x4WithOffset(
        model.tmpMat4,
        model.mcvcMatrix,
        garray,
        p * 16
      );
      program.setUniformMatrix('MCVCMatrix', model.tmpMat4);
    }

    // set color
    if (carray) {
      const cdata = carray.getData();
      model.tmpColor[0] = cdata[p * 4] / 255.0;
      model.tmpColor[1] = cdata[p * 4 + 1] / 255.0;
      model.tmpColor[2] = cdata[p * 4 + 2] / 255.0;
      program.setUniform3fArray('ambientColorUniform', model.tmpColor);
      program.setUniform3fArray('diffuseColorUniform', model.tmpColor);
    }

    if (selector) {
      program.setUniform3fArray('mapperIndex', selector.getPropColorValue());
    }
  };

  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();

    const gl = model.context;

    const drawSurfaceWithEdges =
      actor.getProperty().getEdgeVisibility() &&
      representation === Representation.SURFACE;

    // [WMVP]C == {world, model, view, projection} coordinates
    // E.g., WCPC == world to projection coordinate transformation
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const actMats = model.openGLActor.getKeyMatrices();

    // precompute the actor+camera mats once
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].multiply(
      model.normalMatrix,
      keyMats.normalMatrix,
      actMats.normalMatrix
    );
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(model.mcpcMatrix, keyMats.wcpc, actMats.mcwc);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(model.mcvcMatrix, keyMats.wcvc, actMats.mcwc);

    const garray = model.renderable.getMatrixArray();
    const narray = model.renderable.getNormalArray();
    const carray = model.renderable.getColorArray();
    const numPts = garray.length / 16;

    let compositePass = false;
    if (model.openGLRenderer.getSelector()) {
      if (
        model.openGLRenderer.getSelector().getCurrentPass() ===
        PassTypes.COMPOSITE_INDEX_PASS
      ) {
        compositePass = true;
      }
    }

    // for every primitive type
    for (let i = model.primTypes.Start; i < model.primTypes.End; i++) {
      // if there are entries
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        // are we drawing edges
        model.drawingEdges =
          drawSurfaceWithEdges &&
          (i === model.primTypes.TrisEdges ||
            i === model.primTypes.TriStripsEdges);
        publicAPI.updateShaders(model.primitives[i], ren, actor);
        const program = model.primitives[i].getProgram();

        const mode = publicAPI.getOpenGLMode(representation, i);
        const normalMatrixUsed = program.isUniformUsed('normalMatrix');
        const mcvcMatrixUsed = program.isUniformUsed('MCVCMatrix');

        if (model.hardwareSupport) {
          if (model.extension) {
            model.extension.drawArraysInstancedANGLE(
              mode,
              0,
              cabo.getElementCount(),
              numPts
            );
          } else {
            gl.drawArraysInstanced(mode, 0, cabo.getElementCount(), numPts);
          }
        } else {
          // draw the array multiple times with different cam matrix
          for (let p = 0; p < numPts; ++p) {
            if (compositePass) {
              model.openGLRenderer.getSelector().renderCompositeIndex(p);
            }
            publicAPI.updateGlyphShaderParameters(
              normalMatrixUsed,
              mcvcMatrixUsed,
              model.primitives[i],
              carray,
              garray,
              narray,
              p,
              compositePass ? model.openGLRenderer.getSelector() : null
            );
            gl.drawArrays(mode, 0, cabo.getElementCount());
          }
        }
      }
    }
  };

  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (
      cellBO.getCABO().getElementCount() &&
      (model.glyphBOBuildTime.getMTime() >
        cellBO.getAttributeUpdateTime().getMTime() ||
        cellBO.getShaderSourceTime().getMTime() >
          cellBO.getAttributeUpdateTime().getMTime())
    ) {
      if (cellBO.getProgram().isAttributeUsed('gMatrix')) {
        if (
          !cellBO
            .getVAO()
            .addAttributeMatrixWithDivisor(
              cellBO.getProgram(),
              model.matrixBuffer,
              'gMatrix',
              0,
              64,
              model.context.FLOAT,
              4,
              false,
              1
            )
        ) {
          vtkErrorMacro('Error setting gMatrix in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('gMatrix');
      }
      if (cellBO.getProgram().isAttributeUsed('gNormal')) {
        if (
          !cellBO
            .getVAO()
            .addAttributeMatrixWithDivisor(
              cellBO.getProgram(),
              model.normalBuffer,
              'gNormal',
              0,
              36,
              model.context.FLOAT,
              3,
              false,
              1
            )
        ) {
          vtkErrorMacro('Error setting gNormal in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('gNormal');
      }
      if (cellBO.getProgram().isAttributeUsed('gColor')) {
        if (
          !cellBO
            .getVAO()
            .addAttributeArrayWithDivisor(
              cellBO.getProgram(),
              model.colorBuffer,
              'gColor',
              0,
              4,
              model.context.UNSIGNED_BYTE,
              4,
              true,
              1,
              false
            )
        ) {
          vtkErrorMacro('Error setting gColor in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('gColor');
      }
      if (cellBO.getProgram().isAttributeUsed('mapperIndexVS')) {
        if (
          !cellBO
            .getVAO()
            .addAttributeArrayWithDivisor(
              cellBO.getProgram(),
              model.pickBuffer,
              'mapperIndexVS',
              0,
              4,
              model.context.UNSIGNED_BYTE,
              4,
              true,
              1,
              false
            )
        ) {
          vtkErrorMacro('Error setting mapperIndexVS in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('mapperIndexVS');
      }
      superClass.setMapperShaderParameters(cellBO, ren, actor);
      cellBO.getAttributeUpdateTime().modified();
      return;
    }

    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };

  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    model.renderable.buildArrays();

    // first do a coarse check
    // Note that the actor's mtime includes it's properties mtime
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < model.renderable.getBuildTime().getMTime()) {
      return true;
    }
    return superClass.getNeedToRebuildBufferObjects(ren, actor);
  };

  publicAPI.buildBufferObjects = (ren, actor) => {
    if (model.hardwareSupport) {
      // update the buffer objects if needed
      const garray = model.renderable.getMatrixArray();
      const narray = model.renderable.getNormalArray();
      const carray = model.renderable.getColorArray();
      if (!model.matrixBuffer) {
        model.matrixBuffer = vtk_js_Sources_Rendering_OpenGL_BufferObject__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
        model.matrixBuffer.setOpenGLRenderWindow(model.openGLRenderWindow);
        model.normalBuffer = vtk_js_Sources_Rendering_OpenGL_BufferObject__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
        model.normalBuffer.setOpenGLRenderWindow(model.openGLRenderWindow);
        model.colorBuffer = vtk_js_Sources_Rendering_OpenGL_BufferObject__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
        model.colorBuffer.setOpenGLRenderWindow(model.openGLRenderWindow);
        model.pickBuffer = vtk_js_Sources_Rendering_OpenGL_BufferObject__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
        model.pickBuffer.setOpenGLRenderWindow(model.openGLRenderWindow);
      }
      if (
        model.renderable.getBuildTime().getMTime() >
        model.glyphBOBuildTime.getMTime()
      ) {
        model.matrixBuffer.upload(garray, ObjectType.ARRAY_BUFFER);
        model.normalBuffer.upload(narray, ObjectType.ARRAY_BUFFER);
        if (carray) {
          model.colorBuffer.upload(carray.getData(), ObjectType.ARRAY_BUFFER);
        } else {
          model.colorBuffer.releaseGraphicsResources();
        }
        const numPts = garray.length / 16;
        const parray = new Uint8Array(4 * numPts);
        for (let i = 0; i < numPts; ++i) {
          let value = i + 1;
          const offset = i * 4;
          parray[offset] = value % 256;
          value -= parray[offset];
          value /= 256;
          parray[offset + 1] = value % 256;
          value -= parray[offset + 1];
          value /= 256;
          parray[offset + 2] = value % 256;
          parray[offset + 3] = 255;
        }
        model.pickBuffer.upload(parray, ObjectType.ARRAY_BUFFER);
        model.glyphBOBuildTime.modified();
      }
    }
    return superClass.buildBufferObjects(ren, actor);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  normalMatrix: null,
  mcpcMatrix: null,
  mcwcMatrix: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_OpenGL_PolyDataMapper__WEBPACK_IMPORTED_MODULE_5__["default"].extend(publicAPI, model, initialValues);

  model.tmpMat3 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].create();
  model.normalMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].create();
  model.mcpcMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
  model.mcvcMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
  model.tmpColor = [];

  model.glyphBOBuildTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(model.glyphBOBuildTime, { mtime: 0 });

  // Object methods
  vtkOpenGLGlyph3DMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend, 'vtkOpenGLGlyph3DMapper');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/HardwareSelector/Constants.js":
/*!************************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/HardwareSelector/Constants.js ***!
  \************************************************************************************/
/*! exports provided: PassTypes, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PassTypes", function() { return PassTypes; });
const PassTypes = {
  MIN_KNOWN_PASS: 0,
  ACTOR_PASS: 0,
  COMPOSITE_INDEX_PASS: 1,
  ID_LOW24: 2,
  MAX_KNOWN_PASS: 2,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  PassTypes,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/HardwareSelector/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/HardwareSelector/index.js ***!
  \********************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_HardwareSelector_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/HardwareSelector/Constants */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/HardwareSelector/Constants.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Framebuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Framebuffer */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Framebuffer/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_SelectionNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/SelectionNode */ "./node_modules/vtk.js/Sources/Common/DataModel/SelectionNode/index.js");
/* harmony import */ var vtk_js_Sources_Common_DataModel_DataSet__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/DataSet */ "./node_modules/vtk.js/Sources/Common/DataModel/DataSet/index.js");






const { PassTypes } = vtk_js_Sources_Rendering_OpenGL_HardwareSelector_Constants__WEBPACK_IMPORTED_MODULE_1__["default"];
const { SelectionContent, SelectionField } = vtk_js_Sources_Common_DataModel_SelectionNode__WEBPACK_IMPORTED_MODULE_3__["default"];
const { FieldAssociations } = vtk_js_Sources_Common_DataModel_DataSet__WEBPACK_IMPORTED_MODULE_4__["default"];
const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

// ----------------------------------------------------------------------------
// vtkOpenGLHardwareSelector methods
// ----------------------------------------------------------------------------

function vtkOpenGLHardwareSelector(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLHardwareSelector');

  //----------------------------------------------------------------------------
  publicAPI.releasePixBuffers = () => {
    model.pixBuffer = [];
    model.zBuffer = null;
  };

  //----------------------------------------------------------------------------
  publicAPI.beginSelection = () => {
    model.openGLRenderer = model.openGLRenderWindow.getViewNodeFor(
      model.renderer
    );
    model.maxAttributeId = 0;

    const size = model.openGLRenderWindow.getSize();
    if (!model.framebuffer) {
      model.framebuffer = vtk_js_Sources_Rendering_OpenGL_Framebuffer__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
      model.framebuffer.setOpenGLRenderWindow(model.openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      model.framebuffer.create(size[0], size[1]);
      // this calls model.framebuffer.bind()
      model.framebuffer.populateFramebuffer();
    } else {
      model.framebuffer.setOpenGLRenderWindow(model.openGLRenderWindow);
      model.framebuffer.saveCurrentBindingsAndBuffers();
      const fbSize = model.framebuffer.getSize();
      if (fbSize[0] !== size[0] || fbSize[1] !== size[1]) {
        model.framebuffer.create(size[0], size[1]);
        // this calls model.framebuffer.bind()
        model.framebuffer.populateFramebuffer();
      } else {
        model.framebuffer.bind();
      }
    }

    model.openGLRenderer.clear();
    model.openGLRenderer.setSelector(publicAPI);
    model.hitProps = {};
    model.props = [];
    publicAPI.releasePixBuffers();
  };

  //----------------------------------------------------------------------------
  publicAPI.endSelection = () => {
    model.hitProps = {};
    model.openGLRenderer.setSelector(null);
    model.framebuffer.restorePreviousBindingsAndBuffers();
  };

  publicAPI.preCapturePass = () => {};

  publicAPI.postCapturePass = () => {};

  //----------------------------------------------------------------------------
  publicAPI.select = () => {
    let sel = null;
    if (publicAPI.captureBuffers()) {
      sel = publicAPI.generateSelection(
        model.area[0],
        model.area[1],
        model.area[2],
        model.area[3]
      );
      publicAPI.releasePixBuffers();
    }
    return sel;
  };

  //----------------------------------------------------------------------------
  publicAPI.captureBuffers = () => {
    if (!model.renderer || !model.openGLRenderWindow) {
      vtkErrorMacro('Renderer and view must be set before calling Select.');
      return false;
    }

    model.openGLRenderer = model.openGLRenderWindow.getViewNodeFor(
      model.renderer
    );

    // int rgba[4];
    // rwin.getColorBufferSizes(rgba);
    // if (rgba[0] < 8 || rgba[1] < 8 || rgba[2] < 8) {
    //   vtkErrorMacro("Color buffer depth must be at least 8 bit. "
    //     "Currently: " << rgba[0] << ", " << rgba[1] << ", " <<rgba[2]);
    //   return false;
    // }
    publicAPI.invokeEvent({ type: 'StartEvent' });

    // Initialize renderer for selection.
    // change the renderer's background to black, which will indicate a miss
    model.originalBackground = model.renderer.getBackgroundByReference();
    model.renderer.setBackground(0.0, 0.0, 0.0);
    const rpasses = model.openGLRenderWindow.getRenderPasses();

    publicAPI.beginSelection();
    for (
      model.currentPass = PassTypes.MIN_KNOWN_PASS;
      model.currentPass <= PassTypes.COMPOSITE_INDEX_PASS;
      model.currentPass++
    ) {
      if (publicAPI.passRequired(model.currentPass)) {
        publicAPI.preCapturePass(model.currentPass);
        if (
          model.captureZValues &&
          model.currentPass === PassTypes.ACTOR_PASS &&
          typeof rpasses[0].setDepthRequested === 'function' &&
          typeof rpasses[0].getFramebuffer === 'function'
        ) {
          rpasses[0].setDepthRequested(true);
          model.openGLRenderWindow.traverseAllPasses();
          rpasses[0].setDepthRequested(false);
        } else {
          model.openGLRenderWindow.traverseAllPasses();
        }
        publicAPI.postCapturePass(model.currentPass);

        publicAPI.savePixelBuffer(model.currentPass);
      }
    }
    publicAPI.endSelection();

    // restore original background
    model.renderer.setBackground(model.originalBackground);
    publicAPI.invokeEvent({ type: 'EndEvent' });

    // restore image, not needed?
    // model.openGLRenderWindow.traverseAllPasses();
    return true;
  };

  //----------------------------------------------------------------------------
  publicAPI.passRequired = (pass) => true;

  //----------------------------------------------------------------------------
  publicAPI.savePixelBuffer = (passNo) => {
    model.pixBuffer[passNo] = model.openGLRenderWindow.getPixelData(
      model.area[0],
      model.area[1],
      model.area[2],
      model.area[3]
    );
    if (passNo === PassTypes.ACTOR_PASS) {
      if (model.captureZValues) {
        const rpasses = model.openGLRenderWindow.getRenderPasses();
        if (
          typeof rpasses[0].setDepthRequested === 'function' &&
          typeof rpasses[0].getFramebuffer === 'function'
        ) {
          const fb = rpasses[0].getFramebuffer();
          fb.saveCurrentBindingsAndBuffers();
          fb.bind();
          model.zBuffer = model.openGLRenderWindow.getPixelData(
            model.area[0],
            model.area[1],
            model.area[2],
            model.area[3]
          );
          fb.restorePreviousBindingsAndBuffers();
        }
      }
      publicAPI.buildPropHitList(model.pixBuffer[passNo]);
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.buildPropHitList = (pixelbuffer) => {
    for (let yy = 0; yy <= model.area[3] - model.area[1]; yy++) {
      for (let xx = 0; xx <= model.area[2] - model.area[0]; xx++) {
        let val = publicAPI.convert(xx, yy, pixelbuffer);
        if (val > 0) {
          val--;
          if (!(val in model.hitProps)) {
            model.hitProps[val] = true;
          }
        }
      }
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.renderProp = (prop) => {
    if (model.currentPass === PassTypes.ACTOR_PASS) {
      publicAPI.setPropColorValueFromInt(model.props.length + model.idOffset);
      model.props.push(prop);
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.renderCompositeIndex = (index) => {
    if (model.currentPass === PassTypes.COMPOSITE_INDEX_PASS) {
      publicAPI.setPropColorValueFromInt(index + model.idOffset);
    }
  };

  //----------------------------------------------------------------------------
  // TODO: make inline
  publicAPI.renderAttributeId = (attribid) => {
    if (attribid < 0) {
      // negative attribid is valid. It happens when rendering higher order
      // elements where new points are added for rendering smooth surfaces.
      return;
    }

    model.maxAttributeId =
      attribid > model.maxAttributeId ? attribid : model.maxAttributeId;

    // if (model.currentPass < PassTypes.ID_LOW24) {
    //   return; // useless...
    // }
  };

  //----------------------------------------------------------------------------
  publicAPI.getPropFromID = (id) => {
    if (id >= 0 && id < model.props.length) {
      return model.props[id];
    }
    return null;
  };

  //----------------------------------------------------------------------------
  publicAPI.passTypeToString = (type) => vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].enumToString(PassTypes, type);

  //----------------------------------------------------------------------------
  publicAPI.isPropHit = (id) => Boolean(model.hitProps[id]);

  publicAPI.convert = (xx, yy, pb) => {
    if (!pb) {
      return 0;
    }
    const offset = (yy * (model.area[2] - model.area[0] + 1) + xx) * 4;
    const rgb = [];
    rgb[0] = pb[offset];
    rgb[1] = pb[offset + 1];
    rgb[2] = pb[offset + 2];
    let val = rgb[2];
    val *= 256;
    val += rgb[1];
    val *= 256;
    val += rgb[0];
    return val;
  };

  publicAPI.setPropColorValueFromInt = (val) => {
    model.propColorValue[0] = (val % 256) / 255.0;
    model.propColorValue[1] = (Math.floor(val / 256) % 256) / 255.0;
    model.propColorValue[2] = (Math.floor(val / 65536) % 256) / 255.0;
  };

  // info has
  //   valid
  //   propId
  //   prop
  //   compositeID
  //   attributeID

  //----------------------------------------------------------------------------
  publicAPI.getPixelInformation = (
    inDisplayPosition,
    maxDistance,
    outSelectedPosition
  ) => {
    // Base case
    const maxDist = maxDistance < 0 ? 0 : maxDistance;
    if (maxDist === 0) {
      outSelectedPosition[0] = inDisplayPosition[0];
      outSelectedPosition[1] = inDisplayPosition[1];
      if (
        inDisplayPosition[0] < model.area[0] ||
        inDisplayPosition[0] > model.area[2] ||
        inDisplayPosition[1] < model.area[1] ||
        inDisplayPosition[1] > model.area[3]
      ) {
        return null;
      }

      // offset inDisplayPosition based on the lower-left-corner of the Area.
      const displayPosition = [
        inDisplayPosition[0] - model.area[0],
        inDisplayPosition[1] - model.area[1],
      ];

      const actorid = publicAPI.convert(
        displayPosition[0],
        displayPosition[1],
        model.pixBuffer[PassTypes.ACTOR_PASS]
      );
      if (actorid <= 0) {
        // the pixel did not hit any actor.
        return null;
      }

      const info = {};
      info.valid = true;

      info.propID = actorid - model.idOffset;
      info.prop = publicAPI.getPropFromID(info.propID);

      let compositeID = publicAPI.convert(
        displayPosition[0],
        displayPosition[1],
        model.pixBuffer[PassTypes.COMPOSITE_INDEX_PASS]
      );
      if (compositeID < 0 || compositeID > 0xffffff) {
        compositeID = 0;
      }
      info.compositeID = compositeID - model.idOffset;
      if (model.captureZValues) {
        const offset =
          (displayPosition[1] * (model.area[2] - model.area[0] + 1) +
            displayPosition[0]) *
          4;
        info.zValue =
          (256 * model.zBuffer[offset] + model.zBuffer[offset + 1]) / 65535.0;
        info.displayPosition = inDisplayPosition;
      }

      // const low24 = publicAPI.convert(
      //   displayPosition[0], displayPosition[1], model.pixBuffer[PassTypes.ID_LOW24]);

      // // id 0 is reserved for nothing present.
      // info.attributeID = low24 - model.idOffset;
      // if (info.attributeID < 0) {
      //   // the pixel did not hit any cell.
      //   return null;
      // }
      return info;
    }

    // Iterate over successively growing boxes.
    // They recursively call the base case to handle single pixels.
    const dispPos = [inDisplayPosition[0], inDisplayPosition[1]];
    const curPos = [0, 0];
    let info = publicAPI.getPixelInformation(
      inDisplayPosition,
      0,
      outSelectedPosition
    );
    if (info && info.valid) {
      return info;
    }
    for (let dist = 1; dist < maxDist; ++dist) {
      // Vertical sides of box.
      for (
        let y = dispPos[1] > dist ? dispPos[1] - dist : 0;
        y <= dispPos[1] + dist;
        ++y
      ) {
        curPos[1] = y;
        if (dispPos[0] >= dist) {
          curPos[0] = dispPos[0] - dist;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[0] = dispPos[0] + dist;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
      // Horizontal sides of box.
      for (
        let x = dispPos[0] >= dist ? dispPos[0] - (dist - 1) : 0;
        x <= dispPos[0] + (dist - 1);
        ++x
      ) {
        curPos[0] = x;
        if (dispPos[1] >= dist) {
          curPos[1] = dispPos[1] - dist;
          info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
          if (info && info.valid) {
            return info;
          }
        }
        curPos[1] = dispPos[1] + dist;
        info = publicAPI.getPixelInformation(curPos, 0, outSelectedPosition);
        if (info && info.valid) {
          return info;
        }
      }
    }

    // nothing hit.
    outSelectedPosition[0] = inDisplayPosition[0];
    outSelectedPosition[1] = inDisplayPosition[1];
    return null;
  };

  //-----------------------------------------------------------------------------
  publicAPI.convertSelection = (fieldassociation, dataMap) => {
    const sel = [];

    let count = 0;
    dataMap.forEach((value, key) => {
      const child = vtk_js_Sources_Common_DataModel_SelectionNode__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
      child.setContentType(SelectionContent.INDICES);
      switch (fieldassociation) {
        case FieldAssociations.FIELD_ASSOCIATION_CELLS:
          child.setFieldType(SelectionField.CELL);
          break;
        case FieldAssociations.FIELD_ASSOCIATION_POINTS:
          child.setFieldType(SelectionField.POINT);
          break;
        default:
          vtkErrorMacro('Unknown field association');
      }
      child.getProperties().propID = value.info.propID;
      child.getProperties().prop = value.info.prop;
      child.getProperties().compositeID = value.info.compositeID;
      child.getProperties().pixelCount = value.pixelCount;
      if (model.captureZValues) {
        child.getProperties().displayPosition = [
          value.info.displayPosition[0],
          value.info.displayPosition[1],
          value.info.zValue,
        ];
        child.getProperties().worldPosition = model.openGLRenderWindow.displayToWorld(
          value.info.displayPosition[0],
          value.info.displayPosition[1],
          value.info.zValue,
          model.renderer
        );
      }

      child.setSelectionList(value.attributeIDs);
      sel[count] = child;
      count++;
    });

    return sel;
  };

  publicAPI.getInfoHash = (info) => `${info.propID} ${info.compositeID}`;

  //----------------------------------------------------------------------------
  publicAPI.generateSelection = (fx1, fy1, fx2, fy2) => {
    const x1 = Math.floor(fx1);
    const y1 = Math.floor(fy1);
    const x2 = Math.floor(fx2);
    const y2 = Math.floor(fy2);

    const dataMap = new Map();

    const outSelectedPosition = [0, 0];

    for (let yy = y1; yy <= y2; yy++) {
      for (let xx = x1; xx <= x2; xx++) {
        const pos = [xx, yy];
        const info = publicAPI.getPixelInformation(pos, 0, outSelectedPosition);
        if (info && info.valid) {
          const hash = publicAPI.getInfoHash(info);
          if (!dataMap.has(hash)) {
            dataMap.set(hash, {
              info,
              pixelCount: 1,
              attributeIDs: [info.attributeID],
            });
          } else {
            const dmv = dataMap.get(hash);
            dmv.pixelCount++;
            if (model.captureZValues) {
              if (info.zValue < dmv.info.zValue) {
                dmv.info = info;
              }
            }
            if (dmv.attributeIDs.indexOf(info.attributeID) === -1) {
              dmv.attributeIDs.push(info.attributeID);
            }
          }
        }
      }
    }
    return publicAPI.convertSelection(model.fieldAssociation, dataMap);
  };

  //----------------------------------------------------------------------------

  publicAPI.attach = (w, r) => {
    model.openGLRenderWindow = w;
    model.renderer = r;
  };

  //----------------------------------------------------------------------------

  // override
  const superSetArea = publicAPI.setArea;
  publicAPI.setArea = (...args) => {
    if (superSetArea(...args)) {
      model.area[0] = Math.floor(model.area[0]);
      model.area[1] = Math.floor(model.area[1]);
      model.area[2] = Math.floor(model.area[2]);
      model.area[3] = Math.floor(model.area[3]);
      return true;
    }
    return false;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  fieldAssociation: FieldAssociations.FIELD_ASSOCIATION_CELLS,
  renderer: null,
  area: null,
  openGLRenderWindow: null,
  openGLRenderer: null,
  currentPass: -1,
  propColorValue: null,
  props: null,
  idOffset: 1,
  captureZValues: false,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);

  model.area = [0, 0, 0, 0];
  model.propColorValue = [0, 0, 0];
  model.props = [];

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'fieldAssociation',
    'renderer',
    'currentPass',
    'captureZValues',
  ]);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGetArray(publicAPI, model, ['area'], 4);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGetArray(publicAPI, model, ['propColorValue'], 3);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].event(publicAPI, model, 'event');

  // Object methods
  vtkOpenGLHardwareSelector(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(
  extend,
  'vtkOpenGLHardwareSelector'
);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...vtk_js_Sources_Rendering_OpenGL_HardwareSelector_Constants__WEBPACK_IMPORTED_MODULE_1__["default"] });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Helper/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/Helper/index.js ***!
  \**********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_CellArrayBufferObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/CellArrayBufferObject */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/CellArrayBufferObject/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ShaderProgram */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderProgram/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_VertexArrayObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/VertexArrayObject */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/VertexArrayObject/index.js");





// ----------------------------------------------------------------------------
// vtkOpenGLHelper methods
// ----------------------------------------------------------------------------

function vtkOpenGLHelper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLHelper');

  publicAPI.setOpenGLRenderWindow = (win) => {
    model.program.setContext(win.getContext());
    model.VAO.setOpenGLRenderWindow(win);
    model.CABO.setOpenGLRenderWindow(win);
  };

  publicAPI.releaseGraphicsResources = (oglwin) => {
    model.VAO.releaseGraphicsResources();
    model.CABO.releaseGraphicsResources();
    model.CABO.setElementCount(0);
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  program: null,
  shaderSourceTime: null,
  VAO: null,
  attributeUpdateTime: null,
  CABO: null,
  primitiveType: 0,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);

  model.shaderSourceTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(model.shaderSourceTime);

  model.attributeUpdateTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(model.attributeUpdateTime);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'program',
    'shaderSourceTime',
    'VAO',
    'attributeUpdateTime',
    'CABO',
    'primitiveType',
  ]);

  model.program = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
  model.VAO = vtk_js_Sources_Rendering_OpenGL_VertexArrayObject__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
  model.CABO = vtk_js_Sources_Rendering_OpenGL_CellArrayBufferObject__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();

  // Object methods
  vtkOpenGLHelper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ImageMapper/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/ImageMapper/index.js ***!
  \***************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_ImageMapper_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/ImageMapper/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/ImageMapper/Constants.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray/Constants */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/Constants.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Helper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Helper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Helper/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Texture */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ShaderProgram */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderProgram/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/ViewNode */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Property_Constants__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Property/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/Property/Constants.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Texture/Constants */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/Constants.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_ImageProperty_Constants__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/ImageProperty/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/ImageProperty/Constants.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataVS_glsl__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataVS_glsl__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataVS_glsl__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ReplacementShaderMapper__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ReplacementShaderMapper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ReplacementShaderMapper/index.js");


















const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_2__["default"];

const { SlicingMode } = vtk_js_Sources_Rendering_Core_ImageMapper_Constants__WEBPACK_IMPORTED_MODULE_1__["default"];

// ----------------------------------------------------------------------------
// helper methods
// ----------------------------------------------------------------------------

function computeFnToString(property, fn, numberOfComponents) {
  const pwfun = fn.apply(property);
  if (pwfun) {
    const iComps = property.getIndependentComponents();
    return `${property.getMTime()}-${iComps}-${numberOfComponents}`;
  }
  return '0';
}

// ----------------------------------------------------------------------------
// vtkOpenGLImageMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLImageMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLImageMapper');

  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.openGLImageSlice = publicAPI.getFirstAncestorOfType(
        'vtkOpenGLImageSlice'
      );
      model.openGLRenderer = publicAPI.getFirstAncestorOfType(
        'vtkOpenGLRenderer'
      );
      model.openGLRenderWindow = model.openGLRenderer.getParent();
      model.context = model.openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model.openGLRenderWindow);
      model.openGLTexture.setOpenGLRenderWindow(model.openGLRenderWindow);
      model.colorTexture.setOpenGLRenderWindow(model.openGLRenderWindow);
      model.pwfTexture.setOpenGLRenderWindow(model.openGLRenderWindow);
      const ren = model.openGLRenderer.getRenderable();
      model.openGLCamera = model.openGLRenderer.getViewNodeFor(
        ren.getActiveCamera()
      );
      // is slice set by the camera
      if (model.renderable.getSliceAtFocalPoint()) {
        model.renderable.setSliceFromCamera(ren.getActiveCamera());
      }
    }
  };

  publicAPI.translucentPass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };

  publicAPI.opaqueZBufferPass = (prepass) => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };

  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };

  publicAPI.getCoincidentParameters = (ren, actor) => {
    if (model.renderable.getResolveCoincidentTopology()) {
      return model.renderable.getCoincidentTopologyPolygonOffsetParameters();
    }
    return null;
  };

  // Renders myself
  publicAPI.render = () => {
    const actor = model.openGLImageSlice.getRenderable();
    const ren = model.openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };

  publicAPI.buildShaders = (shaders, ren, actor) => {
    publicAPI.getShaderTemplate(shaders, ren, actor);
    publicAPI.replaceShaderValues(shaders, ren, actor);
  };

  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataVS_glsl__WEBPACK_IMPORTED_MODULE_13___default.a;
    shaders.Fragment = vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_14___default.a;
    shaders.Geometry = '';
  };

  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;

    VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(VSSource, '//VTK::Camera::Dec', [
      'uniform mat4 MCPCMatrix;',
    ]).result;
    VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
      VSSource,
      '//VTK::PositionVC::Impl',
      ['  gl_Position = MCPCMatrix * vertexMC;']
    ).result;

    VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
      VSSource,
      '//VTK::TCoord::Impl',
      'tcoordVCVSOutput = tcoordMC;'
    ).result;

    VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
      VSSource,
      '//VTK::TCoord::Dec',
      'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;'
    ).result;

    const tNumComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();

    let tcoordDec = [
      'varying vec2 tcoordVCVSOutput;',
      // color shift and scale
      'uniform float cshift0;',
      'uniform float cscale0;',
      // pwf shift and scale
      'uniform float pwfshift0;',
      'uniform float pwfscale0;',
      'uniform sampler2D texture1;',
      'uniform sampler2D colorTexture1;',
      'uniform sampler2D pwfTexture1;',
      'uniform float opacity;',
    ];
    if (iComps) {
      for (let comp = 1; comp < tNumComp; comp++) {
        tcoordDec = tcoordDec.concat([
          // color shift and scale
          `uniform float cshift${comp};`,
          `uniform float cscale${comp};`,
          // weighting shift and scale
          `uniform float pwfshift${comp};`,
          `uniform float pwfscale${comp};`,
        ]);
      }
      // the heights defined below are the locations
      // for the up to four components of the tfuns
      // the tfuns have a height of 2XnumComps pixels so the
      // values are computed to hit the middle of the two rows
      // for that component
      switch (tNumComp) {
        case 1:
          tcoordDec = tcoordDec.concat([
            'uniform float mix0;',
            '#define height0 0.5',
          ]);
          break;
        case 2:
          tcoordDec = tcoordDec.concat([
            'uniform float mix0;',
            'uniform float mix1;',
            '#define height0 0.25',
            '#define height1 0.75',
          ]);
          break;
        case 3:
          tcoordDec = tcoordDec.concat([
            'uniform float mix0;',
            'uniform float mix1;',
            'uniform float mix2;',
            '#define height0 0.17',
            '#define height1 0.5',
            '#define height2 0.83',
          ]);
          break;
        case 4:
          tcoordDec = tcoordDec.concat([
            'uniform float mix0;',
            'uniform float mix1;',
            'uniform float mix2;',
            'uniform float mix3;',
            '#define height0 0.125',
            '#define height1 0.375',
            '#define height2 0.625',
            '#define height3 0.875',
          ]);
          break;
        default:
          vtkErrorMacro('Unsupported number of independent coordinates.');
      }
    }
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
      FSSource,
      '//VTK::TCoord::Dec',
      tcoordDec
    ).result;

    if (iComps) {
      const rgba = ['r', 'g', 'b', 'a'];
      let tcoordImpl = ['vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);'];
      for (let comp = 0; comp < tNumComp; comp++) {
        tcoordImpl = tcoordImpl.concat([
          `vec3 tcolor${comp} = mix${comp} * texture2D(colorTexture1, vec2(tvalue.${rgba[comp]} * cscale${comp} + cshift${comp}, height${comp})).rgb;`,
          `float compWeight${comp} = mix${comp} * texture2D(pwfTexture1, vec2(tvalue.${rgba[comp]} * pwfscale${comp} + pwfshift${comp}, height${comp})).r;`,
        ]);
      }
      switch (tNumComp) {
        case 1:
          tcoordImpl = tcoordImpl.concat([
            'gl_FragData[0] = vec4(tcolor0.rgb, opacity);',
          ]);
          break;
        case 2:
          tcoordImpl = tcoordImpl.concat([
            'float weightSum = compWeight0 + compWeight1;',
            'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);',
          ]);
          break;
        case 3:
          tcoordImpl = tcoordImpl.concat([
            'float weightSum = compWeight0 + compWeight1 + compWeight2;',
            'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);',
          ]);
          break;
        case 4:
          tcoordImpl = tcoordImpl.concat([
            'float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;',
            'gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);',
          ]);
          break;
        default:
          vtkErrorMacro('Unsupported number of independent coordinates.');
      }
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
        FSSource,
        '//VTK::TCoord::Impl',
        tcoordImpl
      ).result;
    } else {
      // dependent components
      switch (tNumComp) {
        case 1:
          FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
            FSSource,
            '//VTK::TCoord::Impl',
            [
              'float intensity = texture2D(texture1, tcoordVCVSOutput).r;',
              'vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;',
              'float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;',
              'gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);',
            ]
          ).result;
          break;
        case 2:
          FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
            FSSource,
            '//VTK::TCoord::Impl',
            [
              'vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);',
              'float intensity = tcolor.r*cscale0 + cshift0;',
              'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);',
            ]
          ).result;
          break;
        default:
          FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
            FSSource,
            '//VTK::TCoord::Impl',
            [
              'vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;',
              'gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,',
              '  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,',
              '  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);',
            ]
          ).result;
      }
    }

    if (model.haveSeenDepthRequest) {
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
        FSSource,
        '//VTK::ZBuffer::Dec',
        'uniform int depthRequest;'
      ).result;
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(FSSource, '//VTK::ZBuffer::Impl', [
        'if (depthRequest == 1) {',
        'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);',
        'float rf = floor(iz/256.0)/255.0;',
        'float gf = mod(iz,256.0)/255.0;',
        'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }',
      ]).result;
    }

    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;

    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
  };

  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    // has something changed that would require us to recreate the shader?
    // candidates are
    // property modified (representation interpolation and lighting)
    // input modified
    // light complexity changed

    const tNumComp = model.openGLTexture.getComponents();
    const iComp = actor.getProperty().getIndependentComponents();

    if (
      model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest ||
      cellBO.getProgram() === 0 ||
      model.lastTextureComponents !== tNumComp ||
      model.lastIndependentComponents !== iComp
    ) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      model.lastTextureComponents = tNumComp;
      model.lastIndependentComponents = iComp;
      return true;
    }

    return false;
  };

  publicAPI.updateShaders = (cellBO, ren, actor) => {
    model.lastBoundBO = cellBO;

    // has something changed that would require us to recreate the shader?
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = { Vertex: null, Fragment: null, Geometry: null };

      publicAPI.buildShaders(shaders, ren, actor);

      // compile and bind the program if needed
      const newShader = model.openGLRenderWindow
        .getShaderCache()
        .readyShaderProgramArray(
          shaders.Vertex,
          shaders.Fragment,
          shaders.Geometry
        );

      // if the shader changed reinitialize the VAO
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        // reset the VAO as the shader has changed
        cellBO.getVAO().releaseGraphicsResources();
      }

      cellBO.getShaderSourceTime().modified();
    } else {
      model.openGLRenderWindow
        .getShaderCache()
        .readyShaderProgram(cellBO.getProgram());
    }

    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };

  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    // Now to update the VAO too, if necessary.

    if (
      cellBO.getCABO().getElementCount() &&
      (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() ||
        cellBO.getShaderSourceTime().getMTime() >
          cellBO.getAttributeUpdateTime().getMTime())
    ) {
      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {
        if (
          !cellBO
            .getVAO()
            .addAttributeArray(
              cellBO.getProgram(),
              cellBO.getCABO(),
              'vertexMC',
              cellBO.getCABO().getVertexOffset(),
              cellBO.getCABO().getStride(),
              model.context.FLOAT,
              3,
              model.context.FALSE
            )
        ) {
          vtkErrorMacro('Error setting vertexMC in shader VAO.');
        }
      }
      if (
        cellBO.getProgram().isAttributeUsed('tcoordMC') &&
        cellBO.getCABO().getTCoordOffset()
      ) {
        if (
          !cellBO
            .getVAO()
            .addAttributeArray(
              cellBO.getProgram(),
              cellBO.getCABO(),
              'tcoordMC',
              cellBO.getCABO().getTCoordOffset(),
              cellBO.getCABO().getStride(),
              model.context.FLOAT,
              cellBO.getCABO().getTCoordComponents(),
              model.context.FALSE
            )
        ) {
          vtkErrorMacro('Error setting tcoordMC in shader VAO.');
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }

    const texUnit = model.openGLTexture.getTextureUnit();
    cellBO.getProgram().setUniformi('texture1', texUnit);

    const numComp = model.openGLTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    if (iComps) {
      for (let i = 0; i < numComp; i++) {
        cellBO
          .getProgram()
          .setUniformf(`mix${i}`, actor.getProperty().getComponentWeight(i));
      }
    }

    const oglShiftScale = model.openGLTexture.getShiftAndScale();

    // three levels of shift scale combined into one
    // for performance in the fragment shader
    for (let i = 0; i < numComp; i++) {
      let cw = actor.getProperty().getColorWindow();
      let cl = actor.getProperty().getColorLevel();
      const target = iComps ? i : 0;
      const cfun = actor.getProperty().getRGBTransferFunction(target);
      if (cfun) {
        const cRange = cfun.getRange();
        cw = cRange[1] - cRange[0];
        cl = 0.5 * (cRange[1] + cRange[0]);
      }

      const scale = oglShiftScale.scale / cw;
      const shift = (oglShiftScale.shift - cl) / cw + 0.5;
      cellBO.getProgram().setUniformf(`cshift${i}`, shift);
      cellBO.getProgram().setUniformf(`cscale${i}`, scale);
    }

    // pwf shift/scale
    for (let i = 0; i < numComp; i++) {
      let pwfScale = 1.0;
      let pwfShift = 0.0;
      const target = iComps ? i : 0;
      const pwfun = actor.getProperty().getPiecewiseFunction(target);
      if (pwfun) {
        const pwfRange = pwfun.getRange();
        const length = pwfRange[1] - pwfRange[0];
        const mid = 0.5 * (pwfRange[0] + pwfRange[1]);
        pwfScale = oglShiftScale.scale / length;
        pwfShift = (oglShiftScale.shift - mid) / length + 0.5;
      }
      cellBO.getProgram().setUniformf(`pwfshift${i}`, pwfShift);
      cellBO.getProgram().setUniformf(`pwfscale${i}`, pwfScale);
    }

    if (model.haveSeenDepthRequest) {
      cellBO
        .getProgram()
        .setUniformi('depthRequest', model.renderDepth ? 1 : 0);
    }

    // handle coincident
    if (cellBO.getProgram().isUniformUsed('coffset')) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf('coffset', cp.offset);
      // cfactor isn't always used when coffset is.
      if (cellBO.getProgram().isUniformUsed('cfactor')) {
        cellBO.getProgram().setUniformf('cfactor', cp.factor);
      }
    }

    const texColorUnit = model.colorTexture.getTextureUnit();
    cellBO.getProgram().setUniformi('colorTexture1', texColorUnit);

    const texOpacityUnit = model.pwfTexture.getTextureUnit();
    cellBO.getProgram().setUniformi('pwfTexture1', texOpacityUnit);
  };

  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();

    const actMats = model.openGLImageSlice.getKeyMatrices();
    const image = model.currentInput;
    const i2wmat4 = image.getIndexToWorld();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(model.imagemat, actMats.mcwc, i2wmat4);

    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(model.imagemat, keyMats.wcpc, model.imagemat);

    if (cellBO.getCABO().getCoordShiftAndScaleEnabled()) {
      const inverseShiftScaleMat = cellBO
        .getCABO()
        .getInverseShiftAndScaleMatrix();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(model.imagemat, model.imagemat, inverseShiftScaleMat);
    }

    program.setUniformMatrix('MCPCMatrix', model.imagemat);
  };

  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();

    const ppty = actor.getProperty();

    const opacity = ppty.getOpacity();
    program.setUniformf('opacity', opacity);
  };

  publicAPI.renderPieceStart = (ren, actor) => {
    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);

    // Bind the OpenGL, this is shared between the different primitive/cell types.
    model.lastBoundBO = null;
  };

  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;

    // activate the texture
    model.openGLTexture.activate();
    model.colorTexture.activate();
    model.pwfTexture.activate();

    // draw polygons
    if (model.tris.getCABO().getElementCount()) {
      // First we do the triangles, update the shader, set uniforms, etc.
      publicAPI.updateShaders(model.tris, ren, actor);
      gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
    }

    model.openGLTexture.deactivate();
    model.colorTexture.deactivate();
    model.pwfTexture.deactivate();
  };

  publicAPI.renderPieceFinish = (ren, actor) => {};

  publicAPI.renderPiece = (ren, actor) => {
    // Make sure that we have been properly initialized.
    // if (ren.getRenderWindow().checkAbortStatus()) {
    //   return;
    // }

    publicAPI.invokeEvent({ type: 'StartEvent' });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent({ type: 'EndEvent' });

    if (!model.currentInput) {
      vtkErrorMacro('No input!');
      return;
    }

    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };

  publicAPI.computeBounds = (ren, actor) => {
    if (!publicAPI.getInput()) {
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_6__["uninitializeBounds"](model.bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };

  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffers if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };

  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    // first do a coarse check
    if (
      model.VBOBuildTime.getMTime() < publicAPI.getMTime() ||
      model.VBOBuildTime.getMTime() < actor.getMTime() ||
      model.VBOBuildTime.getMTime() < model.renderable.getMTime() ||
      model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() ||
      model.VBOBuildTime.getMTime() < model.currentInput.getMTime()
    ) {
      return true;
    }
    return false;
  };

  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentInput;

    if (image === null) {
      return;
    }

    const actorProperty = actor.getProperty();

    // set interpolation on the texture based on property setting
    const iType = actorProperty.getInterpolationType();
    if (iType === vtk_js_Sources_Rendering_Core_ImageProperty_Constants__WEBPACK_IMPORTED_MODULE_12__["InterpolationType"].NEAREST) {
      model.colorTexture.setMinificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Filter"].NEAREST);
      model.colorTexture.setMagnificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Filter"].NEAREST);
      model.pwfTexture.setMinificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Filter"].NEAREST);
      model.pwfTexture.setMagnificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Filter"].NEAREST);
    } else {
      model.colorTexture.setMinificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Filter"].LINEAR);
      model.colorTexture.setMagnificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Filter"].LINEAR);
      model.pwfTexture.setMinificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Filter"].LINEAR);
      model.pwfTexture.setMagnificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Filter"].LINEAR);
    }

    const numComp = image.getPointData().getScalars().getNumberOfComponents();
    const iComps = actorProperty.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;
    const textureHeight = iComps ? 2 * numIComps : 1;

    const cfunToString = computeFnToString(
      actorProperty,
      actorProperty.getRGBTransferFunction,
      numIComps
    );

    if (model.colorTextureString !== cfunToString) {
      const cWidth = 1024;
      const cSize = cWidth * textureHeight * 3;
      const cTable = new Uint8Array(cSize);
      let cfun = actorProperty.getRGBTransferFunction();
      if (cfun) {
        const tmpTable = new Float32Array(cWidth * 3);

        for (let c = 0; c < numIComps; c++) {
          cfun = actorProperty.getRGBTransferFunction(c);
          const cRange = cfun.getRange();
          cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
          if (iComps) {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
              cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];
            }
          } else {
            for (let i = 0; i < cWidth * 3; i++) {
              cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
            }
          }
        }
        model.colorTexture.create2DFromRaw(
          cWidth,
          textureHeight,
          3,
          vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_4__["VtkDataTypes"].UNSIGNED_CHAR,
          cTable
        );
      } else {
        for (let i = 0; i < cWidth * 3; ++i) {
          cTable[i] = (255.0 * i) / ((cWidth - 1) * 3);
          cTable[i + 1] = (255.0 * i) / ((cWidth - 1) * 3);
          cTable[i + 2] = (255.0 * i) / ((cWidth - 1) * 3);
        }
        model.colorTexture.create2DFromRaw(
          cWidth,
          1,
          3,
          vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_4__["VtkDataTypes"].UNSIGNED_CHAR,
          cTable
        );
      }

      model.colorTextureString = cfunToString;
    }

    // Build piecewise function buffer.  This buffer is used either
    // for component weighting or opacity, depending on whether we're
    // rendering components independently or not.
    const pwfunToString = computeFnToString(
      actorProperty,
      actorProperty.getPiecewiseFunction,
      numIComps
    );

    if (model.pwfTextureString !== pwfunToString) {
      const pwfWidth = 1024;
      const pwfSize = pwfWidth * textureHeight;
      const pwfTable = new Uint8Array(pwfSize);
      let pwfun = actorProperty.getPiecewiseFunction();
      // support case where pwfun is added/removed
      model.pwfTexture.resetFormatAndType();
      if (pwfun) {
        const pwfFloatTable = new Float32Array(pwfSize);
        const tmpTable = new Float32Array(pwfWidth);

        for (let c = 0; c < numIComps; ++c) {
          pwfun = actorProperty.getPiecewiseFunction(c);
          if (pwfun === null) {
            // Piecewise constant max if no function supplied for this component
            pwfFloatTable.fill(1.0);
          } else {
            const pwfRange = pwfun.getRange();
            pwfun.getTable(pwfRange[0], pwfRange[1], pwfWidth, tmpTable, 1);
            // adjust for sample distance etc
            if (iComps) {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
                pwfFloatTable[c * pwfWidth * 2 + i + pwfWidth] = tmpTable[i];
              }
            } else {
              for (let i = 0; i < pwfWidth; i++) {
                pwfFloatTable[c * pwfWidth * 2 + i] = tmpTable[i];
              }
            }
          }
        }
        model.pwfTexture.create2DFromRaw(
          pwfWidth,
          textureHeight,
          1,
          vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_4__["VtkDataTypes"].FLOAT,
          pwfFloatTable
        );
      } else {
        // default is opaque
        pwfTable.fill(255.0);
        model.pwfTexture.create2DFromRaw(
          pwfWidth,
          1,
          1,
          vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_4__["VtkDataTypes"].UNSIGNED_CHAR,
          pwfTable
        );
      }

      model.pwfTextureString = pwfunToString;
    }

    // Find what IJK axis and what direction to slice along
    const { ijkMode } = model.renderable.getClosestIJKAxis();

    // Find the IJK slice
    let nSlice = model.renderable.getSlice();
    if (ijkMode !== model.renderable.getSlicingMode()) {
      // If not IJK slicing, get the IJK slice from the XYZ position/slice
      nSlice = model.renderable.getSliceAtPosition(nSlice);
    }

    // Find sliceOffset
    const ext = image.getExtent();
    let sliceOffset;
    if (ijkMode === SlicingMode.I) {
      sliceOffset = nSlice - ext[0];
    }
    if (ijkMode === SlicingMode.J) {
      sliceOffset = nSlice - ext[2];
    }
    if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {
      sliceOffset = nSlice - ext[4];
    }

    // rebuild the VBO if the data has changed
    const toString = `${nSlice}A${image.getMTime()}A${image
      .getPointData()
      .getScalars()
      .getMTime()}B${publicAPI.getMTime()}C${model.renderable.getSlicingMode()}D${actor
      .getProperty()
      .getMTime()}`;
    if (model.VBOBuildString !== toString) {
      // Build the VBOs
      const dims = image.getDimensions();
      if (iType === vtk_js_Sources_Rendering_Core_ImageProperty_Constants__WEBPACK_IMPORTED_MODULE_12__["InterpolationType"].NEAREST) {
        if (numComp === 4) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Filter"].NEAREST);
        } else {
          model.openGLTexture.setMinificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Filter"].NEAREST);
        }
        model.openGLTexture.setMagnificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Filter"].NEAREST);
      } else {
        if (numComp === 4) {
          model.openGLTexture.setGenerateMipmap(true);
          model.openGLTexture.setMinificationFilter(
            vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Filter"].LINEAR_MIPMAP_LINEAR
          );
        } else {
          model.openGLTexture.setMinificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Filter"].LINEAR);
        }
        model.openGLTexture.setMagnificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Filter"].LINEAR);
      }
      model.openGLTexture.setWrapS(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Wrap"].CLAMP_TO_EDGE);
      model.openGLTexture.setWrapT(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_11__["Wrap"].CLAMP_TO_EDGE);
      const sliceSize = dims[0] * dims[1] * numComp;

      const ptsArray = new Float32Array(12);
      const tcoordArray = new Float32Array(8);
      for (let i = 0; i < 4; i++) {
        tcoordArray[i * 2] = i % 2 ? 1.0 : 0.0;
        tcoordArray[i * 2 + 1] = i > 1 ? 1.0 : 0.0;
      }

      const basicScalars = image.getPointData().getScalars().getData();
      let scalars = null;
      // Get right scalars according to slicing mode
      if (ijkMode === SlicingMode.I) {
        scalars = new basicScalars.constructor(dims[2] * dims[1] * numComp);
        let id = 0;
        for (let k = 0; k < dims[2]; k++) {
          for (let j = 0; j < dims[1]; j++) {
            const bsIdx =
              (sliceOffset + j * dims[0] + k * dims[0] * dims[1]) * numComp;
            id = (k * dims[1] + j) * numComp;
            scalars.set(basicScalars.subarray(bsIdx, bsIdx + numComp), id);
          }
        }
        dims[0] = dims[1];
        dims[1] = dims[2];
        ptsArray[0] = nSlice;
        ptsArray[1] = ext[2];
        ptsArray[2] = ext[4];
        ptsArray[3] = nSlice;
        ptsArray[4] = ext[3];
        ptsArray[5] = ext[4];
        ptsArray[6] = nSlice;
        ptsArray[7] = ext[2];
        ptsArray[8] = ext[5];
        ptsArray[9] = nSlice;
        ptsArray[10] = ext[3];
        ptsArray[11] = ext[5];
      } else if (ijkMode === SlicingMode.J) {
        scalars = new basicScalars.constructor(dims[2] * dims[0] * numComp);
        let id = 0;
        for (let k = 0; k < dims[2]; k++) {
          for (let i = 0; i < dims[0]; i++) {
            const bsIdx =
              (i + sliceOffset * dims[0] + k * dims[0] * dims[1]) * numComp;
            id = (k * dims[0] + i) * numComp;
            scalars.set(basicScalars.subarray(bsIdx, bsIdx + numComp), id);
          }
        }
        dims[1] = dims[2];
        ptsArray[0] = ext[0];
        ptsArray[1] = nSlice;
        ptsArray[2] = ext[4];
        ptsArray[3] = ext[1];
        ptsArray[4] = nSlice;
        ptsArray[5] = ext[4];
        ptsArray[6] = ext[0];
        ptsArray[7] = nSlice;
        ptsArray[8] = ext[5];
        ptsArray[9] = ext[1];
        ptsArray[10] = nSlice;
        ptsArray[11] = ext[5];
      } else if (ijkMode === SlicingMode.K || ijkMode === SlicingMode.NONE) {
        scalars = basicScalars.subarray(
          sliceOffset * sliceSize,
          (sliceOffset + 1) * sliceSize
        );
        ptsArray[0] = ext[0];
        ptsArray[1] = ext[2];
        ptsArray[2] = nSlice;
        ptsArray[3] = ext[1];
        ptsArray[4] = ext[2];
        ptsArray[5] = nSlice;
        ptsArray[6] = ext[0];
        ptsArray[7] = ext[3];
        ptsArray[8] = nSlice;
        ptsArray[9] = ext[1];
        ptsArray[10] = ext[3];
        ptsArray[11] = nSlice;
      } else {
        vtkErrorMacro('Reformat slicing not yet supported.');
      }

      model.openGLTexture.create2DFromRaw(
        dims[0],
        dims[1],
        numComp,
        image.getPointData().getScalars().getDataType(),
        scalars
      );
      model.openGLTexture.activate();
      model.openGLTexture.sendParameters();
      model.openGLTexture.deactivate();

      const points = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance({
        numberOfComponents: 3,
        values: ptsArray,
      });
      points.setName('points');
      const tcoords = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance({
        numberOfComponents: 2,
        values: tcoordArray,
      });
      tcoords.setName('tcoords');

      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const cells = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance({
        numberOfComponents: 1,
        values: cellArray,
      });

      model.tris.getCABO().createVBO(cells, 'polys', vtk_js_Sources_Rendering_Core_Property_Constants__WEBPACK_IMPORTED_MODULE_10__["Representation"].SURFACE, {
        points,
        tcoords,
        cellOffset: 0,
      });
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString;
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  VBOBuildTime: 0,
  VBOBuildString: null,
  openGLTexture: null,
  tris: null,
  imagemat: null,
  colorTexture: null,
  pwfTexture: null,
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastTextureComponents: 0,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_9__["default"].extend(publicAPI, model, initialValues);
  vtk_js_Sources_Rendering_OpenGL_ReplacementShaderMapper__WEBPACK_IMPORTED_MODULE_15__["default"].implementReplaceShaderCoincidentOffset(
    publicAPI,
    model,
    initialValues
  );

  model.tris = vtk_js_Sources_Rendering_OpenGL_Helper__WEBPACK_IMPORTED_MODULE_5__["default"].newInstance();
  model.openGLTexture = vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_7__["default"].newInstance();
  model.colorTexture = vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_7__["default"].newInstance();
  model.pwfTexture = vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_7__["default"].newInstance();

  model.imagemat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_2__["default"].setGet(publicAPI, model, []);

  model.VBOBuildTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_2__["default"].obj(model.VBOBuildTime);

  // Object methods
  vtkOpenGLImageMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance(extend, 'vtkOpenGLImageMapper');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ImageSlice/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/ImageSlice/index.js ***!
  \**************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/ViewNode */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js");





// ----------------------------------------------------------------------------
// vtkOpenGLImageSlice methods
// ----------------------------------------------------------------------------

function vtkOpenGLImageSlice(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLImageSlice');

  // Builds myself.
  publicAPI.buildPass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      if (!model.renderable) {
        return;
      }

      model.openGLRenderer = publicAPI.getFirstAncestorOfType(
        'vtkOpenGLRenderer'
      );
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };

  publicAPI.traverseOpaqueZBufferPass = (renderPass) => {
    publicAPI.traverseOpaquePass(renderPass);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (
      !model.renderable ||
      !model.renderable.getVisibility() ||
      !model.renderable.getIsOpaque() ||
      (model.openGLRenderer.getSelector() && !model.renderable.getPickable())
    ) {
      return;
    }

    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };

  // we draw textures, then mapper, then post pass textures
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (
      !model.renderable ||
      !model.renderable.getVisibility() ||
      model.renderable.getIsOpaque() ||
      (model.openGLRenderer.getSelector() && !model.renderable.getPickable())
    ) {
      return;
    }

    publicAPI.apply(renderPass, true);
    model.children.forEach((child) => {
      child.traverse(renderPass);
    });
    publicAPI.apply(renderPass, false);
  };

  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };

  publicAPI.opaqueZBufferPass = (prepass, renderPass) =>
    publicAPI.opaquePass(prepass, renderPass);

  // Renders myself
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context = publicAPI
        .getFirstAncestorOfType('vtkOpenGLRenderWindow')
        .getContext();
      model.context.depthMask(true);
    }
  };

  // Renders myself
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.context = publicAPI
        .getFirstAncestorOfType('vtkOpenGLRenderWindow')
        .getContext();
      model.context.depthMask(false);
    } else {
      model.context.depthMask(true);
    }
  };

  publicAPI.getKeyMatrices = () => {
    // has the actor changed?
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      model.keyMatrixTime.modified();
    }

    return model.keyMatrices;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  keyMatrixTime: null,
  keyMatrices: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_2__["default"].extend(publicAPI, model, initialValues);

  model.keyMatrixTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(model.keyMatrixTime, { mtime: 0 });
  model.keyMatrices = {
    mcwc: gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create(),
  };

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGet(publicAPI, model, ['context']);

  // Object methods
  vtkOpenGLImageSlice(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend, 'vtkOpenGLImageSlice');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/PixelSpaceCallbackMapper/index.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/PixelSpaceCallbackMapper/index.js ***!
  \****************************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/ViewNode */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js");
// import { mat4, vec3 }     from 'gl-matrix';




const { vtkDebugMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

// ----------------------------------------------------------------------------
// vtkOpenGLPixelSpaceCallbackMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push('vtkOpenGLPixelSpaceCallbackMapper');

  publicAPI.opaquePass = (prepass, renderPass) => {
    model.openGLRenderer = publicAPI.getFirstAncestorOfType(
      'vtkOpenGLRenderer'
    );
    model.openGLRenderWindow = model.openGLRenderer.getParent();
    const aspectRatio = model.openGLRenderer.getAspectRatio();
    const camera = model.openGLRenderer
      ? model.openGLRenderer.getRenderable().getActiveCamera()
      : null;
    const tsize = model.openGLRenderer.getTiledSizeAndOrigin();
    let texels = null;

    if (model.renderable.getUseZValues()) {
      const zbt = renderPass.getZBufferTexture();
      const width = Math.floor(zbt.getWidth());
      const height = Math.floor(zbt.getHeight());

      const gl = model.openGLRenderWindow.getContext();
      zbt.bind();

      // Here we need to use vtkFramebuffer to save current settings (bindings/buffers)
      const fb = renderPass.getFramebuffer();
      if (!fb) {
        vtkDebugMacro('No framebuffer to save/restore');
      } else {
        // save framebuffer settings
        fb.saveCurrentBindingsAndBuffers();
      }

      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0,
        gl.TEXTURE_2D,
        zbt.getHandle(),
        0
      );

      if (
        gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE
      ) {
        texels = new Uint8Array(width * height * 4);
        gl.viewport(0, 0, width, height);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, texels);
      }

      // Now we need to restore framebuffer bindings/buffers
      if (fb) {
        fb.restorePreviousBindingsAndBuffers();
      }

      gl.deleteFramebuffer(framebuffer);
    }

    model.renderable.invokeCallback(
      model.renderable.getInputData(),
      camera,
      aspectRatio,
      tsize,
      texels
    );
  };

  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (model.renderable.getUseZValues()) {
        renderPass.setDepthRequested(true);
      } else {
        renderPass.setDepthRequested(true);
      }
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_1__["default"].extend(publicAPI, model, initialValues);

  // Object methods
  vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(
  extend,
  'vtkOpenGLPixelSpaceCallbackMapper'
);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/PolyDataMapper/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/PolyDataMapper/index.js ***!
  \******************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Helper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Helper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Helper/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Mapper */ "./node_modules/vtk.js/Sources/Rendering/Core/Mapper/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Texture */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Property__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Property */ "./node_modules/vtk.js/Sources/Rendering/Core/Property/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ShaderProgram */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderProgram/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/ViewNode */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataVS_glsl__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataVS_glsl__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataVS_glsl__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ReplacementShaderMapper__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ReplacementShaderMapper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ReplacementShaderMapper/index.js");















/* eslint-disable no-lonely-if */

const primTypes = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Tris: 2,
  TriStrips: 3,
  TrisEdges: 4,
  TriStripsEdges: 5,
  End: 6,
};

const { Representation, Shading } = vtk_js_Sources_Rendering_Core_Property__WEBPACK_IMPORTED_MODULE_6__["default"];
const { ScalarMode } = vtk_js_Sources_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_3__["default"];
const { Filter, Wrap } = vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_5__["default"];
const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"];
const StartEvent = { type: 'StartEvent' };
const EndEvent = { type: 'EndEvent' };

// ----------------------------------------------------------------------------
// vtkOpenGLPolyDataMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLPolyDataMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLPolyDataMapper');

  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.openGLActor = publicAPI.getFirstAncestorOfType('vtkOpenGLActor');
      model.openGLRenderer = model.openGLActor.getFirstAncestorOfType(
        'vtkOpenGLRenderer'
      );
      model.openGLRenderWindow = model.openGLRenderer.getParent();
      model.openGLCamera = model.openGLRenderer.getViewNodeFor(
        model.openGLRenderer.getRenderable().getActiveCamera()
      );
    }
  };

  // Renders myself
  publicAPI.translucentPass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };

  publicAPI.opaqueZBufferPass = (prepass) => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };

  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };

  publicAPI.render = () => {
    const ctx = model.openGLRenderWindow.getContext();
    if (model.context !== ctx) {
      model.context = ctx;
      for (let i = primTypes.Start; i < primTypes.End; i++) {
        model.primitives[i].setOpenGLRenderWindow(model.openGLRenderWindow);
      }
    }
    const actor = model.openGLActor.getRenderable();
    const ren = model.openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };

  publicAPI.buildShaders = (shaders, ren, actor) => {
    publicAPI.getShaderTemplate(shaders, ren, actor);

    // user specified pre replacements
    const openGLSpec = model.renderable.getViewSpecificProperties().OpenGL;
    let shaderReplacements = null;
    if (openGLSpec) {
      shaderReplacements = openGLSpec.ShaderReplacements;
    }

    if (shaderReplacements) {
      for (let i = 0; i < shaderReplacements.length; i++) {
        const currReplacement = shaderReplacements[i];
        if (currReplacement.replaceFirst) {
          const shaderType = currReplacement.shaderType;
          const ssrc = shaders[shaderType];
          const substituteRes = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
            ssrc,
            currReplacement.originalValue,
            currReplacement.replacementValue,
            currReplacement.replaceAll
          );
          shaders[shaderType] = substituteRes.result;
        }
      }
    }

    publicAPI.replaceShaderValues(shaders, ren, actor);

    // user specified post replacements
    if (shaderReplacements) {
      for (let i = 0; i < shaderReplacements.length; i++) {
        const currReplacement = shaderReplacements[i];
        if (!currReplacement.replaceFirst) {
          const shaderType = currReplacement.shaderType;
          const ssrc = shaders[shaderType];
          const substituteRes = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
            ssrc,
            currReplacement.originalValue,
            currReplacement.replacementValue,
            currReplacement.replaceAll
          );
          shaders[shaderType] = substituteRes.result;
        }
      }
    }
  };

  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    const openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;

    let vertexShaderCode = vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataVS_glsl__WEBPACK_IMPORTED_MODULE_9___default.a;
    if (openGLSpecProp) {
      const vertexSpecProp = openGLSpecProp.VertexShaderCode;
      if (vertexSpecProp !== undefined && vertexSpecProp !== '') {
        vertexShaderCode = vertexSpecProp;
      }
    }
    shaders.Vertex = vertexShaderCode;

    let fragmentShaderCode = vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_10___default.a;
    if (openGLSpecProp) {
      const fragmentSpecProp = openGLSpecProp.FragmentShaderCode;
      if (fragmentSpecProp !== undefined && fragmentSpecProp !== '') {
        fragmentShaderCode = fragmentSpecProp;
      }
    }
    shaders.Fragment = fragmentShaderCode;

    let geometryShaderCode = '';
    if (openGLSpecProp) {
      const geometrySpecProp = openGLSpecProp.GeometryShaderCode;
      if (geometrySpecProp !== undefined) {
        geometryShaderCode = geometrySpecProp;
      }
    }
    shaders.Geometry = geometryShaderCode;
  };

  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;

    const lastLightComplexity = model.lastBoundBO.getReferenceByName(
      'lastLightComplexity'
    );

    // create the material/color property declarations, and VS implementation
    // these are always defined
    let colorDec = [
      'uniform float ambient;',
      'uniform float diffuse;',
      'uniform float specular;',
      'uniform float opacityUniform; // the fragment opacity',
      'uniform vec3 ambientColorUniform;',
      'uniform vec3 diffuseColorUniform;',
    ];
    // add more for specular
    if (lastLightComplexity) {
      colorDec = colorDec.concat([
        'uniform vec3 specularColorUniform;',
        'uniform float specularPowerUniform;',
      ]);
    }

    // now handle the more complex fragment shader implementation
    // the following are always defined variables.  We start
    // by assigning a default value from the uniform
    let colorImpl = [
      'vec3 ambientColor;',
      '  vec3 diffuseColor;',
      '  float opacity;',
    ];
    if (lastLightComplexity) {
      colorImpl = colorImpl.concat([
        '  vec3 specularColor;',
        '  float specularPower;',
      ]);
    }
    colorImpl = colorImpl.concat([
      '  ambientColor = ambientColorUniform;',
      '  diffuseColor = diffuseColorUniform;',
      '  opacity = opacityUniform;',
    ]);
    if (lastLightComplexity) {
      colorImpl = colorImpl.concat([
        '  specularColor = specularColorUniform;',
        '  specularPower = specularPowerUniform;',
      ]);
    }

    // add scalar vertex coloring
    if (
      model.lastBoundBO.getCABO().getColorComponents() !== 0 &&
      !model.drawingEdges
    ) {
      colorDec = colorDec.concat(['varying vec4 vertexColorVSOutput;']);
      VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(VSSource, '//VTK::Color::Dec', [
        'attribute vec4 scalarColor;',
        'varying vec4 vertexColorVSOutput;',
      ]).result;
      VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(VSSource, '//VTK::Color::Impl', [
        'vertexColorVSOutput =  scalarColor;',
      ]).result;
      GSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(GSSource, '//VTK::Color::Dec', [
        'in vec4 vertexColorVSOutput[];',
        'out vec4 vertexColorGSOutput;',
      ]).result;
      GSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(GSSource, '//VTK::Color::Impl', [
        'vertexColorGSOutput = vertexColorVSOutput[i];',
      ]).result;
    }

    if (
      model.lastBoundBO.getCABO().getColorComponents() !== 0 &&
      !model.drawingEdges
    ) {
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
        FSSource,
        '//VTK::Color::Impl',
        colorImpl.concat([
          '  diffuseColor = vertexColorVSOutput.rgb;',
          '  ambientColor = vertexColorVSOutput.rgb;',
          '  opacity = opacity*vertexColorVSOutput.a;',
        ])
      ).result;
    } else {
      if (
        model.renderable.getInterpolateScalarsBeforeMapping() &&
        model.renderable.getColorCoordinates() &&
        !model.drawingEdges
      ) {
        FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          FSSource,
          '//VTK::Color::Impl',
          colorImpl.concat([
            '  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);',
            '  diffuseColor = texColor.rgb;',
            '  ambientColor = texColor.rgb;',
            '  opacity = opacity*texColor.a;',
          ])
        ).result;
      } else {
        FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          FSSource,
          '//VTK::Color::Impl',
          colorImpl
        ).result;
      }
    }

    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
      FSSource,
      '//VTK::Color::Dec',
      colorDec
    ).result;

    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };

  publicAPI.replaceShaderLight = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;

    // check for shadow maps
    const shadowFactor = '';

    const lastLightComplexity = model.lastBoundBO.getReferenceByName(
      'lastLightComplexity'
    );

    const lastLightCount = model.lastBoundBO.getReferenceByName(
      'lastLightCount'
    );

    let sstring = [];

    switch (lastLightComplexity) {
      case 0: // no lighting or RENDER_VALUES
        FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          FSSource,
          '//VTK::Light::Impl',
          [
            '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);',
            '  //VTK::Light::Impl',
          ],
          false
        ).result;
        break;

      case 1: // headlight
        FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          FSSource,
          '//VTK::Light::Impl',
          [
            '  float df = max(0.0, normalVCVSOutput.z);',
            '  float sf = pow(df, specularPower);',
            '  vec3 diffuseL = df * diffuseColor;',
            '  vec3 specularL = sf * specularColor;',
            '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);',
            '  //VTK::Light::Impl',
          ],
          false
        ).result;
        break;

      case 2: // light kit
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([
            `uniform vec3 lightColor${lc};`,
            `uniform vec3 lightDirectionVC${lc}; // normalized`,
            `uniform vec3 lightHalfAngleVC${lc}; // normalized`,
          ]);
        }
        FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          FSSource,
          '//VTK::Light::Dec',
          sstring
        ).result;

        sstring = [
          'vec3 diffuseL = vec3(0,0,0);',
          '  vec3 specularL = vec3(0,0,0);',
          '  float df;',
        ];
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([
            `  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${lc}));`,
            `  diffuseL += ((df${shadowFactor}) * lightColor${lc});`,
            `  if (dot(normalVCVSOutput, lightDirectionVC${lc}) < 0.0)`,
            '    {',
            `    float sf = pow( max(0.0, dot(lightHalfAngleVC${lc},normalVCVSOutput)), specularPower);`,
            `    specularL += ((sf${shadowFactor}) * lightColor${lc});`,
            '    }',
          ]);
        }
        sstring = sstring.concat([
          '  diffuseL = diffuseL * diffuseColor;',
          '  specularL = specularL * specularColor;',
          '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);',
          '  //VTK::Light::Impl',
        ]);
        FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          FSSource,
          '//VTK::Light::Impl',
          sstring,
          false
        ).result;
        break;

      case 3: // positional
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([
            `uniform vec3 lightColor${lc};`,
            `uniform vec3 lightDirectionVC${lc}; // normalized`,
            `uniform vec3 lightHalfAngleVC${lc}; // normalized`,
            `uniform vec3 lightPositionVC${lc};`,
            `uniform vec3 lightAttenuation${lc};`,
            `uniform float lightConeAngle${lc};`,
            `uniform float lightExponent${lc};`,
            `uniform int lightPositional${lc};`,
          ]);
        }
        FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          FSSource,
          '//VTK::Light::Dec',
          sstring
        ).result;

        sstring = [
          'vec3 diffuseL = vec3(0,0,0);',
          '  vec3 specularL = vec3(0,0,0);',
          '  vec3 vertLightDirectionVC;',
          '  float attenuation;',
          '  float df;',
        ];
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([
            '  attenuation = 1.0;',
            `  if (lightPositional${lc} == 0)`,
            '    {',
            `      vertLightDirectionVC = lightDirectionVC${lc};`,
            '    }',
            '  else',
            '    {',
            `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${lc};`,
            '    float distanceVC = length(vertLightDirectionVC);',
            '    vertLightDirectionVC = normalize(vertLightDirectionVC);',
            '    attenuation = 1.0 /',
            `      (lightAttenuation${lc}.x`,
            `       + lightAttenuation${lc}.y * distanceVC`,
            `       + lightAttenuation${lc}.z * distanceVC * distanceVC);`,
            '    // per OpenGL standard cone angle is 90 or less for a spot light',
            `    if (lightConeAngle${lc} <= 90.0)`,
            '      {',
            `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${lc});`,
            '      // if inside the cone',
            `      if (coneDot >= cos(radians(lightConeAngle${lc})))`,
            '        {',
            `        attenuation = attenuation * pow(coneDot, lightExponent${lc});`,
            '        }',
            '      else',
            '        {',
            '        attenuation = 0.0;',
            '        }',
            '      }',
            '    }',
            '    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));',
            `    diffuseL += ((df${shadowFactor}) * lightColor${lc});`,
            '    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)',
            '      {',
            `      float sf = attenuation*pow( max(0.0, dot(lightHalfAngleVC${lc},normalVCVSOutput)), specularPower);`,
            `    specularL += ((sf${shadowFactor}) * lightColor${lc});`,
            '    }',
          ]);
        }
        sstring = sstring.concat([
          '  diffuseL = diffuseL * diffuseColor;',
          '  specularL = specularL * specularColor;',
          '  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);',
          '  //VTK::Light::Impl',
        ]);
        FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          FSSource,
          '//VTK::Light::Impl',
          sstring,
          false
        ).result;
        break;
      default:
        vtkErrorMacro('bad light complexity');
    }

    shaders.Fragment = FSSource;
  };

  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {
    const lastLightComplexity = model.lastBoundBO.getReferenceByName(
      'lastLightComplexity'
    );

    if (lastLightComplexity > 0) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;

      if (model.lastBoundBO.getCABO().getNormalOffset()) {
        VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(VSSource, '//VTK::Normal::Dec', [
          'attribute vec3 normalMC;',
          'uniform mat3 normalMatrix;',
          'varying vec3 normalVCVSOutput;',
        ]).result;
        VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          VSSource,
          '//VTK::Normal::Impl',
          ['normalVCVSOutput = normalMatrix * normalMC;']
        ).result;
        GSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(GSSource, '//VTK::Normal::Dec', [
          'in vec3 normalVCVSOutput[];',
          'out vec3 normalVCGSOutput;',
        ]).result;
        GSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          GSSource,
          '//VTK::Normal::Impl',
          ['normalVCGSOutput = normalVCVSOutput[i];']
        ).result;
        FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(FSSource, '//VTK::Normal::Dec', [
          'varying vec3 normalVCVSOutput;',
        ]).result;
        FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          FSSource,
          '//VTK::Normal::Impl',
          [
            'vec3 normalVCVSOutput = normalize(normalVCVSOutput);',
            //  if (!gl_FrontFacing) does not work in intel hd4000 mac
            //  if (int(gl_FrontFacing) == 0) does not work on mesa
            '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }',
          ]
        ).result;
      } else {
        if (model.haveCellNormals) {
          FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
            FSSource,
            '//VTK::Normal::Dec',
            ['uniform mat3 normalMatrix;', 'uniform samplerBuffer textureN;']
          ).result;
          FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
            FSSource,
            '//VTK::Normal::Impl',
            [
              'vec3 normalVCVSOutput = normalize(normalMatrix *',
              '    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);',
              '  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }',
            ]
          ).result;
        } else {
          if (
            publicAPI.getOpenGLMode(
              actor.getProperty().getRepresentation(),
              model.lastBoundBO.getPrimitiveType()
            ) === model.context.LINES
          ) {
            // generate a normal for lines, it will be perpendicular to the line
            // and maximally aligned with the camera view direction
            // no clue if this is the best way to do this.
            // the code below has been optimized a bit so what follows is
            // an explanation of the basic approach. Compute the gradient of the line
            // with respect to x and y, the the larger of the two
            // cross that with the camera view direction. That gives a vector
            // orthogonal to the camera view and the line. Note that the line and the camera
            // view are probably not orthogonal. Which is why when we cross result that with
            // the line gradient again we get a reasonable normal. It will be othogonal to
            // the line (which is a plane but maximally aligned with the camera view.
            FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
              FSSource,
              '//VTK::UniformFlow::Impl',
              [
                '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',
                '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',
                '  //VTK::UniformFlow::Impl',
              ] // For further replacements
            ).result;
            FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
              FSSource,
              '//VTK::Normal::Impl',
              [
                'vec3 normalVCVSOutput;',
                '  fdx = normalize(fdx);',
                '  fdy = normalize(fdy);',
                '  if (abs(fdx.x) > 0.0)',
                '    { normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }',
                '  else { normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}',
              ]
            ).result;
          } else {
            FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
              FSSource,
              '//VTK::Normal::Dec',
              ['uniform int cameraParallel;']
            ).result;

            FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
              FSSource,
              '//VTK::UniformFlow::Impl',
              [
                // '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',
                // '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',
                '  vec3 fdx = dFdx(vertexVC.xyz);',
                '  vec3 fdy = dFdy(vertexVC.xyz);',
                '  //VTK::UniformFlow::Impl',
              ] // For further replacements
            ).result;
            FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
              FSSource,
              '//VTK::Normal::Impl',
              [
                '  fdx = normalize(fdx);',
                '  fdy = normalize(fdy);',
                '  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));',
                // the code below is faster, but does not work on some devices
                // 'vec3 normalVC = normalize(cross(dFdx(vertexVC.xyz), dFdy(vertexVC.xyz)));',
                '  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }',
                '  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }',
              ]
            ).result;
          }
        }
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };

  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;

    // for points make sure to add in the point size
    if (
      actor.getProperty().getRepresentation() === Representation.POINTS ||
      model.lastBoundBO.getPrimitiveType() === primTypes.Points
    ) {
      VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
        VSSource,
        '//VTK::PositionVC::Impl',
        [
          '//VTK::PositionVC::Impl',
          `  gl_PointSize = ${actor.getProperty().getPointSize()}.0;`,
        ],
        false
      ).result;
    }

    // do we need the vertex in the shader in View Coordinates
    const lastLightComplexity = model.lastBoundBO.getReferenceByName(
      'lastLightComplexity'
    );
    if (lastLightComplexity > 0) {
      VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
        VSSource,
        '//VTK::PositionVC::Dec',
        ['varying vec4 vertexVCVSOutput;']
      ).result;
      VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
        VSSource,
        '//VTK::PositionVC::Impl',
        [
          'vertexVCVSOutput = MCVCMatrix * vertexMC;',
          '  gl_Position = MCPCMatrix * vertexMC;',
        ]
      ).result;
      VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(VSSource, '//VTK::Camera::Dec', [
        'uniform mat4 MCPCMatrix;',
        'uniform mat4 MCVCMatrix;',
      ]).result;
      GSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
        GSSource,
        '//VTK::PositionVC::Dec',
        ['in vec4 vertexVCVSOutput[];', 'out vec4 vertexVCGSOutput;']
      ).result;
      GSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
        GSSource,
        '//VTK::PositionVC::Impl',
        ['vertexVCGSOutput = vertexVCVSOutput[i];']
      ).result;
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
        FSSource,
        '//VTK::PositionVC::Dec',
        ['varying vec4 vertexVCVSOutput;']
      ).result;
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
        FSSource,
        '//VTK::PositionVC::Impl',
        ['vec4 vertexVC = vertexVCVSOutput;']
      ).result;
    } else {
      VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(VSSource, '//VTK::Camera::Dec', [
        'uniform mat4 MCPCMatrix;',
      ]).result;
      VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
        VSSource,
        '//VTK::PositionVC::Impl',
        ['  gl_Position = MCPCMatrix * vertexMC;']
      ).result;
    }
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };

  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    if (model.lastBoundBO.getCABO().getTCoordOffset()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;

      if (model.drawingEdges) {
        return;
      }

      VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
        VSSource,
        '//VTK::TCoord::Impl',
        'tcoordVCVSOutput = tcoordMC;'
      ).result;

      // we only handle the first texture by default
      // additional textures are activated and we set the uniform
      // for the texture unit they are assigned to, but you have to
      // add in the shader code to do something with them
      const tus = model.openGLActor.getActiveTextures();
      let tNumComp = 2;
      let tcdim = 2;
      if (tus && tus.length > 0) {
        tNumComp = tus[0].getComponents();
        if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {
          tcdim = 3;
        }
      }
      if (model.renderable.getColorTextureMap()) {
        tNumComp = model.renderable
          .getColorTextureMap()
          .getPointData()
          .getScalars()
          .getNumberOfComponents();
        tcdim = 2;
      }

      if (tcdim === 2) {
        VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          VSSource,
          '//VTK::TCoord::Dec',
          'attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;'
        ).result;
        GSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(GSSource, '//VTK::TCoord::Dec', [
          'in vec2 tcoordVCVSOutput[];',
          'out vec2 tcoordVCGSOutput;',
        ]).result;
        GSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          GSSource,
          '//VTK::TCoord::Impl',
          'tcoordVCGSOutput = tcoordVCVSOutput[i];'
        ).result;
        FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(FSSource, '//VTK::TCoord::Dec', [
          'varying vec2 tcoordVCVSOutput;',
          'uniform sampler2D texture1;',
        ]).result;
        if (tus && tus.length >= 1) {
          switch (tNumComp) {
            case 1:
              FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
                FSSource,
                '//VTK::TCoord::Impl',
                [
                  'vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);',
                  'gl_FragData[0] = clamp(gl_FragData[0],0.0,1.0)*',
                  '  vec4(tcolor.r,tcolor.r,tcolor.r,1.0);',
                ]
              ).result;
              break;
            case 2:
              FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
                FSSource,
                '//VTK::TCoord::Impl',
                [
                  'vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);',
                  'gl_FragData[0] = clamp(gl_FragData[0],0.0,1.0)*',
                  '  vec4(tcolor.r,tcolor.r,tcolor.r,tcolor.g);',
                ]
              ).result;
              break;
            default:
              FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
                FSSource,
                '//VTK::TCoord::Impl',
                'gl_FragData[0] = clamp(gl_FragData[0],0.0,1.0)*texture2D(texture1, tcoordVCVSOutput.st);'
              ).result;
          }
        }
      } else {
        VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          VSSource,
          '//VTK::TCoord::Dec',
          'attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;'
        ).result;
        GSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(GSSource, '//VTK::TCoord::Dec', [
          'in vec3 tcoordVCVSOutput[];',
          'out vec3 tcoordVCGSOutput;',
        ]).result;
        GSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
          GSSource,
          '//VTK::TCoord::Impl',
          'tcoordVCGSOutput = tcoordVCVSOutput[i];'
        ).result;
        FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(FSSource, '//VTK::TCoord::Dec', [
          'varying vec3 tcoordVCVSOutput;',
          'uniform samplerCube texture1;',
        ]).result;
        switch (tNumComp) {
          case 1:
            FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
              FSSource,
              '//VTK::TCoord::Impl',
              [
                'vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);',
                'gl_FragData[0] = clamp(gl_FragData[0],0.0,1.0)*',
                '  vec4(tcolor.r,tcolor.r,tcolor.r,1.0);',
              ]
            ).result;
            break;
          case 2:
            FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
              FSSource,
              '//VTK::TCoord::Impl',
              [
                'vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);',
                'gl_FragData[0] = clamp(gl_FragData[0],0.0,1.0)*',
                '  vec4(tcolor.r,tcolor.r,tcolor.r,tcolor.g);',
              ]
            ).result;
            break;
          default:
            FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
              FSSource,
              '//VTK::TCoord::Impl',
              'gl_FragData[0] = clamp(gl_FragData[0],0.0,1.0)*textureCube(texture1, tcoordVCVSOutput);'
            ).result;
        }
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };

  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;

    if (model.renderable.getNumberOfClippingPlanes()) {
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].vtkErrorMacro('OpenGL has a limit of 6 clipping planes');
        numClipPlanes = 6;
      }
      VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(VSSource, '//VTK::Clip::Dec', [
        'uniform int numClipPlanes;',
        'uniform vec4 clipPlanes[6];',
        'varying float clipDistancesVSOutput[6];',
      ]).result;

      VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(VSSource, '//VTK::Clip::Impl', [
        'for (int planeNum = 0; planeNum < 6; planeNum++)',
        '    {',
        '    if (planeNum >= numClipPlanes)',
        '        {',
        '        break;',
        '        }',
        '    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);',
        '    }',
      ]).result;
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(FSSource, '//VTK::Clip::Dec', [
        'uniform int numClipPlanes;',
        'varying float clipDistancesVSOutput[6];',
      ]).result;

      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(FSSource, '//VTK::Clip::Impl', [
        'for (int planeNum = 0; planeNum < 6; planeNum++)',
        '    {',
        '    if (planeNum >= numClipPlanes)',
        '        {',
        '        break;',
        '        }',
        '    if (clipDistancesVSOutput[planeNum] < 0.0) discard;',
        '    }',
      ]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };

  publicAPI.getCoincidentParameters = (ren, actor) => {
    // 1. ResolveCoincidentTopology is On and non zero for this primitive
    // type
    let cp = null;
    const prop = actor.getProperty();
    if (
      model.renderable.getResolveCoincidentTopology() ||
      (prop.getEdgeVisibility() &&
        prop.getRepresentation() === Representation.SURFACE)
    ) {
      const primType = model.lastBoundBO.getPrimitiveType();
      if (
        primType === primTypes.Points ||
        prop.getRepresentation() === Representation.POINTS
      ) {
        cp = model.renderable.getCoincidentTopologyPointOffsetParameter();
      } else if (
        primType === primTypes.Lines ||
        prop.getRepresentation() === Representation.WIREFRAME
      ) {
        cp = model.renderable.getCoincidentTopologyLineOffsetParameters();
      } else if (
        primType === primTypes.Tris ||
        primType === primTypes.TriStrips
      ) {
        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
      }
      if (
        primType === primTypes.TrisEdges ||
        primType === primTypes.TriStripsEdges
      ) {
        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
        cp.factor /= 2.0;
        cp.offset /= 2.0;
      }
    }

    // hardware picking always offset due to saved zbuffer
    // This gets you above the saved surface depth buffer.
    // vtkHardwareSelector* selector = ren->GetSelector();
    // if (selector &&
    //     selector->GetFieldAssociation() == vtkDataObject::FIELD_ASSOCIATION_POINTS)
    // {
    //   offset -= 2.0;
    //   return;
    // }
    return cp;
  };

  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(FSSource, '//VTK::Picking::Dec', [
      'uniform vec3 mapperIndex;',
      'uniform int picking;',
    ]).result;
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
      FSSource,
      '//VTK::Picking::Impl',
      '  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];'
    ).result;
    shaders.Fragment = FSSource;
  };

  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderColor(shaders, ren, actor);
    publicAPI.replaceShaderNormal(shaders, ren, actor);
    publicAPI.replaceShaderLight(shaders, ren, actor);
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPicking(shaders, ren, actor);
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);

    if (model.haveSeenDepthRequest) {
      let FSSource = shaders.Fragment;
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(
        FSSource,
        '//VTK::ZBuffer::Dec',
        'uniform int depthRequest;'
      ).result;
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_7__["default"].substitute(FSSource, '//VTK::ZBuffer::Impl', [
        'if (depthRequest == 1) {',
        'float iz = floor(gl_FragCoord.z*65535.0 + 0.1);',
        'float rf = floor(iz/256.0)/255.0;',
        'float gf = mod(iz,256.0)/255.0;',
        'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }',
      ]).result;
      shaders.Fragment = FSSource;
    }
  };

  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    let lightComplexity = 0;
    let numberOfLights = 0;

    const primType = cellBO.getPrimitiveType();
    const poly = model.currentInput;

    // different algo from C++ as of 5/2019
    let needLighting = false;
    const pointNormals = poly.getPointData().getNormals();
    const cellNormals = poly.getCellData().getNormals();
    const flat = actor.getProperty().getInterpolation() === Shading.FLAT;
    const representation = actor.getProperty().getRepresentation();
    const mode = publicAPI.getOpenGLMode(representation, primType);
    // 1) all surfaces need lighting
    if (mode === model.context.TRIANGLES) {
      needLighting = true;
      // 2) all cell normals without point normals need lighting
    } else if (cellNormals && !pointNormals) {
      needLighting = true;
      // 3) Phong + pointNormals need lighting
    } else if (!flat && pointNormals) {
      needLighting = true;
      // 4) Phong Lines need lighting
    } else if (!flat && mode === model.context.LINES) {
      needLighting = true;
    }
    // 5) everything else is unlit

    // do we need lighting?
    if (actor.getProperty().getLighting() && needLighting) {
      // consider the lighting complexity to determine which case applies
      // simple headlight, Light Kit, the whole feature set of VTK
      lightComplexity = 0;
      const lights = ren.getLightsByReference();
      for (let index = 0; index < lights.length; ++index) {
        const light = lights[index];
        const status = light.getSwitch();
        if (status > 0) {
          numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }

        if (
          lightComplexity === 1 &&
          (numberOfLights > 1 ||
            light.getIntensity() !== 1.0 ||
            !light.lightTypeIsHeadLight())
        ) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      }
    }

    let needRebuild = false;
    const lastLightComplexity = model.lastBoundBO.getReferenceByName(
      'lastLightComplexity'
    );
    const lastLightCount = model.lastBoundBO.getReferenceByName(
      'lastLightCount'
    );
    if (
      lastLightComplexity !== lightComplexity ||
      lastLightCount !== numberOfLights
    ) {
      model.lastBoundBO.set({ lastLightComplexity: lightComplexity }, true);
      model.lastBoundBO.set({ lastLightCount: numberOfLights }, true);
      needRebuild = true;
    }

    // has something changed that would require us to recreate the shader?
    // candidates are
    // property modified (representation interpolation and lighting)
    // input modified
    // light complexity changed
    if (
      model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest ||
      cellBO.getProgram() === 0 ||
      cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() ||
      cellBO.getShaderSourceTime().getMTime() < actor.getMTime() ||
      cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() ||
      cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() ||
      needRebuild
    ) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      return true;
    }

    return false;
  };

  publicAPI.updateShaders = (cellBO, ren, actor) => {
    model.lastBoundBO = cellBO;

    // has something changed that would require us to recreate the shader?
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = { Vertex: null, Fragment: null, Geometry: null };
      publicAPI.buildShaders(shaders, ren, actor);

      // compile and bind the program if needed
      const newShader = model.openGLRenderWindow
        .getShaderCache()
        .readyShaderProgramArray(
          shaders.Vertex,
          shaders.Fragment,
          shaders.Geometry
        );

      // if the shader changed reinitialize the VAO
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        // reset the VAO as the shader has changed
        cellBO.getVAO().releaseGraphicsResources();
      }

      cellBO.getShaderSourceTime().modified();
    } else {
      model.openGLRenderWindow
        .getShaderCache()
        .readyShaderProgram(cellBO.getProgram());
    }

    cellBO.getVAO().bind();

    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setLightingShaderParameters(cellBO, ren, actor);

    const listCallbacks = model.renderable.getViewSpecificProperties()
      .ShadersCallbacks;
    if (listCallbacks) {
      listCallbacks.forEach((object) => {
        object.callback(object.userData, cellBO, ren, actor);
      });
    }
  };

  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    // Now to update the VAO too, if necessary.
    if (cellBO.getProgram().isUniformUsed('PrimitiveIDOffset')) {
      cellBO
        .getProgram()
        .setUniformi('PrimitiveIDOffset', model.primitiveIDOffset);
    }

    if (
      cellBO.getCABO().getElementCount() &&
      (model.VBOBuildTime.getMTime() >
        cellBO.getAttributeUpdateTime().getMTime() ||
        cellBO.getShaderSourceTime().getMTime() >
          cellBO.getAttributeUpdateTime().getMTime())
    ) {
      const lastLightComplexity = model.lastBoundBO.getReferenceByName(
        'lastLightComplexity'
      );

      if (cellBO.getProgram().isAttributeUsed('vertexMC')) {
        if (
          !cellBO
            .getVAO()
            .addAttributeArray(
              cellBO.getProgram(),
              cellBO.getCABO(),
              'vertexMC',
              cellBO.getCABO().getVertexOffset(),
              cellBO.getCABO().getStride(),
              model.context.FLOAT,
              3,
              false
            )
        ) {
          vtkErrorMacro('Error setting vertexMC in shader VAO.');
        }
      }
      if (
        cellBO.getProgram().isAttributeUsed('normalMC') &&
        cellBO.getCABO().getNormalOffset() &&
        lastLightComplexity > 0
      ) {
        if (
          !cellBO
            .getVAO()
            .addAttributeArray(
              cellBO.getProgram(),
              cellBO.getCABO(),
              'normalMC',
              cellBO.getCABO().getNormalOffset(),
              cellBO.getCABO().getStride(),
              model.context.FLOAT,
              3,
              false
            )
        ) {
          vtkErrorMacro('Error setting normalMC in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('normalMC');
      }

      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
          if (
            !cellBO
              .getVAO()
              .addAttributeArray(
                cellBO.getProgram(),
                cellBO.getCABO(),
                `${attrName}MC`,
                cellBO.getCABO().getCustomData()[idx].offset,
                cellBO.getCABO().getStride(),
                model.context.FLOAT,
                cellBO.getCABO().getCustomData()[idx].components,
                false
              )
          ) {
            vtkErrorMacro(`Error setting ${attrName}MC in shader VAO.`);
          }
        }
      });

      if (
        cellBO.getProgram().isAttributeUsed('tcoordMC') &&
        cellBO.getCABO().getTCoordOffset()
      ) {
        if (
          !cellBO
            .getVAO()
            .addAttributeArray(
              cellBO.getProgram(),
              cellBO.getCABO(),
              'tcoordMC',
              cellBO.getCABO().getTCoordOffset(),
              cellBO.getCABO().getStride(),
              model.context.FLOAT,
              cellBO.getCABO().getTCoordComponents(),
              false
            )
        ) {
          vtkErrorMacro('Error setting tcoordMC in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('tcoordMC');
      }
      if (
        cellBO.getProgram().isAttributeUsed('scalarColor') &&
        cellBO.getCABO().getColorComponents()
      ) {
        if (
          !cellBO
            .getVAO()
            .addAttributeArray(
              cellBO.getProgram(),
              cellBO.getCABO().getColorBO(),
              'scalarColor',
              cellBO.getCABO().getColorOffset(),
              cellBO.getCABO().getColorBOStride(),
              model.context.UNSIGNED_BYTE,
              4,
              true
            )
        ) {
          vtkErrorMacro('Error setting scalarColor in shader VAO.');
        }
      } else {
        cellBO.getVAO().removeAttributeArray('scalarColor');
      }

      cellBO.getAttributeUpdateTime().modified();
    }

    if (model.renderable.getNumberOfClippingPlanes()) {
      // add all the clipping planes
      let numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      if (numClipPlanes > 6) {
        vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].vtkErrorMacro('OpenGL has a limit of 6 clipping planes');
        numClipPlanes = 6;
      }
      const planeEquations = [];
      for (let i = 0; i < numClipPlanes; i++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(
          actor.getMatrix(),
          i,
          planeEquation
        );

        for (let j = 0; j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      cellBO.getProgram().setUniformi('numClipPlanes', numClipPlanes);
      cellBO.getProgram().setUniform4fv('clipPlanes', 6, planeEquations);
    }

    if (
      model.internalColorTexture &&
      cellBO.getProgram().isUniformUsed('texture1')
    ) {
      cellBO
        .getProgram()
        .setUniformi('texture1', model.internalColorTexture.getTextureUnit());
    }
    const tus = model.openGLActor.getActiveTextures();
    if (tus) {
      for (let index = 0; index < tus.length; ++index) {
        const tex = tus[index];
        const texUnit = tex.getTextureUnit();
        const tname = `texture${texUnit + 1}`;
        if (cellBO.getProgram().isUniformUsed(tname)) {
          cellBO.getProgram().setUniformi(tname, texUnit);
        }
      }
    }

    // handle depth requests
    if (model.haveSeenDepthRequest) {
      cellBO
        .getProgram()
        .setUniformi('depthRequest', model.renderDepth ? 1 : 0);
    }

    // handle coincident
    if (cellBO.getProgram().isUniformUsed('coffset')) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf('coffset', cp.offset);
      // cfactor isn't always used when coffset is.
      if (cellBO.getProgram().isUniformUsed('cfactor')) {
        cellBO.getProgram().setUniformf('cfactor', cp.factor);
      }
    }

    const selector = model.openGLRenderer.getSelector();
    cellBO
      .getProgram()
      .setUniform3fArray(
        'mapperIndex',
        selector ? selector.getPropColorValue() : [0.0, 0.0, 0.0]
      );
    cellBO
      .getProgram()
      .setUniformi('picking', selector ? selector.getCurrentPass() + 1 : 0);
  };

  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
    // for unlit and headlight there are no lighting parameters
    const lastLightComplexity = model.lastBoundBO.getReferenceByName(
      'lastLightComplexity'
    );
    if (lastLightComplexity < 2) {
      return;
    }

    const program = cellBO.getProgram();

    // bind some light settings
    let numberOfLights = 0;

    const lights = ren.getLightsByReference();
    for (let index = 0; index < lights.length; ++index) {
      const light = lights[index];
      const status = light.getSwitch();
      if (status > 0.0) {
        const dColor = light.getColorByReference();
        const intensity = light.getIntensity();
        model.lightColor[0] = dColor[0] * intensity;
        model.lightColor[1] = dColor[1] * intensity;
        model.lightColor[2] = dColor[2] * intensity;
        // get required info from light
        const ld = light.getDirection();
        const transform = ren.getActiveCamera().getViewMatrix();

        const newLightDirection = [...ld];
        if (light.lightTypeIsSceneLight()) {
          newLightDirection[0] =
            transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];
          newLightDirection[1] =
            transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];
          newLightDirection[2] =
            transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];
          vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__["normalize"](newLightDirection);
        }

        model.lightDirection[0] = newLightDirection[0];
        model.lightDirection[1] = newLightDirection[1];
        model.lightDirection[2] = newLightDirection[2];
        model.lightHalfAngle[0] = -model.lightDirection[0];
        model.lightHalfAngle[1] = -model.lightDirection[1];
        model.lightHalfAngle[2] = -model.lightDirection[2] + 1.0;
        vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__["normalize"](model.lightDirection);
        program.setUniform3fArray(
          `lightColor${numberOfLights}`,
          model.lightColor
        );
        program.setUniform3fArray(
          `lightDirectionVC${numberOfLights}`,
          model.lightDirection
        );
        program.setUniform3fArray(
          `lightHalfAngleVC${numberOfLights}`,
          model.lightHalfAngle
        );
        numberOfLights++;
      }
    }

    // we are done unless we have positional lights
    if (lastLightComplexity < 3) {
      return;
    }

    // for lightkit case there are some parameters to set
    const cam = ren.getActiveCamera();
    const viewTF = cam.getViewMatrix();
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(viewTF, viewTF);

    numberOfLights = 0;

    for (let index = 0; index < lights.length; ++index) {
      const light = lights[index];
      const status = light.getSwitch();
      if (status > 0.0) {
        const lp = light.getTransformedPosition();
        const np = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(lp[0], lp[1], lp[2]);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].transformMat4(np, np, viewTF);
        program.setUniform3fArray(
          `lightAttenuation${numberOfLights}`,
          light.getAttenuationValuesByReference()
        );
        program.setUniformi(
          `lightPositional${numberOfLights}`,
          light.getPositional()
        );
        program.setUniformf(
          `lightExponent${numberOfLights}`,
          light.getExponent()
        );
        program.setUniformf(
          `lightConeAngle${numberOfLights}`,
          light.getConeAngle()
        );
        program.setUniform3fArray(`lightPositionVC${numberOfLights}`, [
          np[0],
          np[1],
          np[2],
        ]);
        numberOfLights++;
      }
    }
  };

  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
    matrixType.identity(tmpMat);
    return matrixArray.reduce((res, matrix, index) => {
      if (index === 0) {
        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
      }
      return matrix ? matrixType.multiply(res, res, matrix) : res;
    }, tmpMat);
  }

  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();

    // [WMVP]C == {world, model, view, projection} coordinates
    // E.g., WCPC == world to projection coordinate transformation
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const cam = ren.getActiveCamera();

    const camm = model.openGLCamera.getKeyMatrixTime().getMTime();
    const progm = program.getLastCameraMTime();

    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled
      ? cellBO.getCABO().getInverseShiftAndScaleMatrix()
      : null;

    const actorIsIdentity = actor.getIsIdentity();
    const actMats = actorIsIdentity
      ? { mcwc: null, normalMatrix: null }
      : model.openGLActor.getKeyMatrices();

    program.setUniformMatrix(
      'MCPCMatrix',
      safeMatrixMultiply(
        [keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix],
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"],
        model.tmpMat4
      )
    );
    if (program.isUniformUsed('MCVCMatrix')) {
      program.setUniformMatrix(
        'MCVCMatrix',
        safeMatrixMultiply(
          [keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix],
          gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"],
          model.tmpMat4
        )
      );
    }
    if (program.isUniformUsed('normalMatrix')) {
      program.setUniformMatrix3x3(
        'normalMatrix',
        safeMatrixMultiply(
          [keyMats.normalMatrix, actMats.normalMatrix],
          gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"],
          model.tmpMat3
        )
      );
    }

    if (progm !== camm) {
      if (program.isUniformUsed('cameraParallel')) {
        program.setUniformi('cameraParallel', cam.getParallelProjection());
      }
      program.setLastCameraMTime(camm);
    }

    if (!actorIsIdentity) {
      // reset the cam mtime as actor modified the shader values
      program.setLastCameraMTime(0);
    }
  };

  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();

    const ppty = actor.getProperty();

    const opacity = ppty.getOpacity();
    program.setUniformf('opacityUniform', opacity);

    const aColor = model.drawingEdges
      ? ppty.getEdgeColorByReference()
      : ppty.getAmbientColorByReference();
    program.setUniform3fArray('ambientColorUniform', aColor);
    program.setUniformf('ambient', ppty.getAmbient());

    const dColor = model.drawingEdges
      ? ppty.getEdgeColorByReference()
      : ppty.getDiffuseColorByReference();
    program.setUniform3fArray('diffuseColorUniform', dColor);
    program.setUniformf('diffuse', ppty.getDiffuse());

    // we are done unless we have lighting
    const lastLightComplexity = model.lastBoundBO.getReferenceByName(
      'lastLightComplexity'
    );
    if (lastLightComplexity < 1) {
      return;
    }
    const sColor = ppty.getSpecularColorByReference();
    program.setUniform3fArray('specularColorUniform', sColor);
    program.setUniformf('specular', ppty.getSpecular());
    program.setUniformf('specularPowerUniform', ppty.getSpecularPower());

    // // now set the backface properties if we have them
    // if (actor.getBackfaceProperty() && !model.DrawingEdges)
    //   {
    //   ppty = actor.getBackfaceProperty();

    //   let opacity = static_cast<float>(ppty.getOpacity());
    //   double *aColor = ppty.getAmbientColor();
    //   double aIntensity = ppty.getAmbient();  // ignoring renderer ambient
    //   let ambientColor[3] = {static_cast<float>(aColor[0] * aIntensity),
    //     static_cast<float>(aColor[1] * aIntensity),
    //     static_cast<float>(aColor[2] * aIntensity)};
    //   double *dColor = ppty.getDiffuseColor();
    //   double dIntensity = ppty.getDiffuse();
    //   let diffuseColor[3] = {static_cast<float>(dColor[0] * dIntensity),
    //     static_cast<float>(dColor[1] * dIntensity),
    //     static_cast<float>(dColor[2] * dIntensity)};
    //   double *sColor = ppty.getSpecularColor();
    //   double sIntensity = ppty.getSpecular();
    //   let specularColor[3] = {static_cast<float>(sColor[0] * sIntensity),
    //     static_cast<float>(sColor[1] * sIntensity),
    //     static_cast<float>(sColor[2] * sIntensity)};
    //   double specularPower = ppty.getSpecularPower();

    //   program.SetUniformf('opacityUniformBF', opacity);
    //   program.SetUniform3f('ambientColorUniformBF', ambientColor);
    //   program.SetUniform3f('diffuseColorUniformBF', diffuseColor);
    //   // we are done unless we have lighting
    //   if (model.LastLightComplexity[&cellBO] < 1)
    //     {
    //     return;
    //     }
    //   program.SetUniform3f('specularColorUniformBF', specularColor);
    //   program.SetUniformf('specularPowerUniformBF', specularPower);
    //   }
  };

  publicAPI.renderPieceStart = (ren, actor) => {
    model.primitiveIDOffset = 0;

    if (model.openGLRenderer.getSelector()) {
      switch (model.openGLRenderer.getSelector().getCurrentPass()) {
        default:
          model.openGLRenderer.getSelector().renderProp(actor);
      }
    }

    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);

    // If we are coloring by texture, then load the texture map.
    // Use Map as indicator, because texture hangs around.
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.activate();
    }

    // Bind the OpenGL, this is shared between the different primitive/cell types.
    model.lastBoundBO = null;
  };

  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();

    const gl = model.context;

    const drawSurfaceWithEdges =
      actor.getProperty().getEdgeVisibility() &&
      representation === Representation.SURFACE;

    gl.lineWidth(actor.getProperty().getLineWidth());

    // for every primitive type
    for (let i = primTypes.Start; i < primTypes.End; i++) {
      // if there are entries
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        // are we drawing edges
        model.drawingEdges =
          drawSurfaceWithEdges &&
          (i === primTypes.TrisEdges || i === primTypes.TriStripsEdges);
        const mode = publicAPI.getOpenGLMode(representation, i);
        if (!model.drawingEdges || !model.renderDepth) {
          publicAPI.updateShaders(model.primitives[i], ren, actor);
          gl.drawArrays(mode, 0, cabo.getElementCount());
        }
        const stride =
          (mode === gl.POINTS ? 1 : 0) || (mode === gl.LINES ? 2 : 3);
        model.primitiveIDOffset += cabo.getElementCount() / stride;
      }
    }
    // reset the line width
    gl.lineWidth(1);
  };

  publicAPI.getOpenGLMode = (rep, type) => {
    if (rep === Representation.POINTS || type === primTypes.Points) {
      return model.context.POINTS;
    }
    if (
      rep === Representation.WIREFRAME ||
      type === primTypes.Lines ||
      type === primTypes.TrisEdges ||
      type === primTypes.TriStripsEdges
    ) {
      return model.context.LINES;
    }
    return model.context.TRIANGLES;
  };

  publicAPI.renderPieceFinish = (ren, actor) => {
    if (model.LastBoundBO) {
      model.LastBoundBO.getVAO().release();
    }
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.deactivate();
    }
  };

  publicAPI.renderPiece = (ren, actor) => {
    // Make sure that we have been properly initialized.
    // if (ren.getRenderWindow().checkAbortStatus()) {
    //   return;
    // }

    publicAPI.invokeEvent(StartEvent);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent(EndEvent);

    if (!model.currentInput) {
      vtkErrorMacro('No input!');
      return;
    }

    // if there are no points then we are done
    if (
      !model.currentInput.getPoints ||
      !model.currentInput.getPoints().getNumberOfValues()
    ) {
      return;
    }

    // apply faceCulling
    const gl = model.context;
    const backfaceCulling = actor.getProperty().getBackfaceCulling();
    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();
    if (!backfaceCulling && !frontfaceCulling) {
      model.openGLRenderWindow.disableCullFace();
    } else if (frontfaceCulling) {
      model.openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.FRONT);
    } else {
      model.openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.BACK);
    }

    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };

  publicAPI.computeBounds = (ren, actor) => {
    if (!publicAPI.getInput()) {
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__["uninitializeBounds"](model.bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };

  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffers if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };

  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    // first do a coarse check
    // Note that the actor's mtime includes it's properties mtime
    const vmtime = model.VBOBuildTime.getMTime();
    if (
      vmtime < publicAPI.getMTime() ||
      vmtime < model.renderable.getMTime() ||
      vmtime < actor.getMTime() ||
      vmtime < model.currentInput.getMTime()
    ) {
      return true;
    }
    return false;
  };

  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;

    if (poly === null) {
      return;
    }

    model.renderable.mapScalars(poly, 1.0);
    const c = model.renderable.getColorMapColors();

    model.haveCellScalars = false;
    const scalarMode = model.renderable.getScalarMode();
    if (model.renderable.getScalarVisibility()) {
      // We must figure out how the scalars should be mapped to the polydata.
      if (
        (scalarMode === ScalarMode.USE_CELL_DATA ||
          scalarMode === ScalarMode.USE_CELL_FIELD_DATA ||
          scalarMode === ScalarMode.USE_FIELD_DATA ||
          !poly.getPointData().getScalars()) &&
        scalarMode !== ScalarMode.USE_POINT_FIELD_DATA &&
        c
      ) {
        model.haveCellScalars = true;
      }
    }

    // Do we have normals?
    let n =
      actor.getProperty().getInterpolation() !== Shading.FLAT
        ? poly.getPointData().getNormals()
        : null;
    if (n === null && poly.getCellData().getNormals()) {
      model.haveCellNormals = true;
      n = poly.getCellData().getNormals();
    }

    // rebuild the VBO if the data has changed we create a string for the VBO what
    // can change the VBO? points normals tcoords colors so what can change those?
    // the input data is clearly one as it can change all four items tcoords may
    // haveTextures or not colors may change based on quite a few mapping
    // parameters in the mapper

    const representation = actor.getProperty().getRepresentation();

    let tcoords = poly.getPointData().getTCoords();
    if (!model.openGLActor.getActiveTextures()) {
      tcoords = null;
    }

    // handle color mapping via texture
    if (model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
      if (!model.internalColorTexture) {
        model.internalColorTexture = vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_5__["default"].newInstance();
      }
      const tex = model.internalColorTexture;
      // the following 4 lines allow for NPOT textures
      tex.setMinificationFilter(Filter.NEAREST);
      tex.setMagnificationFilter(Filter.NEAREST);
      tex.setWrapS(Wrap.CLAMP_TO_EDGE);
      tex.setWrapT(Wrap.CLAMP_TO_EDGE);
      tex.setOpenGLRenderWindow(model.openGLRenderWindow);

      const input = model.renderable.getColorTextureMap();
      const ext = input.getExtent();
      const inScalars = input.getPointData().getScalars();
      tex.create2DFromRaw(
        ext[1] - ext[0] + 1,
        ext[3] - ext[2] + 1,
        inScalars.getNumberOfComponents(),
        inScalars.getDataType(),
        inScalars.getData()
      );
      tex.activate();
      tex.sendParameters();
      tex.deactivate();
    }

    const toString =
      `${poly.getMTime()}A${representation}B${poly.getMTime()}` +
      `C${n ? n.getMTime() : 1}D${c ? c.getMTime() : 1}` +
      `E${actor.getProperty().getEdgeVisibility()}` +
      `F${tcoords ? tcoords.getMTime() : 1}`;
    if (model.VBOBuildString !== toString) {
      // Build the VBOs
      const points = poly.getPoints();
      const options = {
        points,
        normals: n,
        tcoords,
        colors: c,
        cellOffset: 0,
        haveCellScalars: model.haveCellScalars,
        haveCellNormals: model.haveCellNormals,
        customAttributes: model.renderable
          .getCustomShaderAttributes()
          .map((arrayName) => poly.getPointData().getArrayByName(arrayName)),
      };
      options.cellOffset += model.primitives[primTypes.Points]
        .getCABO()
        .createVBO(poly.getVerts(), 'verts', representation, options);
      options.cellOffset += model.primitives[primTypes.Lines]
        .getCABO()
        .createVBO(poly.getLines(), 'lines', representation, options);
      options.cellOffset += model.primitives[primTypes.Tris]
        .getCABO()
        .createVBO(poly.getPolys(), 'polys', representation, options);
      options.cellOffset += model.primitives[primTypes.TriStrips]
        .getCABO()
        .createVBO(poly.getStrips(), 'strips', representation, options);

      const drawSurfaceWithEdges =
        actor.getProperty().getEdgeVisibility() &&
        representation === Representation.SURFACE;

      // if we have edge visibility build the edge VBOs
      if (drawSurfaceWithEdges) {
        model.primitives[primTypes.TrisEdges]
          .getCABO()
          .createVBO(poly.getPolys(), 'polys', Representation.WIREFRAME, {
            points,
            normals: n,
            tcoords: null,
            colors: null,
            cellOffset: 0,
            haveCellScalars: false,
            haveCellNormals: false,
          });
        model.primitives[primTypes.TriStripsEdges]
          .getCABO()
          .createVBO(poly.getStrips(), 'strips', Representation.WIREFRAME, {
            points,
            normals: n,
            tcoords: null,
            colors: null,
            cellOffset: 0,
            haveCellScalars: false,
            haveCellNormals: false,
          });
      } else {
        // otherwise free them
        model.primitives[primTypes.TrisEdges].releaseGraphicsResources(
          model.openGLRenderWindow
        );
        model.primitives[primTypes.TriStripsEdges].releaseGraphicsResources(
          model.openGLRenderWindow
        );
      }

      model.VBOBuildTime.modified();
      model.VBOBuildString = toString;
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  VBOBuildTime: 0,
  VBOBuildString: null,
  primitives: null,
  primTypes: null,
  shaderRebuildString: null,
  tmpMat4: null,
  ambientColor: [], // used internally
  diffuseColor: [], // used internally
  specularColor: [], // used internally
  lightColor: [], // used internally
  lightHalfAngle: [], // used internally
  lightDirection: [], // used internally
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_8__["default"].extend(publicAPI, model, initialValues);
  vtk_js_Sources_Rendering_OpenGL_ReplacementShaderMapper__WEBPACK_IMPORTED_MODULE_11__["default"].implementReplaceShaderCoincidentOffset(
    publicAPI,
    model,
    initialValues
  );

  model.primitives = [];
  model.primTypes = primTypes;

  model.tmpMat3 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].create();
  model.tmpMat4 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();

  for (let i = primTypes.Start; i < primTypes.End; i++) {
    model.primitives[i] = vtk_js_Sources_Rendering_OpenGL_Helper__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
    model.primitives[i].setPrimitiveType(i);
    model.primitives[i].set(
      { lastLightComplexity: 0, lastLightCount: 0, lastSelectionPass: false },
      true
    );
  }

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGet(publicAPI, model, ['context']);

  model.VBOBuildTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(model.VBOBuildTime, { mtime: 0 });

  // Object methods
  vtkOpenGLPolyDataMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend, 'vtkOpenGLPolyDataMapper');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/RenderWindow/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/RenderWindow/index.js ***!
  \****************************************************************************/
/*! exports provided: pushMonitorGLContextCount, popMonitorGLContextCount, extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pushMonitorGLContextCount", function() { return pushMonitorGLContextCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "popMonitorGLContextCount", function() { return popMonitorGLContextCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ForwardPass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ForwardPass */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ForwardPass/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ViewNodeFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ViewNodeFactory */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ViewNodeFactory/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_RenderPass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/RenderPass */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/RenderPass/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ShaderCache__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ShaderCache */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderCache/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/ViewNode */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_TextureUnitManager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/TextureUnitManager */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/TextureUnitManager/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray/Constants */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/Constants.js");
/* harmony import */ var webvr_polyfill__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! webvr-polyfill */ "./node_modules/webvr-polyfill/build/webvr-polyfill.js");
/* harmony import */ var webvr_polyfill__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(webvr_polyfill__WEBPACK_IMPORTED_MODULE_8__);










const { vtkDebugMacro, vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];
const IS_CHROME = navigator.userAgent.indexOf('Chrome') !== -1;

function checkRenderTargetSupport(gl, format, type) {
  // create temporary frame buffer and texture
  const framebuffer = gl.createFramebuffer();
  const texture = gl.createTexture();

  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texImage2D(gl.TEXTURE_2D, 0, format, 2, 2, 0, format, type, null);

  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
  gl.framebufferTexture2D(
    gl.FRAMEBUFFER,
    gl.COLOR_ATTACHMENT0,
    gl.TEXTURE_2D,
    texture,
    0
  );

  // check frame buffer status
  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

  // clean up
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.bindTexture(gl.TEXTURE_2D, null);

  return status === gl.FRAMEBUFFER_COMPLETE;
}

// ----------------------------------------------------------------------------
// Monitor the usage of GL context across vtkOpenGLRenderWindow instances
// ----------------------------------------------------------------------------

let GL_CONTEXT_COUNT = 0;
const GL_CONTEXT_LISTENERS = [];

function createGLContext() {
  GL_CONTEXT_COUNT++;
  GL_CONTEXT_LISTENERS.forEach((cb) => cb(GL_CONTEXT_COUNT));
}

function deleteGLContext() {
  GL_CONTEXT_COUNT--;
  GL_CONTEXT_LISTENERS.forEach((cb) => cb(GL_CONTEXT_COUNT));
}

function pushMonitorGLContextCount(cb) {
  GL_CONTEXT_LISTENERS.push(cb);
}

function popMonitorGLContextCount(cb) {
  return GL_CONTEXT_LISTENERS.pop();
}

// ----------------------------------------------------------------------------
// vtkOpenGLRenderWindow methods
// ----------------------------------------------------------------------------

function vtkOpenGLRenderWindow(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLRenderWindow');

  // Auto update style
  const previousSize = [0, 0];
  function updateWindow() {
    // Canvas size
    if (model.renderable) {
      if (
        model.size[0] !== previousSize[0] ||
        model.size[1] !== previousSize[1]
      ) {
        previousSize[0] = model.size[0];
        previousSize[1] = model.size[1];
        model.canvas.setAttribute('width', model.size[0]);
        model.canvas.setAttribute('height', model.size[1]);
      }
    }

    // ImageStream size
    if (model.viewStream) {
      // If same size that's a NoOp
      model.viewStream.setSize(model.size[0], model.size[1]);
    }

    // Offscreen ?
    model.canvas.style.display = model.useOffScreen ? 'none' : 'block';

    // Cursor type
    if (model.el) {
      model.el.style.cursor = model.cursorVisibility ? model.cursor : 'none';
    }

    // Invalidate cached DOM container size
    model.containerSize = null;
  }
  publicAPI.onModified(updateWindow);

  // Builds myself.
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }

      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getRenderersByReference());
      publicAPI.removeUnusedNodes();

      publicAPI.initialize();
      model.children.forEach((child) => {
        child.setOpenGLRenderWindow(publicAPI);
      });
    }
  };

  publicAPI.initialize = () => {
    if (!model.initialized) {
      model.context = publicAPI.get3DContext();
      model.textureUnitManager = vtk_js_Sources_Rendering_OpenGL_TextureUnitManager__WEBPACK_IMPORTED_MODULE_6__["default"].newInstance();
      model.textureUnitManager.setContext(model.context);
      model.shaderCache.setContext(model.context);
      // initialize blending for transparency
      const gl = model.context;
      gl.blendFuncSeparate(
        gl.SRC_ALPHA,
        gl.ONE_MINUS_SRC_ALPHA,
        gl.ONE,
        gl.ONE_MINUS_SRC_ALPHA
      );
      gl.depthFunc(gl.LEQUAL);
      gl.enable(gl.BLEND);
      model.initialized = true;
    }
  };

  publicAPI.makeCurrent = () => {
    model.context.makeCurrent();
  };

  publicAPI.setContainer = (el) => {
    if (model.el && model.el !== el) {
      if (model.canvas.parentNode !== model.el) {
        vtkErrorMacro('Error: canvas parent node does not match container');
      }

      // Remove canvas from previous container
      model.el.removeChild(model.canvas);

      // If the renderer has previously added
      // a background image, remove it from the DOM.
      if (model.el.contains(model.bgImage)) {
        model.el.removeChild(model.bgImage);
      }
    }

    if (model.el !== el) {
      model.el = el;
      if (model.el) {
        model.el.appendChild(model.canvas);

        // If the renderer is set to use a background
        // image, attach it to the DOM.
        if (model.useBackgroundImage) {
          model.el.appendChild(model.bgImage);
        }
      }

      // Trigger modified()
      publicAPI.modified();
    }
  };

  publicAPI.getContainer = () => model.el;

  publicAPI.getContainerSize = () => {
    if (!model.containerSize && model.el) {
      const { width, height } = model.el.getBoundingClientRect();
      model.containerSize = [width, height];
    }
    return model.containerSize || model.size;
  };

  publicAPI.getFramebufferSize = () => {
    if (model.activeFramebuffer) {
      return model.activeFramebuffer.getSize();
    }
    return model.size;
  };

  publicAPI.isInViewport = (x, y, viewport) => {
    const vCoords = viewport.getViewportByReference();
    const size = publicAPI.getFramebufferSize();
    if (
      vCoords[0] * size[0] <= x &&
      vCoords[2] * size[0] >= x &&
      vCoords[1] * size[1] <= y &&
      vCoords[3] * size[1] >= y
    ) {
      return true;
    }
    return false;
  };

  publicAPI.getViewportSize = (viewport) => {
    const vCoords = viewport.getViewportByReference();
    const size = publicAPI.getFramebufferSize();

    return [
      (vCoords[2] - vCoords[0]) * size[0],
      (vCoords[3] - vCoords[1]) * size[1],
    ];
  };

  publicAPI.getViewportCenter = (viewport) => {
    const size = publicAPI.getViewportSize(viewport);
    return [size[0] * 0.5, size[1] * 0.5];
  };

  publicAPI.displayToNormalizedDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x / size[0], y / size[1], z];
  };

  publicAPI.normalizedDisplayToDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x * size[0], y * size[1], z];
  };

  publicAPI.worldToView = (x, y, z, renderer) => renderer.worldToView(x, y, z);

  publicAPI.viewToWorld = (x, y, z, renderer) => renderer.viewToWorld(x, y, z);

  publicAPI.worldToDisplay = (x, y, z, renderer) => {
    const val = renderer.worldToView(x, y, z);
    const dims = publicAPI.getViewportSize(renderer);
    const val2 = renderer.viewToProjection(
      val[0],
      val[1],
      val[2],
      dims[0] / dims[1]
    );
    const val3 = renderer.projectionToNormalizedDisplay(
      val2[0],
      val2[1],
      val2[2]
    );
    return publicAPI.normalizedDisplayToDisplay(val3[0], val3[1], val3[2]);
  };

  publicAPI.displayToWorld = (x, y, z, renderer) => {
    const val = publicAPI.displayToNormalizedDisplay(x, y, z);
    const val2 = renderer.normalizedDisplayToProjection(val[0], val[1], val[2]);
    const dims = publicAPI.getViewportSize(renderer);
    const val3 = renderer.projectionToView(
      val2[0],
      val2[1],
      val2[2],
      dims[0] / dims[1]
    );
    return renderer.viewToWorld(val3[0], val3[1], val3[2]);
  };

  publicAPI.normalizedDisplayToViewport = (x, y, z, renderer) => {
    let vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0.0);
    const coords = publicAPI.normalizedDisplayToDisplay(x, y, z);
    return [coords[0] - vCoords[0] - 0.5, coords[1] - vCoords[1] - 0.5, z];
  };

  publicAPI.viewportToNormalizedViewport = (x, y, z, renderer) => {
    const size = publicAPI.getViewportSize(renderer);
    if (size && size[0] !== 0 && size[1] !== 0) {
      return [x / (size[0] - 1.0), y / (size[1] - 1.0), z];
    }
    return [x, y, z];
  };

  publicAPI.normalizedViewportToViewport = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x * (size[0] - 1.0), y * (size[1] - 1.0), z];
  };

  publicAPI.displayToLocalDisplay = (x, y, z) => {
    const size = publicAPI.getFramebufferSize();
    return [x, size[1] - y - 1, z];
  };

  publicAPI.viewportToNormalizedDisplay = (x, y, z, renderer) => {
    let vCoords = renderer.getViewportByReference();
    vCoords = publicAPI.normalizedDisplayToDisplay(vCoords[0], vCoords[1], 0.0);
    const x2 = x + vCoords[0] + 0.5;
    const y2 = y + vCoords[1] + 0.5;
    return publicAPI.displayToNormalizedDisplay(x2, y2, z);
  };

  publicAPI.getPixelData = (x1, y1, x2, y2) => {
    const pixels = new Uint8Array((x2 - x1 + 1) * (y2 - y1 + 1) * 4);
    model.context.readPixels(
      x1,
      y1,
      x2 - x1 + 1,
      y2 - y1 + 1,
      model.context.RGBA,
      model.context.UNSIGNED_BYTE,
      pixels
    );
    return pixels;
  };

  publicAPI.get3DContext = (
    options = { preserveDrawingBuffer: false, depth: true, alpha: true }
  ) => {
    let result = null;

    const webgl2Supported = typeof WebGL2RenderingContext !== 'undefined';
    model.webgl2 = false;
    if (model.defaultToWebgl2 && webgl2Supported) {
      result = model.canvas.getContext('webgl2', options);
      if (result) {
        model.webgl2 = true;
        vtkDebugMacro('using webgl2');
      }
    }
    if (!result) {
      vtkDebugMacro('using webgl1');
      result =
        model.canvas.getContext('webgl', options) ||
        model.canvas.getContext('experimental-webgl', options);
    }

    /* eslint-disable */
    const polyfill = new webvr_polyfill__WEBPACK_IMPORTED_MODULE_8___default.a({
      // Ensures the polyfill is always active on mobile, due to providing
      // a polyfilled CardboardVRDisplay when no native API is available,
      // and also polyfilling even when the native API is available, due to
      // providing a CardboardVRDisplay when no native VRDisplays exist.
      PROVIDE_MOBILE_VRDISPLAY: true,
      // Polyfill optimizations
      DIRTY_SUBMIT_FRAME_BINDINGS: false,
      BUFFER_SCALE: 0.75,
    });
    /* eslint-enable */

    // Do we have webvr support
    if (navigator.getVRDisplays) {
      navigator.getVRDisplays().then((displays) => {
        if (displays.length > 0) {
          // take the first display for now
          model.vrDisplay = displays[0];
          // set the clipping ranges
          model.vrDisplay.depthNear = 0.01; // meters
          model.vrDisplay.depthFar = 100.0; // meters
          publicAPI.invokeHaveVRDisplay();
        }
      });
    }

    // prevent default context lost handler
    model.canvas.addEventListener(
      'webglcontextlost',
      (event) => {
        event.preventDefault();
      },
      false
    );

    model.canvas.addEventListener(
      'webglcontextrestored',
      publicAPI.restoreContext,
      false
    );

    return result;
  };

  publicAPI.startVR = () => {
    model.oldCanvasSize = model.size.slice();
    if (model.vrDisplay.capabilities.canPresent) {
      model.vrDisplay
        .requestPresent([{ source: model.canvas }])
        .then(() => {
          if (
            model.el &&
            model.vrDisplay.capabilities.hasExternalDisplay &&
            model.hideCanvasInVR
          ) {
            model.el.style.display = 'none';
          }
          if (model.queryVRSize) {
            const leftEye = model.vrDisplay.getEyeParameters('left');
            const rightEye = model.vrDisplay.getEyeParameters('right');
            const width = Math.floor(
              leftEye.renderWidth + rightEye.renderWidth
            );
            const height = Math.floor(
              Math.max(leftEye.renderHeight, rightEye.renderHeight)
            );
            publicAPI.setSize(width, height);
          } else {
            publicAPI.setSize(model.vrResolution);
          }

          const ren = model.renderable.getRenderers()[0];
          ren.resetCamera();
          model.vrFrameData = new VRFrameData();
          model.renderable.getInteractor().switchToVRAnimation();

          model.vrSceneFrame = model.vrDisplay.requestAnimationFrame(
            publicAPI.vrRender
          );
          // If Broswer is chrome we need to request animation again to canvas update
          if (IS_CHROME) {
            model.vrSceneFrame = model.vrDisplay.requestAnimationFrame(
              publicAPI.vrRender
            );
          }
        })
        .catch(() => {
          console.error('failed to requestPresent');
        });
    } else {
      vtkErrorMacro('vrDisplay is not connected');
    }
  };

  publicAPI.stopVR = () => {
    model.renderable.getInteractor().returnFromVRAnimation();
    model.vrDisplay.exitPresent();
    model.vrDisplay.cancelAnimationFrame(model.vrSceneFrame);

    publicAPI.setSize(...model.oldCanvasSize);
    if (model.el && model.vrDisplay.capabilities.hasExternalDisplay) {
      model.el.style.display = 'block';
    }

    const ren = model.renderable.getRenderers()[0];
    ren.getActiveCamera().setProjectionMatrix(null);

    ren.setViewport(0.0, 0, 1.0, 1.0);
    publicAPI.traverseAllPasses();
  };

  publicAPI.vrRender = () => {
    // If not presenting for any reason, we do not submit frame
    if (!model.vrDisplay.isPresenting) {
      return;
    }
    model.renderable.getInteractor().updateGamepads(model.vrDisplay.displayId);
    model.vrSceneFrame = model.vrDisplay.requestAnimationFrame(
      publicAPI.vrRender
    );
    model.vrDisplay.getFrameData(model.vrFrameData);

    // get the first renderer
    const ren = model.renderable.getRenderers()[0];

    // do the left eye
    ren.setViewport(0, 0, 0.5, 1.0);
    ren
      .getActiveCamera()
      .computeViewParametersFromPhysicalMatrix(
        model.vrFrameData.leftViewMatrix
      );
    ren
      .getActiveCamera()
      .setProjectionMatrix(model.vrFrameData.leftProjectionMatrix);
    publicAPI.traverseAllPasses();

    ren.setViewport(0.5, 0, 1.0, 1.0);
    ren
      .getActiveCamera()
      .computeViewParametersFromPhysicalMatrix(
        model.vrFrameData.rightViewMatrix
      );
    ren
      .getActiveCamera()
      .setProjectionMatrix(model.vrFrameData.rightProjectionMatrix);
    publicAPI.traverseAllPasses();

    model.vrDisplay.submitFrame();
  };

  publicAPI.restoreContext = () => {
    const rp = vtk_js_Sources_Rendering_SceneGraph_RenderPass__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
    rp.setCurrentOperation('Release');
    rp.traverse(publicAPI, null);
  };

  publicAPI.activateTexture = (texture) => {
    // Only add if it isn't already there
    const result = model.textureResourceIds.get(texture);
    if (result !== undefined) {
      model.context.activeTexture(model.context.TEXTURE0 + result);
      return;
    }

    const activeUnit = publicAPI.getTextureUnitManager().allocate();
    if (activeUnit < 0) {
      vtkErrorMacro(
        'Hardware does not support the number of textures defined.'
      );
      return;
    }

    model.textureResourceIds.set(texture, activeUnit);
    model.context.activeTexture(model.context.TEXTURE0 + activeUnit);
  };

  publicAPI.deactivateTexture = (texture) => {
    // Only deactivate if it isn't already there
    const result = model.textureResourceIds.get(texture);
    if (result !== undefined) {
      publicAPI.getTextureUnitManager().free(result);
      delete model.textureResourceIds.delete(texture);
    }
  };

  publicAPI.getTextureUnitForTexture = (texture) => {
    const result = model.textureResourceIds.get(texture);
    if (result !== undefined) {
      return result;
    }
    return -1;
  };

  publicAPI.getDefaultTextureInternalFormat = (vtktype, numComps, useFloat) => {
    if (model.webgl2) {
      switch (vtktype) {
        case vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_7__["VtkDataTypes"].UNSIGNED_CHAR:
          switch (numComps) {
            case 1:
              return model.context.R8;
            case 2:
              return model.context.RG8;
            case 3:
              return model.context.RGB8;
            case 4:
            default:
              return model.context.RGBA8;
          }
        default:
        case vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_7__["VtkDataTypes"].FLOAT:
          switch (numComps) {
            case 1:
              return model.context.R16F;
            case 2:
              return model.context.RG16F;
            case 3:
              return model.context.RGB16F;
            case 4:
            default:
              return model.context.RGBA16F;
          }
      }
    }

    // webgl1 only supports four types
    switch (numComps) {
      case 1:
        return model.context.LUMINANCE;
      case 2:
        return model.context.LUMINANCE_ALPHA;
      case 3:
        return model.context.RGB;
      case 4:
      default:
        return model.context.RGBA;
    }
  };

  publicAPI.setBackgroundImage = (img) => {
    model.bgImage.src = img.src;
  };

  publicAPI.setUseBackgroundImage = (value) => {
    model.useBackgroundImage = value;

    // Add or remove the background image from the
    // DOM as specified.
    if (model.useBackgroundImage && !model.el.contains(model.bgImage)) {
      model.el.appendChild(model.bgImage);
    } else if (!model.useBackgroundImage && model.el.contains(model.bgImage)) {
      model.el.removeChild(model.bgImage);
    }
  };

  function getCanvasDataURL(format = model.imageFormat) {
    // Copy current canvas to not modify the original
    const temporaryCanvas = document.createElement('canvas');
    const temporaryContext = temporaryCanvas.getContext('2d');
    temporaryCanvas.width = model.canvas.width;
    temporaryCanvas.height = model.canvas.height;
    temporaryContext.drawImage(model.canvas, 0, 0);

    // Get current client rect to place canvas
    const mainBoundingClientRect = model.canvas.getBoundingClientRect();

    const renderWindow = model.renderable;
    const renderers = renderWindow.getRenderers();
    renderers.forEach((renderer) => {
      const viewProps = renderer.getViewProps();
      viewProps.forEach((viewProp) => {
        // Check if the prop has a container that should have canvas
        if (viewProp.getContainer) {
          const container = viewProp.getContainer();
          const canvasList = container.getElementsByTagName('canvas');
          // Go throughout all canvas and copy it into temporary main canvas
          for (let i = 0; i < canvasList.length; i++) {
            const currentCanvas = canvasList[i];
            const boundingClientRect = currentCanvas.getBoundingClientRect();
            const newXPosition =
              boundingClientRect.x - mainBoundingClientRect.x;
            const newYPosition =
              boundingClientRect.y - mainBoundingClientRect.y;
            temporaryContext.drawImage(
              currentCanvas,
              newXPosition,
              newYPosition
            );
          }
        }
      });
    });

    const screenshot = temporaryCanvas.toDataURL(format);
    temporaryCanvas.remove();
    publicAPI.invokeImageReady(screenshot);
  }

  publicAPI.captureNextImage = (format = 'image/png') => {
    if (model.deleted) {
      return null;
    }
    model.imageFormat = format;
    const previous = model.notifyStartCaptureImage;
    model.notifyStartCaptureImage = true;

    return new Promise((resolve, reject) => {
      const subscription = publicAPI.onImageReady((imageURL) => {
        model.notifyStartCaptureImage = previous;
        subscription.unsubscribe();
        resolve(imageURL);
      });
    });
  };

  publicAPI.getGLInformations = () => {
    const gl = publicAPI.get3DContext();

    const glTextureFloat = gl.getExtension('OES_texture_float');
    const glTextureHalfFloat = gl.getExtension('OES_texture_half_float');
    const glDebugRendererInfo = gl.getExtension('WEBGL_debug_renderer_info');
    const glDrawBuffers = gl.getExtension('WEBGL_draw_buffers');
    const glAnisotropic =
      gl.getExtension('EXT_texture_filter_anisotropic') ||
      gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');

    const params = [
      [
        'Max Vertex Attributes',
        'MAX_VERTEX_ATTRIBS',
        gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
      ],
      [
        'Max Varying Vectors',
        'MAX_VARYING_VECTORS',
        gl.getParameter(gl.MAX_VARYING_VECTORS),
      ],
      [
        'Max Vertex Uniform Vectors',
        'MAX_VERTEX_UNIFORM_VECTORS',
        gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
      ],
      [
        'Max Fragment Uniform Vectors',
        'MAX_FRAGMENT_UNIFORM_VECTORS',
        gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),
      ],
      [
        'Max Fragment Texture Image Units',
        'MAX_TEXTURE_IMAGE_UNITS',
        gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
      ],
      [
        'Max Vertex Texture Image Units',
        'MAX_VERTEX_TEXTURE_IMAGE_UNITS',
        gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      ],
      [
        'Max Combined Texture Image Units',
        'MAX_COMBINED_TEXTURE_IMAGE_UNITS',
        gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
      ],
      [
        'Max 2D Texture Size',
        'MAX_TEXTURE_SIZE',
        gl.getParameter(gl.MAX_TEXTURE_SIZE),
      ],
      [
        'Max Cube Texture Size',
        'MAX_CUBE_MAP_TEXTURE_SIZE',
        gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE),
      ],
      [
        'Max Texture Anisotropy',
        'MAX_TEXTURE_MAX_ANISOTROPY_EXT',
        glAnisotropic &&
          gl.getParameter(glAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT),
      ],
      [
        'Point Size Range',
        'ALIASED_POINT_SIZE_RANGE',
        gl.getParameter(gl.ALIASED_POINT_SIZE_RANGE).join(' - '),
      ],
      [
        'Line Width Range',
        'ALIASED_LINE_WIDTH_RANGE',
        gl.getParameter(gl.ALIASED_LINE_WIDTH_RANGE).join(' - '),
      ],
      [
        'Max Viewport Dimensions',
        'MAX_VIEWPORT_DIMS',
        gl.getParameter(gl.MAX_VIEWPORT_DIMS).join(' - '),
      ],
      [
        'Max Renderbuffer Size',
        'MAX_RENDERBUFFER_SIZE',
        gl.getParameter(gl.MAX_RENDERBUFFER_SIZE),
      ],
      ['Framebuffer Red Bits', 'RED_BITS', gl.getParameter(gl.RED_BITS)],
      ['Framebuffer Green Bits', 'GREEN_BITS', gl.getParameter(gl.GREEN_BITS)],
      ['Framebuffer Blue Bits', 'BLUE_BITS', gl.getParameter(gl.BLUE_BITS)],
      ['Framebuffer Alpha Bits', 'ALPHA_BITS', gl.getParameter(gl.ALPHA_BITS)],
      ['Framebuffer Depth Bits', 'DEPTH_BITS', gl.getParameter(gl.DEPTH_BITS)],
      [
        'Framebuffer Stencil Bits',
        'STENCIL_BITS',
        gl.getParameter(gl.STENCIL_BITS),
      ],
      [
        'Framebuffer Subpixel Bits',
        'SUBPIXEL_BITS',
        gl.getParameter(gl.SUBPIXEL_BITS),
      ],
      ['MSAA Samples', 'SAMPLES', gl.getParameter(gl.SAMPLES)],
      [
        'MSAA Sample Buffers',
        'SAMPLE_BUFFERS',
        gl.getParameter(gl.SAMPLE_BUFFERS),
      ],
      [
        'Supported Formats for UByte Render Targets     ',
        'UNSIGNED_BYTE RENDER TARGET FORMATS',
        [
          glTextureFloat &&
          checkRenderTargetSupport(gl, gl.RGBA, gl.UNSIGNED_BYTE)
            ? 'RGBA'
            : '',
          glTextureFloat &&
          checkRenderTargetSupport(gl, gl.RGB, gl.UNSIGNED_BYTE)
            ? 'RGB'
            : '',
          glTextureFloat &&
          checkRenderTargetSupport(gl, gl.LUMINANCE, gl.UNSIGNED_BYTE)
            ? 'LUMINANCE'
            : '',
          glTextureFloat &&
          checkRenderTargetSupport(gl, gl.ALPHA, gl.UNSIGNED_BYTE)
            ? 'ALPHA'
            : '',
          glTextureFloat &&
          checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.UNSIGNED_BYTE)
            ? 'LUMINANCE_ALPHA'
            : '',
        ].join(' '),
      ],
      [
        'Supported Formats for Half Float Render Targets',
        'HALF FLOAT RENDER TARGET FORMATS',
        [
          glTextureHalfFloat &&
          checkRenderTargetSupport(
            gl,
            gl.RGBA,
            glTextureHalfFloat.HALF_FLOAT_OES
          )
            ? 'RGBA'
            : '',
          glTextureHalfFloat &&
          checkRenderTargetSupport(
            gl,
            gl.RGB,
            glTextureHalfFloat.HALF_FLOAT_OES
          )
            ? 'RGB'
            : '',
          glTextureHalfFloat &&
          checkRenderTargetSupport(
            gl,
            gl.LUMINANCE,
            glTextureHalfFloat.HALF_FLOAT_OES
          )
            ? 'LUMINANCE'
            : '',
          glTextureHalfFloat &&
          checkRenderTargetSupport(
            gl,
            gl.ALPHA,
            glTextureHalfFloat.HALF_FLOAT_OES
          )
            ? 'ALPHA'
            : '',
          glTextureHalfFloat &&
          checkRenderTargetSupport(
            gl,
            gl.LUMINANCE_ALPHA,
            glTextureHalfFloat.HALF_FLOAT_OES
          )
            ? 'LUMINANCE_ALPHA'
            : '',
        ].join(' '),
      ],
      [
        'Supported Formats for Full Float Render Targets',
        'FLOAT RENDER TARGET FORMATS',
        [
          glTextureFloat && checkRenderTargetSupport(gl, gl.RGBA, gl.FLOAT)
            ? 'RGBA'
            : '',
          glTextureFloat && checkRenderTargetSupport(gl, gl.RGB, gl.FLOAT)
            ? 'RGB'
            : '',
          glTextureFloat && checkRenderTargetSupport(gl, gl.LUMINANCE, gl.FLOAT)
            ? 'LUMINANCE'
            : '',
          glTextureFloat && checkRenderTargetSupport(gl, gl.ALPHA, gl.FLOAT)
            ? 'ALPHA'
            : '',
          glTextureFloat &&
          checkRenderTargetSupport(gl, gl.LUMINANCE_ALPHA, gl.FLOAT)
            ? 'LUMINANCE_ALPHA'
            : '',
        ].join(' '),
      ],
      [
        'Max Multiple Render Targets Buffers',
        'MAX_DRAW_BUFFERS_WEBGL',
        glDrawBuffers
          ? gl.getParameter(glDrawBuffers.MAX_DRAW_BUFFERS_WEBGL)
          : 0,
      ],
      [
        'High Float Precision in Vertex Shader',
        'HIGH_FLOAT VERTEX_SHADER',
        [
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT)
            .precision,
          ' (-2<sup>',
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMin,
          '</sup> - 2<sup>',
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).rangeMax,
          '</sup>)',
        ].join(''),
      ],
      [
        'Medium Float Precision in Vertex Shader',
        'MEDIUM_FLOAT VERTEX_SHADER',
        [
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT)
            .precision,
          ' (-2<sup>',
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT)
            .rangeMin,
          '</sup> - 2<sup>',
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT)
            .rangeMax,
          '</sup>)',
        ].join(''),
      ],
      [
        'Low Float Precision in Vertex Shader',
        'LOW_FLOAT VERTEX_SHADER',
        [
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).precision,
          ' (-2<sup>',
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMin,
          '</sup> - 2<sup>',
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_FLOAT).rangeMax,
          '</sup>)',
        ].join(''),
      ],
      [
        'High Float Precision in Fragment Shader',
        'HIGH_FLOAT FRAGMENT_SHADER',
        [
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT)
            .precision,
          ' (-2<sup>',
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT)
            .rangeMin,
          '</sup> - 2<sup>',
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT)
            .rangeMax,
          '</sup>)',
        ].join(''),
      ],
      [
        'Medium Float Precision in Fragment Shader',
        'MEDIUM_FLOAT FRAGMENT_SHADER',
        [
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT)
            .precision,
          ' (-2<sup>',
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT)
            .rangeMin,
          '</sup> - 2<sup>',
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT)
            .rangeMax,
          '</sup>)',
        ].join(''),
      ],
      [
        'Low Float Precision in Fragment Shader',
        'LOW_FLOAT FRAGMENT_SHADER',
        [
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT)
            .precision,
          ' (-2<sup>',
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT)
            .rangeMin,
          '</sup> - 2<sup>',
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT)
            .rangeMax,
          '</sup>)',
        ].join(''),
      ],
      [
        'High Int Precision in Vertex Shader',
        'HIGH_INT VERTEX_SHADER',
        [
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).precision,
          ' (-2<sup>',
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMin,
          '</sup> - 2<sup>',
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_INT).rangeMax,
          '</sup>)',
        ].join(''),
      ],
      [
        'Medium Int Precision in Vertex Shader',
        'MEDIUM_INT VERTEX_SHADER',
        [
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT)
            .precision,
          ' (-2<sup>',
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMin,
          '</sup> - 2<sup>',
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_INT).rangeMax,
          '</sup>)',
        ].join(''),
      ],
      [
        'Low Int Precision in Vertex Shader',
        'LOW_INT VERTEX_SHADER',
        [
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).precision,
          ' (-2<sup>',
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMin,
          '</sup> - 2<sup>',
          gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.LOW_INT).rangeMax,
          '</sup>)',
        ].join(''),
      ],
      [
        'High Int Precision in Fragment Shader',
        'HIGH_INT FRAGMENT_SHADER',
        [
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT)
            .precision,
          ' (-2<sup>',
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMin,
          '</sup> - 2<sup>',
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT).rangeMax,
          '</sup>)',
        ].join(''),
      ],
      [
        'Medium Int Precision in Fragment Shader',
        'MEDIUM_INT FRAGMENT_SHADER',
        [
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT)
            .precision,
          ' (-2<sup>',
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT)
            .rangeMin,
          '</sup> - 2<sup>',
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT)
            .rangeMax,
          '</sup>)',
        ].join(''),
      ],
      [
        'Low Int Precision in Fragment Shader',
        'LOW_INT FRAGMENT_SHADER',
        [
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).precision,
          ' (-2<sup>',
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMin,
          '</sup> - 2<sup>',
          gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT).rangeMax,
          '</sup>)',
        ].join(''),
      ],
      [
        'Supported Extensions',
        'EXTENSIONS',
        gl.getSupportedExtensions().join('<br/>\t\t\t\t\t    '),
      ],
      ['WebGL Renderer', 'RENDERER', gl.getParameter(gl.RENDERER)],
      ['WebGL Vendor', 'VENDOR', gl.getParameter(gl.VENDOR)],
      ['WebGL Version', 'VERSION', gl.getParameter(gl.VERSION)],
      [
        'Shading Language Version',
        'SHADING_LANGUAGE_VERSION',
        gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
      ],
      [
        'Unmasked Renderer',
        'UNMASKED_RENDERER',
        glDebugRendererInfo &&
          gl.getParameter(glDebugRendererInfo.UNMASKED_RENDERER_WEBGL),
      ],
      [
        'Unmasked Vendor',
        'UNMASKED_VENDOR',
        glDebugRendererInfo &&
          gl.getParameter(glDebugRendererInfo.UNMASKED_VENDOR_WEBGL),
      ],
      ['WebGL Version', 'WEBGL_VERSION', model.webgl2 ? 2 : 1],
    ];

    const result = {};
    while (params.length) {
      const [label, key, value] = params.pop();
      if (key) {
        result[key] = { label, value };
      }
    }
    return result;
  };

  publicAPI.traverseAllPasses = () => {
    if (model.renderPasses) {
      for (let index = 0; index < model.renderPasses.length; ++index) {
        model.renderPasses[index].traverse(publicAPI, null);
      }
    }
    if (model.notifyStartCaptureImage) {
      getCanvasDataURL();
    }
  };

  publicAPI.disableDepthMask = () => {
    if (model.depthMaskEnabled) {
      model.context.depthMask(false);
      model.depthMaskEnabled = false;
    }
  };

  publicAPI.enableDepthMask = () => {
    if (!model.depthMaskEnabled) {
      model.context.depthMask(true);
      model.depthMaskEnabled = true;
    }
  };

  publicAPI.disableCullFace = () => {
    if (model.cullFaceEnabled) {
      model.context.disable(model.context.CULL_FACE);
      model.cullFaceEnabled = false;
    }
  };

  publicAPI.enableCullFace = () => {
    if (!model.cullFaceEnabled) {
      model.context.enable(model.context.CULL_FACE);
      model.cullFaceEnabled = true;
    }
  };

  publicAPI.setViewStream = (stream) => {
    if (model.viewStream === stream) {
      return false;
    }
    if (model.subscription) {
      model.subscription.unsubscribe();
      model.subscription = null;
    }
    model.viewStream = stream;
    if (model.viewStream) {
      // Force background to be transparent + render
      const mainRenderer = model.renderable.getRenderers()[0];
      mainRenderer.getBackgroundByReference()[3] = 0;

      // Enable display of the background image
      publicAPI.setUseBackgroundImage(true);

      // Bind to remote stream
      model.subscription = model.viewStream.onImageReady((e) =>
        publicAPI.setBackgroundImage(e.image)
      );
      model.viewStream.setSize(model.size[0], model.size[1]);
      model.viewStream.invalidateCache();
      model.viewStream.render();

      publicAPI.modified();
    }
    return true;
  };

  publicAPI.delete = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].chain(
    publicAPI.delete,
    publicAPI.setViewStream,
    deleteGLContext
  );
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  cullFaceEnabled: false,
  depthMaskEnabled: true,
  shaderCache: null,
  initialized: false,
  context: null,
  canvas: null,
  size: [300, 300],
  cursorVisibility: true,
  cursor: 'pointer',
  textureUnitManager: null,
  textureResourceIds: null,
  containerSize: null,
  renderPasses: [],
  notifyStartCaptureImage: false,
  webgl2: false,
  defaultToWebgl2: true, // attempt webgl2 on by default
  vrResolution: [2160, 1200],
  queryVRSize: false,
  hideCanvasInVR: true,
  activeFramebuffer: null,
  vrDisplay: null,
  imageFormat: 'image/png',
  useOffScreen: false,
  useBackgroundImage: false,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Create internal instances
  model.canvas = document.createElement('canvas');
  model.canvas.style.width = '100%';
  createGLContext();

  // Create internal bgImage
  model.bgImage = new Image();
  model.bgImage.style.position = 'absolute';
  model.bgImage.style.left = '0';
  model.bgImage.style.top = '0';
  model.bgImage.style.width = '100%';
  model.bgImage.style.height = '100%';
  model.bgImage.style.zIndex = '-1';

  model.textureResourceIds = new Map();

  // Inheritance
  vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_5__["default"].extend(publicAPI, model, initialValues);

  model.myFactory = vtk_js_Sources_Rendering_OpenGL_ViewNodeFactory__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
  /* eslint-disable no-use-before-define */
  model.myFactory.registerOverride('vtkRenderWindow', newInstance);
  /* eslint-enable no-use-before-define */

  model.shaderCache = vtk_js_Sources_Rendering_OpenGL_ShaderCache__WEBPACK_IMPORTED_MODULE_4__["default"].newInstance();
  model.shaderCache.setOpenGLRenderWindow(publicAPI);

  // setup default forward pass rendering
  model.renderPasses[0] = vtk_js_Sources_Rendering_OpenGL_ForwardPass__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].event(publicAPI, model, 'imageReady');
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].event(publicAPI, model, 'haveVRDisplay');

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, [
    'shaderCache',
    'textureUnitManager',
    'webgl2',
    'vrDisplay',
    'useBackgroundImage',
  ]);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'initialized',
    'context',
    'canvas',
    'renderPasses',
    'notifyStartCaptureImage',
    'defaultToWebgl2',
    'cursor',
    'queryVRSize',
    'hideCanvasInVR',
    'useOffScreen',
    // might want to make this not call modified as
    // we change the active framebuffer a lot. Or maybe
    // only mark modified if the size or depth
    // of the buffer has changed
    'activeFramebuffer',
  ]);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGetArray(publicAPI, model, ['size', 'vrResolution'], 2);

  // Object methods
  vtkOpenGLRenderWindow(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkOpenGLRenderWindow');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({
  newInstance,
  extend,
  pushMonitorGLContextCount,
  popMonitorGLContextCount,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Renderer/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/Renderer/index.js ***!
  \************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/ViewNode */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");




const { vtkDebugMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

// ----------------------------------------------------------------------------
// vtkOpenGLRenderer methods
// ----------------------------------------------------------------------------
/* eslint-disable no-bitwise */

function vtkOpenGLRenderer(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLRenderer');

  // Builds myself.
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }

      // make sure we have a camera
      if (!model.renderable.isActiveCameraCreated()) {
        model.renderable.resetCamera();
      }
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getActiveCamera());
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
    }
  };

  publicAPI.updateLights = () => {
    let count = 0;

    const lights = model.renderable.getLightsByReference();
    for (let index = 0; index < lights.length; ++index) {
      if (lights[index].getSwitch() > 0.0) {
        count++;
      }
    }

    if (!count) {
      vtkDebugMacro('No lights are on, creating one.');
      model.renderable.createLight();
    }

    return count;
  };

  publicAPI.opaqueZBufferPass = (prepass) => {
    if (prepass) {
      let clearMask = 0;
      const gl = model.context;
      if (!model.renderable.getTransparent()) {
        model.context.clearColor(1.0, 0.0, 0.0, 1.0);
        clearMask |= gl.COLOR_BUFFER_BIT;
      }

      if (!model.renderable.getPreserveDepthBuffer()) {
        gl.clearDepth(1.0);
        clearMask |= gl.DEPTH_BUFFER_BIT;
        gl.depthMask(true);
      }

      const ts = publicAPI.getTiledSizeAndOrigin();
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);

      gl.colorMask(true, true, true, true);
      gl.clear(clearMask);

      gl.enable(gl.DEPTH_TEST);
    }
  };

  // Renders myself
  publicAPI.cameraPass = (prepass) => {
    if (prepass) {
      publicAPI.clear();
    }
  };

  publicAPI.getAspectRatio = () => {
    const size = model.parent.getSizeByReference();
    const viewport = model.renderable.getViewportByReference();
    return (
      (size[0] * (viewport[2] - viewport[0])) /
      ((viewport[3] - viewport[1]) * size[1])
    );
  };

  publicAPI.getTiledSizeAndOrigin = () => {
    const vport = model.renderable.getViewportByReference();

    // if there is no window assume 0 1
    const tileViewPort = [0.0, 0.0, 1.0, 1.0];

    // find the lower left corner of the viewport, taking into account the
    // lower left boundary of this tile
    const vpu = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["clampValue"](vport[0] - tileViewPort[0], 0.0, 1.0);
    const vpv = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["clampValue"](vport[1] - tileViewPort[1], 0.0, 1.0);

    // store the result as a pixel value
    const ndvp = model.parent.normalizedDisplayToDisplay(vpu, vpv);
    const lowerLeftU = Math.round(ndvp[0]);
    const lowerLeftV = Math.round(ndvp[1]);

    // find the upper right corner of the viewport, taking into account the
    // lower left boundary of this tile
    let vpu2 = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["clampValue"](vport[2] - tileViewPort[0], 0.0, 1.0);
    let vpv2 = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_2__["clampValue"](vport[3] - tileViewPort[1], 0.0, 1.0);
    // also watch for the upper right boundary of the tile
    if (vpu2 > tileViewPort[2] - tileViewPort[0]) {
      vpu2 = tileViewPort[2] - tileViewPort[0];
    }
    if (vpv2 > tileViewPort[3] - tileViewPort[1]) {
      vpv2 = tileViewPort[3] - tileViewPort[1];
    }
    const ndvp2 = model.parent.normalizedDisplayToDisplay(vpu2, vpv2);

    // now compute the size of the intersection of the viewport with the
    // current tile
    let usize = Math.round(ndvp2[0]) - lowerLeftU;
    let vsize = Math.round(ndvp2[1]) - lowerLeftV;

    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }

    return { usize, vsize, lowerLeftU, lowerLeftV };
  };

  publicAPI.clear = () => {
    let clearMask = 0;
    const gl = model.context;

    if (!model.renderable.getTransparent()) {
      const background = model.renderable.getBackgroundByReference();
      // renderable ensures that background has 4 entries.
      model.context.clearColor(
        background[0],
        background[1],
        background[2],
        background[3]
      );
      clearMask |= gl.COLOR_BUFFER_BIT;
    }

    if (!model.renderable.getPreserveDepthBuffer()) {
      gl.clearDepth(1.0);
      clearMask |= gl.DEPTH_BUFFER_BIT;
      gl.depthMask(true);
    }

    gl.colorMask(true, true, true, true);

    const ts = publicAPI.getTiledSizeAndOrigin();
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);

    gl.clear(clearMask);

    gl.enable(gl.DEPTH_TEST);
    /* eslint-enable no-bitwise */
  };

  publicAPI.releaseGraphicsResources = () => {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
  };

  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model.openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model.openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model.openGLRenderWindow.getContext();
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  openGLRenderWindow: null,
  selector: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_1__["default"].extend(publicAPI, model, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['shaderCache']);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, ['selector']);

  // Object methods
  vtkOpenGLRenderer(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkOpenGLRenderer');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ReplacementShaderMapper/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/ReplacementShaderMapper/index.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ShaderProgram */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderProgram/index.js");


function implementReplaceShaderCoincidentOffset(
  publicAPI,
  model,
  initialValues = {}
) {
  publicAPI.replaceShaderCoincidentOffset = (shaders, ren, actor) => {
    const cp = publicAPI.getCoincidentParameters(ren, actor);

    // if we need an offset handle it here
    // The value of .000016 is suitable for depth buffers
    // of at least 16 bit depth. We do not query the depth
    // right now because we would need some mechanism to
    // cache the result taking into account FBO changes etc.
    if (cp && (cp.factor !== 0.0 || cp.offset !== 0.0)) {
      let FSSource = shaders.Fragment;

      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_0__["default"].substitute(
        FSSource,
        '//VTK::Coincident::Dec',
        ['uniform float cfactor;', 'uniform float coffset;']
      ).result;

      if (model.context.getExtension('EXT_frag_depth')) {
        if (cp.factor !== 0.0) {
          FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_0__["default"].substitute(
            FSSource,
            '//VTK::UniformFlow::Impl',
            [
              'float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));',
              '//VTK::UniformFlow::Impl',
            ],
            false
          ).result;
          FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_0__["default"].substitute(
            FSSource,
            '//VTK::Depth::Impl',
            'gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;'
          ).result;
        } else {
          FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_0__["default"].substitute(
            FSSource,
            '//VTK::Depth::Impl',
            'gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;'
          ).result;
        }
      }
      if (model.openGLRenderWindow.getWebgl2()) {
        if (cp.factor !== 0.0) {
          FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_0__["default"].substitute(
            FSSource,
            '//VTK::UniformFlow::Impl',
            [
              'float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));',
              '//VTK::UniformFlow::Impl',
            ],
            false
          ).result;
          FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_0__["default"].substitute(
            FSSource,
            '//VTK::Depth::Impl',
            'gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;'
          ).result;
        } else {
          FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_0__["default"].substitute(
            FSSource,
            '//VTK::Depth::Impl',
            'gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;'
          ).result;
        }
      }
      shaders.Fragment = FSSource;
    }
  };
}
/* harmony default export */ __webpack_exports__["default"] = ({ implementReplaceShaderCoincidentOffset });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Shader/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/Shader/index.js ***!
  \**********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");


const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

// export const SHADER_TYPES = ['Vertex', 'Fragment', 'Geometry', 'Unknown'];

// ----------------------------------------------------------------------------
// vtkShader methods
// ----------------------------------------------------------------------------

function vtkShader(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkShader');

  publicAPI.compile = () => {
    let stype = model.context.VERTEX_SHADER;

    if (
      !model.source ||
      !model.source.length ||
      model.shaderType === 'Unknown'
    ) {
      return false;
    }

    // Ensure we delete the previous shader if necessary.
    if (model.handle !== 0) {
      model.context.deleteShader(model.handle);
      model.handle = 0;
    }

    switch (model.shaderType) {
      // case vtkShader::Geometry:
      //   type = GL_GEOMETRY_SHADER;
      //   break;
      case 'Fragment':
        stype = model.context.FRAGMENT_SHADER;
        break;
      case 'Vertex':
      default:
        stype = model.context.VERTEX_SHADER;
        break;
    }

    model.handle = model.context.createShader(stype);
    model.context.shaderSource(model.handle, model.source);
    model.context.compileShader(model.handle);
    const isCompiled = model.context.getShaderParameter(
      model.handle,
      model.context.COMPILE_STATUS
    );
    if (!isCompiled) {
      const lastError = model.context.getShaderInfoLog(model.handle);
      vtkErrorMacro(`Error compiling shader '${model.source}': ${lastError}`);
      model.context.deleteShader(model.handle);
      model.handle = 0;
      return false;
    }

    // The shader compiled, store its handle and return success.
    return true;
  };

  publicAPI.cleanup = () => {
    if (model.shaderType === 'Unknown' || model.handle === 0) {
      return;
    }

    model.context.deleteShader(model.handle);
    model.handle = 0;
    model.dirty = true;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  shaderType: 'Unknown',
  source: '',
  error: '',
  handle: 0,
  dirty: false,
  context: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'shaderType',
    'source',
    'error',
    'handle',
    'context',
  ]);

  // Object methods
  vtkShader(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkShader');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderCache/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderCache/index.js ***!
  \***************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var blueimp_md5__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! blueimp-md5 */ "./node_modules/blueimp-md5/js/md5.js");
/* harmony import */ var blueimp_md5__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(blueimp_md5__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ShaderProgram */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderProgram/index.js");





// ----------------------------------------------------------------------------

const SET_GET_FIELDS = ['lastShaderBound', 'context', 'openGLRenderWindow'];

// ----------------------------------------------------------------------------
// vtkShaderCache methods
// ----------------------------------------------------------------------------

function vtkShaderCache(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkShaderCache');

  publicAPI.replaceShaderValues = (VSSource, FSSource, GSSource) => {
    // first handle renaming any Fragment shader inputs
    // if we have a geometry shader. By default fragment shaders
    // assume their inputs come from a Vertex Shader. When we
    // have a Geometry shader we rename the frament shader inputs
    // to come from the geometry shader

    let nFSSource = FSSource;
    if (GSSource.length > 0) {
      nFSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__["default"].substitute(nFSSource, 'VSOut', 'GSOut')
        .result;
    }

    const gl2 = model.openGLRenderWindow.getWebgl2();

    let fragDepthString = '\n';

    let version = '#version 100\n';
    if (gl2) {
      version =
        '#version 300 es\n' +
        '#define attribute in\n' +
        '#define textureCube texture\n' +
        '#define texture2D texture\n' +
        '#define textureCubeLod textureLod\n' +
        '#define texture2DLod textureLod\n';
    } else {
      model.context.getExtension('OES_standard_derivatives');
      if (model.context.getExtension('EXT_frag_depth')) {
        fragDepthString = '#extension GL_EXT_frag_depth : enable\n';
      }
      if (model.context.getExtension('EXT_shader_texture_lod')) {
        fragDepthString +=
          '#extension GL_EXT_shader_texture_lod : enable\n' +
          '#define textureCubeLod textureCubeLodEXT\n' +
          '#define texture2DLod texture2DLodEXT';
      }
    }

    nFSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__["default"].substitute(nFSSource, '//VTK::System::Dec', [
      `${version}\n`,
      gl2 ? '' : '#extension GL_OES_standard_derivatives : enable\n',
      fragDepthString,
      '#ifdef GL_FRAGMENT_PRECISION_HIGH',
      'precision highp float;',
      'precision highp int;',
      '#else',
      'precision mediump float;',
      'precision mediump int;',
      '#endif',
    ]).result;

    let nVSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__["default"].substitute(
      VSSource,
      '//VTK::System::Dec',
      [
        `${version}\n`,
        '#ifdef GL_FRAGMENT_PRECISION_HIGH',
        'precision highp float;',
        'precision highp int;',
        '#else',
        'precision mediump float;',
        'precision mediump int;',
        '#endif',
      ]
    ).result;

    if (gl2) {
      nVSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__["default"].substitute(nVSSource, 'varying', 'out')
        .result;
      nFSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__["default"].substitute(nFSSource, 'varying', 'in')
        .result;
      nFSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__["default"].substitute(
        nFSSource,
        'gl_FragData\\[0\\]',
        'fragOutput0'
      ).result;
      nFSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__["default"].substitute(
        nFSSource,
        '//VTK::Output::Dec',
        'layout(location = 0) out vec4 fragOutput0;'
      ).result;
    }

    // nFSSource = ShaderProgram.substitute(nFSSource, 'gl_FragData\\[0\\]',
    //   'gl_FragColor').result;

    const nGSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__["default"].substitute(
      GSSource,
      '//VTK::System::Dec',
      version
    ).result;

    return { VSSource: nVSSource, FSSource: nFSSource, GSSource: nGSSource };
  };

  // return NULL if there is an issue
  publicAPI.readyShaderProgramArray = (
    vertexCode,
    fragmentCode,
    geometryCode
  ) => {
    const data = publicAPI.replaceShaderValues(
      vertexCode,
      fragmentCode,
      geometryCode
    );

    const shader = publicAPI.getShaderProgram(
      data.VSSource,
      data.FSSource,
      data.GSSource
    );

    return publicAPI.readyShaderProgram(shader);
  };

  publicAPI.readyShaderProgram = (shader) => {
    if (!shader) {
      return null;
    }

    // compile if needed
    if (!shader.getCompiled() && !shader.compileShader()) {
      return null;
    }

    // bind if needed
    if (!publicAPI.bindShader(shader)) {
      return null;
    }

    return shader;
  };

  publicAPI.getShaderProgram = (vertexCode, fragmentCode, geometryCode) => {
    // compute the MD5 and the check the map
    const hashInput = `${vertexCode}${fragmentCode}${geometryCode}`;
    const result = blueimp_md5__WEBPACK_IMPORTED_MODULE_0___default()(hashInput);

    // does it already exist?
    const loc = Object.keys(model.shaderPrograms).indexOf(result);

    if (loc === -1) {
      // create one
      const sps = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
      sps.setContext(model.context);
      sps.getVertexShader().setSource(vertexCode);
      sps.getFragmentShader().setSource(fragmentCode);
      if (geometryCode) {
        sps.getGeometryShader().setSource(geometryCode);
      }
      sps.setMd5Hash(result);
      model.shaderPrograms[result] = sps;
      return sps;
    }

    return model.shaderPrograms[result];
  };

  publicAPI.releaseGraphicsResources = (win) => {
    // NOTE:
    // In the current implementation as of October 26th, if a shader
    // program is created by ShaderCache then it should make sure
    // that it releases the graphics resources used by these programs.
    // It is not wisely for callers to do that since then they would
    // have to loop over all the programs were in use and invoke
    // release graphics resources individually.

    publicAPI.releaseCurrentShader();

    Object.keys(model.shaderPrograms)
      .map((key) => model.shaderPrograms[key])
      .forEach((sp) => sp.releaseGraphicsResources(win));
  };

  publicAPI.releaseGraphicsResources = () => {
    // release prior shader
    if (model.astShaderBound) {
      model.lastShaderBound.release();
      model.lastShaderBound = null;
    }
  };

  publicAPI.bindShader = (shader) => {
    if (model.lastShaderBound === shader) {
      return 1;
    }

    // release prior shader
    if (model.lastShaderBound) {
      model.lastShaderBound.release();
    }
    shader.bind();
    model.lastShaderBound = shader;
    return 1;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  lastShaderBound: null,
  shaderPrograms: null,
  context: null,
  openGLRenderWindow: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Internal objects
  model.shaderPrograms = {};

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(publicAPI, model);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGet(publicAPI, model, SET_GET_FIELDS);

  // Object methods
  vtkShaderCache(publicAPI, model);

  return Object.freeze(publicAPI);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend, 'vtkShaderCache');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderProgram/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderProgram/index.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Shader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Shader */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Shader/index.js");



const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

// perform in place string substitutions, indicate if a substitution was done
// this is useful for building up shader strings which typically involve
// lots of string substitutions. Return true if a substitution was done.
function substitute(source, search, replace, all = true) {
  const replaceStr = Array.isArray(replace) ? replace.join('\n') : replace;
  let replaced = false;
  if (source.search(search) !== -1) {
    replaced = true;
  }
  let gflag = '';
  if (all) {
    gflag = 'g';
  }
  const regex = new RegExp(search, gflag);
  const resultstr = source.replace(regex, replaceStr);
  return { replace: replaced, result: resultstr };
}

// ----------------------------------------------------------------------------
// vtkShaderProgram methods
// ----------------------------------------------------------------------------

function vtkShaderProgram(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkShaderProgram');

  publicAPI.compileShader = () => {
    if (!model.vertexShader.compile()) {
      vtkErrorMacro(
        model.vertexShader
          .getSource()
          .split('\n')
          .map((line, index) => `${index}: ${line}`)
          .join('\n')
      );
      vtkErrorMacro(model.vertexShader.getError());
      return 0;
    }
    if (!model.fragmentShader.compile()) {
      vtkErrorMacro(
        model.fragmentShader
          .getSource()
          .split('\n')
          .map((line, index) => `${index}: ${line}`)
          .join('\n')
      );
      vtkErrorMacro(model.fragmentShader.getError());
      return 0;
    }
    // skip geometry for now
    if (!publicAPI.attachShader(model.vertexShader)) {
      vtkErrorMacro(model.error);
      return 0;
    }
    if (!publicAPI.attachShader(model.fragmentShader)) {
      vtkErrorMacro(model.error);
      return 0;
    }

    if (!publicAPI.link()) {
      vtkErrorMacro(`Links failed: ${model.error}`);
      return 0;
    }

    publicAPI.setCompiled(true);
    return 1;
  };

  publicAPI.cleanup = () => {
    if (model.shaderType === 'Unknown' || model.handle === 0) {
      return;
    }

    model.context.deleteShader(model.handle);
    model.handle = 0;
  };

  publicAPI.bind = () => {
    if (!model.linked && !publicAPI.link()) {
      return false;
    }

    model.context.useProgram(model.handle);
    publicAPI.setBound(true);
    return true;
  };

  publicAPI.isBound = () => !!model.bound;

  publicAPI.release = () => {
    model.context.useProgram(null);
    publicAPI.setBound(false);
  };

  publicAPI.setContext = (ctx) => {
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };

  publicAPI.link = () => {
    if (model.inked) {
      return true;
    }

    if (model.handle === 0) {
      model.error =
        'Program has not been initialized, and/or does not have shaders.';
      return false;
    }

    // clear out the list of uniforms used
    model.uniformLocs = {};

    model.context.linkProgram(model.handle);
    const isCompiled = model.context.getProgramParameter(
      model.handle,
      model.context.LINK_STATUS
    );
    if (!isCompiled) {
      const lastError = model.context.getProgramInfoLog(model.handle);
      vtkErrorMacro(`Error linking shader ${lastError}`);
      model.handle = 0;
      return false;
    }

    publicAPI.setLinked(true);
    model.attributeLocs = {};
    return true;
  };

  publicAPI.setUniformMatrix = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniformMatrix4fv(location, false, v);
    return true;
  };

  publicAPI.setUniformMatrix3x3 = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniformMatrix3fv(location, false, v);
    return true;
  };

  publicAPI.setUniformf = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1f(location, v);
    return true;
  };

  publicAPI.setUniformfv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1fv(location, v);
    return true;
  };

  publicAPI.setUniformi = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1i(location, v);
    return true;
  };

  publicAPI.setUniformiv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1iv(location, v);
    return true;
  };

  publicAPI.setUniform2f = (name, v1, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (v2 === undefined) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform2f(location, v1, v2);
    return true;
  };

  publicAPI.setUniform2fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform2fv(location, v);
    return true;
  };

  publicAPI.setUniform2i = (name, v1, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (v2 === undefined) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform2i(location, v1, v2);
    return true;
  };

  publicAPI.setUniform2iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform2iv(location, v);
    return true;
  };

  publicAPI.setUniform3f = (name, a1, a2, a3) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (a3 === undefined) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform3f(location, a1, a2, a3);
    return true;
  };

  publicAPI.setUniform3fArray = (name, a) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (!Array.isArray(a) || a.length !== 3) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform3f(location, a[0], a[1], a[2]);
    return true;
  };

  publicAPI.setUniform3fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform3fv(location, v);
    return true;
  };

  publicAPI.setUniform3i = (name, ...args) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    let array = args;
    // allow an array passed as a single argument
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 3) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform3i(location, array[0], array[1], array[2]);
    return true;
  };

  publicAPI.setUniform3iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform3iv(location, v);
    return true;
  };

  publicAPI.setUniform4f = (name, ...args) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    let array = args;
    // allow an array passed as a single argument
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform4f(location, array[0], array[1], array[2], array[3]);
    return true;
  };

  publicAPI.setUniform4fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform4fv(location, v);
    return true;
  };

  publicAPI.setUniform4i = (name, ...args) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    let array = args;
    // allow an array passed as a single argument
    if (array.length === 1 && Array.isArray(array[0])) {
      array = array[0];
    }
    if (array.length !== 4) {
      throw new RangeError('Invalid number of values for array');
    }
    model.context.uniform4i(location, array[0], array[1], array[2], array[3]);
    return true;
  };

  publicAPI.setUniform4iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform4iv(location, v);
    return true;
  };

  publicAPI.setUniform4fv = (name, count, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform4fv(location, v);
    return true;
  };

  publicAPI.findUniform = (name) => {
    if (!name || !model.linked) {
      return -1;
    }

    // see if we have cached the result
    let loc = model.uniformLocs[name];
    if (loc !== undefined) {
      return loc;
    }

    loc = model.context.getUniformLocation(model.handle, name);
    if (loc === null) {
      model.error = `Uniform ${name} not found in current shader program.`;
      model.uniformLocs[name] = -1;
      return -1;
    }

    model.uniformLocs[name] = loc;
    return loc;
  };

  publicAPI.isUniformUsed = (name) => {
    if (!name) {
      return false;
    }

    // see if we have cached the result
    let loc = model.uniformLocs[name];
    if (loc !== undefined) {
      return loc !== null;
    }

    if (!model.linked) {
      vtkErrorMacro(
        'attempt to find uniform when the shader program is not linked'
      );
      return false;
    }

    loc = model.context.getUniformLocation(model.handle, name);
    model.uniformLocs[name] = loc;

    if (loc === null) {
      return false;
    }

    return true;
  };

  publicAPI.isAttributeUsed = (name) => {
    if (!name) {
      return false;
    }

    // see if we have cached the result
    let loc = Object.keys(model.attributeLocs).indexOf(name);
    if (loc !== -1) {
      return true;
    }

    if (!model.linked) {
      vtkErrorMacro(
        'attempt to find uniform when the shader program is not linked'
      );
      return false;
    }

    loc = model.context.getAttribLocation(model.handle, name);
    if (loc === -1) {
      return false;
    }
    model.attributeLocs[name] = loc;

    return true;
  };

  publicAPI.attachShader = (shader) => {
    if (shader.getHandle() === 0) {
      model.error = 'Shader object was not initialized, cannot attach it.';
      return false;
    }
    if (shader.getShaderType() === 'Unknown') {
      model.error = 'Shader object is of type Unknown and cannot be used.';
      return false;
    }

    if (model.handle === 0) {
      const thandle = model.context.createProgram();
      if (thandle === 0) {
        model.error = 'Could not create shader program.';
        return false;
      }
      model.handle = thandle;
      model.linked = false;
    }

    if (shader.getShaderType() === 'Vertex') {
      if (model.vertexShaderHandle !== 0) {
        model.comntext.detachShader(model.handle, model.vertexShaderHandle);
      }
      model.vertexShaderHandle = shader.getHandle();
    }
    if (shader.getShaderType() === 'Fragment') {
      if (model.fragmentShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.fragmentShaderHandle);
      }
      model.fragmentShaderHandle = shader.getHandle();
    }

    model.context.attachShader(model.handle, shader.getHandle());
    publicAPI.setLinked(false);
    return true;
  };

  publicAPI.detachShader = (shader) => {
    if (shader.getHandle() === 0) {
      model.error = 'shader object was not initialized, cannot attach it.';
      return false;
    }
    if (shader.getShaderType() === 'Unknown') {
      model.error = 'Shader object is of type Unknown and cannot be used.';
      return false;
    }
    if (model.handle === 0) {
      model.error = 'This shader program has not been initialized yet.';
    }

    switch (shader.getShaderType()) {
      case 'Vertex':
        if (model.vertexShaderHandle !== shader.getHandle()) {
          model.error = 'The supplied shader was not attached to this program.';
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.vertexShaderHandle = 0;
        model.linked = false;
        return true;
      case 'Fragment':
        if (model.fragmentShaderHandle !== shader.getHandle()) {
          model.error = 'The supplied shader was not attached to this program.';
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.fragmentShaderHandle = 0;
        model.linked = false;
        return true;
      default:
        return false;
    }
  };

  publicAPI.setContext = (ctx) => {
    model.context = ctx;
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };

  publicAPI.setLastCameraMTime = (mtime) => {
    model.lastCameraMTime = mtime;
  };

  // publicAPI.enableAttributeArray = (name) => {
  //   const location = publicAPI.findAttributeArray(name);
  //   if (location === -1) {
  //     model.error = `Could not enable attribute ${name} No such attribute.`;
  //     return false;
  //   }
  //   model.context.enableVertexAttribArray(location);
  //   return true;
  // };

  // publicAPI.disableAttributeArray = (name) => {
  //   const location = publicAPI.findAttributeArray(name);
  //   if (location === -1) {
  //     model.error = `Could not enable attribute ${name} No such attribute.`;
  //     return false;
  //   }
  //   model.context.disableVertexAttribArray(location);
  //   return true;
  // };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  vertexShaderHandle: 0,
  fragmentShaderHandle: 0,
  geometryShaderHandle: 0,
  vertexShader: null,
  fragmentShader: null,
  geometryShader: null,

  linked: false,
  bound: false,
  compiled: false,
  error: '',
  handle: 0,
  numberOfOutputs: 0,
  attributesLocs: null,
  uniformLocs: null,
  md5Hash: 0,
  context: null,
  lastCameraMTime: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Instantiate internal objects
  model.attributesLocs = {};
  model.uniformLocs = {};
  model.vertexShader = vtk_js_Sources_Rendering_OpenGL_Shader__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
  model.vertexShader.setShaderType('Vertex');
  model.fragmentShader = vtk_js_Sources_Rendering_OpenGL_Shader__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
  model.fragmentShader.setShaderType('Fragment');
  model.geometryShader = vtk_js_Sources_Rendering_OpenGL_Shader__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance();
  model.geometryShader.setShaderType('Geometry');

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['lastCameraMTime']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'error',
    'handle',
    'compiled',
    'bound',
    'md5Hash',
    'vertexShader',
    'fragmentShader',
    'geometryShader',
    'linked',
  ]);

  // Object methods
  vtkShaderProgram(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkShaderProgram');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, substitute });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Skybox/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/Skybox/index.js ***!
  \**********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Helper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Helper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Helper/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/ViewNode */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Texture */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Property_Constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Property/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/Property/Constants.js");










const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"];

// ----------------------------------------------------------------------------
// vtkOpenGLSkybox methods
// ----------------------------------------------------------------------------

function vtkOpenGLSkybox(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLSkybox');

  // Builds myself.
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.openGLRenderer = publicAPI.getFirstAncestorOfType(
        'vtkOpenGLRenderer'
      );
      model.openGLRenderWindow = model.openGLRenderer.getParent();
      model.context = model.openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model.openGLRenderWindow);
      model.openGLTexture.setOpenGLRenderWindow(model.openGLRenderWindow);
      const ren = model.openGLRenderer.getRenderable();
      model.openGLCamera = model.openGLRenderer.getViewNodeFor(
        ren.getActiveCamera()
      );
    }
  };

  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementOpaqueActorCount();
    }
  };

  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass && !model.openGLRenderer.getSelector()) {
      publicAPI.updateBufferObjects();

      model.openGLRenderWindow.enableDepthMask();

      model.openGLRenderWindow
        .getShaderCache()
        .readyShaderProgram(model.tris.getProgram());

      model.openGLTexture.render(model.openGLRenderWindow);

      const texUnit = model.openGLTexture.getTextureUnit();
      model.tris.getProgram().setUniformi('sbtexture', texUnit);

      const ren = model.openGLRenderer.getRenderable();

      const keyMats = model.openGLCamera.getKeyMatrices(ren);
      const imat = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].invert(imat, keyMats.wcpc);
      model.tris.getProgram().setUniformMatrix('IMCPCMatrix', imat);

      if (model.lastFormat === 'box') {
        const camPos = ren.getActiveCamera().getPosition();
        model.tris
          .getProgram()
          .setUniform3f('camPos', camPos[0], camPos[1], camPos[2]);
      }

      model.tris.getVAO().bind();

      // draw polygons
      model.context.drawArrays(
        model.context.TRIANGLES,
        0,
        model.tris.getCABO().getElementCount()
      );
      model.tris.getVAO().release();

      model.openGLTexture.deactivate();
    }
  };

  publicAPI.updateBufferObjects = () => {
    // build the VBO if needed, only happens once
    if (!model.tris.getCABO().getElementCount()) {
      const ptsArray = new Float32Array(12);
      for (let i = 0; i < 4; i++) {
        ptsArray[i * 3] = (i % 2) * 2 - 1.0;
        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;
        ptsArray[i * 3 + 2] = 1.0;
      }
      const points = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance({
        numberOfComponents: 3,
        values: ptsArray,
      });
      points.setName('points');

      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const cells = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance({
        numberOfComponents: 1,
        values: cellArray,
      });

      model.tris.getCABO().createVBO(cells, 'polys', vtk_js_Sources_Rendering_Core_Property_Constants__WEBPACK_IMPORTED_MODULE_6__["Representation"].SURFACE, {
        points,
        cellOffset: 0,
      });
    }

    // update the program?
    if (model.renderable.getFormat() !== model.lastFormat) {
      model.lastFormat = model.renderable.getFormat();

      if (model.lastFormat === 'box') {
        // we invert Y below because opengl is messed up!
        // Cube Maps have been specified to follow the RenderMan
        // specification (for whatever reason), and RenderMan
        // assumes the images' origin being in the upper left,
        // contrary to the usual OpenGL behaviour of having the
        // image origin in the lower left. That's why things get
        // swapped in the Y direction. It totally breaks with the usual
        // OpenGL semantics and doesn't make sense at all.
        // But now we're stuck with it.  From
        // https://stackoverflow.com/questions/11685608/convention-of-faces-in-opengl-cubemapping
        //
        model.tris.setProgram(
          model.openGLRenderWindow.getShaderCache().readyShaderProgramArray(
            `//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec3 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = wpos.xyz/wpos.w;
             }`,
            `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec3 TexCoords;
             uniform samplerCube sbtexture;
             uniform vec3 camPos;
             void main () {
               // skybox looks from inside out
               // which means we have to adjust
               // our tcoords. Otherwise text would
               // be flipped
               vec3 tc = normalize(TexCoords - camPos);
               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))
               {
                 tc = vec3(1.0, 1.0, -1.0) * tc;
               }
               else
               {
                 tc = vec3(-1.0, 1.0, 1.0) * tc;
               }
               gl_FragData[0] = textureCube(sbtexture, tc);
             }`,
            ''
          )
        );
      }

      if (model.lastFormat === 'background') {
        // maps the texture to the window
        model.tris.setProgram(
          model.openGLRenderWindow.getShaderCache().readyShaderProgramArray(
            `//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec2 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;
             }`,
            `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec2 TexCoords;
             uniform sampler2D sbtexture;
             void main () {
               gl_FragData[0] = texture2D(sbtexture, TexCoords);
             }`,
            ''
          )
        );
      }

      model.tris.getShaderSourceTime().modified();

      model.tris.getVAO().bind();

      if (
        !model.tris
          .getVAO()
          .addAttributeArray(
            model.tris.getProgram(),
            model.tris.getCABO(),
            'vertexMC',
            model.tris.getCABO().getVertexOffset(),
            model.tris.getCABO().getStride(),
            model.context.FLOAT,
            3,
            model.context.FALSE
          )
      ) {
        vtkErrorMacro('Error setting vertexMC in shader VAO.');
      }
    }

    // set/update the texture map if needed
    const tmaps = model.renderable.getTextures();
    if (!tmaps.length) {
      vtkErrorMacro('vtkSkybox requires a texture map');
    }
    if (model.openGLTexture.getRenderable() !== tmaps[0]) {
      model.openGLTexture.releaseGraphicsResources(model.openGLRenderWindow);
      model.openGLTexture.setRenderable(tmaps[0]);
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_4__["default"].extend(publicAPI, model, initialValues);

  model.openGLTexture = vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_5__["default"].newInstance();
  model.tris = vtk_js_Sources_Rendering_OpenGL_Helper__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();

  model.keyMatrixTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(model.keyMatrixTime, { mtime: 0 });
  model.keyMatrices = {
    normalMatrix: gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].create(),
    mcwc: gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create(),
  };

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGet(publicAPI, model, ['context']);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].get(publicAPI, model, ['activeTextures']);

  // Object methods
  vtkOpenGLSkybox(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/SphereMapper/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/SphereMapper/index.js ***!
  \****************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_BufferObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/BufferObject */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/BufferObject/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ShaderProgram */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderProgram/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_PolyDataMapper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/PolyDataMapper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/PolyDataMapper/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkSphereMapperVS_glsl__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/glsl/vtkSphereMapperVS.glsl */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkSphereMapperVS.glsl");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkSphereMapperVS_glsl__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(vtk_js_Sources_Rendering_OpenGL_glsl_vtkSphereMapperVS_glsl__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_8__);














const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_2__["default"];

// ----------------------------------------------------------------------------
// vtkOpenGLSphereMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLSphereMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLSphereMapper');

  // Capture 'parentClass' api for internal use
  const superClass = { ...publicAPI };

  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtk_js_Sources_Rendering_OpenGL_glsl_vtkSphereMapperVS_glsl__WEBPACK_IMPORTED_MODULE_7___default.a;
    shaders.Fragment = vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_8___default.a;
    shaders.Geometry = '';
  };

  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;

    VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_5__["default"].substitute(VSSource, '//VTK::Camera::Dec', [
      'uniform mat4 VCPCMatrix;\n',
      'uniform mat4 MCVCMatrix;',
    ]).result;

    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_5__["default"].substitute(FSSource, '//VTK::PositionVC::Dec', [
      'varying vec4 vertexVCVSOutput;',
    ]).result;

    // we create vertexVC below, so turn off the default
    // implementation
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_5__["default"].substitute(
      FSSource,
      '//VTK::PositionVC::Impl',
      ['vec4 vertexVC = vertexVCVSOutput;\n']
    ).result;

    // for lights kit and positional the VCPC matrix is already defined
    // so don't redefine it
    const replacement = [
      'uniform float invertedDepth;\n',
      'uniform int cameraParallel;\n',
      'varying float radiusVCVSOutput;\n',
      'varying vec3 centerVCVSOutput;\n',
      'uniform mat4 VCPCMatrix;\n',
    ];
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_5__["default"].substitute(
      FSSource,
      '//VTK::Normal::Dec',
      replacement
    ).result;

    let fragString = '';
    if (model.context.getExtension('EXT_frag_depth')) {
      fragString = 'gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n';
    }
    if (model.openGLRenderWindow.getWebgl2()) {
      fragString = 'gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n';
    }
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_5__["default"].substitute(FSSource, '//VTK::Depth::Impl', [
      // compute the eye position and unit direction
      '  vec3 EyePos;\n',
      '  vec3 EyeDir;\n',
      '  if (cameraParallel != 0) {\n',
      '    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n',
      '    EyeDir = vec3(0.0,0.0,-1.0); }\n',
      '  else {\n',
      '    EyeDir = vertexVC.xyz;\n',
      '    EyePos = vec3(0.0,0.0,0.0);\n',
      '    float lengthED = length(EyeDir);\n',
      '    EyeDir = normalize(EyeDir);\n',
      // we adjust the EyePos to be closer if it is too far away
      // to prevent floating point precision noise
      '    if (lengthED > radiusVCVSOutput*3.0) {\n',
      '      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n',
      '    }\n',

      // translate to Sphere center
      '  EyePos = EyePos - centerVCVSOutput;\n',
      // scale to radius 1.0
      '  EyePos = EyePos/radiusVCVSOutput;\n',
      // find the intersection
      '  float b = 2.0*dot(EyePos,EyeDir);\n',
      '  float c = dot(EyePos,EyePos) - 1.0;\n',
      '  float d = b*b - 4.0*c;\n',
      '  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n',
      '  if (d < 0.0) { discard; }\n',
      '  else {\n',
      '    float t = (-b - invertedDepth*sqrt(d))*0.5;\n',

      // compute the normal, for unit sphere this is just
      // the intersection point
      '    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n',
      // compute the intersection point in VC
      '    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n',
      '    }\n',
      // compute the pixel's depth
      // ' normalVCVSOutput = vec3(0,0,1);\n'
      '  vec4 pos = VCPCMatrix * vertexVC;\n',
      fragString,
    ]).result;

    // Strip out the normal line -- the normal is computed as part of the depth
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_5__["default"].substitute(FSSource, '//VTK::Normal::Impl', '')
      .result;

    if (model.haveSeenDepthRequest) {
      // special depth impl
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_5__["default"].substitute(FSSource, '//VTK::ZBuffer::Impl', [
        'if (depthRequest == 1) {',
        'float computedZ = (pos.z / pos.w + 1.0) / 2.0;',
        'float iz = floor(computedZ * 65535.0 + 0.1);',
        'float rf = floor(iz/256.0)/255.0;',
        'float gf = mod(iz,256.0)/255.0;',
        'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }',
      ]).result;
    }

    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;

    superClass.replaceShaderValues(shaders, ren, actor);
  };

  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (
      cellBO.getCABO().getElementCount() &&
      (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() ||
        cellBO.getShaderSourceTime().getMTime() >
          cellBO.getAttributeUpdateTime().getMTime()) &&
      cellBO.getProgram().isAttributeUsed('offsetMC')
    ) {
      if (
        !cellBO.getVAO().addAttributeArray(
          cellBO.getProgram(),
          cellBO.getCABO(),
          'offsetMC',
          12, // 12:this->VBO->ColorOffset+sizeof(float)
          cellBO.getCABO().getStride(),
          model.context.FLOAT,
          2,
          false
        )
      ) {
        vtkErrorMacro("Error setting 'offsetMC' in shader VAO.");
      }
    }

    if (cellBO.getProgram().isUniformUsed('invertedDepth')) {
      cellBO
        .getProgram()
        .setUniformf('invertedDepth', model.invert ? -1.0 : 1.0);
    }

    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };

  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();

    const cam = ren.getActiveCamera();
    const keyMats = model.openGLCamera.getKeyMatrices(ren);

    if (program.isUniformUsed('VCPCMatrix')) {
      program.setUniformMatrix('VCPCMatrix', keyMats.vcpc);
    }

    if (program.isUniformUsed('MCVCMatrix')) {
      if (!actor.getIsIdentity()) {
        const actMats = model.openGLActor.getKeyMatrices();
        const tmp4 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(tmp4, keyMats.wcvc, actMats.mcwc);
        program.setUniformMatrix('MCVCMatrix', tmp4);
      } else {
        program.setUniformMatrix('MCVCMatrix', keyMats.wcvc);
      }
    }

    if (program.isUniformUsed('cameraParallel')) {
      cellBO
        .getProgram()
        .setUniformi('cameraParallel', cam.getParallelProjection());
    }
  };

  publicAPI.getOpenGLMode = (rep, type) => model.context.TRIANGLES;

  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;

    if (poly === null) {
      return;
    }

    model.renderable.mapScalars(poly, 1.0);
    const c = model.renderable.getColorMapColors();

    const vbo = model.primitives[model.primTypes.Tris].getCABO();

    const pointData = poly.getPointData();
    const points = poly.getPoints();
    const numPoints = points.getNumberOfPoints();
    const pointArray = points.getData();

    const pointSize = 5; // x,y,z,orientation1,orientation2
    let scales = null;

    if (
      model.renderable.getScaleArray() != null &&
      pointData.hasArray(model.renderable.getScaleArray())
    ) {
      scales = pointData.getArray(model.renderable.getScaleArray()).getData();
    }

    let colorData = null;
    let colorComponents = 0;
    let packedUCVBO = null;
    if (c) {
      colorComponents = c.getNumberOfComponents();
      vbo.setColorOffset(0);
      vbo.setColorBOStride(4);
      colorData = c.getData();
      packedUCVBO = new Uint8Array(3 * numPoints * 4);
      if (!vbo.getColorBO()) {
        vbo.setColorBO(vtk_js_Sources_Rendering_OpenGL_BufferObject__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance());
      }
      vbo.getColorBO().setOpenGLRenderWindow(model.openGLRenderWindow);
    } else if (vbo.getColorBO()) {
      vbo.setColorBO(null);
    }
    vbo.setColorComponents(colorComponents);

    const packedVBO = new Float32Array(pointSize * numPoints * 3);

    vbo.setStride(pointSize * 4);

    const cos30 = Math.cos(vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_4__["radiansFromDegrees"](30.0));
    let pointIdx = 0;
    let colorIdx = 0;

    //
    // Generate points and point data for sides
    //
    let vboIdx = 0;
    let ucIdx = 0;
    for (let i = 0; i < numPoints; ++i) {
      let radius = model.renderable.getRadius();
      if (scales) {
        radius = scales[i];
      }

      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = -2.0 * radius * cos30;
      packedVBO[vboIdx++] = -radius;
      if (colorData) {
        colorIdx = i * colorComponents;
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }

      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = 2.0 * radius * cos30;
      packedVBO[vboIdx++] = -radius;
      if (colorData) {
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }

      pointIdx = i * 3;
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = pointArray[pointIdx++];
      packedVBO[vboIdx++] = 0.0;
      packedVBO[vboIdx++] = 2.0 * radius;
      if (colorData) {
        packedUCVBO[ucIdx++] = colorData[colorIdx];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
        packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
      }
    }

    vbo.setElementCount(vboIdx / pointSize);
    vbo.upload(packedVBO, vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_1__["ObjectType"].ARRAY_BUFFER);
    if (c) {
      vbo.getColorBO().upload(packedUCVBO, vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_1__["ObjectType"].ARRAY_BUFFER);
    }

    model.VBOBuildTime.modified();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_OpenGL_PolyDataMapper__WEBPACK_IMPORTED_MODULE_6__["default"].extend(publicAPI, model, initialValues);

  // Object methods
  vtkOpenGLSphereMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance(extend, 'vtkOpenGLSphereMapper');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/StickMapper/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/StickMapper/index.js ***!
  \***************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_BufferObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/BufferObject */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/BufferObject/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkStickMapperVS_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/glsl/vtkStickMapperVS.glsl */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkStickMapperVS.glsl");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkStickMapperVS_glsl__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(vtk_js_Sources_Rendering_OpenGL_glsl_vtkStickMapperVS_glsl__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ShaderProgram */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderProgram/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_PolyDataMapper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/PolyDataMapper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/PolyDataMapper/index.js");












const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_2__;

// ----------------------------------------------------------------------------
// vtkOpenGLStickMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLStickMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLStickMapper');

  // Capture 'parentClass' api for internal use
  const superClass = { ...publicAPI };

  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtk_js_Sources_Rendering_OpenGL_glsl_vtkStickMapperVS_glsl__WEBPACK_IMPORTED_MODULE_4___default.a;
    shaders.Fragment = vtk_js_Sources_Rendering_OpenGL_glsl_vtkPolyDataFS_glsl__WEBPACK_IMPORTED_MODULE_5___default.a;
    shaders.Geometry = '';
  };

  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;

    VSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(VSSource, '//VTK::Camera::Dec', [
      'uniform mat4 VCPCMatrix;\n',
      'uniform mat4 MCVCMatrix;',
    ]).result;

    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(
      FSSource,
      '//VTK::PositionVC::Dec',
      'varying vec4 vertexVCVSOutput;'
    ).result;

    // we create vertexVC below, so turn off the default
    // implementation
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(
      FSSource,
      '//VTK::PositionVC::Impl',
      '  vec4 vertexVC = vertexVCVSOutput;\n'
    ).result;

    // for lights kit and positional the VCPC matrix is already defined
    // so don't redefine it
    const replacement = [
      'uniform int cameraParallel;\n',
      'varying float radiusVCVSOutput;\n',
      'varying vec3 orientVCVSOutput;\n',
      'varying float lengthVCVSOutput;\n',
      'varying vec3 centerVCVSOutput;\n',
      'uniform mat4 VCPCMatrix;\n',
    ];
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(
      FSSource,
      '//VTK::Normal::Dec',
      replacement
    ).result;

    let fragString = '';
    if (model.context.getExtension('EXT_frag_depth')) {
      fragString = '  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n';
    }
    if (model.openGLRenderWindow.getWebgl2()) {
      fragString = 'gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n';
    }
    // see https://www.cl.cam.ac.uk/teaching/1999/AGraphHCI/SMAG/node2.html
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(FSSource, '//VTK::Depth::Impl', [
      // compute the eye position and unit direction
      '  vec3 EyePos;\n',
      '  vec3 EyeDir;\n',
      '  if (cameraParallel != 0) {\n',
      '    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n',
      '    EyeDir = vec3(0.0,0.0,-1.0); }\n',
      '  else {\n',
      '    EyeDir = vertexVC.xyz;\n',
      '    EyePos = vec3(0.0,0.0,0.0);\n',
      '    float lengthED = length(EyeDir);\n',
      '    EyeDir = normalize(EyeDir);\n',
      // we adjust the EyePos to be closer if it is too far away
      // to prevent floating point precision noise
      '    if (lengthED > radiusVCVSOutput*3.0) {\n',
      '      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n',
      '    }\n',

      // translate to Stick center
      '  EyePos = EyePos - centerVCVSOutput;\n',

      // rotate to new basis
      // base1, base2, orientVC
      '  vec3 base1;\n',
      '  if (abs(orientVCVSOutput.z) < 0.99) {\n',
      '    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n',
      '  else {\n',
      '    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n',
      '  vec3 base2 = cross(orientVCVSOutput,base1);\n',
      '  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n',
      '  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n',

      // scale by radius
      '  EyePos = EyePos/radiusVCVSOutput;\n',

      // find the intersection
      '  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n',
      '  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n',
      '  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n',
      '  float d = b*b - 4.0*a*c;\n',
      '  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n',
      '  if (d < 0.0) { discard; }\n',
      '  else {\n',
      '    float t =  (-b - sqrt(d))/(2.0*a);\n',
      '    float tz = EyePos.z + t*EyeDir.z;\n',
      '    vec3 iPoint = EyePos + t*EyeDir;\n',
      '    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n',
      // test for end cap
      '      float t2 = (-b + sqrt(d))/(2.0*a);\n',
      '      float tz2 = EyePos.z + t2*EyeDir.z;\n',
      '      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n',
      '      else {\n',
      '        normalVCVSOutput = orientVCVSOutput;\n',
      '        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n',
      '        iPoint = EyePos + t3*EyeDir;\n',
      '        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n',
      '        }\n',
      '      }\n',
      '    else {\n',
      // The normal is the iPoint.xy rotated back into VC
      '      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n',
      // rescale rerotate and translate
      '      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n',
      '      }\n',
      '    }\n',

      //    '  vec3 normalVC = vec3(0.0,0.0,1.0);\n'
      // compute the pixel's depth
      '  vec4 pos = VCPCMatrix * vertexVC;\n',
      fragString,
    ]).result;

    // Strip out the normal line -- the normal is computed as part of the depth
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(FSSource, '//VTK::Normal::Impl', '')
      .result;

    if (model.haveSeenDepthRequest) {
      // special depth impl
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_6__["default"].substitute(FSSource, '//VTK::ZBuffer::Impl', [
        'if (depthRequest == 1) {',
        'float computedZ = (pos.z / pos.w + 1.0) / 2.0;',
        'float iz = floor(computedZ * 65535.0 + 0.1);',
        'float rf = floor(iz/256.0)/255.0;',
        'float gf = mod(iz,256.0)/255.0;',
        'gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }',
      ]).result;
    }

    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;

    superClass.replaceShaderValues(shaders, ren, actor);
  };

  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (
      cellBO.getCABO().getElementCount() &&
      (model.VBOBuildTime > cellBO.getAttributeUpdateTime().getMTime() ||
        cellBO.getShaderSourceTime().getMTime() >
          cellBO.getAttributeUpdateTime().getMTime())
    ) {
      if (cellBO.getProgram().isAttributeUsed('orientMC')) {
        if (
          !cellBO.getVAO().addAttributeArray(
            cellBO.getProgram(),
            cellBO.getCABO(),
            'orientMC',
            12, // after X Y Z
            cellBO.getCABO().getStride(),
            model.context.FLOAT,
            3,
            false
          )
        ) {
          vtkErrorMacro("Error setting 'orientMC' in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed('offsetMC')) {
        if (
          !cellBO
            .getVAO()
            .addAttributeArray(
              cellBO.getProgram(),
              cellBO.getCABO().getColorBO(),
              'offsetMC',
              0,
              cellBO.getCABO().getColorBOStride(),
              model.context.UNSIGNED_BYTE,
              3,
              true
            )
        ) {
          vtkErrorMacro("Error setting 'offsetMC' in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed('radiusMC')) {
        if (
          !cellBO.getVAO().addAttributeArray(
            cellBO.getProgram(),
            cellBO.getCABO(),
            'radiusMC',
            24, // X Y Z OX OY OZ
            cellBO.getCABO().getStride(),
            model.context.FLOAT,
            1,
            false
          )
        ) {
          vtkErrorMacro("Error setting 'radiusMC' in shader VAO.");
        }
      }
    }

    superClass.setMapperShaderParameters(cellBO, ren, actor);
  };

  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();

    const cam = ren.getActiveCamera();
    const keyMats = model.openGLCamera.getKeyMatrices(ren);

    if (program.isUniformUsed('VCPCMatrix')) {
      program.setUniformMatrix('VCPCMatrix', keyMats.vcpc);
    }

    if (!actor.getIsIdentity()) {
      const actMats = model.openGLActor.getKeyMatrices();
      const tmp4 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();

      if (program.isUniformUsed('MCVCMatrix')) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].multiply(tmp4, keyMats.wcvc, actMats.mcwc);
        program.setUniformMatrix('MCVCMatrix', tmp4);
      }
      if (program.isUniformUsed('normalMatrix')) {
        const anorms = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].create();
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].multiply(anorms, keyMats.normalMatrix, actMats.normalMatrix);
        program.setUniformMatrix3x3('normalMatrix', anorms);
      }
    } else {
      if (program.isUniformUsed('MCVCMatrix')) {
        program.setUniformMatrix('MCVCMatrix', keyMats.wcvc);
      }
      if (program.isUniformUsed('normalMatrix')) {
        program.setUniformMatrix3x3('normalMatrix', keyMats.normalMatrix);
      }
    }

    if (program.isUniformUsed('cameraParallel')) {
      cellBO
        .getProgram()
        .setUniformi('cameraParallel', cam.getParallelProjection());
    }
  };

  publicAPI.getOpenGLMode = (rep, type) => model.context.TRIANGLES;

  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;

    if (poly === null) {
      return;
    }

    model.renderable.mapScalars(poly, 1.0);
    const c = model.renderable.getColorMapColors();

    const vbo = model.primitives[model.primTypes.Tris].getCABO();

    const pointData = poly.getPointData();
    const points = poly.getPoints();
    const numPoints = points.getNumberOfPoints();
    const pointArray = points.getData();
    let pointSize = 3; // x,y,z

    // three more floats for orientation + 1 for radius
    pointSize += 4;

    let colorData = null;
    let colorComponents = 0;
    vbo.setColorBOStride(4);

    if (!vbo.getColorBO()) {
      vbo.setColorBO(vtk_js_Sources_Rendering_OpenGL_BufferObject__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance());
    }
    vbo.getColorBO().setOpenGLRenderWindow(model.openGLRenderWindow);
    if (c) {
      colorComponents = c.getNumberOfComponents();
      vbo.setColorOffset(4);
      colorData = c.getData();
      vbo.setColorBOStride(8);
    }
    vbo.setColorComponents(colorComponents);

    vbo.setStride(pointSize * 4);

    // Create a buffer, and copy the data over.
    const packedVBO = new Float32Array(pointSize * numPoints * 12);
    const packedUCVBO = new Uint8Array(12 * numPoints * (colorData ? 8 : 4));

    let scales = null;
    let orientationArray = null;
    //
    // Generate points and point data for sides
    //
    if (
      model.renderable.getScaleArray() != null &&
      pointData.hasArray(model.renderable.getScaleArray())
    ) {
      scales = pointData.getArray(model.renderable.getScaleArray()).getData();
    }

    if (
      model.renderable.getOrientationArray() != null &&
      pointData.hasArray(model.renderable.getOrientationArray())
    ) {
      orientationArray = pointData
        .getArray(model.renderable.getOrientationArray())
        .getData();
    } else {
      vtkErrorMacro([
        'Error setting orientationArray.\n',
        'You have to specify the stick orientation',
      ]);
    }

    // Vertices
    // 013 - 032 - 324 - 453
    //
    //       _.4---_.5
    //    .-*   .-*
    //   2-----3
    //   |    /|
    //   |   / |
    //   |  /  |
    //   | /   |
    //   |/    |
    //   0-----1
    //
    // coord for each points
    // 0: 000
    // 1: 100
    // 2: 001
    // 3: 101
    // 4: 011
    // 5: 111

    // prettier-ignore
    const verticesArray = [
      0, 1, 3,
      0, 3, 2,
      2, 3, 5,
      2, 5, 4,
    ];

    let pointIdx = 0;
    let colorIdx = 0;
    let vboIdx = 0;
    let ucIdx = 0;

    for (let i = 0; i < numPoints; ++i) {
      let length = model.renderable.getLength();
      let radius = model.renderable.getRadius();
      if (scales) {
        length = scales[i * 2];
        radius = scales[i * 2 + 1];
      }

      for (let j = 0; j < verticesArray.length; ++j) {
        pointIdx = i * 3;
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        packedVBO[vboIdx++] = pointArray[pointIdx++];
        pointIdx = i * 3;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = orientationArray[pointIdx++] * length;
        packedVBO[vboIdx++] = radius;

        packedUCVBO[ucIdx++] = 255 * (verticesArray[j] % 2);
        packedUCVBO[ucIdx++] = verticesArray[j] >= 4 ? 255 : 0;
        packedUCVBO[ucIdx++] = verticesArray[j] >= 2 ? 255 : 0;
        packedUCVBO[ucIdx++] = 255;

        colorIdx = i * colorComponents;
        if (colorData) {
          packedUCVBO[ucIdx++] = colorData[colorIdx];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 1];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 2];
          packedUCVBO[ucIdx++] = colorData[colorIdx + 3];
        }
      }
    }
    vbo.setElementCount(vboIdx / pointSize);
    vbo.upload(packedVBO, vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_1__["ObjectType"].ARRAY_BUFFER);
    vbo.getColorBO().upload(packedUCVBO, vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_1__["ObjectType"].ARRAY_BUFFER);
    model.VBOBuildTime.modified();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_OpenGL_PolyDataMapper__WEBPACK_IMPORTED_MODULE_7__["default"].extend(publicAPI, model, initialValues);

  // Object methods
  vtkOpenGLStickMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_2__["newInstance"](extend, 'vtkOpenGLStickMapper');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/Constants.js":
/*!***************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/Constants.js ***!
  \***************************************************************************/
/*! exports provided: Wrap, Filter, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Wrap", function() { return Wrap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Filter", function() { return Filter; });
const Wrap = {
  CLAMP_TO_EDGE: 0,
  REPEAT: 1,
  MIRRORED_REPEAT: 2,
};

const Filter = {
  NEAREST: 0,
  LINEAR: 1,
  NEAREST_MIPMAP_NEAREST: 2,
  NEAREST_MIPMAP_LINEAR: 3,
  LINEAR_MIPMAP_NEAREST: 4,
  LINEAR_MIPMAP_LINEAR: 5,
};

/* harmony default export */ __webpack_exports__["default"] = ({
  Wrap,
  Filter,
});


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/index.js ***!
  \***********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Texture/Constants */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/Constants.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/ViewNode */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js");






const { Wrap, Filter } = vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_0__["default"];
const { VtkDataTypes } = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__["default"];
const { vtkDebugMacro, vtkErrorMacro, vtkWarningMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"];

// ----------------------------------------------------------------------------
// vtkOpenGLTexture methods
// ----------------------------------------------------------------------------

function vtkOpenGLTexture(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLTexture');
  // Renders myself
  publicAPI.render = (renWin = null) => {
    if (renWin) {
      model.openGLRenderWindow = renWin;
    } else {
      model.openGLRenderer = publicAPI.getFirstAncestorOfType(
        'vtkOpenGLRenderer'
      );
      // sync renderable properties
      model.openGLRenderWindow = model.openGLRenderer.getParent();
    }
    model.context = model.openGLRenderWindow.getContext();
    if (model.renderable.getInterpolate()) {
      if (model.generateMipmap) {
        publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
      } else {
        publicAPI.setMinificationFilter(Filter.LINEAR);
      }
      publicAPI.setMagnificationFilter(Filter.LINEAR);
    } else {
      publicAPI.setMinificationFilter(Filter.NEAREST);
      publicAPI.setMagnificationFilter(Filter.NEAREST);
    }
    if (model.renderable.getRepeat()) {
      publicAPI.setWrapR(Wrap.REPEAT);
      publicAPI.setWrapS(Wrap.REPEAT);
      publicAPI.setWrapT(Wrap.REPEAT);
    }
    // clear image if input data is set
    if (model.renderable.getInputData()) {
      model.renderable.setImage(null);
    }
    // create the texture if it is not done already
    if (
      !model.handle ||
      model.renderable.getMTime() > model.textureBuildTime.getMTime()
    ) {
      // if we have an Image
      if (model.renderable.getImage() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        }
        // Have an Image which may not be complete
        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {
          publicAPI.create2DFromImage(model.renderable.getImage());
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
      }
      // if we have Inputdata
      const input = model.renderable.getInputData(0);
      if (input && input.getPointData().getScalars()) {
        const ext = input.getExtent();
        const inScalars = input.getPointData().getScalars();

        // do we have a cube map? Six inputs
        const data = [];
        for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {
          const indata = model.renderable.getInputData(i);
          const scalars = indata
            ? indata.getPointData().getScalars().getData()
            : null;
          if (scalars) {
            data.push(scalars);
          }
        }
        if (
          model.renderable.getInterpolate() &&
          inScalars.getNumberOfComponents() === 4
        ) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter.LINEAR_MIPMAP_LINEAR);
        }
        if (data.length % 6 === 0) {
          publicAPI.createCubeFromRaw(
            ext[1] - ext[0] + 1,
            ext[3] - ext[2] + 1,
            inScalars.getNumberOfComponents(),
            inScalars.getDataType(),
            data
          );
        } else {
          publicAPI.create2DFromRaw(
            ext[1] - ext[0] + 1,
            ext[3] - ext[2] + 1,
            inScalars.getNumberOfComponents(),
            inScalars.getDataType(),
            inScalars.getData()
          );
        }
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
    }
    if (model.handle) {
      publicAPI.activate();
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.destroyTexture = () => {
    // deactivate it first
    publicAPI.deactivate();

    if (model.context && model.handle) {
      model.context.deleteTexture(model.handle);
    }
    model.handle = 0;
    model.numberOfDimensions = 0;
    model.target = 0;
    model.components = 0;
    model.width = 0;
    model.height = 0;
    model.depth = 0;
    publicAPI.resetFormatAndType();
  };

  //----------------------------------------------------------------------------
  publicAPI.createTexture = () => {
    // reuse the existing handle if we have one
    if (!model.handle) {
      model.handle = model.context.createTexture();

      if (model.target) {
        model.context.bindTexture(model.target, model.handle);

        // See: http://www.openmodel.context..org/wiki/Common_Mistakes#Creating_a_complete_texture
        // turn off mip map filter or set the base and max level correctly. here
        // both are done.
        model.context.texParameteri(
          model.target,
          model.context.TEXTURE_MIN_FILTER,
          publicAPI.getOpenGLFilterMode(model.minificationFilter)
        );
        model.context.texParameteri(
          model.target,
          model.context.TEXTURE_MAG_FILTER,
          publicAPI.getOpenGLFilterMode(model.magnificationFilter)
        );

        model.context.texParameteri(
          model.target,
          model.context.TEXTURE_WRAP_S,
          publicAPI.getOpenGLWrapMode(model.wrapS)
        );
        model.context.texParameteri(
          model.target,
          model.context.TEXTURE_WRAP_T,
          publicAPI.getOpenGLWrapMode(model.wrapT)
        );
        if (model.openGLRenderWindow.getWebgl2()) {
          model.context.texParameteri(
            model.target,
            model.context.TEXTURE_WRAP_R,
            publicAPI.getOpenGLWrapMode(model.wrapR)
          );
        }

        model.context.bindTexture(model.target, null);
      }
    }
  };

  //---------------------------------------------------------------------------
  publicAPI.getTextureUnit = () => {
    if (model.openGLRenderWindow) {
      return model.openGLRenderWindow.getTextureUnitForTexture(publicAPI);
    }
    return -1;
  };

  //---------------------------------------------------------------------------
  publicAPI.activate = () => {
    // activate a free texture unit for this texture
    model.openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.bind();
  };

  //---------------------------------------------------------------------------
  publicAPI.deactivate = () => {
    if (model.openGLRenderWindow) {
      model.openGLRenderWindow.deactivateTexture(publicAPI);
    }
  };

  //---------------------------------------------------------------------------
  publicAPI.releaseGraphicsResources = (rwin) => {
    if (rwin && model.handle) {
      rwin.activateTexture(publicAPI);
      rwin.deactivateTexture(publicAPI);
      model.context.deleteTexture(model.handle);
      model.handle = 0;
      model.numberOfDimensions = 0;
      model.target = 0;
      model.internalFormat = 0;
      model.format = 0;
      model.openGLDataType = 0;
      model.components = 0;
      model.width = 0;
      model.height = 0;
      model.depth = 0;
    }
    if (model.shaderProgram) {
      model.shaderProgram.releaseGraphicsResources(rwin);
      model.shaderProgram = null;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.bind = () => {
    model.context.bindTexture(model.target, model.handle);
    if (
      model.autoParameters &&
      publicAPI.getMTime() > model.sendParametersTime.getMTime()
    ) {
      publicAPI.sendParameters();
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.isBound = () => {
    let result = false;
    if (model.context && model.handle) {
      let target = 0;
      switch (model.target) {
        case model.context.TEXTURE_2D:
          target = model.context.TEXTURE_BINDING_2D;
          break;
        default:
          vtkWarningMacro('impossible case');
          break;
      }
      const oid = model.context.getIntegerv(target);
      result = oid === model.handle;
    }
    return result;
  };

  //----------------------------------------------------------------------------
  publicAPI.sendParameters = () => {
    model.context.texParameteri(
      model.target,
      model.context.TEXTURE_WRAP_S,
      publicAPI.getOpenGLWrapMode(model.wrapS)
    );
    model.context.texParameteri(
      model.target,
      model.context.TEXTURE_WRAP_T,
      publicAPI.getOpenGLWrapMode(model.wrapT)
    );
    if (model.openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(
        model.target,
        model.context.TEXTURE_WRAP_R,
        publicAPI.getOpenGLWrapMode(model.wrapR)
      );
    }

    model.context.texParameteri(
      model.target,
      model.context.TEXTURE_MIN_FILTER,
      publicAPI.getOpenGLFilterMode(model.minificationFilter)
    );

    model.context.texParameteri(
      model.target,
      model.context.TEXTURE_MAG_FILTER,
      publicAPI.getOpenGLFilterMode(model.magnificationFilter)
    );

    if (model.openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(
        model.target,
        model.context.TEXTURE_BASE_LEVEL,
        model.baseLevel
      );

      model.context.texParameteri(
        model.target,
        model.context.TEXTURE_MAX_LEVEL,
        model.maxLevel
      );
    }

    // model.context.texParameterf(model.target, model.context.TEXTURE_MIN_LOD, model.minLOD);
    // model.context.texParameterf(model.target, model.context.TEXTURE_MAX_LOD, model.maxLOD);

    model.sendParametersTime.modified();
  };

  //----------------------------------------------------------------------------
  publicAPI.getInternalFormat = (vtktype, numComps) => {
    if (!model.internalFormat) {
      model.internalFormat = publicAPI.getDefaultInternalFormat(
        vtktype,
        numComps
      );
    }

    if (!model.internalFormat) {
      vtkDebugMacro(
        `Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`
      );
    }

    return model.internalFormat;
  };

  //----------------------------------------------------------------------------
  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {
    let result = 0;

    // try default next
    result = model.openGLRenderWindow.getDefaultTextureInternalFormat(
      vtktype,
      numComps,
      false
    );
    if (result) {
      return result;
    }

    // try floating point
    result = this.openGLRenderWindow.getDefaultTextureInternalFormat(
      vtktype,
      numComps,
      true
    );

    if (!result) {
      vtkDebugMacro('Unsupported internal texture type!');
      vtkDebugMacro(
        `Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`
      );
    }

    return result;
  };

  //----------------------------------------------------------------------------
  publicAPI.setInternalFormat = (iFormat) => {
    if (iFormat !== model.internalFormat) {
      model.internalFormat = iFormat;
      publicAPI.modified();
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.getFormat = (vtktype, numComps) => {
    model.format = publicAPI.getDefaultFormat(vtktype, numComps);
    return model.format;
  };

  //----------------------------------------------------------------------------
  publicAPI.getDefaultFormat = (vtktype, numComps) => {
    if (model.openGLRenderWindow.getWebgl2()) {
      switch (numComps) {
        case 1:
          return model.context.RED;
        case 2:
          return model.context.RG;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    } else {
      // webgl1
      switch (numComps) {
        case 1:
          return model.context.LUMINANCE;
        case 2:
          return model.context.LUMINANCE_ALPHA;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.resetFormatAndType = () => {
    model.format = 0;
    model.internalFormat = 0;
    model.openGLDataType = 0;
  };

  //----------------------------------------------------------------------------
  publicAPI.getDefaultDataType = (vtkScalarType) => {
    // DON'T DEAL with VTK_CHAR as this is platform dependent.
    if (model.openGLRenderWindow.getWebgl2()) {
      switch (vtkScalarType) {
        // case VtkDataTypes.SIGNED_CHAR:
        //   return model.context.BYTE;
        case VtkDataTypes.UNSIGNED_CHAR:
          return model.context.UNSIGNED_BYTE;
        // case VtkDataTypes.SHORT:
        //   return model.context.SHORT;
        // case VtkDataTypes.UNSIGNED_SHORT:
        //   return model.context.UNSIGNED_SHORT;
        // case VtkDataTypes.INT:
        //   return model.context.INT;
        // case VtkDataTypes.UNSIGNED_INT:
        //   return model.context.UNSIGNED_INT;
        case VtkDataTypes.FLOAT:
        case VtkDataTypes.VOID: // used for depth component textures.
        default:
          return model.context.FLOAT;
      }
    }

    switch (vtkScalarType) {
      // case VtkDataTypes.SIGNED_CHAR:
      //   return model.context.BYTE;
      case VtkDataTypes.UNSIGNED_CHAR:
        return model.context.UNSIGNED_BYTE;
      // case VtkDataTypes.SHORT:
      //   return model.context.SHORT;
      // case VtkDataTypes.UNSIGNED_SHORT:
      //   return model.context.UNSIGNED_SHORT;
      // case VtkDataTypes.INT:
      //   return model.context.INT;
      // case VtkDataTypes.UNSIGNED_INT:
      //   return model.context.UNSIGNED_INT;
      case VtkDataTypes.FLOAT:
      case VtkDataTypes.VOID: // used for depth component textures.
      default:
        if (
          model.context.getExtension('OES_texture_float') &&
          model.context.getExtension('OES_texture_float_linear')
        ) {
          return model.context.FLOAT;
        }
        return model.context.UNSIGNED_BYTE;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.getOpenGLDataType = (vtkScalarType) => {
    model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);
    return model.openGLDataType;
  };

  publicAPI.getShiftAndScale = () => {
    let shift = 0.0;
    let scale = 1.0;

    // for all float type internal formats
    switch (model.openGLDataType) {
      case model.context.BYTE:
        scale = 127.5;
        shift = scale - 128.0;
        break;
      case model.context.UNSIGNED_BYTE:
        scale = 255.0;
        shift = 0.0;
        break;
      case model.context.SHORT:
        scale = 32767.5;
        shift = scale - 32768.0;
        break;
      case model.context.UNSIGNED_SHORT:
        scale = 65536.0;
        shift = 0.0;
        break;
      case model.context.INT:
        scale = 2147483647.5;
        shift = scale - 2147483648.0;
        break;
      case model.context.UNSIGNED_INT:
        scale = 4294967295.0;
        shift = 0.0;
        break;
      case model.context.FLOAT:
      default:
        break;
    }
    return { shift, scale };
  };

  //----------------------------------------------------------------------------
  publicAPI.getOpenGLFilterMode = (emode) => {
    switch (emode) {
      case Filter.NEAREST:
        return model.context.NEAREST;
      case Filter.LINEAR:
        return model.context.LINEAR;
      case Filter.NEAREST_MIPMAP_NEAREST:
        return model.context.NEAREST_MIPMAP_NEAREST;
      case Filter.NEAREST_MIPMAP_LINEAR:
        return model.context.NEAREST_MIPMAP_LINEAR;
      case Filter.LINEAR_MIPMAP_NEAREST:
        return model.context.LINEAR_MIPMAP_NEAREST;
      case Filter.LINEAR_MIPMAP_LINEAR:
        return model.context.LINEAR_MIPMAP_LINEAR;
      default:
        return model.context.NEAREST;
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.getOpenGLWrapMode = (vtktype) => {
    switch (vtktype) {
      case Wrap.CLAMP_TO_EDGE:
        return model.context.CLAMP_TO_EDGE;
      case Wrap.REPEAT:
        return model.context.REPEAT;
      case Wrap.MIRRORED_REPEAT:
        return model.context.MIRRORED_REPEAT;
      default:
        return model.context.CLAMP_TO_EDGE;
    }
  };

  //----------------------------------------------------------------------------
  function updateArrayDataType(dataType, data) {
    const pixData = [];
    // if the opengl data type is float
    // then the data array must be float
    if (
      dataType !== VtkDataTypes.FLOAT &&
      model.openGLDataType === model.context.FLOAT
    ) {
      const pixCount = model.width * model.height * model.components;
      for (let idx = 0; idx < data.length; idx++) {
        const newArray = new Float32Array(pixCount);
        for (let i = 0; i < pixCount; i++) {
          newArray[i] = data[idx][i];
        }
        pixData.push(newArray);
      }
    }

    // if the opengl data type is ubyte
    // then the data array must be u8, we currently simply truncate the data
    if (
      dataType !== VtkDataTypes.UNSIGNED_CHAR &&
      model.openGLDataType === model.context.UNSIGNED_BYTE
    ) {
      const pixCount = model.width * model.height * model.components;
      for (let idx = 0; idx < data.length; idx++) {
        const newArray = new Uint8Array(pixCount);
        for (let i = 0; i < pixCount; i++) {
          newArray[i] = data[idx][i];
        }
        pixData.push(newArray);
      }
    }

    // The output has to be filled
    if (pixData.length === 0) {
      for (let i = 0; i < data.length; i++) {
        pixData.push(data[i]);
      }
    }

    return pixData;
  }

  //----------------------------------------------------------------------------
  function scaleTextureToHighestPowerOfTwo(data) {
    if (model.openGLRenderWindow.getWebgl2()) {
      // No need if webGL2
      return data;
    }
    const pixData = [];
    const width = model.width;
    const height = model.height;
    const numComps = model.components;
    if (
      data &&
      (!vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["isPowerOfTwo"](width) || !vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["isPowerOfTwo"](height))
    ) {
      // Scale up the texture to the next highest power of two dimensions.
      const newWidth = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["nearestPowerOfTwo"](width);
      const newHeight = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["nearestPowerOfTwo"](height);
      const pixCount = newWidth * newHeight * model.components;
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx] !== null) {
          let newArray = null;
          switch (model.openGLDataType) {
            case model.context.FLOAT:
              newArray = new Float32Array(pixCount);
              break;
            default:
            case model.context.UNSIGNED_BYTE:
              newArray = new Uint8Array(pixCount);
              break;
          }
          const jFactor = height / newHeight;
          const iFactor = width / newWidth;
          for (let j = 0; j < newHeight; j++) {
            const joff = j * newWidth * numComps;
            const jidx = j * jFactor;
            let jlow = Math.floor(jidx);
            let jhi = Math.ceil(jidx);
            if (jhi >= height) {
              jhi = height - 1;
            }
            const jmix = jidx - jlow;
            const jmix1 = 1.0 - jmix;
            jlow = jlow * width * numComps;
            jhi = jhi * width * numComps;
            for (let i = 0; i < newWidth; i++) {
              const ioff = i * numComps;
              const iidx = i * iFactor;
              let ilow = Math.floor(iidx);
              let ihi = Math.ceil(iidx);
              if (ihi >= width) {
                ihi = width - 1;
              }
              const imix = iidx - ilow;
              ilow *= numComps;
              ihi *= numComps;
              for (let c = 0; c < numComps; c++) {
                newArray[joff + ioff + c] =
                  data[idx][jlow + ilow + c] * jmix1 * (1.0 - imix) +
                  data[idx][jlow + ihi + c] * jmix1 * imix +
                  data[idx][jhi + ilow + c] * jmix * (1.0 - imix) +
                  data[idx][jhi + ihi + c] * jmix * imix;
              }
            }
          }
          pixData.push(newArray);
          model.width = newWidth;
          model.height = newHeight;
        } else {
          pixData.push(null);
        }
      }
    }

    // The output has to be filled
    if (pixData.length === 0) {
      for (let i = 0; i < data.length; i++) {
        pixData.push(data[i]);
      }
    }

    return pixData;
  }

  //----------------------------------------------------------------------------
  publicAPI.create2DFromRaw = (width, height, numComps, dataType, data) => {
    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);

    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }

    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model.openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();

    // Create an array of texture with one texture
    const dataArray = [data];
    const pixData = updateArrayDataType(dataType, dataArray);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);

    // Source texture data from the PBO.
    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);

    model.context.texImage2D(
      model.target,
      0,
      model.internalFormat,
      model.width,
      model.height,
      0,
      model.format,
      model.openGLDataType,
      scaledData[0]
    );

    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }

    publicAPI.deactivate();
    return true;
  };

  //----------------------------------------------------------------------------
  publicAPI.createCubeFromRaw = (width, height, numComps, dataType, data) => {
    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);

    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }

    model.target = model.context.TEXTURE_CUBE_MAP;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model.openGLRenderWindow.activateTexture(publicAPI);
    model.maxLevel = data.length / 6 - 1;
    publicAPI.createTexture();
    publicAPI.bind();

    const pixData = updateArrayDataType(dataType, data);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);

    // invert the data because opengl is messed up with cube maps
    // and uses the old renderman standard with Y going down
    // even though it is completely at odds with OpenGL standards
    const invertedData = [];
    let widthLevel = model.width;
    let heightLevel = model.height;
    for (let i = 0; i < scaledData.length; i++) {
      if (i % 6 === 0 && i !== 0) {
        widthLevel /= 2;
        heightLevel /= 2;
      }
      invertedData[i] = new window[dataType](
        heightLevel * widthLevel * model.components
      );
      for (let y = 0; y < heightLevel; ++y) {
        const row1 = y * widthLevel * model.components;
        const row2 = (heightLevel - y - 1) * widthLevel * model.components;
        invertedData[i].set(
          scaledData[i].slice(row2, row2 + widthLevel * model.components),
          row1
        );
      }
    }

    // Source texture data from the PBO.
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);

    // We get the 6 images
    for (let i = 0; i < 6; i++) {
      // For each mipmap level
      let j = 0;
      let w = model.width;
      let h = model.height;
      while (w >= 1 && h >= 1) {
        // In webgl 1, all levels need to be defined. So if the latest level size is
        // 8x8, we have to add 3 more null textures (4x4, 2x2, 1x1)
        // In webgl 2, the attribute maxLevel will be use.
        let tempData = null;
        if (j <= model.maxLevel) {
          tempData = invertedData[6 * j + i];
        }
        model.context.texImage2D(
          model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i,
          j,
          model.internalFormat,
          w,
          h,
          0,
          model.format,
          model.openGLDataType,
          tempData
        );
        j++;
        w /= 2;
        h /= 2;
      }
    }

    // generateMipmap must not be called here because we manually upload all levels
    // if it is called, all levels will be overwritten

    publicAPI.deactivate();
    return true;
  };

  //----------------------------------------------------------------------------
  publicAPI.createDepthFromRaw = (width, height, dataType, data) => {
    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(dataType);
    model.format = model.context.DEPTH_COMPONENT;
    if (model.openGLRenderWindow.getWebgl2()) {
      if (dataType === VtkDataTypes.FLOAT) {
        model.internalFormat = model.context.DEPTH_COMPONENT32F;
      } else {
        model.internalFormat = model.context.DEPTH_COMPONENT16;
      }
    } else {
      model.internalFormat = model.context.DEPTH_COMPONENT;
    }

    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }

    model.target = model.context.TEXTURE_2D;
    model.components = 1;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model.openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();

    // Source texture data from the PBO.
    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);

    model.context.texImage2D(
      model.target,
      0,
      model.internalFormat,
      model.width,
      model.height,
      0,
      model.format,
      model.openGLDataType,
      data
    );

    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }

    publicAPI.deactivate();
    return true;
  };

  //----------------------------------------------------------------------------
  publicAPI.create2DFromImage = (image) => {
    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(VtkDataTypes.UNSIGNED_CHAR);
    publicAPI.getInternalFormat(VtkDataTypes.UNSIGNED_CHAR, 4);
    publicAPI.getFormat(VtkDataTypes.UNSIGNED_CHAR, 4);

    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }

    model.target = model.context.TEXTURE_2D;
    model.components = 4;
    model.width = image.width;
    model.height = image.height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model.openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();

    // Source texture data from the PBO.
    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);

    // Scale up the texture to the next highest power of two dimensions (if needed) and flip y.
    const needNearestPowerOfTwo =
      !vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["isPowerOfTwo"](image.width) || !vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["isPowerOfTwo"](image.height);
    const canvas = document.createElement('canvas');
    canvas.width = needNearestPowerOfTwo
      ? vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["nearestPowerOfTwo"](image.width)
      : image.width;
    canvas.height = needNearestPowerOfTwo
      ? vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["nearestPowerOfTwo"](image.height)
      : image.height;
    const ctx = canvas.getContext('2d');
    ctx.translate(0, canvas.height);
    ctx.scale(1, -1);
    ctx.drawImage(
      image,
      0,
      0,
      image.width,
      image.height,
      0,
      0,
      canvas.width,
      canvas.height
    );
    // In Chrome 69 on Windows and Ubuntu, there is a bug that prevents some
    // canvases from working properly with webGL textures.  By getting any
    // image data from the canvas, this works around the bug.  See
    // https://bugs.chromium.org/p/chromium/issues/detail?id=896307
    if (navigator.userAgent.indexOf('Chrome/69') >= 0) {
      ctx.getImageData(0, 0, 1, 1);
    }
    const safeImage = canvas;

    model.context.texImage2D(
      model.target,
      0,
      model.internalFormat,
      model.format,
      model.openGLDataType,
      safeImage
    );

    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }

    publicAPI.deactivate();
    return true;
  };

  //----------------------------------------------------------------------------
  publicAPI.create3DFromRaw = (
    width,
    height,
    depth,
    numComps,
    dataType,
    data
  ) => {
    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);

    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }

    model.target = model.context.TEXTURE_3D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = depth;
    model.numberOfDimensions = 3;
    model.openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();

    // Source texture data from the PBO.
    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    // model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);

    model.context.texImage3D(
      model.target,
      0,
      model.internalFormat,
      model.width,
      model.height,
      model.depth,
      0,
      model.format,
      model.openGLDataType,
      data
    );

    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }

    publicAPI.deactivate();
    return true;
  };

  function computeScaleOffsets(numComps, numPixelsIn, data) {
    // compute min and max values per component
    const min = [];
    const max = [];
    for (let c = 0; c < numComps; ++c) {
      min[c] = data[c];
      max[c] = data[c];
    }
    let count = 0;
    for (let i = 0; i < numPixelsIn; ++i) {
      for (let c = 0; c < numComps; ++c) {
        if (data[count] < min[c]) {
          min[c] = data[count];
        }
        if (data[count] > max[c]) {
          max[c] = data[count];
        }
        count++;
      }
    }
    const offset = [];
    const scale = [];
    for (let c = 0; c < numComps; ++c) {
      if (min[c] === max[c]) {
        max[c] = min[c] + 1.0;
      }
      offset[c] = min[c];
      scale[c] = max[c] - min[c];
    }
    return { scale, offset };
  }

  //----------------------------------------------------------------------------
  // This method simulates a 3D texture using 2D
  publicAPI.create3DFilterableFromRaw = (
    width,
    height,
    depth,
    numComps,
    dataType,
    data
  ) => {
    const numPixelsIn = width * height * depth;

    // initialize offset/scale
    const offset = [];
    const scale = [];
    for (let c = 0; c < numComps; ++c) {
      offset[c] = 0.0;
      scale[c] = 1.0;
    }

    // store the information, we will need it later
    // offset and scale are the offset and scale required to get
    // the texture value back to data values ala
    // data = texture * scale + offset
    // and texture = (data - offset)/scale
    model.volumeInfo = { scale, offset, width, height, depth };

    // WebGL2 path, we have 3d textures etc
    if (model.openGLRenderWindow.getWebgl2()) {
      if (dataType === VtkDataTypes.FLOAT) {
        return publicAPI.create3DFromRaw(
          width,
          height,
          depth,
          numComps,
          dataType,
          data
        );
      }
      if (dataType === VtkDataTypes.UNSIGNED_CHAR) {
        for (let c = 0; c < numComps; ++c) {
          model.volumeInfo.scale[c] = 255.0;
        }
        return publicAPI.create3DFromRaw(
          width,
          height,
          depth,
          numComps,
          dataType,
          data
        );
      }
      // otherwise convert to float
      const newArray = new Float32Array(numPixelsIn * numComps);
      // compute min and max values
      const res = computeScaleOffsets(numComps, numPixelsIn, data);
      model.volumeInfo.offset = res.offset;
      model.volumeInfo.scale = res.scale;
      let count = 0;
      for (let i = 0; i < numPixelsIn; ++i) {
        for (let nc = 0; nc < numComps; ++nc) {
          newArray[count] =
            (data[count] - model.volumeInfo.offset[nc]) /
            model.volumeInfo.scale[nc];
          count++;
        }
      }
      return publicAPI.create3DFromRaw(
        width,
        height,
        depth,
        numComps,
        VtkDataTypes.FLOAT,
        newArray
      );
    }

    // not webgl2, deal with webgl1, no 3d textures
    // and maybe no float textures

    // compute min and max values
    const res = computeScaleOffsets(numComps, numPixelsIn, data);

    let volCopyData = (outArray, outIdx, inValue, smin, smax) => {
      outArray[outIdx] = inValue;
    };
    let dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;
    // unsigned char gets used as is
    if (dataType === VtkDataTypes.UNSIGNED_CHAR) {
      for (let c = 0; c < numComps; ++c) {
        res.offset[c] = 0.0;
        res.scale[c] = 255.0;
      }
    } else if (
      model.context.getExtension('OES_texture_float') &&
      model.context.getExtension('OES_texture_float_linear')
    ) {
      // use float textures scaled to 0.0 to 1.0
      dataTypeToUse = VtkDataTypes.FLOAT;
      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {
        outArray[outIdx] = (inValue - soffset) / sscale;
      };
    } else {
      // worst case, scale data to uchar
      dataTypeToUse = VtkDataTypes.UNSIGNED_CHAR;
      volCopyData = (outArray, outIdx, inValue, soffset, sscale) => {
        outArray[outIdx] = (255.0 * (inValue - soffset)) / sscale;
      };
    }

    // Now determine the texture parameters using the arguments.
    publicAPI.getOpenGLDataType(dataTypeToUse);
    publicAPI.getInternalFormat(dataTypeToUse, numComps);
    publicAPI.getFormat(dataTypeToUse, numComps);

    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro('Failed to determine texture parameters.');
      return false;
    }

    // have to pack this 3D texture into pot 2D texture
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.depth = 1;
    model.numberOfDimensions = 2;

    // MAX_TEXTURE_SIZE gives the max dimensions that can be supported by the GPU,
    // but it doesn't mean it will fit in memory. If we have to use a float data type
    // or 4 components, there are good chances that the texture size will blow up
    // and could not fit in the GPU memory. Use a smaller texture size in that case,
    // which will force a downsampling of the dataset.
    // That problem does not occur when using webGL2 since we can pack the data in
    // denser textures based on our data type.
    // TODO: try to fit in the biggest supported texture, catch the gl error if it
    // does not fix (OUT_OF_MEMORY), then attempt with smaller texture
    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
    if (
      maxTexDim > 4096 &&
      (dataTypeToUse === VtkDataTypes.FLOAT || numComps >= 3)
    ) {
      maxTexDim = 4096;
    }

    // compute estimate for XY subsample
    let xstride = 1;
    let ystride = 1;
    if (numPixelsIn > maxTexDim * maxTexDim) {
      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));
      ystride = xstride;
    }
    let targetWidth = Math.sqrt(numPixelsIn) / xstride;
    targetWidth = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["nearestPowerOfTwo"](targetWidth);
    // determine X reps
    const xreps = Math.floor((targetWidth * xstride) / width);
    const yreps = Math.ceil(depth / xreps);
    const targetHeight = vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_3__["nearestPowerOfTwo"]((height * yreps) / ystride);

    model.width = targetWidth;
    model.height = targetHeight;
    model.openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();

    // store the information, we will need it later
    model.volumeInfo.xreps = xreps;
    model.volumeInfo.yreps = yreps;
    model.volumeInfo.xstride = xstride;
    model.volumeInfo.ystride = ystride;
    model.volumeInfo.offset = res.offset;
    model.volumeInfo.scale = res.scale;

    // OK stuff the data into the 2d TEXTURE

    // first allocate the new texture
    let newArray;
    const pixCount = targetWidth * targetHeight * numComps;
    if (dataTypeToUse === VtkDataTypes.FLOAT) {
      newArray = new Float32Array(pixCount);
    } else {
      newArray = new Uint8Array(pixCount);
    }

    // then stuff the data into it, nothing fancy right now
    // for stride
    let outIdx = 0;

    const tileWidth = Math.floor(width / xstride);
    const tileHeight = Math.floor(height / ystride);

    for (let yRep = 0; yRep < yreps; yRep++) {
      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);
      const outXContIncr =
        numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));
      for (let tileY = 0; tileY < tileHeight; tileY++) {
        for (let xRep = 0; xRep < xrepsThisRow; xRep++) {
          const inOffset =
            numComps *
            ((yRep * xreps + xRep) * width * height + ystride * tileY * width);

          for (let tileX = 0; tileX < tileWidth; tileX++) {
            // copy value
            for (let nc = 0; nc < numComps; nc++) {
              volCopyData(
                newArray,
                outIdx,
                data[inOffset + xstride * tileX * numComps + nc],
                res.offset[nc],
                res.scale[nc]
              );
              outIdx++;
            }
          }
        }
        outIdx += outXContIncr;
      }
    }

    // Source texture data from the PBO.
    // model.context.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);

    model.context.texImage2D(
      model.target,
      0,
      model.internalFormat,
      model.width,
      model.height,
      0,
      model.format,
      model.openGLDataType,
      newArray
    );

    publicAPI.deactivate();
    return true;
  };

  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model.openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model.openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model.openGLRenderWindow.getContext();
    }
  };

  //----------------------------------------------------------------------------
  publicAPI.getMaximumTextureSize = (ctx) => {
    if (ctx && ctx.isCurrent()) {
      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);
    }

    return -1;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  openGLRenderWindow: null,
  context: null,
  handle: 0,
  sendParametersTime: null,
  textureBuildTime: null,
  numberOfDimensions: 0,
  target: 0,
  format: 0,
  openGLDataType: 0,
  components: 0,
  width: 0,
  height: 0,
  depth: 0,
  autoParameters: true,
  wrapS: Wrap.CLAMP_TO_EDGE,
  wrapT: Wrap.CLAMP_TO_EDGE,
  wrapR: Wrap.CLAMP_TO_EDGE,
  minificationFilter: Filter.NEAREST,
  magnificationFilter: Filter.NEAREST,
  minLOD: -1000.0,
  maxLOD: 1000.0,
  baseLevel: 0,
  maxLevel: 1000,
  generateMipmap: false,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_4__["default"].extend(publicAPI, model, initialValues);

  model.sendParametersTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(model.sendParametersTime, { mtime: 0 });

  model.textureBuildTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(model.textureBuildTime, { mtime: 0 });

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].set(publicAPI, model, ['format', 'openGLDataType']);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGet(publicAPI, model, [
    'keyMatrixTime',
    'minificationFilter',
    'magnificationFilter',
    'wrapS',
    'wrapT',
    'wrapR',
    'generateMipmap',
  ]);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].get(publicAPI, model, [
    'width',
    'height',
    'volumeInfo',
    'components',
    'handle',
    'target',
  ]);

  // Object methods
  vtkOpenGLTexture(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend, 'vtkOpenGLTexture');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, ...vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_0__["default"] });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/TextureUnitManager/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/TextureUnitManager/index.js ***!
  \**********************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");


const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

// ----------------------------------------------------------------------------
// vtkOpenGLTextureUnitManager methods
// ----------------------------------------------------------------------------

function vtkOpenGLTextureUnitManager(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLTextureUnitManager');

  // ----------------------------------------------------------------------------
  // Description:
  // Delete the allocation table and check if it is not called before
  // all the texture units have been released.
  publicAPI.deleteTable = () => {
    for (let i = 0; i < model.numberOfTextureUnits; ++i) {
      if (model.textureUnits[i] === true) {
        vtkErrorMacro('some texture units  were not properly released');
      }
    }
    model.textureUnits = [];
    model.numberOfTextureUnits = 0;
  };

  // ----------------------------------------------------------------------------
  publicAPI.setContext = (ctx) => {
    if (model.context !== ctx) {
      if (model.context !== 0) {
        publicAPI.deleteTable();
      }
      model.context = ctx;
      if (model.context) {
        model.numberOfTextureUnits = ctx.getParameter(
          ctx.MAX_TEXTURE_IMAGE_UNITS
        );
        for (let i = 0; i < model.numberOfTextureUnits; ++i) {
          model.textureUnits[i] = false;
        }
      }
      publicAPI.modified();
    }
  };

  // ----------------------------------------------------------------------------
  // Description:
  // Reserve a texture unit. It returns its number.
  // It returns -1 if the allocation failed (because there are no more
  // texture units left).
  // \post valid_result: result==-1 || result>=0 && result<this->GetNumberOfTextureUnits())
  // \post allocated: result==-1 || this->IsAllocated(result)
  publicAPI.allocate = () => {
    for (let i = 0; i < model.numberOfTextureUnits; i++) {
      if (!publicAPI.isAllocated(i)) {
        model.textureUnits[i] = true;
        return i;
      }
    }
    return -1;
  };

  publicAPI.allocateUnit = (unit) => {
    if (publicAPI.isAllocated(unit)) {
      return -1;
    }

    model.textureUnits[unit] = true;
    return unit;
  };

  // ----------------------------------------------------------------------------
  // Description:
  // Tell if texture unit `textureUnitId' is already allocated.
  // \pre valid_id_range : textureUnitId>=0 && textureUnitId<this->GetNumberOfTextureUnits()
  publicAPI.isAllocated = (textureUnitId) => model.textureUnits[textureUnitId];

  // ----------------------------------------------------------------------------
  // Description:
  // Release a texture unit.
  // \pre valid_id: textureUnitId>=0 && textureUnitId<this->GetNumberOfTextureUnits()
  // \pre allocated_id: this->IsAllocated(textureUnitId)
  publicAPI.free = (val) => {
    model.textureUnits[val] = false;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  numberOfTextureUnits: 0,
  textureUnits: 0,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);

  model.textureUnits = [];

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['numberOfTextureUnits']);

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, ['context']);

  // Object methods
  vtkOpenGLTextureUnitManager(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(
  extend,
  'vtkOpenGLTextureUnitManager'
);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/VertexArrayObject/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/VertexArrayObject/index.js ***!
  \*********************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/BufferObject/Constants.js");



// ----------------------------------------------------------------------------
// vtkOpenGLVertexArrayObject methods
// ----------------------------------------------------------------------------

function vtkOpenGLVertexArrayObject(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLVertexArrayObject');

  // Public API methods
  publicAPI.exposedMethod = () => {
    // This is a publicly exposed method of this object
  };

  publicAPI.initialize = () => {
    model.instancingExtension = null;
    if (!model.openGLRenderWindow.getWebgl2()) {
      model.instancingExtension = model.context.getExtension(
        'ANGLE_instanced_arrays'
      );
    }
    if (
      !model.forceEmulation &&
      model.openGLRenderWindow &&
      model.openGLRenderWindow.getWebgl2()
    ) {
      model.extension = null;
      model.supported = true;
      model.handleVAO = model.context.createVertexArray();
    } else {
      model.extension = model.context.getExtension('OES_vertex_array_object');
      // Start setting up VAO
      if (!model.forceEmulation && model.extension) {
        model.supported = true;
        model.handleVAO = model.extension.createVertexArrayOES();
      } else {
        model.supported = false;
      }
    }
  };

  publicAPI.isReady = () =>
    // We either probed and allocated a VAO, or are falling back as the current
    // hardware does not support VAOs.
    model.handleVAO !== 0 || model.supported === false;

  publicAPI.bind = () => {
    // Either simply bind the VAO, or emulate behavior by binding all attributes.
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(model.handleVAO);
      } else {
        model.context.bindVertexArray(model.handleVAO);
      }
    } else if (publicAPI.isReady()) {
      const gl = model.context;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (let i = 0; i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(
              attrIt.index + i,
              attrIt.size,
              attrIt.type,
              attrIt.normalize,
              attrIt.stride,
              attrIt.offset + (attrIt.stride * i) / attrIt.size
            );
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(
                  attrIt.index + i,
                  1
                );
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 1);
              }
            }
          }
        }
      }
    }
  };

  publicAPI.release = () => {
    // Either simply release the VAO, or emulate behavior by releasing all attributes.
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(null);
      } else {
        model.context.bindVertexArray(null);
      }
    } else if (publicAPI.isReady()) {
      const gl = model.context;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (let i = 0; i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(
              attrIt.index + i,
              attrIt.size,
              attrIt.type,
              attrIt.normalize,
              attrIt.stride,
              attrIt.offset + (attrIt.stride * i) / attrIt.size
            );
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(
                  attrIt.index + i,
                  0
                );
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 0);
              }
            }
            gl.disableVertexAttribArray(attrIt.index + i);
          }
        }
      }
    }
  };

  publicAPI.shaderProgramChanged = () => {
    publicAPI.release();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.handleProgram = 0;
  };

  publicAPI.releaseGraphicsResources = () => {
    publicAPI.shaderProgramChanged();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.supported = true;
    model.handleProgram = 0;
  };

  publicAPI.addAttributeArray = (
    program,
    buffer,
    name,
    offset,
    stride,
    elementType,
    elementTupleSize,
    normalize
  ) =>
    publicAPI.addAttributeArrayWithDivisor(
      program,
      buffer,
      name,
      offset,
      stride,
      elementType,
      elementTupleSize,
      normalize,
      0,
      false
    );

  publicAPI.addAttributeArrayWithDivisor = (
    program,
    buffer,
    name,
    offset,
    stride,
    elementType,
    elementTupleSize,
    normalize,
    divisor,
    isMatrix
  ) => {
    if (!program) {
      return false;
    }

    // Check the program is bound, and the buffer is valid.
    if (
      !program.isBound() ||
      buffer.getHandle() === 0 ||
      buffer.getType() !== vtk_js_Sources_Rendering_OpenGL_BufferObject_Constants__WEBPACK_IMPORTED_MODULE_1__["ObjectType"].ARRAY_BUFFER
    ) {
      return false;
    }

    // Perform initialization if necessary, ensure program matches VAOs.
    if (model.handleProgram === 0) {
      model.handleProgram = program.getHandle();
    }
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {
      return false;
    }

    const gl = model.context;

    const attribs = {};
    attribs.name = name;
    attribs.index = gl.getAttribLocation(model.handleProgram, name);
    attribs.offset = offset;
    attribs.stride = stride;
    attribs.type = elementType;
    attribs.size = elementTupleSize;
    attribs.normalize = normalize;
    attribs.isMatrix = isMatrix;
    attribs.divisor = divisor;

    if (attribs.Index === -1) {
      return false;
    }

    // Always make the call as even the first use wants the attrib pointer setting
    // up when we are emulating.
    buffer.bind();
    gl.enableVertexAttribArray(attribs.index);
    gl.vertexAttribPointer(
      attribs.index,
      attribs.size,
      attribs.type,
      attribs.normalize,
      attribs.stride,
      attribs.offset
    );

    if (divisor > 0) {
      if (model.instancingExtension) {
        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);
      } else {
        gl.vertexAttribDivisor(attribs.index, 1);
      }
    }

    attribs.buffer = buffer.getHandle();

    // If vertex array objects are not supported then build up our list.
    if (!model.supported) {
      // find the buffer
      let buffFound = false;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        if (buff.buffer === attribs.buffer) {
          buffFound = true;
          let found = false;
          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
            const attrIt = buff.attributes[iatt];
            if (attrIt.name === name) {
              found = true;
              buff.attributes[iatt] = attribs;
            }
          }
          if (!found) {
            buff.attributes.push(attribs);
          }
        }
      }
      if (!buffFound) {
        model.buffers.push({ buffer: attribs.buffer, attributes: [attribs] });
      }
    }
    return true;
  };

  publicAPI.addAttributeMatrixWithDivisor = (
    program,
    buffer,
    name,
    offset,
    stride,
    elementType,
    elementTupleSize,
    normalize,
    divisor
  ) => {
    // bind the first row of values
    const result = publicAPI.addAttributeArrayWithDivisor(
      program,
      buffer,
      name,
      offset,
      stride,
      elementType,
      elementTupleSize,
      normalize,
      divisor,
      true
    );

    if (!result) {
      return result;
    }

    const gl = model.context;

    const index = gl.getAttribLocation(model.handleProgram, name);

    for (let i = 1; i < elementTupleSize; i++) {
      gl.enableVertexAttribArray(index + i);
      gl.vertexAttribPointer(
        index + i,
        elementTupleSize,
        elementType,
        normalize,
        stride,
        offset + (stride * i) / elementTupleSize
      );
      if (divisor > 0) {
        if (model.instancingExtension) {
          model.instancingExtension.vertexAttribDivisorANGLE(index + i, 1);
        } else {
          gl.vertexAttribDivisor(index + i, 1);
        }
      }
    }

    return true;
  };

  publicAPI.removeAttributeArray = (name) => {
    if (!publicAPI.isReady() || model.handleProgram === 0) {
      return false;
    }

    // If we don't have real VAOs find the entry and remove it too.
    if (!model.supported) {
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          if (attrIt.name === name) {
            buff.attributes.splice(iatt, 1);
            if (!buff.attributes.length) {
              model.buffers.splice(ibuff, 1);
            }
            return true;
          }
        }
      }
    }

    return true;
  };

  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model.openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model.openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model.openGLRenderWindow.getContext();
    }
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  forceEmulation: false,
  handleVAO: 0,
  handleProgram: 0,
  supported: true,
  buffers: null,
  context: null,
  openGLRenderWindow: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Internal objects initialization
  model.buffers = [];

  // Object methods
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);

  // Create get-only macros
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['supported']);

  // Create get-set macros
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, ['forceEmulation']);

  // For more macro methods, see "Sources/macro.js"

  // Object specific methods
  vtkOpenGLVertexArrayObject(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(
  extend,
  'vtkOpenGLVertexArrayObject'
);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ViewNodeFactory/index.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/ViewNodeFactory/index.js ***!
  \*******************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_GenericWidgetRepresentation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/GenericWidgetRepresentation */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/GenericWidgetRepresentation/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Actor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Actor */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Actor/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Actor2D__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Actor2D */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Actor2D/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Camera__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Camera */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Camera/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Glyph3DMapper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Glyph3DMapper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Glyph3DMapper/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ImageMapper__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ImageMapper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ImageMapper/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ImageSlice__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ImageSlice */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ImageSlice/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_PixelSpaceCallbackMapper__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/PixelSpaceCallbackMapper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/PixelSpaceCallbackMapper/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_PolyDataMapper__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/PolyDataMapper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/PolyDataMapper/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Renderer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Renderer */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Renderer/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Skybox__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Skybox */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Skybox/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_SphereMapper__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/SphereMapper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/SphereMapper/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_StickMapper__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/StickMapper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/StickMapper/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Texture */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Volume__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Volume */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Volume/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_VolumeMapper__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/VolumeMapper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/VolumeMapper/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_ViewNodeFactory__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/ViewNodeFactory */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNodeFactory/index.js");



















// ----------------------------------------------------------------------------
// vtkOpenGLViewNodeFactory methods
// ----------------------------------------------------------------------------

function vtkOpenGLViewNodeFactory(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLViewNodeFactory');
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_SceneGraph_ViewNodeFactory__WEBPACK_IMPORTED_MODULE_17__["default"].extend(publicAPI, model, initialValues);

  // Object methods
  vtkOpenGLViewNodeFactory(publicAPI, model);

  // Initialization
  publicAPI.registerOverride('vtkActor', vtk_js_Sources_Rendering_OpenGL_Actor__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance);
  publicAPI.registerOverride('vtkActor2D', vtk_js_Sources_Rendering_OpenGL_Actor2D__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance);
  publicAPI.registerOverride('vtkCamera', vtk_js_Sources_Rendering_OpenGL_Camera__WEBPACK_IMPORTED_MODULE_4__["default"].newInstance);
  publicAPI.registerOverride(
    'vtkGlyph3DMapper',
    vtk_js_Sources_Rendering_OpenGL_Glyph3DMapper__WEBPACK_IMPORTED_MODULE_5__["default"].newInstance
  );
  publicAPI.registerOverride(
    'vtkImageMapper',
    vtk_js_Sources_Rendering_OpenGL_ImageMapper__WEBPACK_IMPORTED_MODULE_6__["default"].newInstance
  );
  publicAPI.registerOverride('vtkImageSlice', vtk_js_Sources_Rendering_OpenGL_ImageSlice__WEBPACK_IMPORTED_MODULE_7__["default"].newInstance);
  publicAPI.registerOverride('vtkMapper', vtk_js_Sources_Rendering_OpenGL_PolyDataMapper__WEBPACK_IMPORTED_MODULE_9__["default"].newInstance);
  publicAPI.registerOverride(
    'vtkPixelSpaceCallbackMapper',
    vtk_js_Sources_Rendering_OpenGL_PixelSpaceCallbackMapper__WEBPACK_IMPORTED_MODULE_8__["default"].newInstance
  );
  publicAPI.registerOverride('vtkRenderer', vtk_js_Sources_Rendering_OpenGL_Renderer__WEBPACK_IMPORTED_MODULE_10__["default"].newInstance);
  publicAPI.registerOverride('vtkSkybox', vtk_js_Sources_Rendering_OpenGL_Skybox__WEBPACK_IMPORTED_MODULE_11__["default"].newInstance);
  publicAPI.registerOverride(
    'vtkSphereMapper',
    vtk_js_Sources_Rendering_OpenGL_SphereMapper__WEBPACK_IMPORTED_MODULE_12__["default"].newInstance
  );
  publicAPI.registerOverride(
    'vtkStickMapper',
    vtk_js_Sources_Rendering_OpenGL_StickMapper__WEBPACK_IMPORTED_MODULE_13__["default"].newInstance
  );
  publicAPI.registerOverride('vtkTexture', vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_14__["default"].newInstance);
  publicAPI.registerOverride('vtkVolume', vtk_js_Sources_Rendering_OpenGL_Volume__WEBPACK_IMPORTED_MODULE_15__["default"].newInstance);
  publicAPI.registerOverride(
    'vtkVolumeMapper',
    vtk_js_Sources_Rendering_OpenGL_VolumeMapper__WEBPACK_IMPORTED_MODULE_16__["default"].newInstance
  );
  publicAPI.registerOverride(
    'vtkWidgetRepresentation',
    vtk_js_Sources_Rendering_SceneGraph_GenericWidgetRepresentation__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance
  );
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(
  extend,
  'vtkOpenGLViewNodeFactory'
);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Volume/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/Volume/index.js ***!
  \**********************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/ViewNode */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js");





// ----------------------------------------------------------------------------
// vtkOpenGLVolume methods
// ----------------------------------------------------------------------------

function vtkOpenGLVolume(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLVolume');

  // Builds myself.
  publicAPI.buildPass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model.openGLRenderer = publicAPI.getFirstAncestorOfType(
        'vtkOpenGLRenderer'
      );
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };

  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementVolumeCount();
    }
  };

  publicAPI.traverseVolumePass = (renderPass) => {
    if (
      !model.renderable ||
      !model.renderable.getVisibility() ||
      (model.openGLRenderer.getSelector() && !model.renderable.getPickable())
    ) {
      return;
    }

    publicAPI.apply(renderPass, true);

    model.children[0].traverse(renderPass);

    publicAPI.apply(renderPass, false);
  };

  // Renders myself
  publicAPI.volumePass = (prepass) => {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }
    if (prepass) {
      model.context = publicAPI
        .getFirstAncestorOfType('vtkOpenGLRenderWindow')
        .getContext();
      model.context.depthMask(false);
    } else {
      model.context.depthMask(true);
    }
  };

  publicAPI.getKeyMatrices = () => {
    // has the actor changed?
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].copy(model.MCWCMatrix, model.renderable.getMatrix());
      gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].transpose(model.MCWCMatrix, model.MCWCMatrix);

      if (model.renderable.getIsIdentity()) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].identity(model.normalMatrix);
      } else {
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].fromMat4(model.normalMatrix, model.MCWCMatrix);
        gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].invert(model.normalMatrix, model.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }

    return { mcwc: model.MCWCMatrix, normalMatrix: model.normalMatrix };
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // context: null,
  // keyMatrixTime: null,
  // normalMatrix: null,
  // MCWCMatrix: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_2__["default"].extend(publicAPI, model, initialValues);

  model.keyMatrixTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].obj(model.keyMatrixTime, { mtime: 0 });
  model.normalMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat3"].create();
  model.MCWCMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create();

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].setGet(publicAPI, model, ['context']);

  // Object methods
  vtkOpenGLVolume(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_1__["default"].newInstance(extend, 'vtkOpenGLVolume');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/VolumeMapper/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/VolumeMapper/index.js ***!
  \****************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray/Constants */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/Constants.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Helper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Helper */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Helper/index.js");
/* harmony import */ var vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/Math */ "./node_modules/vtk.js/Sources/Common/Core/Math/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Framebuffer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Framebuffer */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Framebuffer/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Texture */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/ShaderProgram */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/ShaderProgram/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_VertexArrayObject__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/VertexArrayObject */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/VertexArrayObject/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/ViewNode */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Property_Constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Property/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/Property/Constants.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/Texture/Constants */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/Texture/Constants.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_VolumeProperty_Constants__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/VolumeProperty/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/VolumeProperty/Constants.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_VolumeMapper_Constants__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/VolumeMapper/Constants */ "./node_modules/vtk.js/Sources/Rendering/Core/VolumeMapper/Constants.js");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkVolumeVS_glsl__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/glsl/vtkVolumeVS.glsl */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkVolumeVS.glsl");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkVolumeVS_glsl__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(vtk_js_Sources_Rendering_OpenGL_glsl_vtkVolumeVS_glsl__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkVolumeFS_glsl__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/glsl/vtkVolumeFS.glsl */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkVolumeFS.glsl");
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_glsl_vtkVolumeFS_glsl__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(vtk_js_Sources_Rendering_OpenGL_glsl_vtkVolumeFS_glsl__WEBPACK_IMPORTED_MODULE_16__);


// import vtkBoundingBox       from 'vtk.js/Sources/Common/DataModel/BoundingBox';

















const { vtkWarningMacro, vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

// ----------------------------------------------------------------------------
// vtkOpenGLVolumeMapper methods
// ----------------------------------------------------------------------------

function vtkOpenGLVolumeMapper(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLVolumeMapper');

  publicAPI.buildPass = () => {
    model.zBufferTexture = null;
  };

  // ohh someone is doing a zbuffer pass, use that for
  // intermixed volume rendering
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => {
    if (prepass) {
      const zbt = renderPass.getZBufferTexture();
      if (zbt !== model.zBufferTexture) {
        model.zBufferTexture = zbt;
      }
    }
  };

  // Renders myself
  publicAPI.volumePass = (prepass, renderPass) => {
    if (prepass) {
      model.openGLRenderWindow = publicAPI.getFirstAncestorOfType(
        'vtkOpenGLRenderWindow'
      );
      model.context = model.openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model.openGLRenderWindow);
      model.jitterTexture.setOpenGLRenderWindow(model.openGLRenderWindow);
      model.framebuffer.setOpenGLRenderWindow(model.openGLRenderWindow);

      // Per Component?
      model.scalarTexture.setOpenGLRenderWindow(model.openGLRenderWindow);
      model.colorTexture.setOpenGLRenderWindow(model.openGLRenderWindow);
      model.opacityTexture.setOpenGLRenderWindow(model.openGLRenderWindow);

      model.openGLVolume = publicAPI.getFirstAncestorOfType('vtkOpenGLVolume');
      const actor = model.openGLVolume.getRenderable();
      model.openGLRenderer = publicAPI.getFirstAncestorOfType(
        'vtkOpenGLRenderer'
      );
      const ren = model.openGLRenderer.getRenderable();
      model.openGLCamera = model.openGLRenderer.getViewNodeFor(
        ren.getActiveCamera()
      );
      publicAPI.renderPiece(ren, actor);
    }
  };

  publicAPI.buildShaders = (shaders, ren, actor) => {
    publicAPI.getShaderTemplate(shaders, ren, actor);
    publicAPI.replaceShaderValues(shaders, ren, actor);
  };

  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtk_js_Sources_Rendering_OpenGL_glsl_vtkVolumeVS_glsl__WEBPACK_IMPORTED_MODULE_15___default.a;
    shaders.Fragment = vtk_js_Sources_Rendering_OpenGL_glsl_vtkVolumeFS_glsl__WEBPACK_IMPORTED_MODULE_16___default.a;
    shaders.Geometry = '';
  };

  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;

    // define some values in the shader
    const iType = actor.getProperty().getInterpolationType();
    if (iType === vtk_js_Sources_Rendering_Core_VolumeProperty_Constants__WEBPACK_IMPORTED_MODULE_13__["InterpolationType"].LINEAR) {
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
        FSSource,
        '//VTK::TrilinearOn',
        '#define vtkTrilinearOn'
      ).result;
    }

    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
        FSSource,
        '//VTK::ImageLabelOutlineOn',
        '#define vtkImageLabelOutlineOn'
      ).result;
    }

    const numComp = model.scalarTexture.getComponents();
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
      FSSource,
      '//VTK::NumComponents',
      `#define vtkNumComponents ${numComp}`
    ).result;

    const iComps = actor.getProperty().getIndependentComponents();
    if (iComps) {
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
        FSSource,
        '//VTK::IndependentComponentsOn',
        '#define vtkIndependentComponentsOn'
      ).result;

      // Define any proportional components
      const proportionalComponents = [];
      for (let nc = 0; nc < numComp; nc++) {
        if (
          actor.getProperty().getOpacityMode(nc) === vtk_js_Sources_Rendering_Core_VolumeProperty_Constants__WEBPACK_IMPORTED_MODULE_13__["OpacityMode"].PROPORTIONAL
        ) {
          proportionalComponents.push(`#define vtkComponent${nc}Proportional`);
        }
      }

      if (proportionalComponents.length > 0) {
        FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
          FSSource,
          '//VTK::vtkProportionalComponents',
          proportionalComponents.join('\n')
        ).result;
      }
    }

    // WebGL only supports loops over constants
    // and does not support while loops so we
    // have to hard code how many steps/samples to take
    // We do a break so most systems will gracefully
    // early terminate, but it is always possible
    // a system will execute every step regardless
    const ext = model.currentInput.getExtent();
    const spc = model.currentInput.getSpacing();
    const vsize = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(
      vsize,
      (ext[1] - ext[0]) * spc[0],
      (ext[3] - ext[2]) * spc[1],
      (ext[5] - ext[4]) * spc[2]
    );

    const maxSamples =
      gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].length(vsize) / model.renderable.getSampleDistance();

    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
      FSSource,
      '//VTK::MaximumSamplesValue',
      `${Math.ceil(maxSamples)}`
    ).result;

    // set light complexity
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
      FSSource,
      '//VTK::LightComplexity',
      `#define vtkLightComplexity ${model.lastLightComplexity}`
    ).result;

    // if using gradient opacity define that
    model.gopacity = actor.getProperty().getUseGradientOpacity(0);
    for (let nc = 1; iComps && !model.gopacity && nc < numComp; ++nc) {
      if (actor.getProperty().getUseGradientOpacity(nc)) {
        model.gopacity = true;
      }
    }
    if (model.gopacity) {
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
        FSSource,
        '//VTK::GradientOpacityOn',
        '#define vtkGradientOpacityOn'
      ).result;
    }

    // if we have a ztexture then declare it and use it
    if (model.zBufferTexture !== null) {
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(FSSource, '//VTK::ZBuffer::Dec', [
        'uniform sampler2D zBufferTexture;',
        'uniform float vpWidth;',
        'uniform float vpHeight;',
      ]).result;
      FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(FSSource, '//VTK::ZBuffer::Impl', [
        'vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpWidth, gl_FragCoord.y/vpHeight));',
        'float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;',
        'zdepth = zdepth * 2.0 - 1.0;',
        'zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;',
        'zdepth = -zdepth/rayDir.z;',
        'dists.y = min(zdepth,dists.y);',
      ]).result;
    }

    // Set the BlendMode approach
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
      FSSource,
      '//VTK::BlendMode',
      `${model.renderable.getBlendMode()}`
    ).result;

    const averageIPScalarRange = model.renderable.getAverageIPScalarRange();

    // TODO: Adding the .0 at the end feels hacky
    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
      FSSource,
      '//VTK::AverageIPScalarRangeMin',
      `${averageIPScalarRange[0]}.0`
    ).result;

    FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
      FSSource,
      '//VTK::AverageIPScalarRangeMax',
      `${averageIPScalarRange[1]}.0`
    ).result;

    shaders.Fragment = FSSource;

    publicAPI.replaceShaderLight(shaders, ren, actor);
  };

  publicAPI.replaceShaderLight = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;

    // check for shadow maps
    const shadowFactor = '';

    switch (model.lastLightComplexity) {
      default:
      case 0: // no lighting, tcolor is fine as is
        break;

      case 1: // headlight
      case 2: // light kit
      case 3: {
        // positional not implemented fallback to directional
        let lightNum = 0;
        ren.getLights().forEach((light) => {
          const status = light.getSwitch();
          if (status > 0) {
            FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
              FSSource,
              '//VTK::Light::Dec',
              [
                // intensity weighted color
                `uniform vec3 lightColor${lightNum};`,
                `uniform vec3 lightDirectionVC${lightNum}; // normalized`,
                `uniform vec3 lightHalfAngleVC${lightNum}; // normalized`,
                '//VTK::Light::Dec',
              ],
              false
            ).result;
            FSSource = vtk_js_Sources_Rendering_OpenGL_ShaderProgram__WEBPACK_IMPORTED_MODULE_8__["default"].substitute(
              FSSource,
              '//VTK::Light::Impl',
              [
                //              `  float df = max(0.0, dot(normal.rgb, -lightDirectionVC${lightNum}));`,
                `  float df = abs(dot(normal.rgb, -lightDirectionVC${lightNum}));`,
                `  diffuse += ((df${shadowFactor}) * lightColor${lightNum});`,
                // '  if (df > 0.0)',
                // '    {',
                //              `    float sf = pow( max(0.0, dot(lightHalfAngleWC${lightNum},normal.rgb)), specularPower);`,
                `    float sf = pow( abs(dot(lightHalfAngleVC${lightNum},normal.rgb)), vSpecularPower);`,
                `    specular += ((sf${shadowFactor}) * lightColor${lightNum});`,
                //              '    }',
                '  //VTK::Light::Impl',
              ],
              false
            ).result;
            lightNum++;
          }
        });
      }
    }

    shaders.Fragment = FSSource;
  };

  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    // do we need lighting?
    let lightComplexity = 0;
    if (
      actor.getProperty().getShade() &&
      model.renderable.getBlendMode() === vtk_js_Sources_Rendering_Core_VolumeMapper_Constants__WEBPACK_IMPORTED_MODULE_14__["BlendMode"].COMPOSITE_BLEND
    ) {
      // consider the lighting complexity to determine which case applies
      // simple headlight, Light Kit, the whole feature set of VTK
      lightComplexity = 0;
      model.numberOfLights = 0;

      ren.getLights().forEach((light) => {
        const status = light.getSwitch();
        if (status > 0) {
          model.numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }

        if (
          lightComplexity === 1 &&
          (model.numberOfLights > 1 ||
            light.getIntensity() !== 1.0 ||
            !light.lightTypeIsHeadLight())
        ) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      });
    }

    let needRebuild = false;
    if (model.lastLightComplexity !== lightComplexity) {
      model.lastLightComplexity = lightComplexity;
      needRebuild = true;
    }

    // has something changed that would require us to recreate the shader?
    if (
      cellBO.getProgram() === 0 ||
      needRebuild ||
      model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest ||
      !!model.lastZBufferTexture !== !!model.zBufferTexture ||
      cellBO.getShaderSourceTime().getMTime() < publicAPI.getMTime() ||
      cellBO.getShaderSourceTime().getMTime() < actor.getMTime() ||
      cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() ||
      cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()
    ) {
      model.lastZBufferTexture = model.zBufferTexture;
      return true;
    }

    return false;
  };

  publicAPI.updateShaders = (cellBO, ren, actor) => {
    model.lastBoundBO = cellBO;

    // has something changed that would require us to recreate the shader?
    if (publicAPI.getNeedToRebuildShaders(cellBO, ren, actor)) {
      const shaders = { Vertex: null, Fragment: null, Geometry: null };

      publicAPI.buildShaders(shaders, ren, actor);

      // compile and bind the program if needed
      const newShader = model.openGLRenderWindow
        .getShaderCache()
        .readyShaderProgramArray(
          shaders.Vertex,
          shaders.Fragment,
          shaders.Geometry
        );

      // if the shader changed reinitialize the VAO
      if (newShader !== cellBO.getProgram()) {
        cellBO.setProgram(newShader);
        // reset the VAO as the shader has changed
        cellBO.getVAO().releaseGraphicsResources();
      }

      cellBO.getShaderSourceTime().modified();
    } else {
      model.openGLRenderWindow
        .getShaderCache()
        .readyShaderProgram(cellBO.getProgram());
    }

    cellBO.getVAO().bind();
    publicAPI.setMapperShaderParameters(cellBO, ren, actor);
    publicAPI.setCameraShaderParameters(cellBO, ren, actor);
    publicAPI.setPropertyShaderParameters(cellBO, ren, actor);
  };

  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    // Now to update the VAO too, if necessary.
    const program = cellBO.getProgram();

    if (
      cellBO.getCABO().getElementCount() &&
      (model.VBOBuildTime.getMTime() >
        cellBO.getAttributeUpdateTime().getMTime() ||
        cellBO.getShaderSourceTime().getMTime() >
          cellBO.getAttributeUpdateTime().getMTime())
    ) {
      if (program.isAttributeUsed('vertexDC')) {
        if (
          !cellBO
            .getVAO()
            .addAttributeArray(
              program,
              cellBO.getCABO(),
              'vertexDC',
              cellBO.getCABO().getVertexOffset(),
              cellBO.getCABO().getStride(),
              model.context.FLOAT,
              3,
              model.context.FALSE
            )
        ) {
          vtkErrorMacro('Error setting vertexDC in shader VAO.');
        }
      }
      cellBO.getAttributeUpdateTime().modified();
    }

    program.setUniformi('texture1', model.scalarTexture.getTextureUnit());
    program.setUniformf('sampleDistance', model.renderable.getSampleDistance());

    // if we have a zbuffer texture then set it
    if (model.zBufferTexture !== null) {
      program.setUniformi(
        'zBufferTexture',
        model.zBufferTexture.getTextureUnit()
      );
      const size = publicAPI.getRenderTargetSize();
      program.setUniformf('vpWidth', size[0]);
      program.setUniformf('vpHeight', size[1]);
    }
  };

  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    // // [WMVP]C == {world, model, view, projection} coordinates
    // // E.g., WCPC == world to projection coordinate transformation
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const actMats = model.openGLVolume.getKeyMatrices();

    gl_matrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].multiply(model.modelToView, keyMats.wcvc, actMats.mcwc);

    const program = cellBO.getProgram();

    const cam = model.openGLCamera.getRenderable();
    const crange = cam.getClippingRange();
    program.setUniformf('camThick', crange[1] - crange[0]);
    program.setUniformf('camNear', crange[0]);
    program.setUniformf('camFar', crange[1]);

    const bounds = model.currentInput.getBounds();
    const dims = model.currentInput.getDimensions();

    // compute the viewport bounds of the volume
    // we will only render those fragments.
    const pos = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
    const dir = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
    let dcxmin = 1.0;
    let dcxmax = -1.0;
    let dcymin = 1.0;
    let dcymax = -1.0;

    for (let i = 0; i < 8; ++i) {
      gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(
        pos,
        bounds[i % 2],
        bounds[2 + (Math.floor(i / 2) % 2)],
        bounds[4 + Math.floor(i / 4)]
      );
      gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].transformMat4(pos, pos, model.modelToView);
      if (!cam.getParallelProjection()) {
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].normalize(dir, pos);

        // now find the projection of this point onto a
        // nearZ distance plane. Since the camera is at 0,0,0
        // in VC the ray is just t*pos and
        // t is -nearZ/dir.z
        // intersection becomes pos.x/pos.z
        const t = -crange[0] / pos[2];
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].scale(pos, dir, t);
      }
      // now convert to DC
      gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].transformMat4(pos, pos, keyMats.vcpc);

      dcxmin = Math.min(pos[0], dcxmin);
      dcxmax = Math.max(pos[0], dcxmax);
      dcymin = Math.min(pos[1], dcymin);
      dcymax = Math.max(pos[1], dcymax);
    }

    program.setUniformf('dcxmin', dcxmin);
    program.setUniformf('dcxmax', dcxmax);
    program.setUniformf('dcymin', dcymin);
    program.setUniformf('dcymax', dcymax);

    if (program.isUniformUsed('cameraParallel')) {
      program.setUniformi('cameraParallel', cam.getParallelProjection());
    }

    const ext = model.currentInput.getExtent();
    const spc = model.currentInput.getSpacing();
    const vsize = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(
      vsize,
      (ext[1] - ext[0] + 1) * spc[0],
      (ext[3] - ext[2] + 1) * spc[1],
      (ext[5] - ext[4] + 1) * spc[2]
    );
    program.setUniform3f('vSpacing', spc[0], spc[1], spc[2]);

    gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(pos, ext[0], ext[2], ext[4]);
    model.currentInput.indexToWorldVec3(pos, pos);

    gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].transformMat4(pos, pos, model.modelToView);
    program.setUniform3f('vOriginVC', pos[0], pos[1], pos[2]);

    // apply the image directions
    const i2wmat4 = model.currentInput.getIndexToWorld();
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].multiply(model.idxToView, model.modelToView, i2wmat4);

    gl_matrix__WEBPACK_IMPORTED_MODULE_1__["mat3"].multiply(
      model.idxNormalMatrix,
      keyMats.normalMatrix,
      actMats.normalMatrix
    );
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__["mat3"].multiply(
      model.idxNormalMatrix,
      model.idxNormalMatrix,
      model.currentInput.getDirection()
    );

    const maxSamples =
      gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].length(vsize) / model.renderable.getSampleDistance();
    if (maxSamples > model.renderable.getMaximumSamplesPerRay()) {
      vtkWarningMacro(`The number of steps required ${Math.ceil(
        maxSamples
      )} is larger than the
        specified maximum number of steps ${model.renderable.getMaximumSamplesPerRay()}.
        Please either change the
        volumeMapper sampleDistance or its maximum number of samples.`);
    }

    const vctoijk = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();

    gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(vctoijk, 1.0, 1.0, 1.0);
    gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].divide(vctoijk, vctoijk, vsize);
    program.setUniform3f('vVCToIJK', vctoijk[0], vctoijk[1], vctoijk[2]);
    program.setUniform3i('volumeDimensions', dims[0], dims[1], dims[2]);

    if (!model.openGLRenderWindow.getWebgl2()) {
      const volInfo = model.scalarTexture.getVolumeInfo();
      program.setUniformf('texWidth', model.scalarTexture.getWidth());
      program.setUniformf('texHeight', model.scalarTexture.getHeight());
      program.setUniformi('xreps', volInfo.xreps);
      program.setUniformi('xstride', volInfo.xstride);
      program.setUniformi('ystride', volInfo.ystride);
    }

    // map normals through normal matrix
    // then use a point on the plane to compute the distance
    const normal = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
    const pos2 = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].create();
    for (let i = 0; i < 6; ++i) {
      switch (i) {
        default:
        case 0:
          gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(normal, 1.0, 0.0, 0.0);
          gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 1:
          gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(normal, -1.0, 0.0, 0.0);
          gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 2:
          gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(normal, 0.0, 1.0, 0.0);
          gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 3:
          gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(normal, 0.0, -1.0, 0.0);
          gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(pos2, ext[0], ext[2], ext[4]);
          break;
        case 4:
          gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(normal, 0.0, 0.0, 1.0);
          gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(pos2, ext[1], ext[3], ext[5]);
          break;
        case 5:
          gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(normal, 0.0, 0.0, -1.0);
          gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(pos2, ext[0], ext[2], ext[4]);
          break;
      }
      gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].transformMat3(normal, normal, model.idxNormalMatrix);
      gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].transformMat4(pos2, pos2, model.idxToView);
      const dist = -1.0 * gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].dot(pos2, normal);

      // we have the plane in view coordinates
      // specify the planes in view coordinates
      program.setUniform3f(`vPlaneNormal${i}`, normal[0], normal[1], normal[2]);
      program.setUniformf(`vPlaneDistance${i}`, dist);

      if (actor.getProperty().getUseLabelOutline()) {
        const image = model.currentInput;
        const worldToIndex = image.getWorldToIndex();

        program.setUniformMatrix('vWCtoIDX', worldToIndex);

        // Get the projection coordinate to world coordinate transformation matrix.
        gl_matrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].invert(model.projectionToWorld, keyMats.wcpc);
        program.setUniformMatrix('PCWCMatrix', model.projectionToWorld);

        const size = publicAPI.getRenderTargetSize();

        program.setUniformf('vpWidth', size[0]);
        program.setUniformf('vpHeight', size[1]);
      }
    }

    gl_matrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].invert(model.projectionToView, keyMats.vcpc);
    program.setUniformMatrix('PCVCMatrix', model.projectionToView);

    // handle lighting values
    switch (model.lastLightComplexity) {
      default:
      case 0: // no lighting, tcolor is fine as is
        break;

      case 1: // headlight
      case 2: // light kit
      case 3: {
        // positional not implemented fallback to directional
        // mat3.transpose(keyMats.normalMatrix, keyMats.normalMatrix);
        let lightNum = 0;
        const lightColor = [];
        ren.getLights().forEach((light) => {
          const status = light.getSwitch();
          if (status > 0) {
            const dColor = light.getColor();
            const intensity = light.getIntensity();
            lightColor[0] = dColor[0] * intensity;
            lightColor[1] = dColor[1] * intensity;
            lightColor[2] = dColor[2] * intensity;
            program.setUniform3fArray(`lightColor${lightNum}`, lightColor);
            const ldir = light.getDirection();
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].set(normal, ldir[0], ldir[1], ldir[2]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_1__["vec3"].transformMat3(normal, normal, keyMats.normalMatrix);
            program.setUniform3f(
              `lightDirectionVC${lightNum}`,
              normal[0],
              normal[1],
              normal[2]
            );
            // camera DOP is 0,0,-1.0 in VC
            const halfAngle = [
              -0.5 * normal[0],
              -0.5 * normal[1],
              -0.5 * (normal[2] - 1.0),
            ];
            program.setUniform3fArray(`lightHalfAngleVC${lightNum}`, halfAngle);
            lightNum++;
          }
        });
        // mat3.transpose(keyMats.normalMatrix, keyMats.normalMatrix);
      }
    }
  };

  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();

    program.setUniformi('ctexture', model.colorTexture.getTextureUnit());
    program.setUniformi('otexture', model.opacityTexture.getTextureUnit());
    program.setUniformi('jtexture', model.jitterTexture.getTextureUnit());

    const volInfo = model.scalarTexture.getVolumeInfo();
    const vprop = actor.getProperty();

    // set the component mix when independent
    const numComp = model.scalarTexture.getComponents();
    const iComps = actor.getProperty().getIndependentComponents();
    if (iComps && numComp >= 2) {
      for (let i = 0; i < numComp; i++) {
        program.setUniformf(
          `mix${i}`,
          actor.getProperty().getComponentWeight(i)
        );
      }
    }

    // three levels of shift scale combined into one
    // for performance in the fragment shader
    for (let i = 0; i < numComp; i++) {
      const target = iComps ? i : 0;
      const sscale = volInfo.scale[i];
      const ofun = vprop.getScalarOpacity(target);
      const oRange = ofun.getRange();
      const oscale = sscale / (oRange[1] - oRange[0]);
      const oshift = (volInfo.offset[i] - oRange[0]) / (oRange[1] - oRange[0]);
      program.setUniformf(`oshift${i}`, oshift);
      program.setUniformf(`oscale${i}`, oscale);

      const cfun = vprop.getRGBTransferFunction(target);
      const cRange = cfun.getRange();
      program.setUniformf(
        `cshift${i}`,
        (volInfo.offset[i] - cRange[0]) / (cRange[1] - cRange[0])
      );
      program.setUniformf(`cscale${i}`, sscale / (cRange[1] - cRange[0]));
    }

    if (model.gopacity) {
      if (iComps) {
        for (let nc = 0; nc < numComp; ++nc) {
          const sscale = volInfo.scale[nc];
          const useGO = vprop.getUseGradientOpacity(nc);
          if (useGO) {
            const gomin = vprop.getGradientOpacityMinimumOpacity(nc);
            const gomax = vprop.getGradientOpacityMaximumOpacity(nc);
            program.setUniformf(`gomin${nc}`, gomin);
            program.setUniformf(`gomax${nc}`, gomax);
            const goRange = [
              vprop.getGradientOpacityMinimumValue(nc),
              vprop.getGradientOpacityMaximumValue(nc),
            ];
            program.setUniformf(
              `goscale${nc}`,
              (sscale * (gomax - gomin)) / (goRange[1] - goRange[0])
            );
            program.setUniformf(
              `goshift${nc}`,
              (-goRange[0] * (gomax - gomin)) / (goRange[1] - goRange[0]) +
                gomin
            );
          } else {
            program.setUniformf(`gomin${nc}`, 1.0);
            program.setUniformf(`gomax${nc}`, 1.0);
            program.setUniformf(`goscale${nc}`, 0.0);
            program.setUniformf(`goshift${nc}`, 1.0);
          }
        }
      } else {
        const sscale = volInfo.scale[numComp - 1];
        const gomin = vprop.getGradientOpacityMinimumOpacity(0);
        const gomax = vprop.getGradientOpacityMaximumOpacity(0);
        program.setUniformf('gomin0', gomin);
        program.setUniformf('gomax0', gomax);
        const goRange = [
          vprop.getGradientOpacityMinimumValue(0),
          vprop.getGradientOpacityMaximumValue(0),
        ];
        program.setUniformf(
          'goscale0',
          (sscale * (gomax - gomin)) / (goRange[1] - goRange[0])
        );
        program.setUniformf(
          'goshift0',
          (-goRange[0] * (gomax - gomin)) / (goRange[1] - goRange[0]) + gomin
        );
      }
    }

    const vtkImageLabelOutline = actor.getProperty().getUseLabelOutline();
    if (vtkImageLabelOutline === true) {
      const labelOutlineThickness = actor
        .getProperty()
        .getLabelOutlineThickness();

      program.setUniformi('outlineThickness', labelOutlineThickness);
    }

    if (model.lastLightComplexity > 0) {
      program.setUniformf('vAmbient', vprop.getAmbient());
      program.setUniformf('vDiffuse', vprop.getDiffuse());
      program.setUniformf('vSpecular', vprop.getSpecular());
      program.setUniformf('vSpecularPower', vprop.getSpecularPower());
    }
  };

  publicAPI.getRenderTargetSize = () => {
    if (model.lastXYF > 1.43) {
      const sz = model.framebuffer.getSize();
      return [model.fvp[0] * sz[0], model.fvp[1] * sz[1]];
    }
    return model.openGLRenderWindow.getFramebufferSize();
  };

  publicAPI.renderPieceStart = (ren, actor) => {
    if (model.renderable.getAutoAdjustSampleDistances()) {
      const rwi = ren.getVTKWindow().getInteractor();
      const rft = rwi.getLastFrameTime();
      // console.log(`last frame time ${Math.floor(1.0 / rft)}`);

      // frame time is typically for a couple frames prior
      // which makes it messy, so keep long running averages
      // of frame times and pixels rendered
      model.avgFrameTime = 0.97 * model.avgFrameTime + 0.03 * rft;
      model.avgWindowArea =
        0.97 * model.avgWindowArea + 0.03 / (model.lastXYF * model.lastXYF);

      if (ren.getVTKWindow().getInteractor().isAnimating()) {
        // compute target xy factor
        let txyf = Math.sqrt(
          (model.avgFrameTime * rwi.getDesiredUpdateRate()) /
            model.avgWindowArea
        );

        // limit subsampling to a factor of 10
        if (txyf > 10.0) {
          txyf = 10.0;
        }

        model.targetXYF = txyf;
      } else {
        model.targetXYF = Math.sqrt(
          (model.avgFrameTime * rwi.getStillUpdateRate()) / model.avgWindowArea
        );
      }

      // have some inertia to change states around 1.43
      if (model.targetXYF < 1.53 && model.targetXYF > 1.33) {
        model.targetXYF = model.lastXYF;
      }

      // and add some inertia to change at all
      if (Math.abs(1.0 - model.targetXYF / model.lastXYF) < 0.1) {
        model.targetXYF = model.lastXYF;
      }
      model.lastXYF = model.targetXYF;
    } else {
      model.lastXYF = model.renderable.getImageSampleDistance();
    }

    // only use FBO beyond this value
    if (model.lastXYF <= 1.43) {
      model.lastXYF = 1.0;
    }

    // console.log(`last target  ${model.lastXYF} ${model.targetXYF}`);
    // console.log(`awin aft  ${model.avgWindowArea} ${model.avgFrameTime}`);
    const xyf = model.lastXYF;

    const size = model.openGLRenderWindow.getFramebufferSize();
    // const newSize = [
    //   Math.floor((size[0] / xyf) + 0.5),
    //   Math.floor((size[1] / xyf) + 0.5)];

    // const diag = vtkBoundingBox.getDiagonalLength(model.currentInput.getBounds());

    // // so what is the resulting sample size roughly
    // console.log(`sam size ${diag / newSize[0]} ${diag / newSize[1]} ${model.renderable.getImageSampleDistance()}`);

    // // if the sample distance is getting far from the image sample dist
    // if (2.0 * diag / (newSize[0] + newSize[1]) > 4 * model.renderable.getSampleDistance()) {
    //   model.renderable.setSampleDistance(4.0 * model.renderable.getSampleDistance());
    // }
    // if (2.0 * diag / (newSize[0] + newSize[1]) < 0.25 * model.renderable.getSampleDistance()) {
    //   model.renderable.setSampleDistance(0.25 * model.renderable.getSampleDistance());
    // }

    // create/resize framebuffer if needed
    if (xyf > 1.43) {
      model.framebuffer.saveCurrentBindingsAndBuffers();

      if (model.framebuffer.getGLFramebuffer() === null) {
        model.framebuffer.create(
          Math.floor(size[0] * 0.7),
          Math.floor(size[1] * 0.7)
        );
        model.framebuffer.populateFramebuffer();
      } else {
        const fbSize = model.framebuffer.getSize();
        if (
          fbSize[0] !== Math.floor(size[0] * 0.7) ||
          fbSize[1] !== Math.floor(size[1] * 0.7)
        ) {
          model.framebuffer.create(
            Math.floor(size[0] * 0.7),
            Math.floor(size[1] * 0.7)
          );
          model.framebuffer.populateFramebuffer();
        }
      }
      model.framebuffer.bind();
      const gl = model.context;
      gl.clearColor(0.0, 0.0, 0.0, 0.0);
      gl.colorMask(true, true, true, true);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.viewport(0, 0, size[0] / xyf, size[1] / xyf);
      model.fvp = [
        Math.floor(size[0] / xyf) / Math.floor(size[0] * 0.7),
        Math.floor(size[1] / xyf) / Math.floor(size[1] * 0.7),
      ];
    }
    model.context.disable(model.context.DEPTH_TEST);

    // make sure the BOs are up to date
    publicAPI.updateBufferObjects(ren, actor);

    // set interpolation on the texture based on property setting
    const iType = actor.getProperty().getInterpolationType();
    if (iType === vtk_js_Sources_Rendering_Core_VolumeProperty_Constants__WEBPACK_IMPORTED_MODULE_13__["InterpolationType"].NEAREST) {
      model.scalarTexture.setMinificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_12__["Filter"].NEAREST);
      model.scalarTexture.setMagnificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_12__["Filter"].NEAREST);
    } else {
      model.scalarTexture.setMinificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_12__["Filter"].LINEAR);
      model.scalarTexture.setMagnificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_12__["Filter"].LINEAR);
    }

    // Bind the OpenGL, this is shared between the different primitive/cell types.
    model.lastBoundBO = null;

    // if we have a zbuffer texture then activate it
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.activate();
    }
  };

  publicAPI.renderPieceDraw = (ren, actor) => {
    const gl = model.context;

    // render the texture
    model.scalarTexture.activate();
    model.opacityTexture.activate();
    model.colorTexture.activate();
    model.jitterTexture.activate();

    publicAPI.updateShaders(model.tris, ren, actor);

    // First we do the triangles, update the shader, set uniforms, etc.
    // for (let i = 0; i < 11; ++i) {
    //   gl.drawArrays(gl.TRIANGLES, 66 * i, 66);
    // }
    gl.drawArrays(gl.TRIANGLES, 0, model.tris.getCABO().getElementCount());
    model.tris.getVAO().release();

    model.scalarTexture.deactivate();
    model.colorTexture.deactivate();
    model.opacityTexture.deactivate();
    model.jitterTexture.deactivate();
  };

  publicAPI.renderPieceFinish = (ren, actor) => {
    // if we have a zbuffer texture then deactivate it
    if (model.zBufferTexture !== null) {
      model.zBufferTexture.deactivate();
    }

    if (model.lastXYF > 1.43) {
      // now copy the framebuffer with the volume into the
      // regular buffer
      model.framebuffer.restorePreviousBindingsAndBuffers();

      if (model.copyShader === null) {
        model.copyShader = model.openGLRenderWindow
          .getShaderCache()
          .readyShaderProgramArray(
            [
              '//VTK::System::Dec',
              'attribute vec4 vertexDC;',
              'uniform vec2 tfactor;',
              'varying vec2 tcoord;',
              'void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }',
            ].join('\n'),
            [
              '//VTK::System::Dec',
              '//VTK::Output::Dec',
              'uniform sampler2D texture1;',
              'varying vec2 tcoord;',
              'void main() { gl_FragData[0] = texture2D(texture1,tcoord); }',
            ].join('\n'),
            ''
          );
        const program = model.copyShader;

        model.copyVAO = vtk_js_Sources_Rendering_OpenGL_VertexArrayObject__WEBPACK_IMPORTED_MODULE_9__["default"].newInstance();
        model.copyVAO.setOpenGLRenderWindow(model.openGLRenderWindow);

        model.tris.getCABO().bind();
        if (
          !model.copyVAO.addAttributeArray(
            program,
            model.tris.getCABO(),
            'vertexDC',
            model.tris.getCABO().getVertexOffset(),
            model.tris.getCABO().getStride(),
            model.context.FLOAT,
            3,
            model.context.FALSE
          )
        ) {
          vtkErrorMacro('Error setting vertexDC in copy shader VAO.');
        }
      } else {
        model.openGLRenderWindow
          .getShaderCache()
          .readyShaderProgram(model.copyShader);
      }

      const size = model.openGLRenderWindow.getFramebufferSize();
      model.context.viewport(0, 0, size[0], size[1]);

      // activate texture
      const tex = model.framebuffer.getColorTexture();
      tex.activate();
      model.copyShader.setUniformi('texture', tex.getTextureUnit());

      model.copyShader.setUniform2f('tfactor', model.fvp[0], model.fvp[1]);

      const gl = model.context;
      gl.blendFuncSeparate(
        gl.ONE,
        gl.ONE_MINUS_SRC_ALPHA,
        gl.ONE,
        gl.ONE_MINUS_SRC_ALPHA
      );

      // render quad
      model.context.drawArrays(
        model.context.TRIANGLES,
        0,
        model.tris.getCABO().getElementCount()
      );
      tex.deactivate();

      gl.blendFuncSeparate(
        gl.SRC_ALPHA,
        gl.ONE_MINUS_SRC_ALPHA,
        gl.ONE,
        gl.ONE_MINUS_SRC_ALPHA
      );
    }
  };

  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent({ type: 'StartEvent' });
    model.renderable.update();
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent({ type: 'EndEvent' });

    if (!model.currentInput) {
      vtkErrorMacro('No input!');
      return;
    }

    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };

  publicAPI.computeBounds = (ren, actor) => {
    if (!publicAPI.getInput()) {
      vtk_js_Sources_Common_Core_Math__WEBPACK_IMPORTED_MODULE_5__["uninitializeBounds"](model.Bounds);
      return;
    }
    model.bounds = publicAPI.getInput().getBounds();
  };

  publicAPI.updateBufferObjects = (ren, actor) => {
    // Rebuild buffers if needed
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };

  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    // first do a coarse check
    if (
      model.VBOBuildTime.getMTime() < publicAPI.getMTime() ||
      model.VBOBuildTime.getMTime() < actor.getMTime() ||
      model.VBOBuildTime.getMTime() < model.renderable.getMTime() ||
      model.VBOBuildTime.getMTime() < actor.getProperty().getMTime() ||
      model.VBOBuildTime.getMTime() < model.currentInput.getMTime()
    ) {
      return true;
    }
    return false;
  };

  publicAPI.buildBufferObjects = (ren, actor) => {
    const image = model.currentInput;

    if (image === null) {
      return;
    }

    const vprop = actor.getProperty();

    if (!model.jitterTexture.getHandle()) {
      const oTable = new Uint8Array(32 * 32);
      for (let i = 0; i < 32 * 32; ++i) {
        oTable[i] = 255.0 * Math.random();
      }
      model.jitterTexture.setMinificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_12__["Filter"].LINEAR);
      model.jitterTexture.setMagnificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_12__["Filter"].LINEAR);
      model.jitterTexture.create2DFromRaw(
        32,
        32,
        1,
        vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_3__["VtkDataTypes"].UNSIGNED_CHAR,
        oTable
      );
    }

    const numComp = image.getPointData().getScalars().getNumberOfComponents();
    const iComps = vprop.getIndependentComponents();
    const numIComps = iComps ? numComp : 1;

    // rebuild opacity tfun?
    let toString = `${vprop.getMTime()}`;
    if (model.opacityTextureString !== toString) {
      const oWidth = 1024;
      const oSize = oWidth * 2 * numIComps;
      const ofTable = new Float32Array(oSize);
      const tmpTable = new Float32Array(oWidth);

      for (let c = 0; c < numIComps; ++c) {
        const ofun = vprop.getScalarOpacity(c);
        const opacityFactor =
          model.renderable.getSampleDistance() /
          vprop.getScalarOpacityUnitDistance(c);

        const oRange = ofun.getRange();
        ofun.getTable(oRange[0], oRange[1], oWidth, tmpTable, 1);
        // adjust for sample distance etc
        for (let i = 0; i < oWidth; ++i) {
          ofTable[c * oWidth * 2 + i] =
            1.0 - (1.0 - tmpTable[i]) ** opacityFactor;
          ofTable[c * oWidth * 2 + i + oWidth] = ofTable[c * oWidth * 2 + i];
        }
      }

      model.opacityTexture.releaseGraphicsResources(model.openGLRenderWindow);
      model.opacityTexture.setMinificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_12__["Filter"].LINEAR);
      model.opacityTexture.setMagnificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_12__["Filter"].LINEAR);

      // use float texture where possible because we really need the resolution
      // for this table. Errors in low values of opacity accumulate to
      // visible artifacts. High values of opacity quickly terminate without
      // artifacts.
      if (
        model.openGLRenderWindow.getWebgl2() ||
        (model.context.getExtension('OES_texture_float') &&
          model.context.getExtension('OES_texture_float_linear'))
      ) {
        model.opacityTexture.create2DFromRaw(
          oWidth,
          2 * numIComps,
          1,
          vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_3__["VtkDataTypes"].FLOAT,
          ofTable
        );
      } else {
        const oTable = new Uint8Array(oSize);
        for (let i = 0; i < oSize; ++i) {
          oTable[i] = 255.0 * ofTable[i];
        }
        model.opacityTexture.create2DFromRaw(
          oWidth,
          2 * numIComps,
          1,
          vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_3__["VtkDataTypes"].UNSIGNED_CHAR,
          oTable
        );
      }
      model.opacityTextureString = toString;
    }

    // rebuild color tfun?
    toString = `${vprop.getMTime()}`;
    if (model.colorTextureString !== toString) {
      const cWidth = 1024;
      const cSize = cWidth * 2 * numIComps * 3;
      const cTable = new Uint8Array(cSize);
      const tmpTable = new Float32Array(cWidth * 3);

      for (let c = 0; c < numIComps; ++c) {
        const cfun = vprop.getRGBTransferFunction(c);
        const cRange = cfun.getRange();
        cfun.getTable(cRange[0], cRange[1], cWidth, tmpTable, 1);
        for (let i = 0; i < cWidth * 3; ++i) {
          cTable[c * cWidth * 6 + i] = 255.0 * tmpTable[i];
          cTable[c * cWidth * 6 + i + cWidth * 3] = 255.0 * tmpTable[i];
        }
      }

      model.colorTexture.releaseGraphicsResources(model.openGLRenderWindow);
      model.colorTexture.setMinificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_12__["Filter"].LINEAR);
      model.colorTexture.setMagnificationFilter(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_12__["Filter"].LINEAR);

      model.colorTexture.create2DFromRaw(
        cWidth,
        2 * numIComps,
        3,
        vtk_js_Sources_Common_Core_DataArray_Constants__WEBPACK_IMPORTED_MODULE_3__["VtkDataTypes"].UNSIGNED_CHAR,
        cTable
      );
      model.colorTextureString = toString;
    }

    // rebuild the scalarTexture if the data has changed
    toString = `${image.getMTime()}`;
    if (model.scalarTextureString !== toString) {
      // Build the textures
      const dims = image.getDimensions();
      model.scalarTexture.releaseGraphicsResources(model.openGLRenderWindow);
      model.scalarTexture.resetFormatAndType();
      model.scalarTexture.create3DFilterableFromRaw(
        dims[0],
        dims[1],
        dims[2],
        numComp,
        image.getPointData().getScalars().getDataType(),
        image.getPointData().getScalars().getData()
      );
      // console.log(model.scalarTexture.get());
      model.scalarTextureString = toString;
    }

    if (!model.tris.getCABO().getElementCount()) {
      // build the CABO
      const ptsArray = new Float32Array(12);
      for (let i = 0; i < 4; i++) {
        ptsArray[i * 3] = (i % 2) * 2 - 1.0;
        ptsArray[i * 3 + 1] = i > 1 ? 1.0 : -1.0;
        ptsArray[i * 3 + 2] = -1.0;
      }

      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;

      // const dim = 12.0;
      // const ptsArray = new Float32Array(3 * dim * dim);
      // for (let i = 0; i < dim; i++) {
      //   for (let j = 0; j < dim; j++) {
      //     const offset = ((i * dim) + j) * 3;
      //     ptsArray[offset] = (2.0 * (i / (dim - 1.0))) - 1.0;
      //     ptsArray[offset + 1] = (2.0 * (j / (dim - 1.0))) - 1.0;
      //     ptsArray[offset + 2] = -1.0;
      //   }
      // }

      // const cellArray = new Uint16Array(8 * (dim - 1) * (dim - 1));
      // for (let i = 0; i < dim - 1; i++) {
      //   for (let j = 0; j < dim - 1; j++) {
      //     const offset = 8 * ((i * (dim - 1)) + j);
      //     cellArray[offset] = 3;
      //     cellArray[offset + 1] = (i * dim) + j;
      //     cellArray[offset + 2] = (i * dim) + 1 + j;
      //     cellArray[offset + 3] = ((i + 1) * dim) + 1 + j;
      //     cellArray[offset + 4] = 3;
      //     cellArray[offset + 5] = (i * dim) + j;
      //     cellArray[offset + 6] = ((i + 1) * dim) + 1 + j;
      //     cellArray[offset + 7] = ((i + 1) * dim) + j;
      //   }
      // }

      const points = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance({
        numberOfComponents: 3,
        values: ptsArray,
      });
      points.setName('points');
      const cells = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance({
        numberOfComponents: 1,
        values: cellArray,
      });
      model.tris.getCABO().createVBO(cells, 'polys', vtk_js_Sources_Rendering_Core_Property_Constants__WEBPACK_IMPORTED_MODULE_11__["Representation"].SURFACE, {
        points,
        cellOffset: 0,
      });
    }

    model.VBOBuildTime.modified();
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  context: null,
  VBOBuildTime: null,
  scalarTexture: null,
  scalarTextureString: null,
  opacityTexture: null,
  opacityTextureString: null,
  colorTexture: null,
  colorTextureString: null,
  jitterTexture: null,
  tris: null,
  framebuffer: null,
  copyShader: null,
  copyVAO: null,
  lastXYF: 1.0,
  targetXYF: 1.0,
  zBufferTexture: null,
  lastZBufferTexture: null,
  lastLightComplexity: 0,
  fullViewportTime: 1.0,
  idxToView: null,
  idxNormalMatrix: null,
  modelToView: null,
  projectionToView: null,
  avgWindowArea: 0.0,
  avgFrameTime: 0.0,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_10__["default"].extend(publicAPI, model, initialValues);

  model.VBOBuildTime = {};
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(model.VBOBuildTime, { mtime: 0 });

  model.tris = vtk_js_Sources_Rendering_OpenGL_Helper__WEBPACK_IMPORTED_MODULE_4__["default"].newInstance();
  model.scalarTexture = vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_7__["default"].newInstance();
  model.opacityTexture = vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_7__["default"].newInstance();
  model.colorTexture = vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_7__["default"].newInstance();
  model.jitterTexture = vtk_js_Sources_Rendering_OpenGL_Texture__WEBPACK_IMPORTED_MODULE_7__["default"].newInstance();
  model.jitterTexture.setWrapS(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_12__["Wrap"].REPEAT);
  model.jitterTexture.setWrapT(vtk_js_Sources_Rendering_OpenGL_Texture_Constants__WEBPACK_IMPORTED_MODULE_12__["Wrap"].REPEAT);
  model.framebuffer = vtk_js_Sources_Rendering_OpenGL_Framebuffer__WEBPACK_IMPORTED_MODULE_6__["default"].newInstance();

  model.idxToView = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].create();
  model.idxNormalMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["mat3"].create();
  model.modelToView = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].create();
  model.projectionToView = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].create();
  model.projectionToWorld = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].create();

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, ['context']);

  // Object methods
  vtkOpenGLVolumeMapper(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkOpenGLVolumeMapper');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl":
/*!******************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n}\n"

/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl":
/*!******************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n"

/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkSphereMapperVS.glsl":
/*!**********************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkSphereMapperVS.glsl ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(offsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + offsetMC.x*base1 + offsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + offsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n"

/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkStickMapperVS.glsl":
/*!*********************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkStickMapperVS.glsl ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n"

/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkVolumeFS.glsl":
/*!****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkVolumeFS.glsl ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\n// the output of this shader\n//VTK::Output::Dec\n\nvarying vec3 vertexVCVSOutput;\n\n// first declare the settings from the mapper\n// that impact the code paths in here\n\n// always set vtkNumComponents 1,2,3,4\n//VTK::NumComponents\n\n// possibly define vtkUseTriliear\n//VTK::TrilinearOn\n\n// possibly define vtkIndependentComponents\n//VTK::IndependentComponentsOn\n\n// possibly define any \"proportional\" components\n//VTK::vtkProportionalComponents\n\n// Define the blend mode to use\n#define vtkBlendMode //VTK::BlendMode\n\n// Possibly define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n#ifdef vtkImageLabelOutlineOn\nuniform int outlineThickness;\nuniform float vpWidth;\nuniform float vpHeight;\nuniform mat4 PCWCMatrix;\nuniform mat4 vWCtoIDX;\n#endif\n\n// define vtkLightComplexity\n//VTK::LightComplexity\n#if vtkLightComplexity > 0\nuniform float vSpecularPower;\nuniform float vAmbient;\nuniform float vDiffuse;\nuniform float vSpecular;\n//VTK::Light::Dec\n#endif\n\n// possibly define vtkGradientOpacityOn\n//VTK::GradientOpacityOn\n#ifdef vtkGradientOpacityOn\nuniform float goscale0;\nuniform float goshift0;\nuniform float gomin0;\nuniform float gomax0;\n#if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\nuniform float goscale1;\nuniform float goshift1;\nuniform float gomin1;\nuniform float gomax1;\n#if vtkNumComponents >= 3\nuniform float goscale2;\nuniform float goshift2;\nuniform float gomin2;\nuniform float gomax2;\n#endif\n#if vtkNumComponents >= 4\nuniform float goscale3;\nuniform float goshift3;\nuniform float gomin3;\nuniform float gomax3;\n#endif\n#endif\n#endif\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n// values describing the volume geometry\nuniform vec3 vOriginVC;\nuniform vec3 vSpacing;\nuniform ivec3 volumeDimensions; // 3d texture dimensions\nuniform vec3 vPlaneNormal0;\nuniform float vPlaneDistance0;\nuniform vec3 vPlaneNormal1;\nuniform float vPlaneDistance1;\nuniform vec3 vPlaneNormal2;\nuniform float vPlaneDistance2;\nuniform vec3 vPlaneNormal3;\nuniform float vPlaneDistance3;\nuniform vec3 vPlaneNormal4;\nuniform float vPlaneDistance4;\nuniform vec3 vPlaneNormal5;\nuniform float vPlaneDistance5;\n\n// opacity and color textures\nuniform sampler2D otexture;\nuniform float oshift0;\nuniform float oscale0;\nuniform sampler2D ctexture;\nuniform float cshift0;\nuniform float cscale0;\n\n// jitter texture\nuniform sampler2D jtexture;\n\n// some 3D texture values\nuniform float sampleDistance;\nuniform vec3 vVCToIJK;\n\n// the heights defined below are the locations\n// for the up to four components of the tfuns\n// the tfuns have a height of 2XnumComps pixels so the\n// values are computed to hit the middle of the two rows\n// for that component\n#ifdef vtkIndependentComponentsOn\n#if vtkNumComponents == 2\nuniform float mix0;\nuniform float mix1;\n#define height0 0.25\n#define height1 0.75\n#endif\n#if vtkNumComponents == 3\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\n#define height0 0.17\n#define height1 0.5\n#define height2 0.83\n#endif\n#if vtkNumComponents == 4\nuniform float mix0;\nuniform float mix1;\nuniform float mix2;\nuniform float mix3;\n#define height0 0.125\n#define height1 0.375\n#define height2 0.625\n#define height3 0.875\n#endif\n#endif\n\n#if vtkNumComponents >= 2\nuniform float oshift1;\nuniform float oscale1;\nuniform float cshift1;\nuniform float cscale1;\n#endif\n#if vtkNumComponents >= 3\nuniform float oshift2;\nuniform float oscale2;\nuniform float cshift2;\nuniform float cscale2;\n#endif\n#if vtkNumComponents >= 4\nuniform float oshift3;\nuniform float oscale3;\nuniform float cshift3;\nuniform float cscale3;\n#endif\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n// Lighting values\n//VTK::Light::Dec\n\n//=======================================================================\n// Webgl2 specific version of functions\n#if __VERSION__ == 300\n\nuniform highp sampler3D texture1;\n\nvec4 getTextureValue(vec3 pos)\n{\n  vec4 tmp = texture(texture1, pos);\n#if vtkNumComponents == 1\n  tmp.a = tmp.r;\n#endif\n#if vtkNumComponents == 2\n  tmp.a = tmp.g;\n#endif\n#if vtkNumComponents == 3\n  tmp.a = length(tmp.rgb);\n#endif\n  return tmp;\n}\n\n//=======================================================================\n// WebGL1 specific version of functions\n#else\n\nuniform sampler2D texture1;\n\nuniform float texWidth;\nuniform float texHeight;\nuniform int xreps;\nuniform int xstride;\nuniform int ystride;\n\n// if computing triliear values from multiple z slices\n#ifdef vtkTriliearOn\nvec4 getTextureValue(vec3 ijk)\n{\n  float zoff = 1.0/float(volumeDimensions.z);\n  vec4 val1 = getOneTextureValue(ijk);\n  vec4 val2 = getOneTextureValue(vec3(ijk.xy, ijk.z + zoff));\n\n  float indexZ = float(volumeDimensions)*ijk.z;\n  float zmix =  indexZ - floor(indexZ);\n\n  return mix(val1, val2, zmix);\n}\n\nvec4 getOneTextureValue(vec3 ijk)\n#else // nearest or fast linear\nvec4 getTextureValue(vec3 ijk)\n#endif\n{\n  vec3 tdims = vec3(volumeDimensions);\n\n#ifdef debugtile\n  vec2 tpos = vec2(ijk.x, ijk.y);\n  vec4 tmp = texture2D(texture1, tpos);\n  tmp.a = 1.0;\n\n#else\n  int z = int(ijk.z * tdims.z);\n  int yz = z / xreps;\n  int xz = z - yz*xreps;\n\n  int tileWidth = volumeDimensions.x/xstride;\n  int tileHeight = volumeDimensions.y/ystride;\n\n  xz *= tileWidth;\n  yz *= tileHeight;\n\n  float ni = float(xz) + (ijk.x*float(tileWidth));\n  float nj = float(yz) + (ijk.y*float(tileHeight));\n\n  vec2 tpos = vec2(ni/texWidth, nj/texHeight);\n\n  vec4 tmp = texture2D(texture1, tpos);\n\n#if vtkNumComponents == 1\n  tmp.a = tmp.r;\n#endif\n#if vtkNumComponents == 2\n  tmp.g = tmp.a;\n#endif\n#if vtkNumComponents == 3\n  tmp.a = length(tmp.rgb);\n#endif\n#endif\n\n  return tmp;\n}\n\n// End of Webgl1 specific code\n//=======================================================================\n#endif\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position\nvec4 computeNormal(vec3 pos, float scalar, vec3 tstep)\n{\n  vec4 result;\n\n  result.x = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)).a - scalar;\n  result.y = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)).a - scalar;\n  result.z = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)).a - scalar;\n\n  // divide by spacing\n  result.xyz /= vSpacing;\n\n  result.w = length(result.xyz);\n\n  // rotate to View Coords\n  result.xyz =\n    result.x * vPlaneNormal0 +\n    result.y * vPlaneNormal2 +\n    result.z * vPlaneNormal4;\n\n  if (result.w > 0.0)\n  {\n    result.xyz /= result.w;\n  }\n  return result;\n}\n\n#ifdef vtkImageLabelOutlineOn\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\n  vec4 pcPos = vec4(\n    (fragCoord.x / vpWidth - 0.5) * 2.0,\n    (fragCoord.y / vpHeight - 0.5) * 2.0,\n    (fragCoord.z - 0.5) * 2.0,\n    1.0);\n\n  vec4 worldCoord = PCWCMatrix * pcPos;\n  vec4 vertex = (worldCoord/worldCoord.w);\n\n  return (vWCtoIDX * vertex).xyz / vec3(volumeDimensions);\n}\n#endif\n\n//=======================================================================\n// compute the normals and gradient magnitudes for a position\n// for independent components\nmat4 computeMat4Normal(vec3 pos, vec4 tValue, vec3 tstep)\n{\n  mat4 result;\n  vec4 distX = getTextureValue(pos + vec3(tstep.x, 0.0, 0.0)) - tValue;\n  vec4 distY = getTextureValue(pos + vec3(0.0, tstep.y, 0.0)) - tValue;\n  vec4 distZ = getTextureValue(pos + vec3(0.0, 0.0, tstep.z)) - tValue;\n\n  // divide by spacing\n  distX /= vSpacing.x;\n  distY /= vSpacing.y;\n  distZ /= vSpacing.z;\n\n  mat3 rot;\n  rot[0] = vPlaneNormal0;\n  rot[1] = vPlaneNormal2;\n  rot[2] = vPlaneNormal4;\n\n#if !defined(vtkComponent0Proportional)\n  result[0].xyz = vec3(distX.r, distY.r, distZ.r);\n  result[0].a = length(result[0].xyz);\n  result[0].xyz *= rot;\n  if (result[0].w > 0.0)\n  {\n    result[0].xyz /= result[0].w;\n  }\n#endif\n\n// optionally compute the 2nd component\n#if vtkNumComponents >= 2 && !defined(vtkComponent1Proportional)\n  result[1].xyz = vec3(distX.g, distY.g, distZ.g);\n  result[1].a = length(result[1].xyz);\n  result[1].xyz *= rot;\n  if (result[1].w > 0.0)\n  {\n    result[1].xyz /= result[1].w;\n  }\n#endif\n\n// optionally compute the 3rd component\n#if vtkNumComponents >= 3 && !defined(vtkComponent2Proportional)\n  result[2].xyz = vec3(distX.b, distY.b, distZ.b);\n  result[2].a = length(result[2].xyz);\n  result[2].xyz *= rot;\n  if (result[2].w > 0.0)\n  {\n    result[2].xyz /= result[2].w;\n  }\n#endif\n\n// optionally compute the 4th component\n#if vtkNumComponents >= 4 && !defined(vtkComponent3Proportional)\n  result[3].xyz = vec3(distX.a, distY.a, distZ.a);\n  result[3].a = length(result[3].xyz);\n  result[3].xyz *= rot;\n  if (result[3].w > 0.0)\n  {\n    result[3].xyz /= result[3].w;\n  }\n#endif\n\n  return result;\n}\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\n//\nfloat computeGradientOpacityFactor(\n  vec4 normal, float goscale, float goshift, float gomin, float gomax)\n{\n#if defined(vtkGradientOpacityOn)\n  return clamp(normal.a*goscale + goshift, gomin, gomax);\n#else\n  return 1.0;\n#endif\n}\n\n#if vtkLightComplexity > 0\nvoid applyLighting(inout vec3 tColor, vec4 normal)\n{\n  vec3 diffuse = vec3(0.0, 0.0, 0.0);\n  vec3 specular = vec3(0.0, 0.0, 0.0);\n  //VTK::Light::Impl\n  tColor.rgb = tColor.rgb*(diffuse*vDiffuse + vAmbient) + specular*vSpecular;\n}\n#endif\n\n//=======================================================================\n// Given a texture value compute the color and opacity\n//\nvec4 getColorForValue(vec4 tValue, vec3 posIS, vec3 tstep)\n{\n#ifdef vtkImageLabelOutlineOn\n  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = texture2D(ctexture, vec2(centerValue.r * cscale0 + cshift0, 0.5));\n\n  // Get alpha of segment from opacity function.\n  tColor.a = texture2D(otexture, vec2(centerValue.r * oscale0 + oshift0, 0.5)).r;\n\n  // Only perform outline check on fragments rendering voxels that aren't invisible.\n  // Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  if (float(tColor.a) > 0.01) {\n    for (int i = -outlineThickness; i <= outlineThickness; i++) {\n      for (int j = -outlineThickness; j <= outlineThickness; j++) {\n        if (i == 0 || j == 0) {\n          continue;\n        }\n\n        vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n          gl_FragCoord.y + float(j),\n          gl_FragCoord.z, gl_FragCoord.w);\n\n        vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n        vec4 value = getTextureValue(neighborPosIS);\n\n        // If any of my neighbours are not the same value as I\n        // am, this means I am on the border of the segment.\n        // We can break the loops\n        if (any(notEqual(value, centerValue))) {\n          pixelOnBorder = true;\n          break;\n        }\n      }\n\n      if (pixelOnBorder == true) {\n        break;\n      }\n    }\n\n    // If I am on the border, I am displayed at full opacity\n    if (pixelOnBorder == true) {\n      tColor.a = 1.0;\n    }\n  }\n\n#else\n  // compute the normal and gradient magnitude if needed\n  // We compute it as a vec4 if possible otherwise a mat4\n  //\n  vec4 goFactor = vec4(1.0,1.0,1.0,1.0);\n\n  // compute the normal vectors as needed\n  #if (vtkLightComplexity > 0) || defined(vtkGradientOpacityOn)\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\n      mat4 normalMat = computeMat4Normal(posIS, tValue, tstep);\n      #if !defined(vtkComponent0Proportional)\n        vec4 normal0 = normalMat[0];\n      #endif\n      #if !defined(vtkComponent1Proportional)\n        vec4 normal1 = normalMat[1];\n      #endif\n      #if vtkNumComponents > 2\n        #if !defined(vtkComponent2Proportional)\n          vec4 normal2 = normalMat[2];\n        #endif\n        #if vtkNumComponents > 3\n          #if !defined(vtkComponent3Proportional)\n            vec4 normal3 = normalMat[3];\n          #endif\n        #endif\n      #endif\n    #else\n      vec4 normal0 = computeNormal(posIS, tValue.a, tstep);\n    #endif\n  #endif\n\n  // compute gradient opacity factors as needed\n  #if defined(vtkGradientOpacityOn)\n    #if !defined(vtkComponent0Proportional)\n      goFactor.x =\n        computeGradientOpacityFactor(normal0, goscale0, goshift0, gomin0, gomax0);\n    #endif\n    #if defined(vtkIndependentComponentsOn) && (vtkNumComponents > 1)\n      #if !defined(vtkComponent1Proportional)\n        goFactor.y =\n          computeGradientOpacityFactor(normal1, goscale1, goshift1, gomin1, gomax1);\n      #endif\n      #if vtkNumComponents > 2\n        #if !defined(vtkComponent2Proportional)\n          goFactor.z =\n            computeGradientOpacityFactor(normal2, goscale2, goshift2, gomin2, gomax2);\n        #endif\n        #if vtkNumComponents > 3\n          #if !defined(vtkComponent3Proportional)\n            goFactor.w =\n              computeGradientOpacityFactor(normal3, goscale3, goshift3, gomin3, gomax3);\n          #endif\n        #endif\n      #endif\n    #endif\n  #endif\n\n  // single component is always independent\n  #if vtkNumComponents == 1\n    vec4 tColor = texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, 0.5));\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, 0.5)).r;\n  #endif\n\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\n    vec4 tColor = mix0*texture2D(ctexture, vec2(tValue.r * cscale0 + cshift0, height0));\n    #if !defined(vtkComponent0Proportional)\n      tColor.a = goFactor.x*mix0*texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\n    #else\n      float pwfValue = texture2D(otexture, vec2(tValue.r * oscale0 + oshift0, height0)).r;\n      tColor *= pwfValue;\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix0));\n    #endif\n\n    vec3 tColor1 = mix1*texture2D(ctexture, vec2(tValue.g * cscale1 + cshift1, height1)).rgb;\n    #if !defined(vtkComponent1Proportional)\n      tColor.a += goFactor.y*mix1*texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\n    #else\n      float pwfValue = texture2D(otexture, vec2(tValue.g * oscale1 + oshift1, height1)).r;\n      tColor1 *= pwfValue;\n      tColor.a *= mix(pwfValue, 1.0, (1.0 - mix1));\n    #endif\n\n    #if vtkNumComponents >= 3\n      vec3 tColor2 = mix2*texture2D(ctexture, vec2(tValue.b * cscale2 + cshift2, height2)).rgb;\n      #if !defined(vtkComponent2Proportional)\n        tColor.a += goFactor.z*mix2*texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\n      #else\n        float pwfValue = texture2D(otexture, vec2(tValue.b * oscale2 + oshift2, height2)).r;\n        tColor2 *= pwfValue;\n        tColor.a *= mix(pwfValue, 1.0, (1.0 - mix2));\n      #endif\n\n      #if vtkNumComponents >= 4\n        vec3 tColor3 = mix3*texture2D(ctexture, vec2(tValue.a * cscale3 + cshift3, height3)).rgb;\n        #if !defined(vtkComponent3Proportional)\n          tColor.a += goFactor.w*mix3*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\n        #else\n          float pwfValue = texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, height3)).r;\n          tColor3 *= pwfValue;\n          tColor.a *= mix(pwfValue, 1.0, (1.0 - mix3));\n        #endif\n      #endif\n    #endif\n  #else // then not independent\n\n  #if vtkNumComponents == 2\n    float lum = tValue.r * cscale0 + cshift0;\n    float alpha = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale1 + oshift1, 0.5)).r;\n    vec4 tColor = vec4(lum, lum, lum, alpha);\n  #endif\n  #if vtkNumComponents == 3\n    vec4 tColor;\n    tColor.r = tValue.r * cscale0 + cshift0;\n    tColor.g = tValue.g * cscale1 + cshift1;\n    tColor.b = tValue.b * cscale2 + cshift2;\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale0 + oshift0, 0.5)).r;\n  #endif\n  #if vtkNumComponents == 4\n    vec4 tColor;\n    tColor.r = tValue.r * cscale0 + cshift0;\n    tColor.g = tValue.g * cscale1 + cshift1;\n    tColor.b = tValue.b * cscale2 + cshift2;\n    tColor.a = goFactor.x*texture2D(otexture, vec2(tValue.a * oscale3 + oshift3, 0.5)).r;\n  #endif\n  #endif // dependent\n\n  // apply lighting if requested as appropriate\n  #if vtkLightComplexity > 0\n    #if !defined(vtkComponent0Proportional)\n      applyLighting(tColor.rgb, normal0);\n    #endif\n  #if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\n    #if !defined(vtkComponent1Proportional)\n      applyLighting(tColor1, normal1);\n    #endif\n  #if vtkNumComponents >= 3\n    #if !defined(vtkComponent2Proportional)\n      applyLighting(tColor2, normal2);\n    #endif\n  #if vtkNumComponents >= 4\n    #if !defined(vtkComponent3Proportional)\n      applyLighting(tColor3, normal3);\n    #endif\n  #endif\n  #endif\n  #endif\n#endif\n\n// perform final independent blend as needed\n#if defined(vtkIndependentComponentsOn) && vtkNumComponents >= 2\n  tColor.rgb += tColor1;\n#if vtkNumComponents >= 3\n  tColor.rgb += tColor2;\n#if vtkNumComponents >= 4\n  tColor.rgb += tColor3;\n#endif\n#endif\n#endif\n\n#endif\n\n\n\n\n\n\n\nreturn tColor;\n}\n\n\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 posIS, vec3 endIS, float sampleDistanceIS, vec3 tdims)\n{\n  vec3 tstep = 1.0/tdims;\n\n  // start slightly inside and apply some jitter\n  vec3 delta = endIS - posIS;\n  vec3 stepIS = normalize(delta)*sampleDistanceIS;\n  float raySteps = length(delta)/sampleDistanceIS;\n\n  // avoid 0.0 jitter\n  float jitter = 0.01 + 0.99*texture2D(jtexture, gl_FragCoord.xy/32.0).r;\n  float stepsTraveled = jitter;\n\n  // local vars for the loop\n  vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n  vec4 tValue;\n  vec4 tColor;\n\n  // if we have less than one step then pick the middle point\n  // as our value\n  // if (raySteps <= 1.0)\n  // {\n  //   posIS = (posIS + endIS)*0.5;\n  // }\n\n  // Perform initial step at the volume boundary\n  // compute the scalar\n  tValue = getTextureValue(posIS);\n\n  #if vtkBlendMode == 0 // COMPOSITE_BLEND\n    // now map through opacity and color\n    tColor = getColorForValue(tValue, posIS, tstep);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0)\n    {\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps);\n      gl_FragData[0] = tColor;\n      return;\n    }\n\n    tColor.a = 1.0 - pow(1.0 - tColor.a, jitter);\n    color = vec4(tColor.rgb*tColor.a, tColor.a);\n    posIS += (jitter*stepIS);\n\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n\n      float mix = (1.0 - color.a);\n\n      // this line should not be needed but nvidia seems to not handle\n      // the break correctly on windows/chrome 58 angle\n      //mix = mix * sign(max(raySteps - stepsTraveled - 1.0, 0.0));\n\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n      stepsTraveled++;\n      posIS += stepIS;\n      if (color.a > 0.99) { color.a = 1.0; break; }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0)\n    {\n      posIS = endIS;\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // now map through opacity and color\n      tColor = getColorForValue(tValue, posIS, tstep);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb*tColor.a, tColor.a)*mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb/color.a, color.a);\n  #endif\n  #if vtkBlendMode == 1 || vtkBlendMode == 2\n    // MAXIMUM_INTENSITY_BLEND || MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == 1\n    #define OP max\n    #else\n    #define OP min\n    #endif\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0)\n    {\n      gl_FragData[0] = getColorForValue(tValue, posIS, tstep);\n      return;\n    }\n\n    vec4 value = tValue;\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // Update the maximum value if necessary\n      value = OP(tValue, value);\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n    tValue = getTextureValue(posIS);\n    value = OP(tValue, value);\n\n    // Now map through opacity and color\n    gl_FragData[0] = getColorForValue(value, posIS, tstep);\n  #endif\n  #if vtkBlendMode == 3 //AVERAGE_INTENSITY_BLEND\n    vec4 averageIPScalarRangeMin = vec4 (\n      //VTK::AverageIPScalarRangeMin,\n      //VTK::AverageIPScalarRangeMin,\n      //VTK::AverageIPScalarRangeMin,\n      1.0);\n    vec4 averageIPScalarRangeMax = vec4(\n      //VTK::AverageIPScalarRangeMax,\n      //VTK::AverageIPScalarRangeMax,\n      //VTK::AverageIPScalarRangeMax,\n      1.0);\n\n    vec4 sum = vec4(0.);\n\n    averageIPScalarRangeMin.a = tValue.a;\n    averageIPScalarRangeMax.a = tValue.a;\n\n    if (all(greaterThanEqual(tValue, averageIPScalarRangeMin)) &&\n    all(lessThanEqual(tValue, averageIPScalarRangeMax))) {\n      sum += tValue;\n    }\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n      return;\n    }\n\n    posIS += (jitter*stepIS);\n\n    // Sample along the ray until MaximumSamplesValue,\n    // ending slightly inside the total distance\n    for (int i = 0; i < //VTK::MaximumSamplesValue ; ++i)\n    {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) { break; }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n\n      // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation.\n      // Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      // - We are setting the alpha channel for averageIPScalarRangeMin and\n      //   averageIPScalarRangeMax so that we do not trigger this 'continue'\n      //   based on the alpha channel comparison.\n      // - There might be a better way to do this. I'm not sure if there is an\n      //   equivalent of 'any' which only operates on RGB, though I suppose\n      //   we could write an 'anyRGB' function and see if that is faster.\n      averageIPScalarRangeMin.a = tValue.a;\n      averageIPScalarRangeMax.a = tValue.a;\n      if (any(lessThan(tValue, averageIPScalarRangeMin)) ||\n          any(greaterThan(tValue, averageIPScalarRangeMax))) {\n        continue;\n      }\n\n      // Sum the values across each step in the path\n      sum += tValue;\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = endIS;\n\n    // compute the scalar\n    tValue = getTextureValue(posIS);\n\n    // One can control the scalar range by setting the AverageIPScalarRange to disregard scalar values, not in the range of interest, from the average computation\n    if (all(greaterThanEqual(tValue, averageIPScalarRangeMin)) &&\n        all(lessThanEqual(tValue, averageIPScalarRangeMax))) {\n      sum += tValue;\n\n      stepsTraveled++;\n    }\n\n    sum /= vec4(stepsTraveled, stepsTraveled, stepsTraveled, 1.0);\n\n    gl_FragData[0] = getColorForValue(sum, posIS, tstep);\n  #endif\n}\n\n//=======================================================================\n// Compute a new start and end point for a given ray based\n// on the provided bounded clipping plane (aka a rectangle)\nvoid getRayPointIntersectionBounds(\n  vec3 rayPos, vec3 rayDir,\n  vec3 planeDir, float planeDist,\n  inout vec2 tbounds, vec3 vPlaneX, vec3 vPlaneY,\n  float vSize1, float vSize2)\n{\n  float result = dot(rayDir, planeDir);\n  if (result == 0.0)\n  {\n    return;\n  }\n  result = -1.0 * (dot(rayPos, planeDir) + planeDist) / result;\n  vec3 xposVC = rayPos + rayDir*result;\n  vec3 vxpos = xposVC - vOriginVC;\n  vec2 vpos = vec2(\n    dot(vxpos, vPlaneX),\n    dot(vxpos, vPlaneY));\n\n  // on some apple nvidia systems this does not work\n  // if (vpos.x < 0.0 || vpos.x > vSize1 ||\n  //     vpos.y < 0.0 || vpos.y > vSize2)\n  // even just\n  // if (vpos.x < 0.0 || vpos.y < 0.0)\n  // fails\n  // so instead we compute a value that represents in and out\n  //and then compute the return using this value\n  float xcheck = max(0.0, vpos.x * (vpos.x - vSize1)); //  0 means in bounds\n  float check = sign(max(xcheck, vpos.y * (vpos.y - vSize2))); //  0 means in bounds, 1 = out\n\n  tbounds = mix(\n   vec2(min(tbounds.x, result), max(tbounds.y, result)), // in value\n   tbounds, // out value\n   check);  // 0 in 1 out\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayDir, vec3 tdims)\n{\n  vec2 dists = vec2(100.0*camFar, -1.0);\n\n  vec3 vSize = vSpacing*(tdims - 1.0);\n\n  // all this is in View Coordinates\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal0, vPlaneDistance0, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal1, vPlaneDistance1, dists, vPlaneNormal2, vPlaneNormal4,\n    vSize.y, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal2, vPlaneDistance2, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal3, vPlaneDistance3, dists, vPlaneNormal0, vPlaneNormal4,\n    vSize.x, vSize.z);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal4, vPlaneDistance4, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n  getRayPointIntersectionBounds(vertexVCVSOutput, rayDir,\n    vPlaneNormal5, vPlaneDistance5, dists, vPlaneNormal0, vPlaneNormal2,\n    vSize.x, vSize.y);\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0,dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick/rayDir.z;\n  dists.y = min(farDist,dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\n//=======================================================================\n// Compute the index space starting position (pos) and end\n// position\n//\nvoid computeIndexSpaceValues(out vec3 pos, out vec3 endPos, out float sampleDistanceIS, vec3 rayDir, vec2 dists)\n{\n  // compute starting and ending values in volume space\n  pos = vertexVCVSOutput + dists.x*rayDir;\n  pos = pos - vOriginVC;\n  // convert to volume basis and origin\n  pos = vec3(\n    dot(pos, vPlaneNormal0),\n    dot(pos, vPlaneNormal2),\n    dot(pos, vPlaneNormal4));\n\n  endPos = vertexVCVSOutput + dists.y*rayDir;\n  endPos = endPos - vOriginVC;\n  endPos = vec3(\n    dot(endPos, vPlaneNormal0),\n    dot(endPos, vPlaneNormal2),\n    dot(endPos, vPlaneNormal4));\n\n  float delta = length(endPos - pos);\n\n  pos *= vVCToIJK;\n  endPos *= vVCToIJK;\n\n  float delta2 = length(endPos - pos);\n  sampleDistanceIS = sampleDistance*delta2/delta;\n}\n\nvoid main()\n{\n\n  vec3 rayDirVC;\n\n  if (cameraParallel == 1)\n  {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 tdims = vec3(volumeDimensions);\n\n  // compute the start and end points for the ray\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayDirVC, tdims);\n\n  // do we need to composite? aka does the ray have any length\n  // If not, bail out early\n  if (rayStartEndDistancesVC.y <= rayStartEndDistancesVC.x)\n  {\n    discard;\n  }\n\n  // IS = Index Space\n  vec3 posIS;\n  vec3 endIS;\n  float sampleDistanceIS;\n  computeIndexSpaceValues(posIS, endIS, sampleDistanceIS, rayDirVC, rayStartEndDistancesVC);\n\n  // Perform the blending operation along the ray\n  applyBlend(posIS, endIS, sampleDistanceIS, tdims);\n}\n"

/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkVolumeVS.glsl":
/*!****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/OpenGL/glsl/vtkVolumeVS.glsl ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n"

/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/GenericWidgetRepresentation/index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/SceneGraph/GenericWidgetRepresentation/index.js ***!
  \***********************************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
/* harmony import */ var vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vtk.js/Sources/Rendering/SceneGraph/ViewNode */ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js");



// ----------------------------------------------------------------------------
// vtkOpenGLActor methods
// ----------------------------------------------------------------------------

function vtkGenericWidgetRepresentation(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkGenericWidgetRepresentation');
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Inheritance
  vtk_js_Sources_Rendering_SceneGraph_ViewNode__WEBPACK_IMPORTED_MODULE_1__["default"].extend(publicAPI, model, initialValues);

  // Object methods
  vtkGenericWidgetRepresentation(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend);

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/RenderPass/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/SceneGraph/RenderPass/index.js ***!
  \******************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");


// ----------------------------------------------------------------------------

function vtkRenderPass(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkRenderPass');

  publicAPI.getOperation = () => model.currentOperation;

  publicAPI.setCurrentOperation = (val) => {
    model.currentOperation = val;
    model.currentTraverseOperation = `traverse${vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].capitalize(
      model.currentOperation
    )}`;
  };

  publicAPI.getTraverseOperation = () => model.currentTraverseOperation;

  // by default this class will traverse all of its
  // preDelegateOperations, then call its delegate render passes
  // the traverse all of its postDelegateOperations
  // any of those three arrays can be empty
  publicAPI.traverse = (viewNode, parent = null) => {
    if (model.deleted) {
      return;
    }

    // we just render our delegates in order
    model.currentParent = parent;

    model.preDelegateOperations.forEach((val) => {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
    model.delegates.forEach((val) => {
      val.traverse(viewNode, publicAPI);
    });
    model.postDelegateOperations.forEach((val) => {
      publicAPI.setCurrentOperation(val);
      viewNode.traverse(publicAPI);
    });
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  delegates: [],
  currentOperation: null,
  preDelegateOperations: [],
  postDelegateOperations: [],
  currentParent: null,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['currentOperation']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, [
    'delegates',
    'currentParent',
    'preDelegateOperations',
    'postDelegateOperations',
  ]);

  // Object methods
  vtkRenderPass(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkRenderPass');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNode/index.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");


const { vtkErrorMacro } = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"];

const PASS_TYPES = ['Build', 'Render'];

// ----------------------------------------------------------------------------
// vtkViewNode methods
// ----------------------------------------------------------------------------

function vtkViewNode(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkViewNode');

  // Builds myself.
  publicAPI.build = (prepass) => {};

  // Renders myself
  publicAPI.render = (prepass) => {};

  publicAPI.traverse = (renderPass) => {
    // we can choose to do special
    // traversal here based on pass
    const passTraversal = renderPass.getTraverseOperation();
    const fn = publicAPI[passTraversal];
    if (fn) {
      fn(renderPass);
      return;
    }

    // default traversal
    publicAPI.apply(renderPass, true);

    for (let index = 0; index < model.children.length; index++) {
      model.children[index].traverse(renderPass);
    }

    publicAPI.apply(renderPass, false);
  };

  publicAPI.apply = (renderPass, prepass) => {
    const customRenderPass = publicAPI[renderPass.getOperation()];
    if (customRenderPass) {
      customRenderPass(prepass, renderPass);
    }
  };

  publicAPI.getViewNodeFor = (dataObject) => {
    if (model.renderable === dataObject) {
      return publicAPI;
    }

    for (let index = 0; index < model.children.length; ++index) {
      const child = model.children[index];
      const vn = child.getViewNodeFor(dataObject);
      if (vn) {
        return vn;
      }
    }
    return undefined;
  };

  publicAPI.getFirstAncestorOfType = (type) => {
    if (!model.parent) {
      return null;
    }
    if (model.parent.isA(type)) {
      return model.parent;
    }
    return model.parent.getFirstAncestorOfType(type);
  };

  publicAPI.addMissingNode = (dobj) => {
    if (!dobj) {
      return;
    }
    const result = model.renderableChildMap.get(dobj);
    // if found just mark as visited
    if (result !== undefined) {
      result.setVisited(true);
    } else {
      // otherwise create a node
      const newNode = publicAPI.createViewNode(dobj);
      if (newNode) {
        newNode.setParent(publicAPI);
        newNode.setVisited(true);
        model.renderableChildMap.set(dobj, newNode);
        model.children.push(newNode);
      }
    }
  };

  publicAPI.addMissingNodes = (dataObjs) => {
    if (!dataObjs || !dataObjs.length) {
      return;
    }

    for (let index = 0; index < dataObjs.length; ++index) {
      const dobj = dataObjs[index];
      const result = model.renderableChildMap.get(dobj);
      // if found just mark as visited
      if (result !== undefined) {
        result.setVisited(true);
      } else {
        // otherwise create a node
        const newNode = publicAPI.createViewNode(dobj);
        if (newNode) {
          newNode.setParent(publicAPI);
          newNode.setVisited(true);
          model.renderableChildMap.set(dobj, newNode);
          model.children.push(newNode);
        }
      }
    }
  };

  publicAPI.prepareNodes = () => {
    for (let index = 0; index < model.children.length; ++index) {
      model.children[index].setVisited(false);
    }
  };

  publicAPI.setVisited = (val) => {
    model.visited = val;
  };

  publicAPI.removeUnusedNodes = () => {
    let deleted = null;
    for (let index = 0; index < model.children.length; ++index) {
      const child = model.children[index];
      const visited = child.getVisited();
      if (!visited) {
        const renderable = child.getRenderable();
        if (renderable) {
          model.renderableChildMap.delete(renderable);
        }
        if (!deleted) {
          deleted = [];
        }
        deleted.push(child);
      } else {
        child.setVisited(false);
      }
    }

    if (deleted) {
      // slow does alloc but not as common
      model.children = model.children.filter((el) => !deleted.includes(el));
    }
  };

  publicAPI.createViewNode = (dataObj) => {
    if (!model.myFactory) {
      vtkErrorMacro('Cannot create view nodes without my own factory');
      return null;
    }
    const ret = model.myFactory.createNode(dataObj);
    if (ret) {
      ret.setRenderable(dataObj);
    }
    return ret;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  parent: null,
  renderable: null,
  myFactory: null,
  children: [],
  visited: false,
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].event(publicAPI, model, 'event');

  model.renderableChildMap = new Map();

  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].get(publicAPI, model, ['visited']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].setGet(publicAPI, model, ['parent', 'renderable', 'myFactory']);
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].getArray(publicAPI, model, ['children']);

  // Object methods
  vtkViewNode(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkViewNode');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend, PASS_TYPES });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNodeFactory/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/vtk.js/Sources/Rendering/SceneGraph/ViewNodeFactory/index.js ***!
  \***********************************************************************************/
/*! exports provided: extend, newInstance, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");


// ----------------------------------------------------------------------------
// vtkViewNodeFactory methods
// ----------------------------------------------------------------------------

function vtkViewNodeFactory(publicAPI, model) {
  // Make sure our overrides is just for our instance not shared with everyone...
  model.overrides = {};

  // Set our className
  model.classHierarchy.push('vtkViewNodeFactory');

  publicAPI.createNode = (dataObject) => {
    if (dataObject.isDeleted()) {
      return null;
    }

    let cpt = 0;
    let className = dataObject.getClassName(cpt++);
    let isObject = false;
    const keys = Object.keys(model.overrides);
    while (className && !isObject) {
      if (keys.indexOf(className) !== -1) {
        isObject = true;
      } else {
        className = dataObject.getClassName(cpt++);
      }
    }

    if (!isObject) {
      return null;
    }
    const vn = model.overrides[className]();
    vn.setMyFactory(publicAPI);
    return vn;
  };

  publicAPI.registerOverride = (className, func) => {
    model.overrides[className] = func;
  };
}

// ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------

const DEFAULT_VALUES = {
  // overrides: {},
};

// ----------------------------------------------------------------------------

function extend(publicAPI, model, initialValues = {}) {
  Object.assign(model, DEFAULT_VALUES, initialValues);

  // Build VTK API
  vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].obj(publicAPI, model);

  // Object methods
  vtkViewNodeFactory(publicAPI, model);
}

// ----------------------------------------------------------------------------

const newInstance = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_0__["default"].newInstance(extend, 'vtkViewNodeFactory');

// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({ newInstance, extend });


/***/ }),

/***/ "./node_modules/vtk.js/Sources/macro.js":
/*!**********************************************!*\
  !*** ./node_modules/vtk.js/Sources/macro.js ***!
  \**********************************************/
/*! exports provided: VOID, setLoggerFunction, vtkLogMacro, vtkInfoMacro, vtkDebugMacro, vtkErrorMacro, vtkWarningMacro, vtkOnceErrorMacro, TYPED_ARRAYS, capitalize, uncapitalize, formatBytesToProperUnit, formatNumbersWithThousandSeparator, setImmediateVTK, obj, get, set, setGet, getArray, setArray, setGetArray, algo, EVENT_ABORT, event, newInstance, chain, isVtkObject, traverseInstanceTree, debounce, throttle, keystore, proxy, proxyPropertyMapping, proxyPropertyState, normalizeWheel, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VOID", function() { return VOID; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setLoggerFunction", function() { return setLoggerFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vtkLogMacro", function() { return vtkLogMacro; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vtkInfoMacro", function() { return vtkInfoMacro; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vtkDebugMacro", function() { return vtkDebugMacro; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vtkErrorMacro", function() { return vtkErrorMacro; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vtkWarningMacro", function() { return vtkWarningMacro; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vtkOnceErrorMacro", function() { return vtkOnceErrorMacro; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TYPED_ARRAYS", function() { return TYPED_ARRAYS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "capitalize", function() { return capitalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uncapitalize", function() { return uncapitalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatBytesToProperUnit", function() { return formatBytesToProperUnit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatNumbersWithThousandSeparator", function() { return formatNumbersWithThousandSeparator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setImmediateVTK", function() { return setImmediateVTK; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "obj", function() { return obj; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setGet", function() { return setGet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArray", function() { return getArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setArray", function() { return setArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setGetArray", function() { return setGetArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "algo", function() { return algo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EVENT_ABORT", function() { return EVENT_ABORT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "event", function() { return event; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "newInstance", function() { return newInstance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "chain", function() { return chain; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isVtkObject", function() { return isVtkObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "traverseInstanceTree", function() { return traverseInstanceTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "debounce", function() { return debounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return throttle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keystore", function() { return keystore; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "proxy", function() { return proxy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "proxyPropertyMapping", function() { return proxyPropertyMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "proxyPropertyState", function() { return proxyPropertyState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeWheel", function() { return normalizeWheel; });
/* harmony import */ var _vtk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vtk */ "./node_modules/vtk.js/Sources/vtk.js");


let globalMTime = 0;

const VOID = Symbol('void');

function getCurrentGlobalMTime() {
  return globalMTime;
}

// ----------------------------------------------------------------------------
// Logging function calls
// ----------------------------------------------------------------------------
/* eslint-disable no-prototype-builtins                                      */

const fakeConsole = {};

function noOp() {}

const consoleMethods = [
  'log',
  'debug',
  'info',
  'warn',
  'error',
  'time',
  'timeEnd',
  'group',
  'groupEnd',
];
consoleMethods.forEach((methodName) => {
  fakeConsole[methodName] = noOp;
});

global.console = console.hasOwnProperty('log') ? console : fakeConsole;

const loggerFunctions = {
  debug: noOp, // Don't print debug by default
  error: global.console.error || noOp,
  info: global.console.info || noOp,
  log: global.console.log || noOp,
  warn: global.console.warn || noOp,
};

function setLoggerFunction(name, fn) {
  if (loggerFunctions[name]) {
    loggerFunctions[name] = fn || noOp;
  }
}

function vtkLogMacro(...args) {
  loggerFunctions.log(...args);
}

function vtkInfoMacro(...args) {
  loggerFunctions.info(...args);
}

function vtkDebugMacro(...args) {
  loggerFunctions.debug(...args);
}

function vtkErrorMacro(...args) {
  loggerFunctions.error(...args);
}

function vtkWarningMacro(...args) {
  loggerFunctions.warn(...args);
}

const ERROR_ONCE_MAP = {};
function vtkOnceErrorMacro(str) {
  if (!ERROR_ONCE_MAP[str]) {
    loggerFunctions.error(str);
    ERROR_ONCE_MAP[str] = true;
  }
}

// ----------------------------------------------------------------------------
// TypedArray
// ----------------------------------------------------------------------------

const TYPED_ARRAYS = {
  Float32Array,
  Float64Array,
  Uint8Array,
  Int8Array,
  Uint16Array,
  Int16Array,
  Uint32Array,
  Int32Array,
};

// ----------------------------------------------------------------------------
// capitilze provided string
// ----------------------------------------------------------------------------

function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

function uncapitalize(str) {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

// ----------------------------------------------------------------------------
// Convert byte size into a well formatted string
// ----------------------------------------------------------------------------

function formatBytesToProperUnit(size, precision = 2, chunkSize = 1000) {
  const units = ['TB', 'GB', 'MB', 'KB'];
  let value = Number(size);
  let currentUnit = 'B';
  while (value > chunkSize) {
    value /= chunkSize;
    currentUnit = units.pop();
  }
  return `${value.toFixed(precision)} ${currentUnit}`;
}
// ----------------------------------------------------------------------------
// Convert thousand number with proper separator
// ----------------------------------------------------------------------------

function formatNumbersWithThousandSeparator(n, separator = ' ') {
  const sections = [];
  let size = n;
  while (size > 1000) {
    sections.push(`000${size % 1000}`.slice(-3));
    size = Math.floor(size / 1000);
  }
  if (size > 0) {
    sections.push(size);
  }
  sections.reverse();
  return sections.join(separator);
}

// ----------------------------------------------------------------------------
// Array helper
// ----------------------------------------------------------------------------

function safeArrays(model) {
  Object.keys(model).forEach((key) => {
    if (Array.isArray(model[key])) {
      model[key] = [].concat(model[key]);
    }
  });
}

// ----------------------------------------------------------------------------
// shallow equals
// ----------------------------------------------------------------------------

function shallowEquals(a, b) {
  if (a === b) {
    return true;
  }

  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }

  return false;
}

// ----------------------------------------------------------------------------

function enumToString(e, value) {
  return Object.keys(e).find((key) => e[key] === value);
}

function getStateArrayMapFunc(item) {
  if (item.isA) {
    return item.getState();
  }
  return item;
}

// ----------------------------------------------------------------------------
// setImmediate
// ----------------------------------------------------------------------------

function setImmediateVTK(fn) {
  setTimeout(fn, 0);
}

// ----------------------------------------------------------------------------
// vtkObject: modified(), onModified(callback), delete()
// ----------------------------------------------------------------------------

function obj(publicAPI = {}, model = {}) {
  // Ensure each instance as a unique ref of array
  safeArrays(model);

  const callbacks = [];
  if (!Number.isInteger(model.mtime)) {
    model.mtime = ++globalMTime;
  }
  model.classHierarchy = ['vtkObject'];

  function off(index) {
    callbacks[index] = null;
  }

  function on(index) {
    function unsubscribe() {
      off(index);
    }
    return Object.freeze({
      unsubscribe,
    });
  }

  publicAPI.isDeleted = () => !!model.deleted;

  publicAPI.modified = (otherMTime) => {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }

    if (otherMTime && otherMTime < publicAPI.getMTime()) {
      return;
    }

    model.mtime = ++globalMTime;
    callbacks.forEach((callback) => callback && callback(publicAPI));
  };

  publicAPI.onModified = (callback) => {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return null;
    }

    const index = callbacks.length;
    callbacks.push(callback);
    return on(index);
  };

  publicAPI.getMTime = () => model.mtime;

  publicAPI.isA = (className) => {
    let count = model.classHierarchy.length;
    // we go backwards as that is more likely for
    // early termination
    while (count--) {
      if (model.classHierarchy[count] === className) {
        return true;
      }
    }
    return false;
  };

  publicAPI.getClassName = (depth = 0) =>
    model.classHierarchy[model.classHierarchy.length - 1 - depth];

  publicAPI.set = (map = {}, noWarning = false, noFunction = false) => {
    let ret = false;
    Object.keys(map).forEach((name) => {
      const fn = noFunction ? null : publicAPI[`set${capitalize(name)}`];
      if (fn && Array.isArray(map[name]) && fn.length > 1) {
        ret = fn(...map[name]) || ret;
      } else if (fn) {
        ret = fn(map[name]) || ret;
      } else {
        // Set data on model directly
        if (['mtime'].indexOf(name) === -1 && !noWarning) {
          vtkWarningMacro(
            `Warning: Set value to model directly ${name}, ${map[name]}`
          );
        }
        model[name] = map[name];
        ret = true;
      }
    });
    return ret;
  };

  publicAPI.get = (...list) => {
    if (!list.length) {
      return model;
    }
    const subset = {};
    list.forEach((name) => {
      subset[name] = model[name];
    });
    return subset;
  };

  publicAPI.getReferenceByName = (val) => model[val];

  publicAPI.delete = () => {
    Object.keys(model).forEach((field) => delete model[field]);
    callbacks.forEach((el, index) => off(index));

    // Flag the instance being deleted
    model.deleted = true;
  };

  // Add serialization support
  publicAPI.getState = () => {
    const jsonArchive = { ...model, vtkClass: publicAPI.getClassName() };

    // Convert every vtkObject to its serializable form
    Object.keys(jsonArchive).forEach((keyName) => {
      if (jsonArchive[keyName] === null || jsonArchive[keyName] === undefined) {
        delete jsonArchive[keyName];
      } else if (jsonArchive[keyName].isA) {
        jsonArchive[keyName] = jsonArchive[keyName].getState();
      } else if (Array.isArray(jsonArchive[keyName])) {
        jsonArchive[keyName] = jsonArchive[keyName].map(getStateArrayMapFunc);
      }
    });

    // Sort resulting object by key name
    const sortedObj = {};
    Object.keys(jsonArchive)
      .sort()
      .forEach((name) => {
        sortedObj[name] = jsonArchive[name];
      });

    // Remove mtime
    if (sortedObj.mtime) {
      delete sortedObj.mtime;
    }

    return sortedObj;
  };

  // Add shallowCopy(otherInstance) support
  publicAPI.shallowCopy = (other, debug = false) => {
    if (other.getClassName() !== publicAPI.getClassName()) {
      throw new Error(
        `Cannot ShallowCopy ${other.getClassName()} into ${publicAPI.getClassName()}`
      );
    }
    const otherModel = other.get();

    const keyList = Object.keys(model).sort();
    const otherKeyList = Object.keys(otherModel).sort();

    otherKeyList.forEach((key) => {
      const keyIdx = keyList.indexOf(key);
      if (keyIdx === -1) {
        if (debug) {
          vtkDebugMacro(`add ${key} in shallowCopy`);
        }
      } else {
        keyList.splice(keyIdx, 1);
      }
      model[key] = otherModel[key];
    });
    if (keyList.length && debug) {
      vtkDebugMacro(`Untouched keys: ${keyList.join(', ')}`);
    }

    publicAPI.modified();
  };

  // Allow usage as decorator
  return publicAPI;
}

// ----------------------------------------------------------------------------
// getXXX: add getters
// ----------------------------------------------------------------------------

function get(publicAPI, model, fieldNames) {
  fieldNames.forEach((field) => {
    if (typeof field === 'object') {
      publicAPI[`get${capitalize(field.name)}`] = () => model[field.name];
    } else {
      publicAPI[`get${capitalize(field)}`] = () => model[field];
    }
  });
}

// ----------------------------------------------------------------------------
// setXXX: add setters
// ----------------------------------------------------------------------------

const objectSetterMap = {
  enum(publicAPI, model, field) {
    return (value) => {
      if (typeof value === 'string') {
        if (field.enum[value] !== undefined) {
          if (model[field.name] !== field.enum[value]) {
            model[field.name] = field.enum[value];
            publicAPI.modified();
            return true;
          }
          return false;
        }
        vtkErrorMacro(`Set Enum with invalid argument ${field}, ${value}`);
        throw new RangeError('Set Enum with invalid string argument');
      }
      if (typeof value === 'number') {
        if (model[field.name] !== value) {
          if (
            Object.keys(field.enum)
              .map((key) => field.enum[key])
              .indexOf(value) !== -1
          ) {
            model[field.name] = value;
            publicAPI.modified();
            return true;
          }
          vtkErrorMacro(`Set Enum outside numeric range ${field}, ${value}`);
          throw new RangeError('Set Enum outside numeric range');
        }
        return false;
      }
      vtkErrorMacro(
        `Set Enum with invalid argument (String/Number) ${field}, ${value}`
      );
      throw new TypeError('Set Enum with invalid argument (String/Number)');
    };
  },
};

function findSetter(field) {
  if (typeof field === 'object') {
    const fn = objectSetterMap[field.type];
    if (fn) {
      return (publicAPI, model) => fn(publicAPI, model, field);
    }

    vtkErrorMacro(`No setter for field ${field}`);
    throw new TypeError('No setter for field');
  }
  return function getSetter(publicAPI, model) {
    return function setter(value) {
      if (model.deleted) {
        vtkErrorMacro('instance deleted - cannot call any method');
        return false;
      }

      if (model[field] !== value) {
        model[field] = value;
        publicAPI.modified();
        return true;
      }
      return false;
    };
  };
}

function set(publicAPI, model, fields) {
  fields.forEach((field) => {
    if (typeof field === 'object') {
      publicAPI[`set${capitalize(field.name)}`] = findSetter(field)(
        publicAPI,
        model
      );
    } else {
      publicAPI[`set${capitalize(field)}`] = findSetter(field)(
        publicAPI,
        model
      );
    }
  });
}

// ----------------------------------------------------------------------------
// set/get XXX: add both setters and getters
// ----------------------------------------------------------------------------

function setGet(publicAPI, model, fieldNames) {
  get(publicAPI, model, fieldNames);
  set(publicAPI, model, fieldNames);
}

// ----------------------------------------------------------------------------
// getXXX: add getters for object of type array with copy to be safe
// getXXXByReference: add getters for object of type array without copy
// ----------------------------------------------------------------------------

function getArray(publicAPI, model, fieldNames) {
  fieldNames.forEach((field) => {
    publicAPI[`get${capitalize(field)}`] = () => [].concat(model[field]);
    publicAPI[`get${capitalize(field)}ByReference`] = () => model[field];
  });
}

// ----------------------------------------------------------------------------
// setXXX: add setter for object of type array
// if 'defaultVal' is supplied, shorter arrays will be padded to 'size' with 'defaultVal'
// set...From: fast path to copy the content of an array to the current one without call to modified.
// ----------------------------------------------------------------------------

function setArray(
  publicAPI,
  model,
  fieldNames,
  size,
  defaultVal = undefined
) {
  fieldNames.forEach((field) => {
    publicAPI[`set${capitalize(field)}`] = (...args) => {
      if (model.deleted) {
        vtkErrorMacro('instance deleted - cannot call any method');
        return false;
      }

      let array = args;
      // allow an array passed as a single arg.
      if (array.length === 1 && Array.isArray(array[0])) {
        /* eslint-disable prefer-destructuring */
        array = array[0];
        /* eslint-enable prefer-destructuring */
      }

      if (array.length !== size) {
        if (array.length < size && defaultVal !== undefined) {
          array = [].concat(array);
          while (array.length < size) array.push(defaultVal);
        } else {
          throw new RangeError(
            `Invalid number of values for array setter (${field})`
          );
        }
      }
      let changeDetected = false;
      model[field].forEach((item, index) => {
        if (item !== array[index]) {
          if (changeDetected) {
            return;
          }
          changeDetected = true;
        }
      });

      if (changeDetected || model[field].length !== array.length) {
        model[field] = [].concat(array);
        publicAPI.modified();
        return true;
      }
      return false;
    };

    publicAPI[`set${capitalize(field)}From`] = (otherArray) => {
      const target = model[field];
      otherArray.forEach((v, i) => {
        target[i] = v;
      });
    };
  });
}

// ----------------------------------------------------------------------------
// set/get XXX: add setter and getter for object of type array
// ----------------------------------------------------------------------------

function setGetArray(
  publicAPI,
  model,
  fieldNames,
  size,
  defaultVal = undefined
) {
  getArray(publicAPI, model, fieldNames);
  setArray(publicAPI, model, fieldNames, size, defaultVal);
}

// ----------------------------------------------------------------------------
// vtkAlgorithm: setInputData(), setInputConnection(), getOutputData(), getOutputPort()
// ----------------------------------------------------------------------------

function algo(publicAPI, model, numberOfInputs, numberOfOutputs) {
  if (model.inputData) {
    model.inputData = model.inputData.map(_vtk__WEBPACK_IMPORTED_MODULE_0__["default"]);
  } else {
    model.inputData = [];
  }

  if (model.inputConnection) {
    model.inputConnection = model.inputConnection.map(_vtk__WEBPACK_IMPORTED_MODULE_0__["default"]);
  } else {
    model.inputConnection = [];
  }

  if (model.output) {
    model.output = model.output.map(_vtk__WEBPACK_IMPORTED_MODULE_0__["default"]);
  } else {
    model.output = [];
  }

  if (model.inputArrayToProcess) {
    model.inputArrayToProcess = model.inputArrayToProcess.map(_vtk__WEBPACK_IMPORTED_MODULE_0__["default"]);
  } else {
    model.inputArrayToProcess = [];
  }

  // Cache the argument for later manipulation
  model.numberOfInputs = numberOfInputs;

  // Methods
  function setInputData(dataset, port = 0) {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    if (port >= model.numberOfInputs) {
      vtkErrorMacro(
        `algorithm ${publicAPI.getClassName()} only has ${
          model.numberOfInputs
        } input ports. To add more input ports, use addInputData()`
      );
      return;
    }
    if (model.inputData[port] !== dataset || model.inputConnection[port]) {
      model.inputData[port] = dataset;
      model.inputConnection[port] = null;
      if (publicAPI.modified) {
        publicAPI.modified();
      }
    }
  }

  function getInputData(port = 0) {
    if (model.inputConnection[port]) {
      model.inputData[port] = model.inputConnection[port]();
    }
    return model.inputData[port];
  }

  function setInputConnection(outputPort, port = 0) {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    if (port >= model.numberOfInputs) {
      let msg = `algorithm ${publicAPI.getClassName()} only has `;
      msg += `${model.numberOfInputs}`;
      msg += ' input ports. To add more input ports, use addInputConnection()';
      vtkErrorMacro(msg);
      return;
    }
    model.inputData[port] = null;
    model.inputConnection[port] = outputPort;
  }

  function getInputConnection(port = 0) {
    return model.inputConnection[port];
  }

  function addInputConnection(outputPort) {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    model.numberOfInputs++;
    setInputConnection(outputPort, model.numberOfInputs - 1);
  }

  function addInputData(dataset) {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    model.numberOfInputs++;
    setInputData(dataset, model.numberOfInputs - 1);
  }

  function getOutputData(port = 0) {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return null;
    }
    if (publicAPI.shouldUpdate()) {
      publicAPI.update();
    }
    return model.output[port];
  }

  publicAPI.shouldUpdate = () => {
    const localMTime = publicAPI.getMTime();
    let count = numberOfOutputs;
    let minOutputMTime = Infinity;
    while (count--) {
      if (!model.output[count]) {
        return true;
      }
      const mt = model.output[count].getMTime();
      if (mt < localMTime) {
        return true;
      }
      if (mt < minOutputMTime) {
        minOutputMTime = mt;
      }
    }

    count = model.numberOfInputs;
    while (count--) {
      if (
        model.inputConnection[count] &&
        model.inputConnection[count].filter.shouldUpdate()
      ) {
        return true;
      }
    }

    count = model.numberOfInputs;
    while (count--) {
      if (
        publicAPI.getInputData(count) &&
        publicAPI.getInputData(count).getMTime() > minOutputMTime
      ) {
        return true;
      }
    }
    return false;
  };

  function getOutputPort(port = 0) {
    const outputPortAccess = () => getOutputData(port);
    // Add reference to filter
    outputPortAccess.filter = publicAPI;
    return outputPortAccess;
  }

  // Handle input if needed
  if (model.numberOfInputs) {
    // Reserve inputs
    let count = model.numberOfInputs;
    while (count--) {
      model.inputData.push(null);
      model.inputConnection.push(null);
    }

    // Expose public methods
    publicAPI.setInputData = setInputData;
    publicAPI.setInputConnection = setInputConnection;
    publicAPI.addInputData = addInputData;
    publicAPI.addInputConnection = addInputConnection;
    publicAPI.getInputData = getInputData;
    publicAPI.getInputConnection = getInputConnection;
  }

  if (numberOfOutputs) {
    publicAPI.getOutputData = getOutputData;
    publicAPI.getOutputPort = getOutputPort;
  }

  publicAPI.update = () => {
    const ins = [];
    if (model.numberOfInputs) {
      let count = 0;
      while (count < model.numberOfInputs) {
        ins[count] = publicAPI.getInputData(count);
        count++;
      }
    }
    if (publicAPI.shouldUpdate() && publicAPI.requestData) {
      publicAPI.requestData(ins, model.output);
    }
  };

  publicAPI.getNumberOfInputPorts = () => model.numberOfInputs;
  publicAPI.getNumberOfOutputPorts = () =>
    numberOfOutputs || model.output.length;

  publicAPI.getInputArrayToProcess = (inputPort) => {
    const arrayDesc = model.inputArrayToProcess[inputPort];
    const ds = model.inputData[inputPort];
    if (arrayDesc && ds) {
      return ds[`get${arrayDesc.fieldAssociation}`]().getArray(
        arrayDesc.arrayName
      );
    }
    return null;
  };
  publicAPI.setInputArrayToProcess = (
    inputPort,
    arrayName,
    fieldAssociation,
    attributeType = 'Scalars'
  ) => {
    while (model.inputArrayToProcess.length < inputPort) {
      model.inputArrayToProcess.push(null);
    }
    model.inputArrayToProcess[inputPort] = {
      arrayName,
      fieldAssociation,
      attributeType,
    };
  };
}

// ----------------------------------------------------------------------------
// Event handling: onXXX(callback), invokeXXX(args...)
// ----------------------------------------------------------------------------

const EVENT_ABORT = Symbol('Event abort');

function event(publicAPI, model, eventName) {
  const callbacks = [];
  const previousDelete = publicAPI.delete;
  let curCallbackID = 1;

  function off(callbackID) {
    for (let i = 0; i < callbacks.length; ++i) {
      const [cbID] = callbacks[i];
      if (cbID === callbackID) {
        callbacks.splice(i, 1);
        return;
      }
    }
  }

  function on(callbackID) {
    function unsubscribe() {
      off(callbackID);
    }
    return Object.freeze({
      unsubscribe,
    });
  }

  function invoke() {
    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return;
    }
    /* eslint-disable prefer-rest-params */
    // Go through a copy of the callbacks array in case new callbacks
    // get prepended within previous callbacks
    const currentCallbacks = callbacks.slice();
    for (let index = 0; index < currentCallbacks.length; ++index) {
      const [, cb, priority] = currentCallbacks[index];

      if (!cb) {
        continue; // eslint-disable-line
      }

      if (priority < 0) {
        setTimeout(() => cb.apply(publicAPI, arguments), 1 - priority);
      } else {
        // Abort only if the callback explicitly returns false
        const continueNext = cb.apply(publicAPI, arguments);
        if (continueNext === EVENT_ABORT) {
          break;
        }
      }
    }
    /* eslint-enable prefer-rest-params */
  }

  publicAPI[`invoke${capitalize(eventName)}`] = invoke;

  publicAPI[`on${capitalize(eventName)}`] = (callback, priority = 0.0) => {
    if (!callback.apply) {
      console.error(`Invalid callback for event ${eventName}`);
      return null;
    }

    if (model.deleted) {
      vtkErrorMacro('instance deleted - cannot call any method');
      return null;
    }

    const callbackID = curCallbackID++;
    callbacks.push([callbackID, callback, priority]);
    callbacks.sort((cb1, cb2) => cb2[2] - cb1[2]);
    return on(callbackID);
  };

  publicAPI.delete = () => {
    previousDelete();
    callbacks.forEach(([cbID]) => off(cbID));
  };
}

// ----------------------------------------------------------------------------
// newInstance
// ----------------------------------------------------------------------------

function newInstance(extend, className) {
  const constructor = (initialValues = {}) => {
    const model = {};
    const publicAPI = {};
    extend(publicAPI, model, initialValues);

    return Object.freeze(publicAPI);
  };

  // Register constructor to factory
  if (className) {
    _vtk__WEBPACK_IMPORTED_MODULE_0__["default"].register(className, constructor);
  }

  return constructor;
}

// ----------------------------------------------------------------------------
// Chain function calls
// ----------------------------------------------------------------------------

function chain(...fn) {
  return (...args) => fn.filter((i) => !!i).map((i) => i(...args));
}

// ----------------------------------------------------------------------------
// Some utility methods for vtk objects
// ----------------------------------------------------------------------------

function isVtkObject(instance) {
  return instance && instance.isA && instance.isA('vtkObject');
}

function traverseInstanceTree(
  instance,
  extractFunction,
  accumulator = [],
  visitedInstances = []
) {
  if (isVtkObject(instance)) {
    if (visitedInstances.indexOf(instance) >= 0) {
      // avoid cycles
      return accumulator;
    }

    visitedInstances.push(instance);
    const result = extractFunction(instance);
    if (result !== undefined) {
      accumulator.push(result);
    }

    // Now go through this instance's model
    const model = instance.get();
    Object.keys(model).forEach((key) => {
      const modelObj = model[key];
      if (Array.isArray(modelObj)) {
        modelObj.forEach((subObj) => {
          traverseInstanceTree(
            subObj,
            extractFunction,
            accumulator,
            visitedInstances
          );
        });
      } else {
        traverseInstanceTree(
          modelObj,
          extractFunction,
          accumulator,
          visitedInstances
        );
      }
    });
  }

  return accumulator;
}

// ----------------------------------------------------------------------------
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.

function debounce(func, wait, immediate) {
  let timeout;
  return (...args) => {
    const context = this;
    const later = () => {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}

// ----------------------------------------------------------------------------
// Creates a throttled function that only invokes `func` at most once per
// every `wait` milliseconds.

function throttle(callback, delay) {
  let isThrottled = false;
  let argsToUse = null;

  function next() {
    isThrottled = false;
    if (argsToUse !== null) {
      wrapper(...argsToUse); // eslint-disable-line
      argsToUse = null;
    }
  }

  function wrapper(...args) {
    if (isThrottled) {
      argsToUse = args;
      return;
    }
    isThrottled = true;
    callback(...args);
    setTimeout(next, delay);
  }

  return wrapper;
}

// ----------------------------------------------------------------------------
// keystore(publicAPI, model, initialKeystore)
//
//    - initialKeystore: Initial keystore. This can be either a Map or an
//      object.
//
// Generated API
//  setKey(key, value) : mixed (returns value)
//  getKey(key) : mixed
//  getAllKeys() : [mixed]
//  deleteKey(key) : Boolean
// ----------------------------------------------------------------------------

function keystore(publicAPI, model, initialKeystore = {}) {
  model.keystore = Object.assign(model.keystore || {}, initialKeystore);

  publicAPI.setKey = (key, value) => {
    model.keystore[key] = value;
  };
  publicAPI.getKey = (key) => model.keystore[key];
  publicAPI.getAllKeys = () => Object.keys(model.keystore);
  publicAPI.deleteKey = (key) => delete model.keystore[key];
  publicAPI.clearKeystore = () =>
    publicAPI.getAllKeys().forEach((key) => delete model.keystore[key]);
}

// ----------------------------------------------------------------------------
// proxy(publicAPI, model, sectionName, propertyUI)
//
//    - sectionName: Name of the section for UI
//    - propertyUI: List of props with their UI description
//
// Generated API
//  getProxyId() : String
//  listProxyProperties() : [string]
//  updateProxyProperty(name, prop)
//  getProxySection() => List of properties for UI generation
// ----------------------------------------------------------------------------
let nextProxyId = 1;
const ROOT_GROUP_NAME = '__root__';

function proxy(publicAPI, model) {
  // Proxies are keystores
  keystore(publicAPI, model);

  const parentDelete = publicAPI.delete;

  // getProxyId
  model.proxyId = `${nextProxyId++}`;

  // ui handling
  model.ui = JSON.parse(JSON.stringify(model.ui || [])); // deep copy
  get(publicAPI, model, ['proxyId', 'proxyGroup', 'proxyName']);
  setGet(publicAPI, model, ['proxyManager']);

  // group properties
  const propertyMap = {};
  const groupChildrenNames = {};

  function registerProperties(descriptionList, currentGroupName) {
    if (!groupChildrenNames[currentGroupName]) {
      groupChildrenNames[currentGroupName] = [];
    }
    const childrenNames = groupChildrenNames[currentGroupName];

    for (let i = 0; i < descriptionList.length; i++) {
      childrenNames.push(descriptionList[i].name);
      propertyMap[descriptionList[i].name] = descriptionList[i];
      if (descriptionList[i].children && descriptionList[i].children.length) {
        registerProperties(
          descriptionList[i].children,
          descriptionList[i].name
        );
      }
    }
  }
  registerProperties(model.ui, ROOT_GROUP_NAME);

  publicAPI.updateUI = (ui) => {
    model.ui = JSON.parse(JSON.stringify(ui || [])); // deep copy
    Object.keys(propertyMap).forEach((k) => delete propertyMap[k]);
    Object.keys(groupChildrenNames).forEach(
      (k) => delete groupChildrenNames[k]
    );
    registerProperties(model.ui, ROOT_GROUP_NAME);
    publicAPI.modified();
  };

  function listProxyProperties(gName = ROOT_GROUP_NAME) {
    return groupChildrenNames[gName];
  }

  publicAPI.updateProxyProperty = (propertyName, propUI) => {
    const prop = propertyMap[propertyName];
    if (prop) {
      Object.assign(prop, propUI);
    } else {
      propertyMap[propertyName] = { ...propUI };
    }
  };

  publicAPI.activate = () => {
    if (model.proxyManager) {
      const setActiveMethod = `setActive${capitalize(
        publicAPI.getProxyGroup().slice(0, -1)
      )}`;
      if (model.proxyManager[setActiveMethod]) {
        model.proxyManager[setActiveMethod](publicAPI);
      }
    }
  };

  // property link
  model.propertyLinkSubscribers = {};
  publicAPI.registerPropertyLinkForGC = (otherLink, type) => {
    if (!(type in model.propertyLinkSubscribers)) {
      model.propertyLinkSubscribers[type] = [];
    }
    model.propertyLinkSubscribers[type].push(otherLink);
  };

  publicAPI.gcPropertyLinks = (type) => {
    const subscribers = model.propertyLinkSubscribers[type] || [];
    while (subscribers.length) {
      subscribers.pop().unbind(publicAPI);
    }
  };

  model.propertyLinkMap = {};
  publicAPI.getPropertyLink = (id, persistent = false) => {
    if (model.propertyLinkMap[id]) {
      return model.propertyLinkMap[id];
    }
    let value = null;
    const links = [];
    let count = 0;
    let updateInProgress = false;

    function update(source, force = false) {
      if (updateInProgress) {
        return null;
      }

      const needUpdate = [];
      let sourceLink = null;
      count = links.length;
      while (count--) {
        const link = links[count];
        if (link.instance === source) {
          sourceLink = link;
        } else {
          needUpdate.push(link);
        }
      }

      if (!sourceLink) {
        return null;
      }

      const newValue = sourceLink.instance[
        `get${capitalize(sourceLink.propertyName)}`
      ]();
      if (!shallowEquals(newValue, value) || force) {
        value = newValue;
        updateInProgress = true;
        while (needUpdate.length) {
          const linkToUpdate = needUpdate.pop();
          linkToUpdate.instance.set({
            [linkToUpdate.propertyName]: value,
          });
        }
        updateInProgress = false;
      }

      if (model.propertyLinkMap[id].persistent) {
        model.propertyLinkMap[id].value = newValue;
      }

      return newValue;
    }

    function unbind(instance, propertyName) {
      const indexToDelete = [];
      count = links.length;
      while (count--) {
        const link = links[count];
        if (
          link.instance === instance &&
          (link.propertyName === propertyName || propertyName === undefined)
        ) {
          link.subscription.unsubscribe();
          indexToDelete.push(count);
        }
      }
      while (indexToDelete.length) {
        links.splice(indexToDelete.pop(), 1);
      }
    }

    function bind(instance, propertyName, updateMe = false) {
      const subscription = instance.onModified(update);
      const other = links[0];
      links.push({
        instance,
        propertyName,
        subscription,
      });
      if (updateMe) {
        if (
          model.propertyLinkMap[id].persistent &&
          model.propertyLinkMap[id].value !== undefined
        ) {
          instance.set({
            [propertyName]: model.propertyLinkMap[id].value,
          });
        } else if (other) {
          update(other.instance, true);
        }
      }
      return {
        unsubscribe: () => unbind(instance, propertyName),
      };
    }

    function unsubscribe() {
      while (links.length) {
        links.pop().subscription.unsubscribe();
      }
    }

    const linkHandler = {
      bind,
      unbind,
      unsubscribe,
      persistent,
    };
    model.propertyLinkMap[id] = linkHandler;
    return linkHandler;
  };

  // extract values
  function getProperties(groupName = ROOT_GROUP_NAME) {
    const values = [];
    const id = model.proxyId;
    const propertyNames = listProxyProperties(groupName) || [];
    for (let i = 0; i < propertyNames.length; i++) {
      const name = propertyNames[i];
      const method = publicAPI[`get${capitalize(name)}`];
      const value = method ? method() : undefined;
      const prop = {
        id,
        name,
        value,
      };
      const children = getProperties(name);
      if (children.length) {
        prop.children = children;
      }
      values.push(prop);
    }
    return values;
  }

  publicAPI.listPropertyNames = () => getProperties().map((p) => p.name);

  publicAPI.getPropertyByName = (name) =>
    getProperties().find((p) => p.name === name);

  publicAPI.getPropertyDomainByName = (name) =>
    (propertyMap[name] || {}).domain;

  // ui section
  publicAPI.getProxySection = () => ({
    id: model.proxyId,
    name: model.proxyGroup,
    ui: model.ui,
    properties: getProperties(),
  });

  // free resources
  publicAPI.delete = () => {
    const list = Object.keys(model.propertyLinkMap);
    let count = list.length;
    while (count--) {
      model.propertyLinkMap[list[count]].unsubscribe();
    }
    Object.keys(model.propertyLinkSubscribers).forEach(
      publicAPI.gcPropertyLinks
    );
    parentDelete();
  };

  function registerLinks() {
    // Allow dynamic registration of links at the application level
    if (model.links) {
      for (let i = 0; i < model.links.length; i++) {
        const { link, property, persistent, updateOnBind, type } = model.links[
          i
        ];
        if (type === 'application') {
          const sLink = model.proxyManager.getPropertyLink(link, persistent);
          publicAPI.registerPropertyLinkForGC(sLink, 'application');
          sLink.bind(publicAPI, property, updateOnBind);
        }
      }
    }
  }
  setImmediateVTK(registerLinks);
}

// ----------------------------------------------------------------------------
// proxyPropertyMapping(publicAPI, model, map)
//
//   map = {
//      opacity: { modelKey: 'property', property: 'opacity' },
//   }
//
// Generated API:
//  Elevate set/get methods from internal object stored in the model to current one
// ----------------------------------------------------------------------------

function proxyPropertyMapping(publicAPI, model, map) {
  const parentDelete = publicAPI.delete;
  const subscriptions = [];

  const propertyNames = Object.keys(map);
  let count = propertyNames.length;
  while (count--) {
    const propertyName = propertyNames[count];
    const { modelKey, property, modified = true } = map[propertyName];
    const methodSrc = capitalize(property);
    const methodDst = capitalize(propertyName);
    publicAPI[`get${methodDst}`] = model[modelKey][`get${methodSrc}`];
    publicAPI[`set${methodDst}`] = model[modelKey][`set${methodSrc}`];
    if (modified) {
      subscriptions.push(model[modelKey].onModified(publicAPI.modified));
    }
  }

  publicAPI.delete = () => {
    while (subscriptions.length) {
      subscriptions.pop().unsubscribe();
    }
    parentDelete();
  };
}

// ----------------------------------------------------------------------------
// proxyPropertyState(publicAPI, model, state, defaults)
//
//   state = {
//     representation: {
//       'Surface with edges': { property: { edgeVisibility: true, representation: 2 } },
//       Surface: { property: { edgeVisibility: false, representation: 2 } },
//       Wireframe: { property: { edgeVisibility: false, representation: 1 } },
//       Points: { property: { edgeVisibility: false, representation: 0 } },
//     },
//   }
//
//   defaults = {
//      representation: 'Surface',
//   }
//
// Generated API
//   get / set Representation ( string ) => push state to various internal objects
// ----------------------------------------------------------------------------

function proxyPropertyState(
  publicAPI,
  model,
  state = {},
  defaults = {}
) {
  model.this = publicAPI;

  function applyState(map) {
    const modelKeys = Object.keys(map);
    let count = modelKeys.length;
    while (count--) {
      const modelKey = modelKeys[count];
      model[modelKey].set(map[modelKey]);
    }
  }

  const modelKeys = Object.keys(defaults);
  let count = modelKeys.length;
  while (count--) {
    // Add default
    const key = modelKeys[count];
    model[key] = defaults[key];

    // Add set method
    const mapping = state[key];
    publicAPI[`set${capitalize(key)}`] = (value) => {
      if (value !== model[key]) {
        model[key] = value;
        const propValues = mapping[value];
        applyState(propValues);
        publicAPI.modified();
      }
    };
  }

  // Add getter
  if (modelKeys.length) {
    get(publicAPI, model, modelKeys);
  }
}

// ----------------------------------------------------------------------------
// From : https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
//
//
// Copyright (c) 2015, Facebook, Inc.
// All rights reserved.
//
// This source code is licensed under the BSD-style license found in the
// LICENSE file in the root directory of this source tree. An additional grant
// of patent rights can be found in the PATENTS file in the same directory.
//
//
// Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
// complicated, thus this doc is long and (hopefully) detailed enough to answer
// your questions.
//
// If you need to react to the mouse wheel in a predictable way, this code is
// like your bestest friend.// hugs//
//
// As of today, there are 4 DOM event types you can listen to:
//
//   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
//   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
//   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
//   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
//
// So what to do?  The is the best:
//
//   normalizeWheel.getEventType();
//
// In your event callback, use this code to get sane interpretation of the
// deltas.  This code will return an object with properties:
//
//   spinX   -- normalized spin speed (use for zoom) - x plane
//   spinY   -- " - y plane
//   pixelX  -- normalized distance (to pixels) - x plane
//   pixelY  -- " - y plane
//
// Wheel values are provided by the browser assuming you are using the wheel to
// scroll a web page by a number of lines or pixels (or pages).  Values can vary
// significantly on different platforms and browsers, forgetting that you can
// scroll at different speeds.  Some devices (like trackpads) emit more events
// at smaller increments with fine granularity, and some emit massive jumps with
// linear speed or acceleration.
//
// This code does its best to normalize the deltas for you:
//
//   - spin is trying to normalize how far the wheel was spun (or trackpad
//     dragged).  This is super useful for zoom support where you want to
//     throw away the chunky scroll steps on the PC and make those equal to
//     the slow and smooth tiny steps on the Mac. Key data: This code tries to
//     resolve a single slow step on a wheel to 1.
//
//   - pixel is normalizing the desired scroll delta in pixel units.  You'll
//     get the crazy differences between browsers, but at least it'll be in
//     pixels!
//
//   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
//     should translate to positive value zooming IN, negative zooming OUT.
//     This matches the newer 'wheel' event.
//
// Why are there spinX, spinY (or pixels)?
//
//   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
//     with a mouse.  It results in side-scrolling in the browser by default.
//
//   - spinY is what you expect -- it's the classic axis of a mouse wheel.
//
//   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
//     probably is by browsers in conjunction with fancy 3D controllers .. but
//     you know.
//
// Implementation info:
//
// Examples of 'wheel' event if you scroll slowly (down) by one step with an
// average mouse:
//
//   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
//   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
//   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
//   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
//   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
//
// On the trackpad:
//
//   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
//   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
//
// On other/older browsers.. it's more complicated as there can be multiple and
// also missing delta values.
//
// The 'wheel' event is more standard:
//
// http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
//
// The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
// deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
// backward compatibility with older events.  Those other values help us
// better normalize spin speed.  Example of what the browsers provide:
//
//                          | event.wheelDelta | event.detail
//        ------------------+------------------+--------------
//          Safari v5/OS X  |       -120       |       0
//          Safari v5/Win7  |       -120       |       0
//         Chrome v17/OS X  |       -120       |       0
//         Chrome v17/Win7  |       -120       |       0
//                IE9/Win7  |       -120       |   undefined
//         Firefox v4/OS X  |     undefined    |       1
//         Firefox v4/Win7  |     undefined    |       3
//
// ----------------------------------------------------------------------------

// Reasonable defaults
const PIXEL_STEP = 10;
const LINE_HEIGHT = 40;
const PAGE_HEIGHT = 800;

function normalizeWheel(wheelEvent) {
  let sX = 0; // spinX
  let sY = 0; // spinY
  let pX = 0; // pixelX
  let pY = 0; // pixelY

  // Legacy
  if ('detail' in wheelEvent) {
    sY = wheelEvent.detail;
  }
  if ('wheelDelta' in wheelEvent) {
    sY = -wheelEvent.wheelDelta / 120;
  }
  if ('wheelDeltaY' in wheelEvent) {
    sY = -wheelEvent.wheelDeltaY / 120;
  }
  if ('wheelDeltaX' in wheelEvent) {
    sX = -wheelEvent.wheelDeltaX / 120;
  }

  // side scrolling on FF with DOMMouseScroll
  if ('axis' in wheelEvent && wheelEvent.axis === wheelEvent.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }

  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;

  if ('deltaY' in wheelEvent) {
    pY = wheelEvent.deltaY;
  }
  if ('deltaX' in wheelEvent) {
    pX = wheelEvent.deltaX;
  }

  if ((pX || pY) && wheelEvent.deltaMode) {
    if (wheelEvent.deltaMode === 1) {
      // delta in LINE units
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {
      // delta in PAGE units
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }

  // Fall-back if spin cannot be determined
  if (pX && !sX) {
    sX = pX < 1 ? -1 : 1;
  }
  if (pY && !sY) {
    sY = pY < 1 ? -1 : 1;
  }

  return {
    spinX: sX,
    spinY: sY,
    pixelX: pX,
    pixelY: pY,
  };
}

// ----------------------------------------------------------------------------
// Default export
// ----------------------------------------------------------------------------

/* harmony default export */ __webpack_exports__["default"] = ({
  algo,
  capitalize,
  chain,
  debounce,
  enumToString,
  event,
  EVENT_ABORT,
  formatBytesToProperUnit,
  formatNumbersWithThousandSeparator,
  get,
  getArray,
  getCurrentGlobalMTime,
  getStateArrayMapFunc,
  isVtkObject,
  keystore,
  newInstance,
  normalizeWheel,
  obj,
  proxy,
  proxyPropertyMapping,
  proxyPropertyState,
  safeArrays,
  set,
  setArray,
  setGet,
  setGetArray,
  setImmediate: setImmediateVTK,
  setLoggerFunction,
  throttle,
  traverseInstanceTree,
  TYPED_ARRAYS,
  uncapitalize,
  VOID,
  vtkDebugMacro,
  vtkErrorMacro,
  vtkInfoMacro,
  vtkLogMacro,
  vtkOnceErrorMacro,
  vtkWarningMacro,
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/vtk.js/Sources/vtk.js":
/*!********************************************!*\
  !*** ./node_modules/vtk.js/Sources/vtk.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return vtk; });
const factoryMapping = {
  vtkObject: () => null,
};

function vtk(obj) {
  if (obj === null || obj === undefined) {
    return obj;
  }
  if (obj.isA) {
    return obj;
  }
  if (!obj.vtkClass) {
    if (global.console && global.console.error) {
      global.console.error('Invalid VTK object');
    }
    return null;
  }
  const constructor = factoryMapping[obj.vtkClass];
  if (!constructor) {
    if (global.console && global.console.error) {
      global.console.error(
        `No vtk class found for Object of type ${obj.vtkClass}`
      );
    }
    return null;
  }

  // Shallow copy object
  const model = { ...obj };

  // Convert into vtkObject any nested key
  Object.keys(model).forEach((keyName) => {
    if (
      model[keyName] &&
      typeof model[keyName] === 'object' &&
      model[keyName].vtkClass
    ) {
      model[keyName] = vtk(model[keyName]);
    }
  });

  // Return the root
  const newInst = constructor(model);
  if (newInst && newInst.modified) {
    newInst.modified();
  }
  return newInst;
}

function register(vtkClassName, constructor) {
  factoryMapping[vtkClassName] = constructor;
}

// Nest register method under the vtk function
vtk.register = register;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-define.js":
/*!***************************************!*\
  !*** (webpack)/buildin/amd-define.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function() {
	throw new Error("define cannot be used indirect");
};


/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webvr-polyfill/build/webvr-polyfill.js":
/*!*************************************************************!*\
  !*** ./node_modules/webvr-polyfill/build/webvr-polyfill.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * @license
 * webvr-polyfill
 * Copyright (c) 2015-2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * cardboard-vr-display
 * Copyright (c) 2015-2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * webvr-polyfill-dpdb 
 * Copyright (c) 2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @license
 * wglu-preserve-state
 * Copyright (c) 2016, Brandon Jones.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/**
 * @license
 * nosleep.js
 * Copyright (c) 2017, Rich Tibbett
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};



function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var isMobile = function isMobile() {
  return (/Android/i.test(navigator.userAgent) || /iPhone|iPad|iPod/i.test(navigator.userAgent)
  );
};
var copyArray = function copyArray(source, dest) {
  for (var i = 0, n = source.length; i < n; i++) {
    dest[i] = source[i];
  }
};
var extend = function extend(dest, src) {
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      dest[key] = src[key];
    }
  }
  return dest;
};

var cardboardVrDisplay = createCommonjsModule(function (module, exports) {
/**
 * @license
 * cardboard-vr-display
 * Copyright (c) 2015-2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * gl-preserve-state
 * Copyright (c) 2016, Brandon Jones.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/**
 * @license
 * webvr-polyfill-dpdb
 * Copyright (c) 2015-2017 Google
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * nosleep.js
 * Copyright (c) 2017, Rich Tibbett
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
(function (global, factory) {
	module.exports = factory();
}(commonjsGlobal, (function () { var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }
  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var MIN_TIMESTEP = 0.001;
var MAX_TIMESTEP = 1;
var dataUri = function dataUri(mimeType, svg) {
  return 'data:' + mimeType + ',' + encodeURIComponent(svg);
};
var lerp = function lerp(a, b, t) {
  return a + (b - a) * t;
};
var isIOS = function () {
  var isIOS = /iPad|iPhone|iPod/.test(navigator.platform);
  return function () {
    return isIOS;
  };
}();
var isWebViewAndroid = function () {
  var isWebViewAndroid = navigator.userAgent.indexOf('Version') !== -1 && navigator.userAgent.indexOf('Android') !== -1 && navigator.userAgent.indexOf('Chrome') !== -1;
  return function () {
    return isWebViewAndroid;
  };
}();
var isSafari = function () {
  var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  return function () {
    return isSafari;
  };
}();
var isFirefoxAndroid = function () {
  var isFirefoxAndroid = navigator.userAgent.indexOf('Firefox') !== -1 && navigator.userAgent.indexOf('Android') !== -1;
  return function () {
    return isFirefoxAndroid;
  };
}();
var getChromeVersion = function () {
  var match = navigator.userAgent.match(/.*Chrome\/([0-9]+)/);
  var value = match ? parseInt(match[1], 10) : null;
  return function () {
    return value;
  };
}();
var isSafariWithoutDeviceMotion = function () {
  var value = false;
  value = isIOS() && isSafari() && navigator.userAgent.indexOf('13_4') !== -1;
  return function () {
    return value;
  };
}();
var isChromeWithoutDeviceMotion = function () {
  var value = false;
  if (getChromeVersion() === 65) {
    var match = navigator.userAgent.match(/.*Chrome\/([0-9\.]*)/);
    if (match) {
      var _match$1$split = match[1].split('.'),
          _match$1$split2 = slicedToArray(_match$1$split, 4),
          major = _match$1$split2[0],
          minor = _match$1$split2[1],
          branch = _match$1$split2[2],
          build = _match$1$split2[3];
      value = parseInt(branch, 10) === 3325 && parseInt(build, 10) < 148;
    }
  }
  return function () {
    return value;
  };
}();
var isR7 = function () {
  var isR7 = navigator.userAgent.indexOf('R7 Build') !== -1;
  return function () {
    return isR7;
  };
}();
var isLandscapeMode = function isLandscapeMode() {
  var rtn = window.orientation == 90 || window.orientation == -90;
  return isR7() ? !rtn : rtn;
};
var isTimestampDeltaValid = function isTimestampDeltaValid(timestampDeltaS) {
  if (isNaN(timestampDeltaS)) {
    return false;
  }
  if (timestampDeltaS <= MIN_TIMESTEP) {
    return false;
  }
  if (timestampDeltaS > MAX_TIMESTEP) {
    return false;
  }
  return true;
};
var getScreenWidth = function getScreenWidth() {
  return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio;
};
var getScreenHeight = function getScreenHeight() {
  return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio;
};
var requestFullscreen = function requestFullscreen(element) {
  if (isWebViewAndroid()) {
    return false;
  }
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen();
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen();
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen();
  } else {
    return false;
  }
  return true;
};
var exitFullscreen = function exitFullscreen() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  } else {
    return false;
  }
  return true;
};
var getFullscreenElement = function getFullscreenElement() {
  return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
};
var linkProgram = function linkProgram(gl, vertexSource, fragmentSource, attribLocationMap) {
  var vertexShader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertexShader, vertexSource);
  gl.compileShader(vertexShader);
  var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragmentShader, fragmentSource);
  gl.compileShader(fragmentShader);
  var program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  for (var attribName in attribLocationMap) {
    gl.bindAttribLocation(program, attribLocationMap[attribName], attribName);
  }gl.linkProgram(program);
  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);
  return program;
};
var getProgramUniforms = function getProgramUniforms(gl, program) {
  var uniforms = {};
  var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
  var uniformName = '';
  for (var i = 0; i < uniformCount; i++) {
    var uniformInfo = gl.getActiveUniform(program, i);
    uniformName = uniformInfo.name.replace('[0]', '');
    uniforms[uniformName] = gl.getUniformLocation(program, uniformName);
  }
  return uniforms;
};
var orthoMatrix = function orthoMatrix(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right),
      bt = 1 / (bottom - top),
      nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
};
var isMobile = function isMobile() {
  var check = false;
  (function (a) {
    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) check = true;
  })(navigator.userAgent || navigator.vendor || window.opera);
  return check;
};
var extend = function extend(dest, src) {
  for (var key in src) {
    if (src.hasOwnProperty(key)) {
      dest[key] = src[key];
    }
  }
  return dest;
};
var safariCssSizeWorkaround = function safariCssSizeWorkaround(canvas) {
  if (isIOS()) {
    var width = canvas.style.width;
    var height = canvas.style.height;
    canvas.style.width = parseInt(width) + 1 + 'px';
    canvas.style.height = parseInt(height) + 'px';
    setTimeout(function () {
      canvas.style.width = width;
      canvas.style.height = height;
    }, 100);
  }
  window.canvas = canvas;
};
var frameDataFromPose = function () {
  var piOver180 = Math.PI / 180.0;
  var rad45 = Math.PI * 0.25;
  function mat4_perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov ? fov.upDegrees * piOver180 : rad45),
        downTan = Math.tan(fov ? fov.downDegrees * piOver180 : rad45),
        leftTan = Math.tan(fov ? fov.leftDegrees * piOver180 : rad45),
        rightTan = Math.tan(fov ? fov.rightDegrees * piOver180 : rad45),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = far * near / (near - far);
    out[15] = 0.0;
    return out;
  }
  function mat4_fromRotationTranslation(out, q, v) {
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,
        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function mat4_translate(out, a, v) {
    var x = v[0],
        y = v[1],
        z = v[2],
        a00,
        a01,
        a02,
        a03,
        a10,
        a11,
        a12,
        a13,
        a20,
        a21,
        a22,
        a23;
    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
      a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
      a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];
      out[0] = a00;out[1] = a01;out[2] = a02;out[3] = a03;
      out[4] = a10;out[5] = a11;out[6] = a12;out[7] = a13;
      out[8] = a20;out[9] = a21;out[10] = a22;out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
  }
  function mat4_invert(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11],
        a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15],
        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,
    det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  var defaultOrientation = new Float32Array([0, 0, 0, 1]);
  var defaultPosition = new Float32Array([0, 0, 0]);
  function updateEyeMatrices(projection, view, pose, fov, offset, vrDisplay) {
    mat4_perspectiveFromFieldOfView(projection, fov || null, vrDisplay.depthNear, vrDisplay.depthFar);
    var orientation = pose.orientation || defaultOrientation;
    var position = pose.position || defaultPosition;
    mat4_fromRotationTranslation(view, orientation, position);
    if (offset) mat4_translate(view, view, offset);
    mat4_invert(view, view);
  }
  return function (frameData, pose, vrDisplay) {
    if (!frameData || !pose) return false;
    frameData.pose = pose;
    frameData.timestamp = pose.timestamp;
    updateEyeMatrices(frameData.leftProjectionMatrix, frameData.leftViewMatrix, pose, vrDisplay._getFieldOfView("left"), vrDisplay._getEyeOffset("left"), vrDisplay);
    updateEyeMatrices(frameData.rightProjectionMatrix, frameData.rightViewMatrix, pose, vrDisplay._getFieldOfView("right"), vrDisplay._getEyeOffset("right"), vrDisplay);
    return true;
  };
}();
var isInsideCrossOriginIFrame = function isInsideCrossOriginIFrame() {
  var isFramed = window.self !== window.top;
  var refOrigin = getOriginFromUrl(document.referrer);
  var thisOrigin = getOriginFromUrl(window.location.href);
  return isFramed && refOrigin !== thisOrigin;
};
var getOriginFromUrl = function getOriginFromUrl(url) {
  var domainIdx;
  var protoSepIdx = url.indexOf("://");
  if (protoSepIdx !== -1) {
    domainIdx = protoSepIdx + 3;
  } else {
    domainIdx = 0;
  }
  var domainEndIdx = url.indexOf('/', domainIdx);
  if (domainEndIdx === -1) {
    domainEndIdx = url.length;
  }
  return url.substring(0, domainEndIdx);
};
var getQuaternionAngle = function getQuaternionAngle(quat) {
  if (quat.w > 1) {
    console.warn('getQuaternionAngle: w > 1');
    return 0;
  }
  var angle = 2 * Math.acos(quat.w);
  return angle;
};
var warnOnce = function () {
  var observedWarnings = {};
  return function (key, message) {
    if (observedWarnings[key] === undefined) {
      console.warn('webvr-polyfill: ' + message);
      observedWarnings[key] = true;
    }
  };
}();
var deprecateWarning = function deprecateWarning(deprecated, suggested) {
  var alternative = suggested ? 'Please use ' + suggested + ' instead.' : '';
  warnOnce(deprecated, deprecated + ' has been deprecated. ' + 'This may not work on native WebVR displays. ' + alternative);
};
function WGLUPreserveGLState(gl, bindings, callback) {
  if (!bindings) {
    callback(gl);
    return;
  }
  var boundValues = [];
  var activeTexture = null;
  for (var i = 0; i < bindings.length; ++i) {
    var binding = bindings[i];
    switch (binding) {
      case gl.TEXTURE_BINDING_2D:
      case gl.TEXTURE_BINDING_CUBE_MAP:
        var textureUnit = bindings[++i];
        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31) {
          console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit");
          boundValues.push(null, null);
          break;
        }
        if (!activeTexture) {
          activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
        }
        gl.activeTexture(textureUnit);
        boundValues.push(gl.getParameter(binding), null);
        break;
      case gl.ACTIVE_TEXTURE:
        activeTexture = gl.getParameter(gl.ACTIVE_TEXTURE);
        boundValues.push(null);
        break;
      default:
        boundValues.push(gl.getParameter(binding));
        break;
    }
  }
  callback(gl);
  for (var i = 0; i < bindings.length; ++i) {
    var binding = bindings[i];
    var boundValue = boundValues[i];
    switch (binding) {
      case gl.ACTIVE_TEXTURE:
        break;
      case gl.ARRAY_BUFFER_BINDING:
        gl.bindBuffer(gl.ARRAY_BUFFER, boundValue);
        break;
      case gl.COLOR_CLEAR_VALUE:
        gl.clearColor(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
        break;
      case gl.COLOR_WRITEMASK:
        gl.colorMask(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
        break;
      case gl.CURRENT_PROGRAM:
        gl.useProgram(boundValue);
        break;
      case gl.ELEMENT_ARRAY_BUFFER_BINDING:
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, boundValue);
        break;
      case gl.FRAMEBUFFER_BINDING:
        gl.bindFramebuffer(gl.FRAMEBUFFER, boundValue);
        break;
      case gl.RENDERBUFFER_BINDING:
        gl.bindRenderbuffer(gl.RENDERBUFFER, boundValue);
        break;
      case gl.TEXTURE_BINDING_2D:
        var textureUnit = bindings[++i];
        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
          break;
        gl.activeTexture(textureUnit);
        gl.bindTexture(gl.TEXTURE_2D, boundValue);
        break;
      case gl.TEXTURE_BINDING_CUBE_MAP:
        var textureUnit = bindings[++i];
        if (textureUnit < gl.TEXTURE0 || textureUnit > gl.TEXTURE31)
          break;
        gl.activeTexture(textureUnit);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, boundValue);
        break;
      case gl.VIEWPORT:
        gl.viewport(boundValue[0], boundValue[1], boundValue[2], boundValue[3]);
        break;
      case gl.BLEND:
      case gl.CULL_FACE:
      case gl.DEPTH_TEST:
      case gl.SCISSOR_TEST:
      case gl.STENCIL_TEST:
        if (boundValue) {
          gl.enable(binding);
        } else {
          gl.disable(binding);
        }
        break;
      default:
        console.log("No GL restore behavior for 0x" + binding.toString(16));
        break;
    }
    if (activeTexture) {
      gl.activeTexture(activeTexture);
    }
  }
}
var glPreserveState = WGLUPreserveGLState;
var distortionVS = ['attribute vec2 position;', 'attribute vec3 texCoord;', 'varying vec2 vTexCoord;', 'uniform vec4 viewportOffsetScale[2];', 'void main() {', '  vec4 viewport = viewportOffsetScale[int(texCoord.z)];', '  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;', '  gl_Position = vec4( position, 1.0, 1.0 );', '}'].join('\n');
var distortionFS = ['precision mediump float;', 'uniform sampler2D diffuse;', 'varying vec2 vTexCoord;', 'void main() {', '  gl_FragColor = texture2D(diffuse, vTexCoord);', '}'].join('\n');
function CardboardDistorter(gl, cardboardUI, bufferScale, dirtySubmitFrameBindings) {
  this.gl = gl;
  this.cardboardUI = cardboardUI;
  this.bufferScale = bufferScale;
  this.dirtySubmitFrameBindings = dirtySubmitFrameBindings;
  this.ctxAttribs = gl.getContextAttributes();
  this.instanceExt = gl.getExtension('ANGLE_instanced_arrays');
  this.meshWidth = 20;
  this.meshHeight = 20;
  this.bufferWidth = gl.drawingBufferWidth;
  this.bufferHeight = gl.drawingBufferHeight;
  this.realBindFramebuffer = gl.bindFramebuffer;
  this.realEnable = gl.enable;
  this.realDisable = gl.disable;
  this.realColorMask = gl.colorMask;
  this.realClearColor = gl.clearColor;
  this.realViewport = gl.viewport;
  if (!isIOS()) {
    this.realCanvasWidth = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, 'width');
    this.realCanvasHeight = Object.getOwnPropertyDescriptor(gl.canvas.__proto__, 'height');
  }
  this.isPatched = false;
  this.lastBoundFramebuffer = null;
  this.cullFace = false;
  this.depthTest = false;
  this.blend = false;
  this.scissorTest = false;
  this.stencilTest = false;
  this.viewport = [0, 0, 0, 0];
  this.colorMask = [true, true, true, true];
  this.clearColor = [0, 0, 0, 0];
  this.attribs = {
    position: 0,
    texCoord: 1
  };
  this.program = linkProgram(gl, distortionVS, distortionFS, this.attribs);
  this.uniforms = getProgramUniforms(gl, this.program);
  this.viewportOffsetScale = new Float32Array(8);
  this.setTextureBounds();
  this.vertexBuffer = gl.createBuffer();
  this.indexBuffer = gl.createBuffer();
  this.indexCount = 0;
  this.renderTarget = gl.createTexture();
  this.framebuffer = gl.createFramebuffer();
  this.depthStencilBuffer = null;
  this.depthBuffer = null;
  this.stencilBuffer = null;
  if (this.ctxAttribs.depth && this.ctxAttribs.stencil) {
    this.depthStencilBuffer = gl.createRenderbuffer();
  } else if (this.ctxAttribs.depth) {
    this.depthBuffer = gl.createRenderbuffer();
  } else if (this.ctxAttribs.stencil) {
    this.stencilBuffer = gl.createRenderbuffer();
  }
  this.patch();
  this.onResize();
}
CardboardDistorter.prototype.destroy = function () {
  var gl = this.gl;
  this.unpatch();
  gl.deleteProgram(this.program);
  gl.deleteBuffer(this.vertexBuffer);
  gl.deleteBuffer(this.indexBuffer);
  gl.deleteTexture(this.renderTarget);
  gl.deleteFramebuffer(this.framebuffer);
  if (this.depthStencilBuffer) {
    gl.deleteRenderbuffer(this.depthStencilBuffer);
  }
  if (this.depthBuffer) {
    gl.deleteRenderbuffer(this.depthBuffer);
  }
  if (this.stencilBuffer) {
    gl.deleteRenderbuffer(this.stencilBuffer);
  }
  if (this.cardboardUI) {
    this.cardboardUI.destroy();
  }
};
CardboardDistorter.prototype.onResize = function () {
  var gl = this.gl;
  var self = this;
  var glState = [gl.RENDERBUFFER_BINDING, gl.TEXTURE_BINDING_2D, gl.TEXTURE0];
  glPreserveState(gl, glState, function (gl) {
    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, null);
    if (self.scissorTest) {
      self.realDisable.call(gl, gl.SCISSOR_TEST);
    }
    self.realColorMask.call(gl, true, true, true, true);
    self.realViewport.call(gl, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    self.realClearColor.call(gl, 0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.framebuffer);
    gl.bindTexture(gl.TEXTURE_2D, self.renderTarget);
    gl.texImage2D(gl.TEXTURE_2D, 0, self.ctxAttribs.alpha ? gl.RGBA : gl.RGB, self.bufferWidth, self.bufferHeight, 0, self.ctxAttribs.alpha ? gl.RGBA : gl.RGB, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, self.renderTarget, 0);
    if (self.ctxAttribs.depth && self.ctxAttribs.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, self.depthStencilBuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, self.bufferWidth, self.bufferHeight);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, self.depthStencilBuffer);
    } else if (self.ctxAttribs.depth) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, self.depthBuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, self.bufferWidth, self.bufferHeight);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, self.depthBuffer);
    } else if (self.ctxAttribs.stencil) {
      gl.bindRenderbuffer(gl.RENDERBUFFER, self.stencilBuffer);
      gl.renderbufferStorage(gl.RENDERBUFFER, gl.STENCIL_INDEX8, self.bufferWidth, self.bufferHeight);
      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, self.stencilBuffer);
    }
    if (!gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
      console.error('Framebuffer incomplete!');
    }
    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.lastBoundFramebuffer);
    if (self.scissorTest) {
      self.realEnable.call(gl, gl.SCISSOR_TEST);
    }
    self.realColorMask.apply(gl, self.colorMask);
    self.realViewport.apply(gl, self.viewport);
    self.realClearColor.apply(gl, self.clearColor);
  });
  if (this.cardboardUI) {
    this.cardboardUI.onResize();
  }
};
CardboardDistorter.prototype.patch = function () {
  if (this.isPatched) {
    return;
  }
  var self = this;
  var canvas = this.gl.canvas;
  var gl = this.gl;
  if (!isIOS()) {
    canvas.width = getScreenWidth() * this.bufferScale;
    canvas.height = getScreenHeight() * this.bufferScale;
    Object.defineProperty(canvas, 'width', {
      configurable: true,
      enumerable: true,
      get: function get() {
        return self.bufferWidth;
      },
      set: function set(value) {
        self.bufferWidth = value;
        self.realCanvasWidth.set.call(canvas, value);
        self.onResize();
      }
    });
    Object.defineProperty(canvas, 'height', {
      configurable: true,
      enumerable: true,
      get: function get() {
        return self.bufferHeight;
      },
      set: function set(value) {
        self.bufferHeight = value;
        self.realCanvasHeight.set.call(canvas, value);
        self.onResize();
      }
    });
  }
  this.lastBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
  if (this.lastBoundFramebuffer == null) {
    this.lastBoundFramebuffer = this.framebuffer;
    this.gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
  }
  this.gl.bindFramebuffer = function (target, framebuffer) {
    self.lastBoundFramebuffer = framebuffer ? framebuffer : self.framebuffer;
    self.realBindFramebuffer.call(gl, target, self.lastBoundFramebuffer);
  };
  this.cullFace = gl.getParameter(gl.CULL_FACE);
  this.depthTest = gl.getParameter(gl.DEPTH_TEST);
  this.blend = gl.getParameter(gl.BLEND);
  this.scissorTest = gl.getParameter(gl.SCISSOR_TEST);
  this.stencilTest = gl.getParameter(gl.STENCIL_TEST);
  gl.enable = function (pname) {
    switch (pname) {
      case gl.CULL_FACE:
        self.cullFace = true;break;
      case gl.DEPTH_TEST:
        self.depthTest = true;break;
      case gl.BLEND:
        self.blend = true;break;
      case gl.SCISSOR_TEST:
        self.scissorTest = true;break;
      case gl.STENCIL_TEST:
        self.stencilTest = true;break;
    }
    self.realEnable.call(gl, pname);
  };
  gl.disable = function (pname) {
    switch (pname) {
      case gl.CULL_FACE:
        self.cullFace = false;break;
      case gl.DEPTH_TEST:
        self.depthTest = false;break;
      case gl.BLEND:
        self.blend = false;break;
      case gl.SCISSOR_TEST:
        self.scissorTest = false;break;
      case gl.STENCIL_TEST:
        self.stencilTest = false;break;
    }
    self.realDisable.call(gl, pname);
  };
  this.colorMask = gl.getParameter(gl.COLOR_WRITEMASK);
  gl.colorMask = function (r, g, b, a) {
    self.colorMask[0] = r;
    self.colorMask[1] = g;
    self.colorMask[2] = b;
    self.colorMask[3] = a;
    self.realColorMask.call(gl, r, g, b, a);
  };
  this.clearColor = gl.getParameter(gl.COLOR_CLEAR_VALUE);
  gl.clearColor = function (r, g, b, a) {
    self.clearColor[0] = r;
    self.clearColor[1] = g;
    self.clearColor[2] = b;
    self.clearColor[3] = a;
    self.realClearColor.call(gl, r, g, b, a);
  };
  this.viewport = gl.getParameter(gl.VIEWPORT);
  gl.viewport = function (x, y, w, h) {
    self.viewport[0] = x;
    self.viewport[1] = y;
    self.viewport[2] = w;
    self.viewport[3] = h;
    self.realViewport.call(gl, x, y, w, h);
  };
  this.isPatched = true;
  safariCssSizeWorkaround(canvas);
};
CardboardDistorter.prototype.unpatch = function () {
  if (!this.isPatched) {
    return;
  }
  var gl = this.gl;
  var canvas = this.gl.canvas;
  if (!isIOS()) {
    Object.defineProperty(canvas, 'width', this.realCanvasWidth);
    Object.defineProperty(canvas, 'height', this.realCanvasHeight);
  }
  canvas.width = this.bufferWidth;
  canvas.height = this.bufferHeight;
  gl.bindFramebuffer = this.realBindFramebuffer;
  gl.enable = this.realEnable;
  gl.disable = this.realDisable;
  gl.colorMask = this.realColorMask;
  gl.clearColor = this.realClearColor;
  gl.viewport = this.realViewport;
  if (this.lastBoundFramebuffer == this.framebuffer) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }
  this.isPatched = false;
  setTimeout(function () {
    safariCssSizeWorkaround(canvas);
  }, 1);
};
CardboardDistorter.prototype.setTextureBounds = function (leftBounds, rightBounds) {
  if (!leftBounds) {
    leftBounds = [0, 0, 0.5, 1];
  }
  if (!rightBounds) {
    rightBounds = [0.5, 0, 0.5, 1];
  }
  this.viewportOffsetScale[0] = leftBounds[0];
  this.viewportOffsetScale[1] = leftBounds[1];
  this.viewportOffsetScale[2] = leftBounds[2];
  this.viewportOffsetScale[3] = leftBounds[3];
  this.viewportOffsetScale[4] = rightBounds[0];
  this.viewportOffsetScale[5] = rightBounds[1];
  this.viewportOffsetScale[6] = rightBounds[2];
  this.viewportOffsetScale[7] = rightBounds[3];
};
CardboardDistorter.prototype.submitFrame = function () {
  var gl = this.gl;
  var self = this;
  var glState = [];
  if (!this.dirtySubmitFrameBindings) {
    glState.push(gl.CURRENT_PROGRAM, gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING, gl.TEXTURE_BINDING_2D, gl.TEXTURE0);
  }
  glPreserveState(gl, glState, function (gl) {
    self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, null);
    var positionDivisor = 0;
    var texCoordDivisor = 0;
    if (self.instanceExt) {
      positionDivisor = gl.getVertexAttrib(self.attribs.position, self.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE);
      texCoordDivisor = gl.getVertexAttrib(self.attribs.texCoord, self.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE);
    }
    if (self.cullFace) {
      self.realDisable.call(gl, gl.CULL_FACE);
    }
    if (self.depthTest) {
      self.realDisable.call(gl, gl.DEPTH_TEST);
    }
    if (self.blend) {
      self.realDisable.call(gl, gl.BLEND);
    }
    if (self.scissorTest) {
      self.realDisable.call(gl, gl.SCISSOR_TEST);
    }
    if (self.stencilTest) {
      self.realDisable.call(gl, gl.STENCIL_TEST);
    }
    self.realColorMask.call(gl, true, true, true, true);
    self.realViewport.call(gl, 0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    if (self.ctxAttribs.alpha || isIOS()) {
      self.realClearColor.call(gl, 0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT);
    }
    gl.useProgram(self.program);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, self.indexBuffer);
    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
    gl.enableVertexAttribArray(self.attribs.position);
    gl.enableVertexAttribArray(self.attribs.texCoord);
    gl.vertexAttribPointer(self.attribs.position, 2, gl.FLOAT, false, 20, 0);
    gl.vertexAttribPointer(self.attribs.texCoord, 3, gl.FLOAT, false, 20, 8);
    if (self.instanceExt) {
      if (positionDivisor != 0) {
        self.instanceExt.vertexAttribDivisorANGLE(self.attribs.position, 0);
      }
      if (texCoordDivisor != 0) {
        self.instanceExt.vertexAttribDivisorANGLE(self.attribs.texCoord, 0);
      }
    }
    gl.activeTexture(gl.TEXTURE0);
    gl.uniform1i(self.uniforms.diffuse, 0);
    gl.bindTexture(gl.TEXTURE_2D, self.renderTarget);
    gl.uniform4fv(self.uniforms.viewportOffsetScale, self.viewportOffsetScale);
    gl.drawElements(gl.TRIANGLES, self.indexCount, gl.UNSIGNED_SHORT, 0);
    if (self.cardboardUI) {
      self.cardboardUI.renderNoState();
    }
    self.realBindFramebuffer.call(self.gl, gl.FRAMEBUFFER, self.framebuffer);
    if (!self.ctxAttribs.preserveDrawingBuffer) {
      self.realClearColor.call(gl, 0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
    }
    if (!self.dirtySubmitFrameBindings) {
      self.realBindFramebuffer.call(gl, gl.FRAMEBUFFER, self.lastBoundFramebuffer);
    }
    if (self.cullFace) {
      self.realEnable.call(gl, gl.CULL_FACE);
    }
    if (self.depthTest) {
      self.realEnable.call(gl, gl.DEPTH_TEST);
    }
    if (self.blend) {
      self.realEnable.call(gl, gl.BLEND);
    }
    if (self.scissorTest) {
      self.realEnable.call(gl, gl.SCISSOR_TEST);
    }
    if (self.stencilTest) {
      self.realEnable.call(gl, gl.STENCIL_TEST);
    }
    self.realColorMask.apply(gl, self.colorMask);
    self.realViewport.apply(gl, self.viewport);
    if (self.ctxAttribs.alpha || !self.ctxAttribs.preserveDrawingBuffer) {
      self.realClearColor.apply(gl, self.clearColor);
    }
    if (self.instanceExt) {
      if (positionDivisor != 0) {
        self.instanceExt.vertexAttribDivisorANGLE(self.attribs.position, positionDivisor);
      }
      if (texCoordDivisor != 0) {
        self.instanceExt.vertexAttribDivisorANGLE(self.attribs.texCoord, texCoordDivisor);
      }
    }
  });
  if (isIOS()) {
    var canvas = gl.canvas;
    if (canvas.width != self.bufferWidth || canvas.height != self.bufferHeight) {
      self.bufferWidth = canvas.width;
      self.bufferHeight = canvas.height;
      self.onResize();
    }
  }
};
CardboardDistorter.prototype.updateDeviceInfo = function (deviceInfo) {
  var gl = this.gl;
  var self = this;
  var glState = [gl.ARRAY_BUFFER_BINDING, gl.ELEMENT_ARRAY_BUFFER_BINDING];
  glPreserveState(gl, glState, function (gl) {
    var vertices = self.computeMeshVertices_(self.meshWidth, self.meshHeight, deviceInfo);
    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    if (!self.indexCount) {
      var indices = self.computeMeshIndices_(self.meshWidth, self.meshHeight);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, self.indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
      self.indexCount = indices.length;
    }
  });
};
CardboardDistorter.prototype.computeMeshVertices_ = function (width, height, deviceInfo) {
  var vertices = new Float32Array(2 * width * height * 5);
  var lensFrustum = deviceInfo.getLeftEyeVisibleTanAngles();
  var noLensFrustum = deviceInfo.getLeftEyeNoLensTanAngles();
  var viewport = deviceInfo.getLeftEyeVisibleScreenRect(noLensFrustum);
  var vidx = 0;
  for (var e = 0; e < 2; e++) {
    for (var j = 0; j < height; j++) {
      for (var i = 0; i < width; i++, vidx++) {
        var u = i / (width - 1);
        var v = j / (height - 1);
        var s = u;
        var t = v;
        var x = lerp(lensFrustum[0], lensFrustum[2], u);
        var y = lerp(lensFrustum[3], lensFrustum[1], v);
        var d = Math.sqrt(x * x + y * y);
        var r = deviceInfo.distortion.distortInverse(d);
        var p = x * r / d;
        var q = y * r / d;
        u = (p - noLensFrustum[0]) / (noLensFrustum[2] - noLensFrustum[0]);
        v = (q - noLensFrustum[3]) / (noLensFrustum[1] - noLensFrustum[3]);
        u = (viewport.x + u * viewport.width - 0.5) * 2.0;
        v = (viewport.y + v * viewport.height - 0.5) * 2.0;
        vertices[vidx * 5 + 0] = u;
        vertices[vidx * 5 + 1] = v;
        vertices[vidx * 5 + 2] = s;
        vertices[vidx * 5 + 3] = t;
        vertices[vidx * 5 + 4] = e;
      }
    }
    var w = lensFrustum[2] - lensFrustum[0];
    lensFrustum[0] = -(w + lensFrustum[0]);
    lensFrustum[2] = w - lensFrustum[2];
    w = noLensFrustum[2] - noLensFrustum[0];
    noLensFrustum[0] = -(w + noLensFrustum[0]);
    noLensFrustum[2] = w - noLensFrustum[2];
    viewport.x = 1 - (viewport.x + viewport.width);
  }
  return vertices;
};
CardboardDistorter.prototype.computeMeshIndices_ = function (width, height) {
  var indices = new Uint16Array(2 * (width - 1) * (height - 1) * 6);
  var halfwidth = width / 2;
  var halfheight = height / 2;
  var vidx = 0;
  var iidx = 0;
  for (var e = 0; e < 2; e++) {
    for (var j = 0; j < height; j++) {
      for (var i = 0; i < width; i++, vidx++) {
        if (i == 0 || j == 0) continue;
        if (i <= halfwidth == j <= halfheight) {
          indices[iidx++] = vidx;
          indices[iidx++] = vidx - width - 1;
          indices[iidx++] = vidx - width;
          indices[iidx++] = vidx - width - 1;
          indices[iidx++] = vidx;
          indices[iidx++] = vidx - 1;
        } else {
          indices[iidx++] = vidx - 1;
          indices[iidx++] = vidx - width;
          indices[iidx++] = vidx;
          indices[iidx++] = vidx - width;
          indices[iidx++] = vidx - 1;
          indices[iidx++] = vidx - width - 1;
        }
      }
    }
  }
  return indices;
};
CardboardDistorter.prototype.getOwnPropertyDescriptor_ = function (proto, attrName) {
  var descriptor = Object.getOwnPropertyDescriptor(proto, attrName);
  if (descriptor.get === undefined || descriptor.set === undefined) {
    descriptor.configurable = true;
    descriptor.enumerable = true;
    descriptor.get = function () {
      return this.getAttribute(attrName);
    };
    descriptor.set = function (val) {
      this.setAttribute(attrName, val);
    };
  }
  return descriptor;
};
var uiVS = ['attribute vec2 position;', 'uniform mat4 projectionMat;', 'void main() {', '  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );', '}'].join('\n');
var uiFS = ['precision mediump float;', 'uniform vec4 color;', 'void main() {', '  gl_FragColor = color;', '}'].join('\n');
var DEG2RAD = Math.PI / 180.0;
var kAnglePerGearSection = 60;
var kOuterRimEndAngle = 12;
var kInnerRimBeginAngle = 20;
var kOuterRadius = 1;
var kMiddleRadius = 0.75;
var kInnerRadius = 0.3125;
var kCenterLineThicknessDp = 4;
var kButtonWidthDp = 28;
var kTouchSlopFactor = 1.5;
function CardboardUI(gl) {
  this.gl = gl;
  this.attribs = {
    position: 0
  };
  this.program = linkProgram(gl, uiVS, uiFS, this.attribs);
  this.uniforms = getProgramUniforms(gl, this.program);
  this.vertexBuffer = gl.createBuffer();
  this.gearOffset = 0;
  this.gearVertexCount = 0;
  this.arrowOffset = 0;
  this.arrowVertexCount = 0;
  this.projMat = new Float32Array(16);
  this.listener = null;
  this.onResize();
}
CardboardUI.prototype.destroy = function () {
  var gl = this.gl;
  if (this.listener) {
    gl.canvas.removeEventListener('click', this.listener, false);
  }
  gl.deleteProgram(this.program);
  gl.deleteBuffer(this.vertexBuffer);
};
CardboardUI.prototype.listen = function (optionsCallback, backCallback) {
  var canvas = this.gl.canvas;
  this.listener = function (event) {
    var midline = canvas.clientWidth / 2;
    var buttonSize = kButtonWidthDp * kTouchSlopFactor;
    if (event.clientX > midline - buttonSize && event.clientX < midline + buttonSize && event.clientY > canvas.clientHeight - buttonSize) {
      optionsCallback(event);
    }
    else if (event.clientX < buttonSize && event.clientY < buttonSize) {
        backCallback(event);
      }
  };
  canvas.addEventListener('click', this.listener, false);
};
CardboardUI.prototype.onResize = function () {
  var gl = this.gl;
  var self = this;
  var glState = [gl.ARRAY_BUFFER_BINDING];
  glPreserveState(gl, glState, function (gl) {
    var vertices = [];
    var midline = gl.drawingBufferWidth / 2;
    var physicalPixels = Math.max(screen.width, screen.height) * window.devicePixelRatio;
    var scalingRatio = gl.drawingBufferWidth / physicalPixels;
    var dps = scalingRatio * window.devicePixelRatio;
    var lineWidth = kCenterLineThicknessDp * dps / 2;
    var buttonSize = kButtonWidthDp * kTouchSlopFactor * dps;
    var buttonScale = kButtonWidthDp * dps / 2;
    var buttonBorder = (kButtonWidthDp * kTouchSlopFactor - kButtonWidthDp) * dps;
    vertices.push(midline - lineWidth, buttonSize);
    vertices.push(midline - lineWidth, gl.drawingBufferHeight);
    vertices.push(midline + lineWidth, buttonSize);
    vertices.push(midline + lineWidth, gl.drawingBufferHeight);
    self.gearOffset = vertices.length / 2;
    function addGearSegment(theta, r) {
      var angle = (90 - theta) * DEG2RAD;
      var x = Math.cos(angle);
      var y = Math.sin(angle);
      vertices.push(kInnerRadius * x * buttonScale + midline, kInnerRadius * y * buttonScale + buttonScale);
      vertices.push(r * x * buttonScale + midline, r * y * buttonScale + buttonScale);
    }
    for (var i = 0; i <= 6; i++) {
      var segmentTheta = i * kAnglePerGearSection;
      addGearSegment(segmentTheta, kOuterRadius);
      addGearSegment(segmentTheta + kOuterRimEndAngle, kOuterRadius);
      addGearSegment(segmentTheta + kInnerRimBeginAngle, kMiddleRadius);
      addGearSegment(segmentTheta + (kAnglePerGearSection - kInnerRimBeginAngle), kMiddleRadius);
      addGearSegment(segmentTheta + (kAnglePerGearSection - kOuterRimEndAngle), kOuterRadius);
    }
    self.gearVertexCount = vertices.length / 2 - self.gearOffset;
    self.arrowOffset = vertices.length / 2;
    function addArrowVertex(x, y) {
      vertices.push(buttonBorder + x, gl.drawingBufferHeight - buttonBorder - y);
    }
    var angledLineWidth = lineWidth / Math.sin(45 * DEG2RAD);
    addArrowVertex(0, buttonScale);
    addArrowVertex(buttonScale, 0);
    addArrowVertex(buttonScale + angledLineWidth, angledLineWidth);
    addArrowVertex(angledLineWidth, buttonScale + angledLineWidth);
    addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
    addArrowVertex(0, buttonScale);
    addArrowVertex(buttonScale, buttonScale * 2);
    addArrowVertex(buttonScale + angledLineWidth, buttonScale * 2 - angledLineWidth);
    addArrowVertex(angledLineWidth, buttonScale - angledLineWidth);
    addArrowVertex(0, buttonScale);
    addArrowVertex(angledLineWidth, buttonScale - lineWidth);
    addArrowVertex(kButtonWidthDp * dps, buttonScale - lineWidth);
    addArrowVertex(angledLineWidth, buttonScale + lineWidth);
    addArrowVertex(kButtonWidthDp * dps, buttonScale + lineWidth);
    self.arrowVertexCount = vertices.length / 2 - self.arrowOffset;
    gl.bindBuffer(gl.ARRAY_BUFFER, self.vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
  });
};
CardboardUI.prototype.render = function () {
  var gl = this.gl;
  var self = this;
  var glState = [gl.CULL_FACE, gl.DEPTH_TEST, gl.BLEND, gl.SCISSOR_TEST, gl.STENCIL_TEST, gl.COLOR_WRITEMASK, gl.VIEWPORT, gl.CURRENT_PROGRAM, gl.ARRAY_BUFFER_BINDING];
  glPreserveState(gl, glState, function (gl) {
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.BLEND);
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.colorMask(true, true, true, true);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    self.renderNoState();
  });
};
CardboardUI.prototype.renderNoState = function () {
  var gl = this.gl;
  gl.useProgram(this.program);
  gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
  gl.enableVertexAttribArray(this.attribs.position);
  gl.vertexAttribPointer(this.attribs.position, 2, gl.FLOAT, false, 8, 0);
  gl.uniform4f(this.uniforms.color, 1.0, 1.0, 1.0, 1.0);
  orthoMatrix(this.projMat, 0, gl.drawingBufferWidth, 0, gl.drawingBufferHeight, 0.1, 1024.0);
  gl.uniformMatrix4fv(this.uniforms.projectionMat, false, this.projMat);
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  gl.drawArrays(gl.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount);
  gl.drawArrays(gl.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount);
};
function Distortion(coefficients) {
  this.coefficients = coefficients;
}
Distortion.prototype.distortInverse = function (radius) {
  var r0 = 0;
  var r1 = 1;
  var dr0 = radius - this.distort(r0);
  while (Math.abs(r1 - r0) > 0.0001             ) {
    var dr1 = radius - this.distort(r1);
    var r2 = r1 - dr1 * ((r1 - r0) / (dr1 - dr0));
    r0 = r1;
    r1 = r2;
    dr0 = dr1;
  }
  return r1;
};
Distortion.prototype.distort = function (radius) {
  var r2 = radius * radius;
  var ret = 0;
  for (var i = 0; i < this.coefficients.length; i++) {
    ret = r2 * (ret + this.coefficients[i]);
  }
  return (ret + 1) * radius;
};
var degToRad = Math.PI / 180;
var radToDeg = 180 / Math.PI;
var Vector3 = function Vector3(x, y, z) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
};
Vector3.prototype = {
  constructor: Vector3,
  set: function set(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  },
  copy: function copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  },
  length: function length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  },
  normalize: function normalize() {
    var scalar = this.length();
    if (scalar !== 0) {
      var invScalar = 1 / scalar;
      this.multiplyScalar(invScalar);
    } else {
      this.x = 0;
      this.y = 0;
      this.z = 0;
    }
    return this;
  },
  multiplyScalar: function multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
  },
  applyQuaternion: function applyQuaternion(q) {
    var x = this.x;
    var y = this.y;
    var z = this.z;
    var qx = q.x;
    var qy = q.y;
    var qz = q.z;
    var qw = q.w;
    var ix = qw * x + qy * z - qz * y;
    var iy = qw * y + qz * x - qx * z;
    var iz = qw * z + qx * y - qy * x;
    var iw = -qx * x - qy * y - qz * z;
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return this;
  },
  dot: function dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  },
  crossVectors: function crossVectors(a, b) {
    var ax = a.x,
        ay = a.y,
        az = a.z;
    var bx = b.x,
        by = b.y,
        bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
};
var Quaternion = function Quaternion(x, y, z, w) {
  this.x = x || 0;
  this.y = y || 0;
  this.z = z || 0;
  this.w = w !== undefined ? w : 1;
};
Quaternion.prototype = {
  constructor: Quaternion,
  set: function set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  },
  copy: function copy(quaternion) {
    this.x = quaternion.x;
    this.y = quaternion.y;
    this.z = quaternion.z;
    this.w = quaternion.w;
    return this;
  },
  setFromEulerXYZ: function setFromEulerXYZ(x, y, z) {
    var c1 = Math.cos(x / 2);
    var c2 = Math.cos(y / 2);
    var c3 = Math.cos(z / 2);
    var s1 = Math.sin(x / 2);
    var s2 = Math.sin(y / 2);
    var s3 = Math.sin(z / 2);
    this.x = s1 * c2 * c3 + c1 * s2 * s3;
    this.y = c1 * s2 * c3 - s1 * c2 * s3;
    this.z = c1 * c2 * s3 + s1 * s2 * c3;
    this.w = c1 * c2 * c3 - s1 * s2 * s3;
    return this;
  },
  setFromEulerYXZ: function setFromEulerYXZ(x, y, z) {
    var c1 = Math.cos(x / 2);
    var c2 = Math.cos(y / 2);
    var c3 = Math.cos(z / 2);
    var s1 = Math.sin(x / 2);
    var s2 = Math.sin(y / 2);
    var s3 = Math.sin(z / 2);
    this.x = s1 * c2 * c3 + c1 * s2 * s3;
    this.y = c1 * s2 * c3 - s1 * c2 * s3;
    this.z = c1 * c2 * s3 - s1 * s2 * c3;
    this.w = c1 * c2 * c3 + s1 * s2 * s3;
    return this;
  },
  setFromAxisAngle: function setFromAxisAngle(axis, angle) {
    var halfAngle = angle / 2,
        s = Math.sin(halfAngle);
    this.x = axis.x * s;
    this.y = axis.y * s;
    this.z = axis.z * s;
    this.w = Math.cos(halfAngle);
    return this;
  },
  multiply: function multiply(q) {
    return this.multiplyQuaternions(this, q);
  },
  multiplyQuaternions: function multiplyQuaternions(a, b) {
    var qax = a.x,
        qay = a.y,
        qaz = a.z,
        qaw = a.w;
    var qbx = b.x,
        qby = b.y,
        qbz = b.z,
        qbw = b.w;
    this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    return this;
  },
  inverse: function inverse() {
    this.x *= -1;
    this.y *= -1;
    this.z *= -1;
    this.normalize();
    return this;
  },
  normalize: function normalize() {
    var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    if (l === 0) {
      this.x = 0;
      this.y = 0;
      this.z = 0;
      this.w = 1;
    } else {
      l = 1 / l;
      this.x = this.x * l;
      this.y = this.y * l;
      this.z = this.z * l;
      this.w = this.w * l;
    }
    return this;
  },
  slerp: function slerp(qb, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(qb);
    var x = this.x,
        y = this.y,
        z = this.z,
        w = this.w;
    var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;
    if (cosHalfTheta < 0) {
      this.w = -qb.w;
      this.x = -qb.x;
      this.y = -qb.y;
      this.z = -qb.z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1.0) {
      this.w = w;
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    }
    var halfTheta = Math.acos(cosHalfTheta);
    var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
    if (Math.abs(sinHalfTheta) < 0.001) {
      this.w = 0.5 * (w + this.w);
      this.x = 0.5 * (x + this.x);
      this.y = 0.5 * (y + this.y);
      this.z = 0.5 * (z + this.z);
      return this;
    }
    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
        ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this.w = w * ratioA + this.w * ratioB;
    this.x = x * ratioA + this.x * ratioB;
    this.y = y * ratioA + this.y * ratioB;
    this.z = z * ratioA + this.z * ratioB;
    return this;
  },
  setFromUnitVectors: function () {
    var v1, r;
    var EPS = 0.000001;
    return function (vFrom, vTo) {
      if (v1 === undefined) v1 = new Vector3();
      r = vFrom.dot(vTo) + 1;
      if (r < EPS) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          v1.set(-vFrom.y, vFrom.x, 0);
        } else {
          v1.set(0, -vFrom.z, vFrom.y);
        }
      } else {
        v1.crossVectors(vFrom, vTo);
      }
      this.x = v1.x;
      this.y = v1.y;
      this.z = v1.z;
      this.w = r;
      this.normalize();
      return this;
    };
  }()
};
function Device(params) {
  this.width = params.width || getScreenWidth();
  this.height = params.height || getScreenHeight();
  this.widthMeters = params.widthMeters;
  this.heightMeters = params.heightMeters;
  this.bevelMeters = params.bevelMeters;
}
var DEFAULT_ANDROID = new Device({
  widthMeters: 0.110,
  heightMeters: 0.062,
  bevelMeters: 0.004
});
var DEFAULT_IOS = new Device({
  widthMeters: 0.1038,
  heightMeters: 0.0584,
  bevelMeters: 0.004
});
var Viewers = {
  CardboardV1: new CardboardViewer({
    id: 'CardboardV1',
    label: 'Cardboard I/O 2014',
    fov: 40,
    interLensDistance: 0.060,
    baselineLensDistance: 0.035,
    screenLensDistance: 0.042,
    distortionCoefficients: [0.441, 0.156],
    inverseCoefficients: [-0.4410035, 0.42756155, -0.4804439, 0.5460139, -0.58821183, 0.5733938, -0.48303202, 0.33299083, -0.17573841, 0.0651772, -0.01488963, 0.001559834]
  }),
  CardboardV2: new CardboardViewer({
    id: 'CardboardV2',
    label: 'Cardboard I/O 2015',
    fov: 60,
    interLensDistance: 0.064,
    baselineLensDistance: 0.035,
    screenLensDistance: 0.039,
    distortionCoefficients: [0.34, 0.55],
    inverseCoefficients: [-0.33836704, -0.18162185, 0.862655, -1.2462051, 1.0560602, -0.58208317, 0.21609078, -0.05444823, 0.009177956, -9.904169E-4, 6.183535E-5, -1.6981803E-6]
  })
};
function DeviceInfo(deviceParams, additionalViewers) {
  this.viewer = Viewers.CardboardV2;
  this.updateDeviceParams(deviceParams);
  this.distortion = new Distortion(this.viewer.distortionCoefficients);
  for (var i = 0; i < additionalViewers.length; i++) {
    var viewer = additionalViewers[i];
    Viewers[viewer.id] = new CardboardViewer(viewer);
  }
}
DeviceInfo.prototype.updateDeviceParams = function (deviceParams) {
  this.device = this.determineDevice_(deviceParams) || this.device;
};
DeviceInfo.prototype.getDevice = function () {
  return this.device;
};
DeviceInfo.prototype.setViewer = function (viewer) {
  this.viewer = viewer;
  this.distortion = new Distortion(this.viewer.distortionCoefficients);
};
DeviceInfo.prototype.determineDevice_ = function (deviceParams) {
  if (!deviceParams) {
    if (isIOS()) {
      console.warn('Using fallback iOS device measurements.');
      return DEFAULT_IOS;
    } else {
      console.warn('Using fallback Android device measurements.');
      return DEFAULT_ANDROID;
    }
  }
  var METERS_PER_INCH = 0.0254;
  var metersPerPixelX = METERS_PER_INCH / deviceParams.xdpi;
  var metersPerPixelY = METERS_PER_INCH / deviceParams.ydpi;
  var width = getScreenWidth();
  var height = getScreenHeight();
  return new Device({
    widthMeters: metersPerPixelX * width,
    heightMeters: metersPerPixelY * height,
    bevelMeters: deviceParams.bevelMm * 0.001
  });
};
DeviceInfo.prototype.getDistortedFieldOfViewLeftEye = function () {
  var viewer = this.viewer;
  var device = this.device;
  var distortion = this.distortion;
  var eyeToScreenDistance = viewer.screenLensDistance;
  var outerDist = (device.widthMeters - viewer.interLensDistance) / 2;
  var innerDist = viewer.interLensDistance / 2;
  var bottomDist = viewer.baselineLensDistance - device.bevelMeters;
  var topDist = device.heightMeters - bottomDist;
  var outerAngle = radToDeg * Math.atan(distortion.distort(outerDist / eyeToScreenDistance));
  var innerAngle = radToDeg * Math.atan(distortion.distort(innerDist / eyeToScreenDistance));
  var bottomAngle = radToDeg * Math.atan(distortion.distort(bottomDist / eyeToScreenDistance));
  var topAngle = radToDeg * Math.atan(distortion.distort(topDist / eyeToScreenDistance));
  return {
    leftDegrees: Math.min(outerAngle, viewer.fov),
    rightDegrees: Math.min(innerAngle, viewer.fov),
    downDegrees: Math.min(bottomAngle, viewer.fov),
    upDegrees: Math.min(topAngle, viewer.fov)
  };
};
DeviceInfo.prototype.getLeftEyeVisibleTanAngles = function () {
  var viewer = this.viewer;
  var device = this.device;
  var distortion = this.distortion;
  var fovLeft = Math.tan(-degToRad * viewer.fov);
  var fovTop = Math.tan(degToRad * viewer.fov);
  var fovRight = Math.tan(degToRad * viewer.fov);
  var fovBottom = Math.tan(-degToRad * viewer.fov);
  var halfWidth = device.widthMeters / 4;
  var halfHeight = device.heightMeters / 2;
  var verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight;
  var centerX = viewer.interLensDistance / 2 - halfWidth;
  var centerY = -verticalLensOffset;
  var centerZ = viewer.screenLensDistance;
  var screenLeft = distortion.distort((centerX - halfWidth) / centerZ);
  var screenTop = distortion.distort((centerY + halfHeight) / centerZ);
  var screenRight = distortion.distort((centerX + halfWidth) / centerZ);
  var screenBottom = distortion.distort((centerY - halfHeight) / centerZ);
  var result = new Float32Array(4);
  result[0] = Math.max(fovLeft, screenLeft);
  result[1] = Math.min(fovTop, screenTop);
  result[2] = Math.min(fovRight, screenRight);
  result[3] = Math.max(fovBottom, screenBottom);
  return result;
};
DeviceInfo.prototype.getLeftEyeNoLensTanAngles = function () {
  var viewer = this.viewer;
  var device = this.device;
  var distortion = this.distortion;
  var result = new Float32Array(4);
  var fovLeft = distortion.distortInverse(Math.tan(-degToRad * viewer.fov));
  var fovTop = distortion.distortInverse(Math.tan(degToRad * viewer.fov));
  var fovRight = distortion.distortInverse(Math.tan(degToRad * viewer.fov));
  var fovBottom = distortion.distortInverse(Math.tan(-degToRad * viewer.fov));
  var halfWidth = device.widthMeters / 4;
  var halfHeight = device.heightMeters / 2;
  var verticalLensOffset = viewer.baselineLensDistance - device.bevelMeters - halfHeight;
  var centerX = viewer.interLensDistance / 2 - halfWidth;
  var centerY = -verticalLensOffset;
  var centerZ = viewer.screenLensDistance;
  var screenLeft = (centerX - halfWidth) / centerZ;
  var screenTop = (centerY + halfHeight) / centerZ;
  var screenRight = (centerX + halfWidth) / centerZ;
  var screenBottom = (centerY - halfHeight) / centerZ;
  result[0] = Math.max(fovLeft, screenLeft);
  result[1] = Math.min(fovTop, screenTop);
  result[2] = Math.min(fovRight, screenRight);
  result[3] = Math.max(fovBottom, screenBottom);
  return result;
};
DeviceInfo.prototype.getLeftEyeVisibleScreenRect = function (undistortedFrustum) {
  var viewer = this.viewer;
  var device = this.device;
  var dist = viewer.screenLensDistance;
  var eyeX = (device.widthMeters - viewer.interLensDistance) / 2;
  var eyeY = viewer.baselineLensDistance - device.bevelMeters;
  var left = (undistortedFrustum[0] * dist + eyeX) / device.widthMeters;
  var top = (undistortedFrustum[1] * dist + eyeY) / device.heightMeters;
  var right = (undistortedFrustum[2] * dist + eyeX) / device.widthMeters;
  var bottom = (undistortedFrustum[3] * dist + eyeY) / device.heightMeters;
  return {
    x: left,
    y: bottom,
    width: right - left,
    height: top - bottom
  };
};
DeviceInfo.prototype.getFieldOfViewLeftEye = function (opt_isUndistorted) {
  return opt_isUndistorted ? this.getUndistortedFieldOfViewLeftEye() : this.getDistortedFieldOfViewLeftEye();
};
DeviceInfo.prototype.getFieldOfViewRightEye = function (opt_isUndistorted) {
  var fov = this.getFieldOfViewLeftEye(opt_isUndistorted);
  return {
    leftDegrees: fov.rightDegrees,
    rightDegrees: fov.leftDegrees,
    upDegrees: fov.upDegrees,
    downDegrees: fov.downDegrees
  };
};
DeviceInfo.prototype.getUndistortedFieldOfViewLeftEye = function () {
  var p = this.getUndistortedParams_();
  return {
    leftDegrees: radToDeg * Math.atan(p.outerDist),
    rightDegrees: radToDeg * Math.atan(p.innerDist),
    downDegrees: radToDeg * Math.atan(p.bottomDist),
    upDegrees: radToDeg * Math.atan(p.topDist)
  };
};
DeviceInfo.prototype.getUndistortedViewportLeftEye = function () {
  var p = this.getUndistortedParams_();
  var viewer = this.viewer;
  var device = this.device;
  var eyeToScreenDistance = viewer.screenLensDistance;
  var screenWidth = device.widthMeters / eyeToScreenDistance;
  var screenHeight = device.heightMeters / eyeToScreenDistance;
  var xPxPerTanAngle = device.width / screenWidth;
  var yPxPerTanAngle = device.height / screenHeight;
  var x = Math.round((p.eyePosX - p.outerDist) * xPxPerTanAngle);
  var y = Math.round((p.eyePosY - p.bottomDist) * yPxPerTanAngle);
  return {
    x: x,
    y: y,
    width: Math.round((p.eyePosX + p.innerDist) * xPxPerTanAngle) - x,
    height: Math.round((p.eyePosY + p.topDist) * yPxPerTanAngle) - y
  };
};
DeviceInfo.prototype.getUndistortedParams_ = function () {
  var viewer = this.viewer;
  var device = this.device;
  var distortion = this.distortion;
  var eyeToScreenDistance = viewer.screenLensDistance;
  var halfLensDistance = viewer.interLensDistance / 2 / eyeToScreenDistance;
  var screenWidth = device.widthMeters / eyeToScreenDistance;
  var screenHeight = device.heightMeters / eyeToScreenDistance;
  var eyePosX = screenWidth / 2 - halfLensDistance;
  var eyePosY = (viewer.baselineLensDistance - device.bevelMeters) / eyeToScreenDistance;
  var maxFov = viewer.fov;
  var viewerMax = distortion.distortInverse(Math.tan(degToRad * maxFov));
  var outerDist = Math.min(eyePosX, viewerMax);
  var innerDist = Math.min(halfLensDistance, viewerMax);
  var bottomDist = Math.min(eyePosY, viewerMax);
  var topDist = Math.min(screenHeight - eyePosY, viewerMax);
  return {
    outerDist: outerDist,
    innerDist: innerDist,
    topDist: topDist,
    bottomDist: bottomDist,
    eyePosX: eyePosX,
    eyePosY: eyePosY
  };
};
function CardboardViewer(params) {
  this.id = params.id;
  this.label = params.label;
  this.fov = params.fov;
  this.interLensDistance = params.interLensDistance;
  this.baselineLensDistance = params.baselineLensDistance;
  this.screenLensDistance = params.screenLensDistance;
  this.distortionCoefficients = params.distortionCoefficients;
  this.inverseCoefficients = params.inverseCoefficients;
}
DeviceInfo.Viewers = Viewers;
var format = 1;
var last_updated = "2019-11-09T17:36:14Z";
var devices = [{"type":"android","rules":[{"mdmh":"asus/*/Nexus 7/*"},{"ua":"Nexus 7"}],"dpi":[320.8,323],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"asus/*/ASUS_X00PD/*"},{"ua":"ASUS_X00PD"}],"dpi":245,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"asus/*/ASUS_X008D/*"},{"ua":"ASUS_X008D"}],"dpi":282,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"asus/*/ASUS_Z00AD/*"},{"ua":"ASUS_Z00AD"}],"dpi":[403,404.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Google/*/Pixel 2 XL/*"},{"ua":"Pixel 2 XL"}],"dpi":537.9,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Google/*/Pixel 3 XL/*"},{"ua":"Pixel 3 XL"}],"dpi":[558.5,553.8],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Google/*/Pixel XL/*"},{"ua":"Pixel XL"}],"dpi":[537.9,533],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Google/*/Pixel 3/*"},{"ua":"Pixel 3"}],"dpi":442.4,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Google/*/Pixel 2/*"},{"ua":"Pixel 2"}],"dpi":441,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"Google/*/Pixel/*"},{"ua":"Pixel"}],"dpi":[432.6,436.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"HTC/*/HTC6435LVW/*"},{"ua":"HTC6435LVW"}],"dpi":[449.7,443.3],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One XL/*"},{"ua":"HTC One XL"}],"dpi":[315.3,314.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"htc/*/Nexus 9/*"},{"ua":"Nexus 9"}],"dpi":289,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One M9/*"},{"ua":"HTC One M9"}],"dpi":[442.5,443.3],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One_M8/*"},{"ua":"HTC One_M8"}],"dpi":[449.7,447.4],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"HTC/*/HTC One/*"},{"ua":"HTC One"}],"dpi":472.8,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Huawei/*/Nexus 6P/*"},{"ua":"Nexus 6P"}],"dpi":[515.1,518],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Huawei/*/BLN-L24/*"},{"ua":"HONORBLN-L24"}],"dpi":480,"bw":4,"ac":500},{"type":"android","rules":[{"mdmh":"Huawei/*/BKL-L09/*"},{"ua":"BKL-L09"}],"dpi":403,"bw":3.47,"ac":500},{"type":"android","rules":[{"mdmh":"LENOVO/*/Lenovo PB2-690Y/*"},{"ua":"Lenovo PB2-690Y"}],"dpi":[457.2,454.713],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"LGE/*/Nexus 5X/*"},{"ua":"Nexus 5X"}],"dpi":[422,419.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LGMS345/*"},{"ua":"LGMS345"}],"dpi":[221.7,219.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"LGE/*/LG-D800/*"},{"ua":"LG-D800"}],"dpi":[422,424.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"LGE/*/LG-D850/*"},{"ua":"LG-D850"}],"dpi":[537.9,541.9],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"LGE/*/VS985 4G/*"},{"ua":"VS985 4G"}],"dpi":[537.9,535.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/Nexus 5/*"},{"ua":"Nexus 5 B"}],"dpi":[442.4,444.8],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/Nexus 4/*"},{"ua":"Nexus 4"}],"dpi":[319.8,318.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LG-P769/*"},{"ua":"LG-P769"}],"dpi":[240.6,247.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LGMS323/*"},{"ua":"LGMS323"}],"dpi":[206.6,204.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"LGE/*/LGLS996/*"},{"ua":"LGLS996"}],"dpi":[403.4,401.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Micromax/*/4560MMX/*"},{"ua":"4560MMX"}],"dpi":[240,219.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Micromax/*/A250/*"},{"ua":"Micromax A250"}],"dpi":[480,446.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Micromax/*/Micromax AQ4501/*"},{"ua":"Micromax AQ4501"}],"dpi":240,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/G5/*"},{"ua":"Moto G (5) Plus"}],"dpi":[403.4,403],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/DROID RAZR/*"},{"ua":"DROID RAZR"}],"dpi":[368.1,256.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT830C/*"},{"ua":"XT830C"}],"dpi":[254,255.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1021/*"},{"ua":"XT1021"}],"dpi":[254,256.7],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1023/*"},{"ua":"XT1023"}],"dpi":[254,256.7],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1028/*"},{"ua":"XT1028"}],"dpi":[326.6,327.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1034/*"},{"ua":"XT1034"}],"dpi":[326.6,328.4],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1053/*"},{"ua":"XT1053"}],"dpi":[315.3,316.1],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1562/*"},{"ua":"XT1562"}],"dpi":[403.4,402.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/Nexus 6/*"},{"ua":"Nexus 6 B"}],"dpi":[494.3,489.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1063/*"},{"ua":"XT1063"}],"dpi":[295,296.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/XT1064/*"},{"ua":"XT1064"}],"dpi":[295,295.6],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1092/*"},{"ua":"XT1092"}],"dpi":[422,424.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"motorola/*/XT1095/*"},{"ua":"XT1095"}],"dpi":[422,423.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"motorola/*/G4/*"},{"ua":"Moto G (4)"}],"dpi":401,"bw":4,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/A0001/*"},{"ua":"A0001"}],"dpi":[403.4,401],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONE E1001/*"},{"ua":"ONE E1001"}],"dpi":[442.4,441.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONE E1003/*"},{"ua":"ONE E1003"}],"dpi":[442.4,441.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONE E1005/*"},{"ua":"ONE E1005"}],"dpi":[442.4,441.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONE A2001/*"},{"ua":"ONE A2001"}],"dpi":[391.9,405.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONE A2003/*"},{"ua":"ONE A2003"}],"dpi":[391.9,405.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONE A2005/*"},{"ua":"ONE A2005"}],"dpi":[391.9,405.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONEPLUS A3000/*"},{"ua":"ONEPLUS A3000"}],"dpi":401,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONEPLUS A3003/*"},{"ua":"ONEPLUS A3003"}],"dpi":401,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONEPLUS A3010/*"},{"ua":"ONEPLUS A3010"}],"dpi":401,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONEPLUS A5000/*"},{"ua":"ONEPLUS A5000 "}],"dpi":[403.411,399.737],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONE A5010/*"},{"ua":"ONEPLUS A5010"}],"dpi":[403,400],"bw":2,"ac":1000},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONEPLUS A6000/*"},{"ua":"ONEPLUS A6000"}],"dpi":401,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONEPLUS A6003/*"},{"ua":"ONEPLUS A6003"}],"dpi":401,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONEPLUS A6010/*"},{"ua":"ONEPLUS A6010"}],"dpi":401,"bw":2,"ac":500},{"type":"android","rules":[{"mdmh":"OnePlus/*/ONEPLUS A6013/*"},{"ua":"ONEPLUS A6013"}],"dpi":401,"bw":2,"ac":500},{"type":"android","rules":[{"mdmh":"OPPO/*/X909/*"},{"ua":"X909"}],"dpi":[442.4,444.1],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9082/*"},{"ua":"GT-I9082"}],"dpi":[184.7,185.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G360P/*"},{"ua":"SM-G360P"}],"dpi":[196.7,205.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/Nexus S/*"},{"ua":"Nexus S"}],"dpi":[234.5,229.8],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9300/*"},{"ua":"GT-I9300"}],"dpi":[304.8,303.9],"bw":5,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-T230NU/*"},{"ua":"SM-T230NU"}],"dpi":216,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SGH-T399/*"},{"ua":"SGH-T399"}],"dpi":[217.7,231.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SGH-M919/*"},{"ua":"SGH-M919"}],"dpi":[440.8,437.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N9005/*"},{"ua":"SM-N9005"}],"dpi":[386.4,387],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SAMSUNG-SM-N900A/*"},{"ua":"SAMSUNG-SM-N900A"}],"dpi":[386.4,387.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9500/*"},{"ua":"GT-I9500"}],"dpi":[442.5,443.3],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9505/*"},{"ua":"GT-I9505"}],"dpi":439.4,"bw":4,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G900F/*"},{"ua":"SM-G900F"}],"dpi":[415.6,431.6],"bw":5,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G900M/*"},{"ua":"SM-G900M"}],"dpi":[415.6,431.6],"bw":5,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G800F/*"},{"ua":"SM-G800F"}],"dpi":326.8,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G906S/*"},{"ua":"SM-G906S"}],"dpi":[562.7,572.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9300/*"},{"ua":"GT-I9300"}],"dpi":[306.7,304.8],"bw":5,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-T535/*"},{"ua":"SM-T535"}],"dpi":[142.6,136.4],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N920C/*"},{"ua":"SM-N920C"}],"dpi":[515.1,518.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N920P/*"},{"ua":"SM-N920P"}],"dpi":[386.3655,390.144],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N920W8/*"},{"ua":"SM-N920W8"}],"dpi":[515.1,518.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9300I/*"},{"ua":"GT-I9300I"}],"dpi":[304.8,305.8],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-I9195/*"},{"ua":"GT-I9195"}],"dpi":[249.4,256.7],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SPH-L520/*"},{"ua":"SPH-L520"}],"dpi":[249.4,255.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SAMSUNG-SGH-I717/*"},{"ua":"SAMSUNG-SGH-I717"}],"dpi":285.8,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SPH-D710/*"},{"ua":"SPH-D710"}],"dpi":[217.7,204.2],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/GT-N7100/*"},{"ua":"GT-N7100"}],"dpi":265.1,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SCH-I605/*"},{"ua":"SCH-I605"}],"dpi":265.1,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/Galaxy Nexus/*"},{"ua":"Galaxy Nexus"}],"dpi":[315.3,314.2],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N910H/*"},{"ua":"SM-N910H"}],"dpi":[515.1,518],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-N910C/*"},{"ua":"SM-N910C"}],"dpi":[515.2,520.2],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G130M/*"},{"ua":"SM-G130M"}],"dpi":[165.9,164.8],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G928I/*"},{"ua":"SM-G928I"}],"dpi":[515.1,518.4],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G920F/*"},{"ua":"SM-G920F"}],"dpi":580.6,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G920P/*"},{"ua":"SM-G920P"}],"dpi":[522.5,577],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G925F/*"},{"ua":"SM-G925F"}],"dpi":580.6,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G925V/*"},{"ua":"SM-G925V"}],"dpi":[522.5,576.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G930F/*"},{"ua":"SM-G930F"}],"dpi":576.6,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G935F/*"},{"ua":"SM-G935F"}],"dpi":533,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G950F/*"},{"ua":"SM-G950F"}],"dpi":[562.707,565.293],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G955U/*"},{"ua":"SM-G955U"}],"dpi":[522.514,525.762],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G955F/*"},{"ua":"SM-G955F"}],"dpi":[522.514,525.762],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G960F/*"},{"ua":"SM-G960F"}],"dpi":[569.575,571.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G9600/*"},{"ua":"SM-G9600"}],"dpi":[569.575,571.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G960T/*"},{"ua":"SM-G960T"}],"dpi":[569.575,571.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G960N/*"},{"ua":"SM-G960N"}],"dpi":[569.575,571.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G960U/*"},{"ua":"SM-G960U"}],"dpi":[569.575,571.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G9608/*"},{"ua":"SM-G9608"}],"dpi":[569.575,571.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G960FD/*"},{"ua":"SM-G960FD"}],"dpi":[569.575,571.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G960W/*"},{"ua":"SM-G960W"}],"dpi":[569.575,571.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G965F/*"},{"ua":"SM-G965F"}],"dpi":529,"bw":2,"ac":1000},{"type":"android","rules":[{"mdmh":"Sony/*/C6903/*"},{"ua":"C6903"}],"dpi":[442.5,443.3],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"Sony/*/D6653/*"},{"ua":"D6653"}],"dpi":[428.6,427.6],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Sony/*/E6653/*"},{"ua":"E6653"}],"dpi":[428.6,425.7],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Sony/*/E6853/*"},{"ua":"E6853"}],"dpi":[403.4,401.9],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Sony/*/SGP321/*"},{"ua":"SGP321"}],"dpi":[224.7,224.1],"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"TCT/*/ALCATEL ONE TOUCH Fierce/*"},{"ua":"ALCATEL ONE TOUCH Fierce"}],"dpi":[240,247.5],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"THL/*/thl 5000/*"},{"ua":"thl 5000"}],"dpi":[480,443.3],"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"Fly/*/IQ4412/*"},{"ua":"IQ4412"}],"dpi":307.9,"bw":3,"ac":1000},{"type":"android","rules":[{"mdmh":"ZTE/*/ZTE Blade L2/*"},{"ua":"ZTE Blade L2"}],"dpi":240,"bw":3,"ac":500},{"type":"android","rules":[{"mdmh":"BENEVE/*/VR518/*"},{"ua":"VR518"}],"dpi":480,"bw":3,"ac":500},{"type":"ios","rules":[{"res":[640,960]}],"dpi":[325.1,328.4],"bw":4,"ac":1000},{"type":"ios","rules":[{"res":[640,1136]}],"dpi":[317.1,320.2],"bw":3,"ac":1000},{"type":"ios","rules":[{"res":[750,1334]}],"dpi":326.4,"bw":4,"ac":1000},{"type":"ios","rules":[{"res":[1242,2208]}],"dpi":[453.6,458.4],"bw":4,"ac":1000},{"type":"ios","rules":[{"res":[1125,2001]}],"dpi":[410.9,415.4],"bw":4,"ac":1000},{"type":"ios","rules":[{"res":[1125,2436]}],"dpi":458,"bw":4,"ac":1000},{"type":"android","rules":[{"mdmh":"Huawei/*/EML-L29/*"},{"ua":"EML-L29"}],"dpi":428,"bw":3.45,"ac":500},{"type":"android","rules":[{"mdmh":"Nokia/*/Nokia 7.1/*"},{"ua":"Nokia 7.1"}],"dpi":[432,431.9],"bw":3,"ac":500},{"type":"ios","rules":[{"res":[1242,2688]}],"dpi":458,"bw":4,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G570M/*"},{"ua":"SM-G570M"}],"dpi":320,"bw":3.684,"ac":1000},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G970F/*"},{"ua":"SM-G970F"}],"dpi":438,"bw":2.281,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G973F/*"},{"ua":"SM-G973F"}],"dpi":550,"bw":2.002,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G975F/*"},{"ua":"SM-G975F"}],"dpi":522,"bw":2.054,"ac":500},{"type":"android","rules":[{"mdmh":"samsung/*/SM-G977F/*"},{"ua":"SM-G977F"}],"dpi":505,"bw":2.334,"ac":500},{"type":"ios","rules":[{"res":[828,1792]}],"dpi":326,"bw":5,"ac":500}];
var DPDB_CACHE = {
	format: format,
	last_updated: last_updated,
	devices: devices
};
function Dpdb(url, onDeviceParamsUpdated) {
  this.dpdb = DPDB_CACHE;
  this.recalculateDeviceParams_();
  if (url) {
    this.onDeviceParamsUpdated = onDeviceParamsUpdated;
    var xhr = new XMLHttpRequest();
    var obj = this;
    xhr.open('GET', url, true);
    xhr.addEventListener('load', function () {
      obj.loading = false;
      if (xhr.status >= 200 && xhr.status <= 299) {
        obj.dpdb = JSON.parse(xhr.response);
        obj.recalculateDeviceParams_();
      } else {
        console.error('Error loading online DPDB!');
      }
    });
    xhr.send();
  }
}
Dpdb.prototype.getDeviceParams = function () {
  return this.deviceParams;
};
Dpdb.prototype.recalculateDeviceParams_ = function () {
  var newDeviceParams = this.calcDeviceParams_();
  if (newDeviceParams) {
    this.deviceParams = newDeviceParams;
    if (this.onDeviceParamsUpdated) {
      this.onDeviceParamsUpdated(this.deviceParams);
    }
  } else {
    console.error('Failed to recalculate device parameters.');
  }
};
Dpdb.prototype.calcDeviceParams_ = function () {
  var db = this.dpdb;
  if (!db) {
    console.error('DPDB not available.');
    return null;
  }
  if (db.format != 1) {
    console.error('DPDB has unexpected format version.');
    return null;
  }
  if (!db.devices || !db.devices.length) {
    console.error('DPDB does not have a devices section.');
    return null;
  }
  var userAgent = navigator.userAgent || navigator.vendor || window.opera;
  var width = getScreenWidth();
  var height = getScreenHeight();
  if (!db.devices) {
    console.error('DPDB has no devices section.');
    return null;
  }
  for (var i = 0; i < db.devices.length; i++) {
    var device = db.devices[i];
    if (!device.rules) {
      console.warn('Device[' + i + '] has no rules section.');
      continue;
    }
    if (device.type != 'ios' && device.type != 'android') {
      console.warn('Device[' + i + '] has invalid type.');
      continue;
    }
    if (isIOS() != (device.type == 'ios')) continue;
    var matched = false;
    for (var j = 0; j < device.rules.length; j++) {
      var rule = device.rules[j];
      if (this.ruleMatches_(rule, userAgent, width, height)) {
        matched = true;
        break;
      }
    }
    if (!matched) continue;
    var xdpi = device.dpi[0] || device.dpi;
    var ydpi = device.dpi[1] || device.dpi;
    return new DeviceParams({ xdpi: xdpi, ydpi: ydpi, bevelMm: device.bw });
  }
  console.warn('No DPDB device match.');
  return null;
};
Dpdb.prototype.ruleMatches_ = function (rule, ua, screenWidth, screenHeight) {
  if (!rule.ua && !rule.res) return false;
  if (rule.ua && rule.ua.substring(0, 2) === 'SM') rule.ua = rule.ua.substring(0, 7);
  if (rule.ua && ua.indexOf(rule.ua) < 0) return false;
  if (rule.res) {
    if (!rule.res[0] || !rule.res[1]) return false;
    var resX = rule.res[0];
    var resY = rule.res[1];
    if (Math.min(screenWidth, screenHeight) != Math.min(resX, resY) || Math.max(screenWidth, screenHeight) != Math.max(resX, resY)) {
      return false;
    }
  }
  return true;
};
function DeviceParams(params) {
  this.xdpi = params.xdpi;
  this.ydpi = params.ydpi;
  this.bevelMm = params.bevelMm;
}
function SensorSample(sample, timestampS) {
  this.set(sample, timestampS);
}
SensorSample.prototype.set = function (sample, timestampS) {
  this.sample = sample;
  this.timestampS = timestampS;
};
SensorSample.prototype.copy = function (sensorSample) {
  this.set(sensorSample.sample, sensorSample.timestampS);
};
function ComplementaryFilter(kFilter, isDebug) {
  this.kFilter = kFilter;
  this.isDebug = isDebug;
  this.currentAccelMeasurement = new SensorSample();
  this.currentGyroMeasurement = new SensorSample();
  this.previousGyroMeasurement = new SensorSample();
  if (isIOS()) {
    this.filterQ = new Quaternion(-1, 0, 0, 1);
  } else {
    this.filterQ = new Quaternion(1, 0, 0, 1);
  }
  this.previousFilterQ = new Quaternion();
  this.previousFilterQ.copy(this.filterQ);
  this.accelQ = new Quaternion();
  this.isOrientationInitialized = false;
  this.estimatedGravity = new Vector3();
  this.measuredGravity = new Vector3();
  this.gyroIntegralQ = new Quaternion();
}
ComplementaryFilter.prototype.addAccelMeasurement = function (vector, timestampS) {
  this.currentAccelMeasurement.set(vector, timestampS);
};
ComplementaryFilter.prototype.addGyroMeasurement = function (vector, timestampS) {
  this.currentGyroMeasurement.set(vector, timestampS);
  var deltaT = timestampS - this.previousGyroMeasurement.timestampS;
  if (isTimestampDeltaValid(deltaT)) {
    this.run_();
  }
  this.previousGyroMeasurement.copy(this.currentGyroMeasurement);
};
ComplementaryFilter.prototype.run_ = function () {
  if (!this.isOrientationInitialized) {
    this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample);
    this.previousFilterQ.copy(this.accelQ);
    this.isOrientationInitialized = true;
    return;
  }
  var deltaT = this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS;
  var gyroDeltaQ = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, deltaT);
  this.gyroIntegralQ.multiply(gyroDeltaQ);
  this.filterQ.copy(this.previousFilterQ);
  this.filterQ.multiply(gyroDeltaQ);
  var invFilterQ = new Quaternion();
  invFilterQ.copy(this.filterQ);
  invFilterQ.inverse();
  this.estimatedGravity.set(0, 0, -1);
  this.estimatedGravity.applyQuaternion(invFilterQ);
  this.estimatedGravity.normalize();
  this.measuredGravity.copy(this.currentAccelMeasurement.sample);
  this.measuredGravity.normalize();
  var deltaQ = new Quaternion();
  deltaQ.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
  deltaQ.inverse();
  if (this.isDebug) {
    console.log('Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)', radToDeg * getQuaternionAngle(deltaQ), this.estimatedGravity.x.toFixed(1), this.estimatedGravity.y.toFixed(1), this.estimatedGravity.z.toFixed(1), this.measuredGravity.x.toFixed(1), this.measuredGravity.y.toFixed(1), this.measuredGravity.z.toFixed(1));
  }
  var targetQ = new Quaternion();
  targetQ.copy(this.filterQ);
  targetQ.multiply(deltaQ);
  this.filterQ.slerp(targetQ, 1 - this.kFilter);
  this.previousFilterQ.copy(this.filterQ);
};
ComplementaryFilter.prototype.getOrientation = function () {
  return this.filterQ;
};
ComplementaryFilter.prototype.accelToQuaternion_ = function (accel) {
  var normAccel = new Vector3();
  normAccel.copy(accel);
  normAccel.normalize();
  var quat = new Quaternion();
  quat.setFromUnitVectors(new Vector3(0, 0, -1), normAccel);
  quat.inverse();
  return quat;
};
ComplementaryFilter.prototype.gyroToQuaternionDelta_ = function (gyro, dt) {
  var quat = new Quaternion();
  var axis = new Vector3();
  axis.copy(gyro);
  axis.normalize();
  quat.setFromAxisAngle(axis, gyro.length() * dt);
  return quat;
};
function PosePredictor(predictionTimeS, isDebug) {
  this.predictionTimeS = predictionTimeS;
  this.isDebug = isDebug;
  this.previousQ = new Quaternion();
  this.previousTimestampS = null;
  this.deltaQ = new Quaternion();
  this.outQ = new Quaternion();
}
PosePredictor.prototype.getPrediction = function (currentQ, gyro, timestampS) {
  if (!this.previousTimestampS) {
    this.previousQ.copy(currentQ);
    this.previousTimestampS = timestampS;
    return currentQ;
  }
  var axis = new Vector3();
  axis.copy(gyro);
  axis.normalize();
  var angularSpeed = gyro.length();
  if (angularSpeed < degToRad * 20) {
    if (this.isDebug) {
      console.log('Moving slowly, at %s deg/s: no prediction', (radToDeg * angularSpeed).toFixed(1));
    }
    this.outQ.copy(currentQ);
    this.previousQ.copy(currentQ);
    return this.outQ;
  }
  var predictAngle = angularSpeed * this.predictionTimeS;
  this.deltaQ.setFromAxisAngle(axis, predictAngle);
  this.outQ.copy(this.previousQ);
  this.outQ.multiply(this.deltaQ);
  this.previousQ.copy(currentQ);
  this.previousTimestampS = timestampS;
  return this.outQ;
};
function FusionPoseSensor(kFilter, predictionTime, yawOnly, isDebug) {
  this.yawOnly = yawOnly;
  this.accelerometer = new Vector3();
  this.gyroscope = new Vector3();
  this.filter = new ComplementaryFilter(kFilter, isDebug);
  this.posePredictor = new PosePredictor(predictionTime, isDebug);
  this.isFirefoxAndroid = isFirefoxAndroid();
  this.isIOS = isIOS();
  var chromeVersion = getChromeVersion();
  this.isDeviceMotionInRadians = !this.isIOS && chromeVersion && chromeVersion < 66;
  this.isWithoutDeviceMotion = isChromeWithoutDeviceMotion() || isSafariWithoutDeviceMotion();
  this.filterToWorldQ = new Quaternion();
  if (isIOS()) {
    this.filterToWorldQ.setFromAxisAngle(new Vector3(1, 0, 0), Math.PI / 2);
  } else {
    this.filterToWorldQ.setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
  }
  this.inverseWorldToScreenQ = new Quaternion();
  this.worldToScreenQ = new Quaternion();
  this.originalPoseAdjustQ = new Quaternion();
  this.originalPoseAdjustQ.setFromAxisAngle(new Vector3(0, 0, 1), -window.orientation * Math.PI / 180);
  this.setScreenTransform_();
  if (isLandscapeMode()) {
    this.filterToWorldQ.multiply(this.inverseWorldToScreenQ);
  }
  this.resetQ = new Quaternion();
  this.orientationOut_ = new Float32Array(4);
  this.start();
}
FusionPoseSensor.prototype.getPosition = function () {
  return null;
};
FusionPoseSensor.prototype.getOrientation = function () {
  var orientation = void 0;
  if (this.isWithoutDeviceMotion && this._deviceOrientationQ) {
    this.deviceOrientationFixQ = this.deviceOrientationFixQ || function () {
      var z = new Quaternion().setFromAxisAngle(new Vector3(0, 0, -1), 0);
      var y = new Quaternion();
      if (window.orientation === -90) {
        y.setFromAxisAngle(new Vector3(0, 1, 0), Math.PI / -2);
      } else {
        y.setFromAxisAngle(new Vector3(0, 1, 0), Math.PI / 2);
      }
      return z.multiply(y);
    }();
    this.deviceOrientationFilterToWorldQ = this.deviceOrientationFilterToWorldQ || function () {
      var q = new Quaternion();
      q.setFromAxisAngle(new Vector3(1, 0, 0), -Math.PI / 2);
      return q;
    }();
    orientation = this._deviceOrientationQ;
    var out = new Quaternion();
    out.copy(orientation);
    out.multiply(this.deviceOrientationFilterToWorldQ);
    out.multiply(this.resetQ);
    out.multiply(this.worldToScreenQ);
    out.multiplyQuaternions(this.deviceOrientationFixQ, out);
    if (this.yawOnly) {
      out.x = 0;
      out.z = 0;
      out.normalize();
    }
    this.orientationOut_[0] = out.x;
    this.orientationOut_[1] = out.y;
    this.orientationOut_[2] = out.z;
    this.orientationOut_[3] = out.w;
    return this.orientationOut_;
  } else {
    var filterOrientation = this.filter.getOrientation();
    orientation = this.posePredictor.getPrediction(filterOrientation, this.gyroscope, this.previousTimestampS);
  }
  var out = new Quaternion();
  out.copy(this.filterToWorldQ);
  out.multiply(this.resetQ);
  out.multiply(orientation);
  out.multiply(this.worldToScreenQ);
  if (this.yawOnly) {
    out.x = 0;
    out.z = 0;
    out.normalize();
  }
  this.orientationOut_[0] = out.x;
  this.orientationOut_[1] = out.y;
  this.orientationOut_[2] = out.z;
  this.orientationOut_[3] = out.w;
  return this.orientationOut_;
};
FusionPoseSensor.prototype.resetPose = function () {
  this.resetQ.copy(this.filter.getOrientation());
  this.resetQ.x = 0;
  this.resetQ.y = 0;
  this.resetQ.z *= -1;
  this.resetQ.normalize();
  if (isLandscapeMode()) {
    this.resetQ.multiply(this.inverseWorldToScreenQ);
  }
  this.resetQ.multiply(this.originalPoseAdjustQ);
};
FusionPoseSensor.prototype.onDeviceOrientation_ = function (e) {
  this._deviceOrientationQ = this._deviceOrientationQ || new Quaternion();
  var alpha = e.alpha,
      beta = e.beta,
      gamma = e.gamma;
  alpha = (alpha || 0) * Math.PI / 180;
  beta = (beta || 0) * Math.PI / 180;
  gamma = (gamma || 0) * Math.PI / 180;
  this._deviceOrientationQ.setFromEulerYXZ(beta, alpha, -gamma);
};
FusionPoseSensor.prototype.onDeviceMotion_ = function (deviceMotion) {
  this.updateDeviceMotion_(deviceMotion);
};
FusionPoseSensor.prototype.updateDeviceMotion_ = function (deviceMotion) {
  var accGravity = deviceMotion.accelerationIncludingGravity;
  var rotRate = deviceMotion.rotationRate;
  var timestampS = deviceMotion.timeStamp / 1000;
  var deltaS = timestampS - this.previousTimestampS;
  if (deltaS < 0) {
    warnOnce('fusion-pose-sensor:invalid:non-monotonic', 'Invalid timestamps detected: non-monotonic timestamp from devicemotion');
    this.previousTimestampS = timestampS;
    return;
  } else if (deltaS <= MIN_TIMESTEP || deltaS > MAX_TIMESTEP) {
    warnOnce('fusion-pose-sensor:invalid:outside-threshold', 'Invalid timestamps detected: Timestamp from devicemotion outside expected range.');
    this.previousTimestampS = timestampS;
    return;
  }
  this.accelerometer.set(-accGravity.x, -accGravity.y, -accGravity.z);
  if (rotRate) {
    if (isR7()) {
      this.gyroscope.set(-rotRate.beta, rotRate.alpha, rotRate.gamma);
    } else {
      this.gyroscope.set(rotRate.alpha, rotRate.beta, rotRate.gamma);
    }
    if (!this.isDeviceMotionInRadians) {
      this.gyroscope.multiplyScalar(Math.PI / 180);
    }
    this.filter.addGyroMeasurement(this.gyroscope, timestampS);
  }
  this.filter.addAccelMeasurement(this.accelerometer, timestampS);
  this.previousTimestampS = timestampS;
};
FusionPoseSensor.prototype.onOrientationChange_ = function (screenOrientation) {
  this.setScreenTransform_();
};
FusionPoseSensor.prototype.onMessage_ = function (event) {
  var message = event.data;
  if (!message || !message.type) {
    return;
  }
  var type = message.type.toLowerCase();
  if (type !== 'devicemotion') {
    return;
  }
  this.updateDeviceMotion_(message.deviceMotionEvent);
};
FusionPoseSensor.prototype.setScreenTransform_ = function () {
  this.worldToScreenQ.set(0, 0, 0, 1);
  switch (window.orientation) {
    case 0:
      break;
    case 90:
      this.worldToScreenQ.setFromAxisAngle(new Vector3(0, 0, 1), -Math.PI / 2);
      break;
    case -90:
      this.worldToScreenQ.setFromAxisAngle(new Vector3(0, 0, 1), Math.PI / 2);
      break;
    case 180:
      break;
  }
  this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
  this.inverseWorldToScreenQ.inverse();
};
FusionPoseSensor.prototype.start = function () {
  this.onDeviceMotionCallback_ = this.onDeviceMotion_.bind(this);
  this.onOrientationChangeCallback_ = this.onOrientationChange_.bind(this);
  this.onMessageCallback_ = this.onMessage_.bind(this);
  this.onDeviceOrientationCallback_ = this.onDeviceOrientation_.bind(this);
  if (isIOS() && isInsideCrossOriginIFrame()) {
    window.addEventListener('message', this.onMessageCallback_);
  }
  window.addEventListener('orientationchange', this.onOrientationChangeCallback_);
  if (this.isWithoutDeviceMotion) {
    window.addEventListener('deviceorientation', this.onDeviceOrientationCallback_);
  } else {
    window.addEventListener('devicemotion', this.onDeviceMotionCallback_);
  }
};
FusionPoseSensor.prototype.stop = function () {
  window.removeEventListener('devicemotion', this.onDeviceMotionCallback_);
  window.removeEventListener('deviceorientation', this.onDeviceOrientationCallback_);
  window.removeEventListener('orientationchange', this.onOrientationChangeCallback_);
  window.removeEventListener('message', this.onMessageCallback_);
};
var SENSOR_FREQUENCY = 60;
var X_AXIS = new Vector3(1, 0, 0);
var Z_AXIS = new Vector3(0, 0, 1);
var SENSOR_TO_VR = new Quaternion();
SENSOR_TO_VR.setFromAxisAngle(X_AXIS, -Math.PI / 2);
SENSOR_TO_VR.multiply(new Quaternion().setFromAxisAngle(Z_AXIS, Math.PI / 2));
var PoseSensor = function () {
  function PoseSensor(config) {
    classCallCheck(this, PoseSensor);
    this.config = config;
    this.sensor = null;
    this.fusionSensor = null;
    this._out = new Float32Array(4);
    this.api = null;
    this.errors = [];
    this._sensorQ = new Quaternion();
    this._outQ = new Quaternion();
    this._onSensorRead = this._onSensorRead.bind(this);
    this._onSensorError = this._onSensorError.bind(this);
    this.init();
  }
  createClass(PoseSensor, [{
    key: 'init',
    value: function init() {
      var sensor = null;
      try {
        sensor = new RelativeOrientationSensor({
          frequency: SENSOR_FREQUENCY,
          referenceFrame: 'screen'
        });
        sensor.addEventListener('error', this._onSensorError);
      } catch (error) {
        this.errors.push(error);
        if (error.name === 'SecurityError') {
          console.error('Cannot construct sensors due to the Feature Policy');
          console.warn('Attempting to fall back using "devicemotion"; however this will ' + 'fail in the future without correct permissions.');
          this.useDeviceMotion();
        } else if (error.name === 'ReferenceError') {
          this.useDeviceMotion();
        } else {
          console.error(error);
        }
      }
      if (sensor) {
        this.api = 'sensor';
        this.sensor = sensor;
        this.sensor.addEventListener('reading', this._onSensorRead);
        this.sensor.start();
      }
    }
  }, {
    key: 'useDeviceMotion',
    value: function useDeviceMotion() {
      this.api = 'devicemotion';
      this.fusionSensor = new FusionPoseSensor(this.config.K_FILTER, this.config.PREDICTION_TIME_S, this.config.YAW_ONLY, this.config.DEBUG);
      if (this.sensor) {
        this.sensor.removeEventListener('reading', this._onSensorRead);
        this.sensor.removeEventListener('error', this._onSensorError);
        this.sensor = null;
      }
    }
  }, {
    key: 'getOrientation',
    value: function getOrientation() {
      if (this.fusionSensor) {
        return this.fusionSensor.getOrientation();
      }
      if (!this.sensor || !this.sensor.quaternion) {
        this._out[0] = this._out[1] = this._out[2] = 0;
        this._out[3] = 1;
        return this._out;
      }
      var q = this.sensor.quaternion;
      this._sensorQ.set(q[0], q[1], q[2], q[3]);
      var out = this._outQ;
      out.copy(SENSOR_TO_VR);
      out.multiply(this._sensorQ);
      if (this.config.YAW_ONLY) {
        out.x = out.z = 0;
        out.normalize();
      }
      this._out[0] = out.x;
      this._out[1] = out.y;
      this._out[2] = out.z;
      this._out[3] = out.w;
      return this._out;
    }
  }, {
    key: '_onSensorError',
    value: function _onSensorError(event) {
      this.errors.push(event.error);
      if (event.error.name === 'NotAllowedError') {
        console.error('Permission to access sensor was denied');
      } else if (event.error.name === 'NotReadableError') {
        console.error('Sensor could not be read');
      } else {
        console.error(event.error);
      }
      this.useDeviceMotion();
    }
  }, {
    key: '_onSensorRead',
    value: function _onSensorRead() {}
  }]);
  return PoseSensor;
}();
var rotateInstructionsAsset = "<svg width='198' height='240' viewBox='0 0 198 240' xmlns='http://www.w3.org/2000/svg'><g fill='none' fill-rule='evenodd'><path d='M149.625 109.527l6.737 3.891v.886c0 .177.013.36.038.549.01.081.02.162.027.242.14 1.415.974 2.998 2.105 3.999l5.72 5.062.081-.09s4.382-2.53 5.235-3.024l25.97 14.993v54.001c0 .771-.386 1.217-.948 1.217-.233 0-.495-.076-.772-.236l-23.967-13.838-.014.024-27.322 15.775-.85-1.323c-4.731-1.529-9.748-2.74-14.951-3.61a.27.27 0 0 0-.007.024l-5.067 16.961-7.891 4.556-.037-.063v27.59c0 .772-.386 1.217-.948 1.217-.232 0-.495-.076-.772-.236l-42.473-24.522c-.95-.549-1.72-1.877-1.72-2.967v-1.035l-.021.047a5.111 5.111 0 0 0-1.816-.399 5.682 5.682 0 0 0-.546.001 13.724 13.724 0 0 1-1.918-.041c-1.655-.153-3.2-.6-4.404-1.296l-46.576-26.89.005.012-10.278-18.75c-1.001-1.827-.241-4.216 1.698-5.336l56.011-32.345a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.659 3.227 1.853l.005-.003.227.413-.006.004a9.63 9.63 0 0 0 1.477 2.018l.277.27c1.914 1.85 4.468 2.801 7.113 2.801 1.949 0 3.948-.517 5.775-1.572.013 0 7.319-4.219 7.319-4.219a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.658 3.226 1.853l3.25 5.928.022-.018 6.785 3.917-.105-.182 46.881-26.965m0-1.635c-.282 0-.563.073-.815.218l-46.169 26.556-5.41-3.124-3.005-5.481c-.913-1.667-2.699-2.702-4.66-2.703-1.011 0-2.02.274-2.917.792a3825 3825 0 0 1-7.275 4.195l-.044.024a9.937 9.937 0 0 1-4.957 1.353c-2.292 0-4.414-.832-5.976-2.342l-.252-.245a7.992 7.992 0 0 1-1.139-1.534 1.379 1.379 0 0 0-.06-.122l-.227-.414a1.718 1.718 0 0 0-.095-.154c-.938-1.574-2.673-2.545-4.571-2.545-1.011 0-2.02.274-2.917.792L3.125 155.502c-2.699 1.559-3.738 4.94-2.314 7.538l10.278 18.75c.177.323.448.563.761.704l46.426 26.804c1.403.81 3.157 1.332 5.072 1.508a15.661 15.661 0 0 0 2.146.046 4.766 4.766 0 0 1 .396 0c.096.004.19.011.283.022.109 1.593 1.159 3.323 2.529 4.114l42.472 24.522c.524.302 1.058.455 1.59.455 1.497 0 2.583-1.2 2.583-2.852v-26.562l7.111-4.105a1.64 1.64 0 0 0 .749-.948l4.658-15.593c4.414.797 8.692 1.848 12.742 3.128l.533.829a1.634 1.634 0 0 0 2.193.531l26.532-15.317L193 192.433c.523.302 1.058.455 1.59.455 1.497 0 2.583-1.199 2.583-2.852v-54.001c0-.584-.312-1.124-.818-1.416l-25.97-14.993a1.633 1.633 0 0 0-1.636.001c-.606.351-2.993 1.73-4.325 2.498l-4.809-4.255c-.819-.725-1.461-1.933-1.561-2.936a7.776 7.776 0 0 0-.033-.294 2.487 2.487 0 0 1-.023-.336v-.886c0-.584-.312-1.123-.817-1.416l-6.739-3.891a1.633 1.633 0 0 0-.817-.219' fill='#455A64'/><path d='M96.027 132.636l46.576 26.891c1.204.695 1.979 1.587 2.242 2.541l-.01.007-81.374 46.982h-.001c-1.654-.152-3.199-.6-4.403-1.295l-46.576-26.891 83.546-48.235' fill='#FAFAFA'/><path d='M63.461 209.174c-.008 0-.015 0-.022-.002-1.693-.156-3.228-.609-4.441-1.309l-46.576-26.89a.118.118 0 0 1 0-.203l83.546-48.235a.117.117 0 0 1 .117 0l46.576 26.891c1.227.708 2.021 1.612 2.296 2.611a.116.116 0 0 1-.042.124l-.021.016-81.375 46.981a.11.11 0 0 1-.058.016zm-50.747-28.303l46.401 26.79c1.178.68 2.671 1.121 4.32 1.276l81.272-46.922c-.279-.907-1.025-1.73-2.163-2.387l-46.517-26.857-83.313 48.1z' fill='#607D8B'/><path d='M148.327 165.471a5.85 5.85 0 0 1-.546.001c-1.894-.083-3.302-1.038-3.145-2.132a2.693 2.693 0 0 0-.072-1.105l-81.103 46.822c.628.058 1.272.073 1.918.042.182-.009.364-.009.546-.001 1.894.083 3.302 1.038 3.145 2.132l79.257-45.759' fill='#FFF'/><path d='M69.07 211.347a.118.118 0 0 1-.115-.134c.045-.317-.057-.637-.297-.925-.505-.61-1.555-1.022-2.738-1.074a5.966 5.966 0 0 0-.535.001 14.03 14.03 0 0 1-1.935-.041.117.117 0 0 1-.103-.092.116.116 0 0 1 .055-.126l81.104-46.822a.117.117 0 0 1 .171.07c.104.381.129.768.074 1.153-.045.316.057.637.296.925.506.61 1.555 1.021 2.739 1.073.178.008.357.008.535-.001a.117.117 0 0 1 .064.218l-79.256 45.759a.114.114 0 0 1-.059.016zm-3.405-2.372c.089 0 .177.002.265.006 1.266.056 2.353.488 2.908 1.158.227.274.35.575.36.882l78.685-45.429c-.036 0-.072-.001-.107-.003-1.267-.056-2.354-.489-2.909-1.158-.282-.34-.402-.724-.347-1.107a2.604 2.604 0 0 0-.032-.91L63.846 208.97a13.91 13.91 0 0 0 1.528.012c.097-.005.194-.007.291-.007z' fill='#607D8B'/><path d='M2.208 162.134c-1.001-1.827-.241-4.217 1.698-5.337l56.011-32.344c1.939-1.12 4.324-.546 5.326 1.281l.232.41a9.344 9.344 0 0 0 1.47 2.021l.278.27c3.325 3.214 8.583 3.716 12.888 1.23l7.319-4.22c1.94-1.119 4.324-.546 5.325 1.282l3.25 5.928-83.519 48.229-10.278-18.75z' fill='#FAFAFA'/><path d='M12.486 181.001a.112.112 0 0 1-.031-.005.114.114 0 0 1-.071-.056L2.106 162.19c-1.031-1.88-.249-4.345 1.742-5.494l56.01-32.344a4.328 4.328 0 0 1 2.158-.588c1.415 0 2.65.702 3.311 1.882.01.008.018.017.024.028l.227.414a.122.122 0 0 1 .013.038 9.508 9.508 0 0 0 1.439 1.959l.275.266c1.846 1.786 4.344 2.769 7.031 2.769 1.977 0 3.954-.538 5.717-1.557a.148.148 0 0 1 .035-.013l7.284-4.206a4.321 4.321 0 0 1 2.157-.588c1.427 0 2.672.716 3.329 1.914l3.249 5.929a.116.116 0 0 1-.044.157l-83.518 48.229a.116.116 0 0 1-.059.016zm49.53-57.004c-.704 0-1.41.193-2.041.557l-56.01 32.345c-1.882 1.086-2.624 3.409-1.655 5.179l10.221 18.645 83.317-48.112-3.195-5.829c-.615-1.122-1.783-1.792-3.124-1.792a4.08 4.08 0 0 0-2.04.557l-7.317 4.225a.148.148 0 0 1-.035.013 11.7 11.7 0 0 1-5.801 1.569c-2.748 0-5.303-1.007-7.194-2.835l-.278-.27a9.716 9.716 0 0 1-1.497-2.046.096.096 0 0 1-.013-.037l-.191-.347a.11.11 0 0 1-.023-.029c-.615-1.123-1.783-1.793-3.124-1.793z' fill='#607D8B'/><path d='M42.434 155.808c-2.51-.001-4.697-1.258-5.852-3.365-1.811-3.304-.438-7.634 3.059-9.654l12.291-7.098a7.599 7.599 0 0 1 3.789-1.033c2.51 0 4.697 1.258 5.852 3.365 1.811 3.304.439 7.634-3.059 9.654l-12.291 7.098a7.606 7.606 0 0 1-3.789 1.033zm13.287-20.683a7.128 7.128 0 0 0-3.555.971l-12.291 7.098c-3.279 1.893-4.573 5.942-2.883 9.024 1.071 1.955 3.106 3.122 5.442 3.122a7.13 7.13 0 0 0 3.556-.97l12.291-7.098c3.279-1.893 4.572-5.942 2.883-9.024-1.072-1.955-3.106-3.123-5.443-3.123z' fill='#607D8B'/><path d='M149.588 109.407l6.737 3.89v.887c0 .176.013.36.037.549.011.081.02.161.028.242.14 1.415.973 2.998 2.105 3.999l7.396 6.545c.177.156.358.295.541.415 1.579 1.04 2.95.466 3.062-1.282.049-.784.057-1.595.023-2.429l-.003-.16v-1.151l25.987 15.003v54c0 1.09-.77 1.53-1.72.982l-42.473-24.523c-.95-.548-1.72-1.877-1.72-2.966v-34.033' fill='#FAFAFA'/><path d='M194.553 191.25c-.257 0-.54-.085-.831-.253l-42.472-24.521c-.981-.567-1.779-1.943-1.779-3.068v-34.033h.234v34.033c0 1.051.745 2.336 1.661 2.866l42.473 24.521c.424.245.816.288 1.103.122.285-.164.442-.52.442-1.002v-53.933l-25.753-14.868.003 1.106c.034.832.026 1.654-.024 2.439-.054.844-.396 1.464-.963 1.746-.619.309-1.45.173-2.28-.373a5.023 5.023 0 0 1-.553-.426l-7.397-6.544c-1.158-1.026-1.999-2.625-2.143-4.076a9.624 9.624 0 0 0-.027-.238 4.241 4.241 0 0 1-.038-.564v-.82l-6.68-3.856.117-.202 6.738 3.89.058.034v.954c0 .171.012.351.036.533.011.083.021.165.029.246.138 1.395.948 2.935 2.065 3.923l7.397 6.545c.173.153.35.289.527.406.758.499 1.504.63 2.047.359.49-.243.786-.795.834-1.551.05-.778.057-1.591.024-2.417l-.004-.163v-1.355l.175.1 25.987 15.004.059.033v54.068c0 .569-.198.996-.559 1.204a1.002 1.002 0 0 1-.506.131' fill='#607D8B'/><path d='M145.685 163.161l24.115 13.922-25.978 14.998-1.462-.307c-6.534-2.17-13.628-3.728-21.019-4.616-4.365-.524-8.663 1.096-9.598 3.62a2.746 2.746 0 0 0-.011 1.928c1.538 4.267 4.236 8.363 7.995 12.135l.532.845-25.977 14.997-24.115-13.922 75.518-43.6' fill='#FFF'/><path d='M94.282 220.818l-.059-.033-24.29-14.024.175-.101 75.577-43.634.058.033 24.29 14.024-26.191 15.122-.045-.01-1.461-.307c-6.549-2.174-13.613-3.725-21.009-4.614a13.744 13.744 0 0 0-1.638-.097c-3.758 0-7.054 1.531-7.837 3.642a2.62 2.62 0 0 0-.01 1.848c1.535 4.258 4.216 8.326 7.968 12.091l.016.021.526.835.006.01.064.102-.105.061-25.977 14.998-.058.033zm-23.881-14.057l23.881 13.788 24.802-14.32c.546-.315.846-.489 1.017-.575l-.466-.74c-3.771-3.787-6.467-7.881-8.013-12.168a2.851 2.851 0 0 1 .011-2.008c.815-2.199 4.203-3.795 8.056-3.795.557 0 1.117.033 1.666.099 7.412.891 14.491 2.445 21.041 4.621.836.175 1.215.254 1.39.304l25.78-14.884-23.881-13.788-75.284 43.466z' fill='#607D8B'/><path d='M167.23 125.979v50.871l-27.321 15.773-6.461-14.167c-.91-1.996-3.428-1.738-5.624.574a10.238 10.238 0 0 0-2.33 4.018l-6.46 21.628-27.322 15.774v-50.871l75.518-43.6' fill='#FFF'/><path d='M91.712 220.567a.127.127 0 0 1-.059-.016.118.118 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.519-43.6a.117.117 0 0 1 .175.101v50.871c0 .041-.023.08-.059.1l-27.321 15.775a.118.118 0 0 1-.094.01.12.12 0 0 1-.071-.063l-6.46-14.168c-.375-.822-1.062-1.275-1.934-1.275-1.089 0-2.364.686-3.5 1.881a10.206 10.206 0 0 0-2.302 3.972l-6.46 21.627a.118.118 0 0 1-.054.068L91.77 220.551a.12.12 0 0 1-.058.016zm.117-50.92v50.601l27.106-15.65 6.447-21.583a10.286 10.286 0 0 1 2.357-4.065c1.18-1.242 2.517-1.954 3.669-1.954.969 0 1.731.501 2.146 1.411l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M168.543 126.213v50.87l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.624.574a10.248 10.248 0 0 0-2.33 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6' fill='#FFF'/><path d='M93.025 220.8a.123.123 0 0 1-.059-.015.12.12 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.518-43.6a.112.112 0 0 1 .117 0c.036.02.059.059.059.1v50.871a.116.116 0 0 1-.059.101l-27.321 15.774a.111.111 0 0 1-.094.01.115.115 0 0 1-.071-.062l-6.46-14.168c-.375-.823-1.062-1.275-1.935-1.275-1.088 0-2.363.685-3.499 1.881a10.19 10.19 0 0 0-2.302 3.971l-6.461 21.628a.108.108 0 0 1-.053.067l-27.322 15.775a.12.12 0 0 1-.058.015zm.117-50.919v50.6l27.106-15.649 6.447-21.584a10.293 10.293 0 0 1 2.357-4.065c1.179-1.241 2.516-1.954 3.668-1.954.969 0 1.732.502 2.147 1.412l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M169.8 177.083l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.625.574a10.246 10.246 0 0 0-2.329 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6v50.87z' fill='#FAFAFA'/><path d='M94.282 220.917a.234.234 0 0 1-.234-.233v-50.871c0-.083.045-.161.117-.202l75.518-43.601a.234.234 0 1 1 .35.202v50.871a.233.233 0 0 1-.116.202l-27.322 15.775a.232.232 0 0 1-.329-.106l-6.461-14.168c-.36-.789-.992-1.206-1.828-1.206-1.056 0-2.301.672-3.415 1.844a10.099 10.099 0 0 0-2.275 3.924l-6.46 21.628a.235.235 0 0 1-.107.136l-27.322 15.774a.23.23 0 0 1-.116.031zm.233-50.969v50.331l26.891-15.525 6.434-21.539a10.41 10.41 0 0 1 2.384-4.112c1.201-1.265 2.569-1.991 3.753-1.991 1.018 0 1.818.526 2.253 1.48l6.354 13.934 26.982-15.578v-50.331l-75.051 43.331z' fill='#607D8B'/><path d='M109.894 199.943c-1.774 0-3.241-.725-4.244-2.12a.224.224 0 0 1 .023-.294.233.233 0 0 1 .301-.023c.78.547 1.705.827 2.75.827 1.323 0 2.754-.439 4.256-1.306 5.311-3.067 9.631-10.518 9.631-16.611 0-1.927-.442-3.56-1.278-4.724a.232.232 0 0 1 .323-.327c1.671 1.172 2.591 3.381 2.591 6.219 0 6.242-4.426 13.863-9.865 17.003-1.574.908-3.084 1.356-4.488 1.356zm-2.969-1.542c.813.651 1.82.877 2.968.877h.001c1.321 0 2.753-.327 4.254-1.194 5.311-3.067 9.632-10.463 9.632-16.556 0-1.979-.463-3.599-1.326-4.761.411 1.035.625 2.275.625 3.635 0 6.243-4.426 13.883-9.865 17.023-1.574.909-3.084 1.317-4.49 1.317-.641 0-1.243-.149-1.799-.341z' fill='#607D8B'/><path d='M113.097 197.23c5.384-3.108 9.748-10.636 9.748-16.814 0-2.051-.483-3.692-1.323-4.86-1.784-1.252-4.374-1.194-7.257.47-5.384 3.108-9.748 10.636-9.748 16.814 0 2.051.483 3.692 1.323 4.86 1.784 1.252 4.374 1.194 7.257-.47' fill='#FAFAFA'/><path d='M108.724 198.614c-1.142 0-2.158-.213-3.019-.817-.021-.014-.04.014-.055-.007-.894-1.244-1.367-2.948-1.367-4.973 0-6.242 4.426-13.864 9.865-17.005 1.574-.908 3.084-1.363 4.49-1.363 1.142 0 2.158.309 3.018.913a.23.23 0 0 1 .056.056c.894 1.244 1.367 2.972 1.367 4.997 0 6.243-4.426 13.783-9.865 16.923-1.574.909-3.084 1.276-4.49 1.276zm-2.718-1.109c.774.532 1.688.776 2.718.776 1.323 0 2.754-.413 4.256-1.28 5.311-3.066 9.631-10.505 9.631-16.598 0-1.909-.434-3.523-1.255-4.685-.774-.533-1.688-.799-2.718-.799-1.323 0-2.755.441-4.256 1.308-5.311 3.066-9.631 10.506-9.631 16.599 0 1.909.434 3.517 1.255 4.679z' fill='#607D8B'/><path d='M149.318 114.262l-9.984 8.878 15.893 11.031 5.589-6.112-11.498-13.797' fill='#FAFAFA'/><path d='M169.676 120.84l-9.748 5.627c-3.642 2.103-9.528 2.113-13.147.024-3.62-2.089-3.601-5.488.041-7.591l9.495-5.608-6.729-3.885-81.836 47.071 45.923 26.514 3.081-1.779c.631-.365.869-.898.618-1.39-2.357-4.632-2.593-9.546-.683-14.262 5.638-13.92 24.509-24.815 48.618-28.07 8.169-1.103 16.68-.967 24.704.394.852.145 1.776.008 2.407-.357l3.081-1.778-25.825-14.91' fill='#FAFAFA'/><path d='M113.675 183.459a.47.47 0 0 1-.233-.062l-45.924-26.515a.468.468 0 0 1 .001-.809l81.836-47.071a.467.467 0 0 1 .466 0l6.729 3.885a.467.467 0 0 1-.467.809l-6.496-3.75-80.9 46.533 44.988 25.973 2.848-1.644c.192-.111.62-.409.435-.773-2.416-4.748-2.658-9.814-.7-14.65 2.806-6.927 8.885-13.242 17.582-18.263 8.657-4.998 19.518-8.489 31.407-10.094 8.198-1.107 16.79-.97 24.844.397.739.125 1.561.007 2.095-.301l2.381-1.374-25.125-14.506a.467.467 0 0 1 .467-.809l25.825 14.91a.467.467 0 0 1 0 .809l-3.081 1.779c-.721.417-1.763.575-2.718.413-7.963-1.351-16.457-1.486-24.563-.392-11.77 1.589-22.512 5.039-31.065 9.977-8.514 4.916-14.456 11.073-17.183 17.805-1.854 4.578-1.623 9.376.666 13.875.37.725.055 1.513-.8 2.006l-3.081 1.78a.476.476 0 0 1-.234.062' fill='#455A64'/><path d='M153.316 128.279c-2.413 0-4.821-.528-6.652-1.586-1.818-1.049-2.82-2.461-2.82-3.975 0-1.527 1.016-2.955 2.861-4.02l9.493-5.607a.233.233 0 1 1 .238.402l-9.496 5.609c-1.696.979-2.628 2.263-2.628 3.616 0 1.34.918 2.608 2.585 3.571 3.549 2.049 9.343 2.038 12.914-.024l9.748-5.628a.234.234 0 0 1 .234.405l-9.748 5.628c-1.858 1.072-4.296 1.609-6.729 1.609' fill='#607D8B'/><path d='M113.675 182.992l-45.913-26.508M113.675 183.342a.346.346 0 0 1-.175-.047l-45.913-26.508a.35.35 0 1 1 .35-.607l45.913 26.508a.35.35 0 0 1-.175.654' fill='#455A64'/><path d='M67.762 156.484v54.001c0 1.09.77 2.418 1.72 2.967l42.473 24.521c.95.549 1.72.11 1.72-.98v-54.001' fill='#FAFAFA'/><path d='M112.727 238.561c-.297 0-.62-.095-.947-.285l-42.473-24.521c-1.063-.613-1.895-2.05-1.895-3.27v-54.001a.35.35 0 1 1 .701 0v54.001c0 .96.707 2.18 1.544 2.663l42.473 24.522c.344.198.661.243.87.122.206-.119.325-.411.325-.799v-54.001a.35.35 0 1 1 .7 0v54.001c0 .655-.239 1.154-.675 1.406a1.235 1.235 0 0 1-.623.162' fill='#455A64'/><path d='M112.86 147.512h-.001c-2.318 0-4.499-.522-6.142-1.471-1.705-.984-2.643-2.315-2.643-3.749 0-1.445.952-2.791 2.68-3.788l12.041-6.953c1.668-.962 3.874-1.493 6.212-1.493 2.318 0 4.499.523 6.143 1.472 1.704.984 2.643 2.315 2.643 3.748 0 1.446-.952 2.791-2.68 3.789l-12.042 6.952c-1.668.963-3.874 1.493-6.211 1.493zm12.147-16.753c-2.217 0-4.298.497-5.861 1.399l-12.042 6.952c-1.502.868-2.33 1.998-2.33 3.182 0 1.173.815 2.289 2.293 3.142 1.538.889 3.596 1.378 5.792 1.378h.001c2.216 0 4.298-.497 5.861-1.399l12.041-6.953c1.502-.867 2.33-1.997 2.33-3.182 0-1.172-.814-2.288-2.292-3.142-1.539-.888-3.596-1.377-5.793-1.377z' fill='#607D8B'/><path d='M165.63 123.219l-5.734 3.311c-3.167 1.828-8.286 1.837-11.433.02-3.147-1.817-3.131-4.772.036-6.601l5.734-3.31 11.397 6.58' fill='#FAFAFA'/><path d='M154.233 117.448l9.995 5.771-4.682 2.704c-1.434.827-3.352 1.283-5.399 1.283-2.029 0-3.923-.449-5.333-1.263-1.29-.744-2-1.694-2-2.674 0-.991.723-1.955 2.036-2.713l5.383-3.108m0-.809l-5.734 3.31c-3.167 1.829-3.183 4.784-.036 6.601 1.568.905 3.623 1.357 5.684 1.357 2.077 0 4.159-.46 5.749-1.377l5.734-3.311-11.397-6.58M145.445 179.667c-1.773 0-3.241-.85-4.243-2.245-.067-.092-.057-.275.023-.356.08-.081.207-.12.3-.055.781.548 1.706.812 2.751.811 1.322 0 2.754-.446 4.256-1.313 5.31-3.066 9.631-10.522 9.631-16.615 0-1.927-.442-3.562-1.279-4.726a.235.235 0 0 1 .024-.301.232.232 0 0 1 .3-.027c1.67 1.172 2.59 3.38 2.59 6.219 0 6.242-4.425 13.987-9.865 17.127-1.573.908-3.083 1.481-4.488 1.481zM142.476 178c.814.651 1.82 1.002 2.969 1.002 1.322 0 2.753-.452 4.255-1.32 5.31-3.065 9.631-10.523 9.631-16.617 0-1.98-.463-3.63-1.325-4.793.411 1.035.624 2.26.624 3.62 0 6.242-4.425 13.875-9.865 17.015-1.573.909-3.084 1.376-4.489 1.376a5.49 5.49 0 0 1-1.8-.283z' fill='#607D8B'/><path d='M148.648 176.704c5.384-3.108 9.748-10.636 9.748-16.813 0-2.052-.483-3.693-1.322-4.861-1.785-1.252-4.375-1.194-7.258.471-5.383 3.108-9.748 10.636-9.748 16.813 0 2.051.484 3.692 1.323 4.86 1.785 1.253 4.374 1.195 7.257-.47' fill='#FAFAFA'/><path d='M144.276 178.276c-1.143 0-2.158-.307-3.019-.911a.217.217 0 0 1-.055-.054c-.895-1.244-1.367-2.972-1.367-4.997 0-6.241 4.425-13.875 9.865-17.016 1.573-.908 3.084-1.369 4.489-1.369 1.143 0 2.158.307 3.019.91a.24.24 0 0 1 .055.055c.894 1.244 1.367 2.971 1.367 4.997 0 6.241-4.425 13.875-9.865 17.016-1.573.908-3.084 1.369-4.489 1.369zm-2.718-1.172c.773.533 1.687.901 2.718.901 1.322 0 2.754-.538 4.256-1.405 5.31-3.066 9.631-10.567 9.631-16.661 0-1.908-.434-3.554-1.256-4.716-.774-.532-1.688-.814-2.718-.814-1.322 0-2.754.433-4.256 1.3-5.31 3.066-9.631 10.564-9.631 16.657 0 1.91.434 3.576 1.256 4.738z' fill='#607D8B'/><path d='M150.72 172.361l-.363-.295a24.105 24.105 0 0 0 2.148-3.128 24.05 24.05 0 0 0 1.977-4.375l.443.149a24.54 24.54 0 0 1-2.015 4.46 24.61 24.61 0 0 1-2.19 3.189M115.917 191.514l-.363-.294a24.174 24.174 0 0 0 2.148-3.128 24.038 24.038 0 0 0 1.976-4.375l.443.148a24.48 24.48 0 0 1-2.015 4.461 24.662 24.662 0 0 1-2.189 3.188M114 237.476V182.584 237.476' fill='#607D8B'/><g><path d='M81.822 37.474c.017-.135-.075-.28-.267-.392-.327-.188-.826-.21-1.109-.045l-6.012 3.471c-.131.076-.194.178-.191.285.002.132.002.461.002.578v.043l-.007.128-6.591 3.779c-.001 0-2.077 1.046-2.787 5.192 0 0-.912 6.961-.898 19.745.015 12.57.606 17.07 1.167 21.351.22 1.684 3.001 2.125 3.001 2.125.331.04.698-.027 1.08-.248l75.273-43.551c1.808-1.069 2.667-3.719 3.056-6.284 1.213-7.99 1.675-32.978-.275-39.878-.196-.693-.51-1.083-.868-1.282l-2.086-.79c-.727.028-1.416.467-1.534.535L82.032 37.072l-.21.402' fill='#FFF'/><path d='M144.311 1.701l2.085.79c.358.199.672.589.868 1.282 1.949 6.9 1.487 31.887.275 39.878-.39 2.565-1.249 5.215-3.056 6.284L69.21 93.486a1.78 1.78 0 0 1-.896.258l-.183-.011c0 .001-2.782-.44-3.003-2.124-.56-4.282-1.151-8.781-1.165-21.351-.015-12.784.897-19.745.897-19.745.71-4.146 2.787-5.192 2.787-5.192l6.591-3.779.007-.128v-.043c0-.117 0-.446-.002-.578-.003-.107.059-.21.191-.285l6.012-3.472a.98.98 0 0 1 .481-.11c.218 0 .449.053.627.156.193.112.285.258.268.392l.211-.402 60.744-34.836c.117-.068.806-.507 1.534-.535m0-.997l-.039.001c-.618.023-1.283.244-1.974.656l-.021.012-60.519 34.706a2.358 2.358 0 0 0-.831-.15c-.365 0-.704.084-.98.244l-6.012 3.471c-.442.255-.699.69-.689 1.166l.001.15-6.08 3.487c-.373.199-2.542 1.531-3.29 5.898l-.006.039c-.009.07-.92 7.173-.906 19.875.014 12.62.603 17.116 1.172 21.465l.002.015c.308 2.355 3.475 2.923 3.836 2.98l.034.004c.101.013.204.019.305.019a2.77 2.77 0 0 0 1.396-.392l75.273-43.552c1.811-1.071 2.999-3.423 3.542-6.997 1.186-7.814 1.734-33.096-.301-40.299-.253-.893-.704-1.527-1.343-1.882l-.132-.062-2.085-.789a.973.973 0 0 0-.353-.065' fill='#455A64'/><path d='M128.267 11.565l1.495.434-56.339 32.326' fill='#FFF'/><path d='M74.202 90.545a.5.5 0 0 1-.25-.931l18.437-10.645a.499.499 0 1 1 .499.864L74.451 90.478l-.249.067M75.764 42.654l-.108-.062.046-.171 5.135-2.964.17.045-.045.171-5.135 2.964-.063.017M70.52 90.375V46.421l.063-.036L137.84 7.554v43.954l-.062.036L70.52 90.375zm.25-43.811v43.38l66.821-38.579V7.985L70.77 46.564z' fill='#607D8B'/><path d='M86.986 83.182c-.23.149-.612.384-.849.523l-11.505 6.701c-.237.139-.206.252.068.252h.565c.275 0 .693-.113.93-.252L87.7 83.705c.237-.139.428-.253.425-.256a11.29 11.29 0 0 1-.006-.503c0-.274-.188-.377-.418-.227l-.715.463' fill='#607D8B'/><path d='M75.266 90.782H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.236-.138.615-.371.844-.519l.715-.464a.488.488 0 0 1 .266-.089c.172 0 .345.13.345.421 0 .214.001.363.003.437l.006.004-.004.069c-.003.075-.003.075-.486.356l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.108.866-.234l11.505-6.702c.168-.098.294-.173.361-.214-.004-.084-.004-.218-.004-.437l-.095-.171-.131.049-.714.463c-.232.15-.616.386-.854.525l-11.505 6.702-.029.018z' fill='#607D8B'/><path d='M75.266 89.871H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.258-.151.694-.268.993-.268h.565c.2 0 .316.056.346.166.03.11-.043.217-.215.317l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.107.866-.234l11.505-6.702.03-.018-.035-.001h-.565c-.252 0-.649.108-.867.234l-11.505 6.702-.029.018zM74.37 90.801v-1.247 1.247' fill='#607D8B'/><path d='M68.13 93.901c-.751-.093-1.314-.737-1.439-1.376-.831-4.238-1.151-8.782-1.165-21.352-.015-12.784.897-19.745.897-19.745.711-4.146 2.787-5.192 2.787-5.192l74.859-43.219c.223-.129 2.487-1.584 3.195.923 1.95 6.9 1.488 31.887.275 39.878-.389 2.565-1.248 5.215-3.056 6.283L69.21 93.653c-.382.221-.749.288-1.08.248 0 0-2.781-.441-3.001-2.125-.561-4.281-1.152-8.781-1.167-21.351-.014-12.784.898-19.745.898-19.745.71-4.146 2.787-5.191 2.787-5.191l6.598-3.81.871-.119 6.599-3.83.046-.461L68.13 93.901' fill='#FAFAFA'/><path d='M68.317 94.161l-.215-.013h-.001l-.244-.047c-.719-.156-2.772-.736-2.976-2.292-.568-4.34-1.154-8.813-1.168-21.384-.014-12.654.891-19.707.9-19.777.725-4.231 2.832-5.338 2.922-5.382l6.628-3.827.87-.119 6.446-3.742.034-.334a.248.248 0 0 1 .273-.223.248.248 0 0 1 .223.272l-.059.589-6.752 3.919-.87.118-6.556 3.785c-.031.016-1.99 1.068-2.666 5.018-.007.06-.908 7.086-.894 19.702.014 12.539.597 16.996 1.161 21.305.091.691.689 1.154 1.309 1.452a1.95 1.95 0 0 1-.236-.609c-.781-3.984-1.155-8.202-1.17-21.399-.014-12.653.891-19.707.9-19.777.725-4.231 2.832-5.337 2.922-5.382-.004.001 74.444-42.98 74.846-43.212l.028-.017c.904-.538 1.72-.688 2.36-.433.555.221.949.733 1.172 1.52 2.014 7.128 1.46 32.219.281 39.983-.507 3.341-1.575 5.515-3.175 6.462L69.335 93.869a2.023 2.023 0 0 1-1.018.292zm-.147-.507c.293.036.604-.037.915-.217l75.273-43.551c1.823-1.078 2.602-3.915 2.934-6.106 1.174-7.731 1.731-32.695-.268-39.772-.178-.631-.473-1.032-.876-1.192-.484-.193-1.166-.052-1.921.397l-.034.021-74.858 43.218c-.031.017-1.989 1.069-2.666 5.019-.007.059-.908 7.085-.894 19.702.015 13.155.386 17.351 1.161 21.303.09.461.476.983 1.037 1.139.114.025.185.037.196.039h.001z' fill='#455A64'/><path d='M69.317 68.982c.489-.281.885-.056.885.505 0 .56-.396 1.243-.885 1.525-.488.282-.884.057-.884-.504 0-.56.396-1.243.884-1.526' fill='#FFF'/><path d='M68.92 71.133c-.289 0-.487-.228-.487-.625 0-.56.396-1.243.884-1.526a.812.812 0 0 1 .397-.121c.289 0 .488.229.488.626 0 .56-.396 1.243-.885 1.525a.812.812 0 0 1-.397.121m.794-2.459a.976.976 0 0 0-.49.147c-.548.317-.978 1.058-.978 1.687 0 .486.271.812.674.812a.985.985 0 0 0 .491-.146c.548-.317.978-1.057.978-1.687 0-.486-.272-.813-.675-.813' fill='#8097A2'/><path d='M68.92 70.947c-.271 0-.299-.307-.299-.439 0-.491.361-1.116.79-1.363a.632.632 0 0 1 .303-.096c.272 0 .301.306.301.438 0 .491-.363 1.116-.791 1.364a.629.629 0 0 1-.304.096m.794-2.086a.812.812 0 0 0-.397.121c-.488.283-.884.966-.884 1.526 0 .397.198.625.487.625a.812.812 0 0 0 .397-.121c.489-.282.885-.965.885-1.525 0-.397-.199-.626-.488-.626' fill='#8097A2'/><path d='M69.444 85.35c.264-.152.477-.031.477.272 0 .303-.213.67-.477.822-.263.153-.477.031-.477-.271 0-.302.214-.671.477-.823' fill='#FFF'/><path d='M69.23 86.51c-.156 0-.263-.123-.263-.337 0-.302.214-.671.477-.823a.431.431 0 0 1 .214-.066c.156 0 .263.124.263.338 0 .303-.213.67-.477.822a.431.431 0 0 1-.214.066m.428-1.412c-.1 0-.203.029-.307.09-.32.185-.57.618-.57.985 0 .309.185.524.449.524a.63.63 0 0 0 .308-.09c.32-.185.57-.618.57-.985 0-.309-.185-.524-.45-.524' fill='#8097A2'/><path d='M69.23 86.322l-.076-.149c0-.235.179-.544.384-.661l.12-.041.076.151c0 .234-.179.542-.383.66l-.121.04m.428-1.038a.431.431 0 0 0-.214.066c-.263.152-.477.521-.477.823 0 .214.107.337.263.337a.431.431 0 0 0 .214-.066c.264-.152.477-.519.477-.822 0-.214-.107-.338-.263-.338' fill='#8097A2'/><path d='M139.278 7.769v43.667L72.208 90.16V46.493l67.07-38.724' fill='#455A64'/><path d='M72.083 90.375V46.421l.063-.036 67.257-38.831v43.954l-.062.036-67.258 38.831zm.25-43.811v43.38l66.821-38.579V7.985L72.333 46.564z' fill='#607D8B'/></g><path d='M125.737 88.647l-7.639 3.334V84l-11.459 4.713v8.269L99 100.315l13.369 3.646 13.368-15.314' fill='#455A64'/></g></svg>";
function RotateInstructions() {
  this.loadIcon_();
  var overlay = document.createElement('div');
  var s = overlay.style;
  s.position = 'fixed';
  s.top = 0;
  s.right = 0;
  s.bottom = 0;
  s.left = 0;
  s.backgroundColor = 'gray';
  s.fontFamily = 'sans-serif';
  s.zIndex = 1000000;
  var img = document.createElement('img');
  img.src = this.icon;
  var s = img.style;
  s.marginLeft = '25%';
  s.marginTop = '25%';
  s.width = '50%';
  overlay.appendChild(img);
  var text = document.createElement('div');
  var s = text.style;
  s.textAlign = 'center';
  s.fontSize = '16px';
  s.lineHeight = '24px';
  s.margin = '24px 25%';
  s.width = '50%';
  text.innerHTML = 'Place your phone into your Cardboard viewer.';
  overlay.appendChild(text);
  var snackbar = document.createElement('div');
  var s = snackbar.style;
  s.backgroundColor = '#CFD8DC';
  s.position = 'fixed';
  s.bottom = 0;
  s.width = '100%';
  s.height = '48px';
  s.padding = '14px 24px';
  s.boxSizing = 'border-box';
  s.color = '#656A6B';
  overlay.appendChild(snackbar);
  var snackbarText = document.createElement('div');
  snackbarText.style.float = 'left';
  snackbarText.innerHTML = 'No Cardboard viewer?';
  var snackbarButton = document.createElement('a');
  snackbarButton.href = 'https://www.google.com/get/cardboard/get-cardboard/';
  snackbarButton.innerHTML = 'get one';
  snackbarButton.target = '_blank';
  var s = snackbarButton.style;
  s.float = 'right';
  s.fontWeight = 600;
  s.textTransform = 'uppercase';
  s.borderLeft = '1px solid gray';
  s.paddingLeft = '24px';
  s.textDecoration = 'none';
  s.color = '#656A6B';
  snackbar.appendChild(snackbarText);
  snackbar.appendChild(snackbarButton);
  this.overlay = overlay;
  this.text = text;
  this.hide();
}
RotateInstructions.prototype.show = function (parent) {
  if (!parent && !this.overlay.parentElement) {
    document.body.appendChild(this.overlay);
  } else if (parent) {
    if (this.overlay.parentElement && this.overlay.parentElement != parent) this.overlay.parentElement.removeChild(this.overlay);
    parent.appendChild(this.overlay);
  }
  this.overlay.style.display = 'block';
  var img = this.overlay.querySelector('img');
  var s = img.style;
  if (isLandscapeMode()) {
    s.width = '20%';
    s.marginLeft = '40%';
    s.marginTop = '3%';
  } else {
    s.width = '50%';
    s.marginLeft = '25%';
    s.marginTop = '25%';
  }
};
RotateInstructions.prototype.hide = function () {
  this.overlay.style.display = 'none';
};
RotateInstructions.prototype.showTemporarily = function (ms, parent) {
  this.show(parent);
  this.timer = setTimeout(this.hide.bind(this), ms);
};
RotateInstructions.prototype.disableShowTemporarily = function () {
  clearTimeout(this.timer);
};
RotateInstructions.prototype.update = function () {
  this.disableShowTemporarily();
  if (!isLandscapeMode() && isMobile()) {
    this.show();
  } else {
    this.hide();
  }
};
RotateInstructions.prototype.loadIcon_ = function () {
  this.icon = dataUri('image/svg+xml', rotateInstructionsAsset);
};
var DEFAULT_VIEWER = 'CardboardV1';
var VIEWER_KEY = 'WEBVR_CARDBOARD_VIEWER';
var CLASS_NAME = 'webvr-polyfill-viewer-selector';
function ViewerSelector(defaultViewer) {
  try {
    this.selectedKey = localStorage.getItem(VIEWER_KEY);
  } catch (error) {
    console.error('Failed to load viewer profile: %s', error);
  }
  if (!this.selectedKey) {
    this.selectedKey = defaultViewer || DEFAULT_VIEWER;
  }
  this.dialog = this.createDialog_(DeviceInfo.Viewers);
  this.root = null;
  this.onChangeCallbacks_ = [];
}
ViewerSelector.prototype.show = function (root) {
  this.root = root;
  root.appendChild(this.dialog);
  var selected = this.dialog.querySelector('#' + this.selectedKey);
  selected.checked = true;
  this.dialog.style.display = 'block';
};
ViewerSelector.prototype.hide = function () {
  if (this.root && this.root.contains(this.dialog)) {
    this.root.removeChild(this.dialog);
  }
  this.dialog.style.display = 'none';
};
ViewerSelector.prototype.getCurrentViewer = function () {
  return DeviceInfo.Viewers[this.selectedKey];
};
ViewerSelector.prototype.getSelectedKey_ = function () {
  var input = this.dialog.querySelector('input[name=field]:checked');
  if (input) {
    return input.id;
  }
  return null;
};
ViewerSelector.prototype.onChange = function (cb) {
  this.onChangeCallbacks_.push(cb);
};
ViewerSelector.prototype.fireOnChange_ = function (viewer) {
  for (var i = 0; i < this.onChangeCallbacks_.length; i++) {
    this.onChangeCallbacks_[i](viewer);
  }
};
ViewerSelector.prototype.onSave_ = function () {
  this.selectedKey = this.getSelectedKey_();
  if (!this.selectedKey || !DeviceInfo.Viewers[this.selectedKey]) {
    console.error('ViewerSelector.onSave_: this should never happen!');
    return;
  }
  this.fireOnChange_(DeviceInfo.Viewers[this.selectedKey]);
  try {
    localStorage.setItem(VIEWER_KEY, this.selectedKey);
  } catch (error) {
    console.error('Failed to save viewer profile: %s', error);
  }
  this.hide();
};
ViewerSelector.prototype.createDialog_ = function (options) {
  var container = document.createElement('div');
  container.classList.add(CLASS_NAME);
  container.style.display = 'none';
  var overlay = document.createElement('div');
  var s = overlay.style;
  s.position = 'fixed';
  s.left = 0;
  s.top = 0;
  s.width = '100%';
  s.height = '100%';
  s.background = 'rgba(0, 0, 0, 0.3)';
  overlay.addEventListener('click', this.hide.bind(this));
  var width = 280;
  var dialog = document.createElement('div');
  var s = dialog.style;
  s.boxSizing = 'border-box';
  s.position = 'fixed';
  s.top = '24px';
  s.left = '50%';
  s.marginLeft = -width / 2 + 'px';
  s.width = width + 'px';
  s.padding = '24px';
  s.overflow = 'hidden';
  s.background = '#fafafa';
  s.fontFamily = "'Roboto', sans-serif";
  s.boxShadow = '0px 5px 20px #666';
  dialog.appendChild(this.createH1_('Select your viewer'));
  for (var id in options) {
    dialog.appendChild(this.createChoice_(id, options[id].label));
  }
  dialog.appendChild(this.createButton_('Save', this.onSave_.bind(this)));
  container.appendChild(overlay);
  container.appendChild(dialog);
  return container;
};
ViewerSelector.prototype.createH1_ = function (name) {
  var h1 = document.createElement('h1');
  var s = h1.style;
  s.color = 'black';
  s.fontSize = '20px';
  s.fontWeight = 'bold';
  s.marginTop = 0;
  s.marginBottom = '24px';
  h1.innerHTML = name;
  return h1;
};
ViewerSelector.prototype.createChoice_ = function (id, name) {
  var div = document.createElement('div');
  div.style.marginTop = '8px';
  div.style.color = 'black';
  var input = document.createElement('input');
  input.style.fontSize = '30px';
  input.setAttribute('id', id);
  input.setAttribute('type', 'radio');
  input.setAttribute('value', id);
  input.setAttribute('name', 'field');
  var label = document.createElement('label');
  label.style.marginLeft = '4px';
  label.setAttribute('for', id);
  label.innerHTML = name;
  div.appendChild(input);
  div.appendChild(label);
  return div;
};
ViewerSelector.prototype.createButton_ = function (label, onclick) {
  var button = document.createElement('button');
  button.innerHTML = label;
  var s = button.style;
  s.float = 'right';
  s.textTransform = 'uppercase';
  s.color = '#1094f7';
  s.fontSize = '14px';
  s.letterSpacing = 0;
  s.border = 0;
  s.background = 'none';
  s.marginTop = '16px';
  button.addEventListener('click', onclick);
  return button;
};
var commonjsGlobal$$1 = typeof window !== 'undefined' ? window : typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof self !== 'undefined' ? self : {};
function unwrapExports$$1 (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}
function createCommonjsModule$$1(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}
var NoSleep = createCommonjsModule$$1(function (module, exports) {
(function webpackUniversalModuleDefinition(root, factory) {
	module.exports = factory();
})(commonjsGlobal$$1, function() {
return          (function(modules) {
         	var installedModules = {};
         	function __webpack_require__(moduleId) {
         		if(installedModules[moduleId]) {
         			return installedModules[moduleId].exports;
         		}
         		var module = installedModules[moduleId] = {
         			i: moduleId,
         			l: false,
         			exports: {}
         		};
         		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
         		module.l = true;
         		return module.exports;
         	}
         	__webpack_require__.m = modules;
         	__webpack_require__.c = installedModules;
         	__webpack_require__.d = function(exports, name, getter) {
         		if(!__webpack_require__.o(exports, name)) {
         			Object.defineProperty(exports, name, {
         				configurable: false,
         				enumerable: true,
         				get: getter
         			});
         		}
         	};
         	__webpack_require__.n = function(module) {
         		var getter = module && module.__esModule ?
         			function getDefault() { return module['default']; } :
         			function getModuleExports() { return module; };
         		__webpack_require__.d(getter, 'a', getter);
         		return getter;
         	};
         	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
         	__webpack_require__.p = "";
         	return __webpack_require__(__webpack_require__.s = 0);
         })
         ([
      (function(module, exports, __webpack_require__) {
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
var mediaFile = __webpack_require__(1);
var oldIOS = typeof navigator !== 'undefined' && parseFloat(('' + (/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ''])[1]).replace('undefined', '3_2').replace('_', '.').replace('_', '')) < 10 && !window.MSStream;
var NoSleep = function () {
  function NoSleep() {
    _classCallCheck(this, NoSleep);
    if (oldIOS) {
      this.noSleepTimer = null;
    } else {
      this.noSleepVideo = document.createElement('video');
      this.noSleepVideo.setAttribute('playsinline', '');
      this.noSleepVideo.setAttribute('src', mediaFile);
      this.noSleepVideo.addEventListener('timeupdate', function (e) {
        if (this.noSleepVideo.currentTime > 0.5) {
          this.noSleepVideo.currentTime = Math.random();
        }
      }.bind(this));
    }
  }
  _createClass(NoSleep, [{
    key: 'enable',
    value: function enable() {
      if (oldIOS) {
        this.disable();
        this.noSleepTimer = window.setInterval(function () {
          window.location.href = '/';
          window.setTimeout(window.stop, 0);
        }, 15000);
      } else {
        this.noSleepVideo.play();
      }
    }
  }, {
    key: 'disable',
    value: function disable() {
      if (oldIOS) {
        if (this.noSleepTimer) {
          window.clearInterval(this.noSleepTimer);
          this.noSleepTimer = null;
        }
      } else {
        this.noSleepVideo.pause();
      }
    }
  }]);
  return NoSleep;
}();
module.exports = NoSleep;
      }),
      (function(module, exports, __webpack_require__) {
module.exports = 'data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQAD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';
      })
         ]);
});
});
var NoSleep$1 = unwrapExports$$1(NoSleep);
var nextDisplayId = 1000;
var defaultLeftBounds = [0, 0, 0.5, 1];
var defaultRightBounds = [0.5, 0, 0.5, 1];
var raf = window.requestAnimationFrame;
var caf = window.cancelAnimationFrame;
function VRFrameData() {
  this.leftProjectionMatrix = new Float32Array(16);
  this.leftViewMatrix = new Float32Array(16);
  this.rightProjectionMatrix = new Float32Array(16);
  this.rightViewMatrix = new Float32Array(16);
  this.pose = null;
}
function VRDisplayCapabilities(config) {
  Object.defineProperties(this, {
    hasPosition: {
      writable: false, enumerable: true, value: config.hasPosition
    },
    hasExternalDisplay: {
      writable: false, enumerable: true, value: config.hasExternalDisplay
    },
    canPresent: {
      writable: false, enumerable: true, value: config.canPresent
    },
    maxLayers: {
      writable: false, enumerable: true, value: config.maxLayers
    },
    hasOrientation: {
      enumerable: true, get: function get() {
        deprecateWarning('VRDisplayCapabilities.prototype.hasOrientation', 'VRDisplay.prototype.getFrameData');
        return config.hasOrientation;
      }
    }
  });
}
function VRDisplay(config) {
  config = config || {};
  var USE_WAKELOCK = 'wakelock' in config ? config.wakelock : true;
  this.isPolyfilled = true;
  this.displayId = nextDisplayId++;
  this.displayName = '';
  this.depthNear = 0.01;
  this.depthFar = 10000.0;
  this.isPresenting = false;
  Object.defineProperty(this, 'isConnected', {
    get: function get() {
      deprecateWarning('VRDisplay.prototype.isConnected', 'VRDisplayCapabilities.prototype.hasExternalDisplay');
      return false;
    }
  });
  this.capabilities = new VRDisplayCapabilities({
    hasPosition: false,
    hasOrientation: false,
    hasExternalDisplay: false,
    canPresent: false,
    maxLayers: 1
  });
  this.stageParameters = null;
  this.waitingForPresent_ = false;
  this.layer_ = null;
  this.originalParent_ = null;
  this.fullscreenElement_ = null;
  this.fullscreenWrapper_ = null;
  this.fullscreenElementCachedStyle_ = null;
  this.fullscreenEventTarget_ = null;
  this.fullscreenChangeHandler_ = null;
  this.fullscreenErrorHandler_ = null;
  if (USE_WAKELOCK && isMobile()) {
    this.wakelock_ = new NoSleep$1();
  }
}
VRDisplay.prototype.getFrameData = function (frameData) {
  return frameDataFromPose(frameData, this._getPose(), this);
};
VRDisplay.prototype.getPose = function () {
  deprecateWarning('VRDisplay.prototype.getPose', 'VRDisplay.prototype.getFrameData');
  return this._getPose();
};
VRDisplay.prototype.resetPose = function () {
  deprecateWarning('VRDisplay.prototype.resetPose');
  return this._resetPose();
};
VRDisplay.prototype.getImmediatePose = function () {
  deprecateWarning('VRDisplay.prototype.getImmediatePose', 'VRDisplay.prototype.getFrameData');
  return this._getPose();
};
VRDisplay.prototype.requestAnimationFrame = function (callback) {
  return raf(callback);
};
VRDisplay.prototype.cancelAnimationFrame = function (id) {
  return caf(id);
};
VRDisplay.prototype.wrapForFullscreen = function (element) {
  if (isIOS()) {
    return element;
  }
  if (!this.fullscreenWrapper_) {
    this.fullscreenWrapper_ = document.createElement('div');
    var cssProperties = ['height: ' + Math.min(screen.height, screen.width) + 'px !important', 'top: 0 !important', 'left: 0 !important', 'right: 0 !important', 'border: 0', 'margin: 0', 'padding: 0', 'z-index: 999999 !important', 'position: fixed'];
    this.fullscreenWrapper_.setAttribute('style', cssProperties.join('; ') + ';');
    this.fullscreenWrapper_.classList.add('webvr-polyfill-fullscreen-wrapper');
  }
  if (this.fullscreenElement_ == element) {
    return this.fullscreenWrapper_;
  }
  if (this.fullscreenElement_) {
    if (this.originalParent_) {
      this.originalParent_.appendChild(this.fullscreenElement_);
    } else {
      this.fullscreenElement_.parentElement.removeChild(this.fullscreenElement_);
    }
  }
  this.fullscreenElement_ = element;
  this.originalParent_ = element.parentElement;
  if (!this.originalParent_) {
    document.body.appendChild(element);
  }
  if (!this.fullscreenWrapper_.parentElement) {
    var parent = this.fullscreenElement_.parentElement;
    parent.insertBefore(this.fullscreenWrapper_, this.fullscreenElement_);
    parent.removeChild(this.fullscreenElement_);
  }
  this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild);
  this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute('style');
  var self = this;
  function applyFullscreenElementStyle() {
    if (!self.fullscreenElement_) {
      return;
    }
    var cssProperties = ['position: absolute', 'top: 0', 'left: 0', 'width: ' + Math.max(screen.width, screen.height) + 'px', 'height: ' + Math.min(screen.height, screen.width) + 'px', 'border: 0', 'margin: 0', 'padding: 0'];
    self.fullscreenElement_.setAttribute('style', cssProperties.join('; ') + ';');
  }
  applyFullscreenElementStyle();
  return this.fullscreenWrapper_;
};
VRDisplay.prototype.removeFullscreenWrapper = function () {
  if (!this.fullscreenElement_) {
    return;
  }
  var element = this.fullscreenElement_;
  if (this.fullscreenElementCachedStyle_) {
    element.setAttribute('style', this.fullscreenElementCachedStyle_);
  } else {
    element.removeAttribute('style');
  }
  this.fullscreenElement_ = null;
  this.fullscreenElementCachedStyle_ = null;
  var parent = this.fullscreenWrapper_.parentElement;
  this.fullscreenWrapper_.removeChild(element);
  if (this.originalParent_ === parent) {
    parent.insertBefore(element, this.fullscreenWrapper_);
  }
  else if (this.originalParent_) {
      this.originalParent_.appendChild(element);
    }
  parent.removeChild(this.fullscreenWrapper_);
  return element;
};
VRDisplay.prototype.requestPresent = function (layers) {
  var wasPresenting = this.isPresenting;
  var self = this;
  if (!(layers instanceof Array)) {
    deprecateWarning('VRDisplay.prototype.requestPresent with non-array argument', 'an array of VRLayers as the first argument');
    layers = [layers];
  }
  return new Promise(function (resolve, reject) {
    if (!self.capabilities.canPresent) {
      reject(new Error('VRDisplay is not capable of presenting.'));
      return;
    }
    if (layers.length == 0 || layers.length > self.capabilities.maxLayers) {
      reject(new Error('Invalid number of layers.'));
      return;
    }
    var incomingLayer = layers[0];
    if (!incomingLayer.source) {
      resolve();
      return;
    }
    var leftBounds = incomingLayer.leftBounds || defaultLeftBounds;
    var rightBounds = incomingLayer.rightBounds || defaultRightBounds;
    if (wasPresenting) {
      var layer = self.layer_;
      if (layer.source !== incomingLayer.source) {
        layer.source = incomingLayer.source;
      }
      for (var i = 0; i < 4; i++) {
        layer.leftBounds[i] = leftBounds[i];
        layer.rightBounds[i] = rightBounds[i];
      }
      self.wrapForFullscreen(self.layer_.source);
      self.updatePresent_();
      resolve();
      return;
    }
    self.layer_ = {
      predistorted: incomingLayer.predistorted,
      source: incomingLayer.source,
      leftBounds: leftBounds.slice(0),
      rightBounds: rightBounds.slice(0)
    };
    self.waitingForPresent_ = false;
    if (self.layer_ && self.layer_.source) {
      var fullscreenElement = self.wrapForFullscreen(self.layer_.source);
      var onFullscreenChange = function onFullscreenChange() {
        var actualFullscreenElement = getFullscreenElement();
        self.isPresenting = fullscreenElement === actualFullscreenElement;
        if (self.isPresenting) {
          if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('landscape-primary').catch(function (error) {
              console.error('screen.orientation.lock() failed due to', error.message);
            });
          }
          self.waitingForPresent_ = false;
          self.beginPresent_();
          resolve();
        } else {
          if (screen.orientation && screen.orientation.unlock) {
            screen.orientation.unlock();
          }
          self.removeFullscreenWrapper();
          self.disableWakeLock();
          self.endPresent_();
          self.removeFullscreenListeners_();
        }
        self.fireVRDisplayPresentChange_();
      };
      var onFullscreenError = function onFullscreenError() {
        if (!self.waitingForPresent_) {
          return;
        }
        self.removeFullscreenWrapper();
        self.removeFullscreenListeners_();
        self.disableWakeLock();
        self.waitingForPresent_ = false;
        self.isPresenting = false;
        reject(new Error('Unable to present.'));
      };
      self.addFullscreenListeners_(fullscreenElement, onFullscreenChange, onFullscreenError);
      if (requestFullscreen(fullscreenElement)) {
        self.enableWakeLock();
        self.waitingForPresent_ = true;
      } else if (isIOS() || isWebViewAndroid()) {
        self.enableWakeLock();
        self.isPresenting = true;
        self.beginPresent_();
        self.fireVRDisplayPresentChange_();
        resolve();
      }
    }
    if (!self.waitingForPresent_ && !isIOS()) {
      exitFullscreen();
      reject(new Error('Unable to present.'));
    }
  });
};
VRDisplay.prototype.exitPresent = function () {
  var wasPresenting = this.isPresenting;
  var self = this;
  this.isPresenting = false;
  this.layer_ = null;
  this.disableWakeLock();
  return new Promise(function (resolve, reject) {
    if (wasPresenting) {
      if (!exitFullscreen() && isIOS()) {
        self.endPresent_();
        self.fireVRDisplayPresentChange_();
      }
      if (isWebViewAndroid()) {
        self.removeFullscreenWrapper();
        self.removeFullscreenListeners_();
        self.endPresent_();
        self.fireVRDisplayPresentChange_();
      }
      resolve();
    } else {
      reject(new Error('Was not presenting to VRDisplay.'));
    }
  });
};
VRDisplay.prototype.getLayers = function () {
  if (this.layer_) {
    return [this.layer_];
  }
  return [];
};
VRDisplay.prototype.fireVRDisplayPresentChange_ = function () {
  var event = new CustomEvent('vrdisplaypresentchange', { detail: { display: this } });
  window.dispatchEvent(event);
};
VRDisplay.prototype.fireVRDisplayConnect_ = function () {
  var event = new CustomEvent('vrdisplayconnect', { detail: { display: this } });
  window.dispatchEvent(event);
};
VRDisplay.prototype.addFullscreenListeners_ = function (element, changeHandler, errorHandler) {
  this.removeFullscreenListeners_();
  this.fullscreenEventTarget_ = element;
  this.fullscreenChangeHandler_ = changeHandler;
  this.fullscreenErrorHandler_ = errorHandler;
  if (changeHandler) {
    if (document.fullscreenEnabled) {
      element.addEventListener('fullscreenchange', changeHandler, false);
    } else if (document.webkitFullscreenEnabled) {
      element.addEventListener('webkitfullscreenchange', changeHandler, false);
    } else if (document.mozFullScreenEnabled) {
      document.addEventListener('mozfullscreenchange', changeHandler, false);
    } else if (document.msFullscreenEnabled) {
      element.addEventListener('msfullscreenchange', changeHandler, false);
    }
  }
  if (errorHandler) {
    if (document.fullscreenEnabled) {
      element.addEventListener('fullscreenerror', errorHandler, false);
    } else if (document.webkitFullscreenEnabled) {
      element.addEventListener('webkitfullscreenerror', errorHandler, false);
    } else if (document.mozFullScreenEnabled) {
      document.addEventListener('mozfullscreenerror', errorHandler, false);
    } else if (document.msFullscreenEnabled) {
      element.addEventListener('msfullscreenerror', errorHandler, false);
    }
  }
};
VRDisplay.prototype.removeFullscreenListeners_ = function () {
  if (!this.fullscreenEventTarget_) return;
  var element = this.fullscreenEventTarget_;
  if (this.fullscreenChangeHandler_) {
    var changeHandler = this.fullscreenChangeHandler_;
    element.removeEventListener('fullscreenchange', changeHandler, false);
    element.removeEventListener('webkitfullscreenchange', changeHandler, false);
    document.removeEventListener('mozfullscreenchange', changeHandler, false);
    element.removeEventListener('msfullscreenchange', changeHandler, false);
  }
  if (this.fullscreenErrorHandler_) {
    var errorHandler = this.fullscreenErrorHandler_;
    element.removeEventListener('fullscreenerror', errorHandler, false);
    element.removeEventListener('webkitfullscreenerror', errorHandler, false);
    document.removeEventListener('mozfullscreenerror', errorHandler, false);
    element.removeEventListener('msfullscreenerror', errorHandler, false);
  }
  this.fullscreenEventTarget_ = null;
  this.fullscreenChangeHandler_ = null;
  this.fullscreenErrorHandler_ = null;
};
VRDisplay.prototype.enableWakeLock = function () {
  if (this.wakelock_) {
    this.wakelock_.enable();
  }
};
VRDisplay.prototype.disableWakeLock = function () {
  if (this.wakelock_) {
    this.wakelock_.disable();
  }
};
VRDisplay.prototype.beginPresent_ = function () {
};
VRDisplay.prototype.endPresent_ = function () {
};
VRDisplay.prototype.submitFrame = function (pose) {
};
VRDisplay.prototype.getEyeParameters = function (whichEye) {
  return null;
};
var config = {
  ADDITIONAL_VIEWERS: [],
  DEFAULT_VIEWER: '',
  MOBILE_WAKE_LOCK: true,
  DEBUG: false,
  DPDB_URL: 'https://dpdb.webvr.rocks/dpdb.json',
  K_FILTER: 0.98,
  PREDICTION_TIME_S: 0.040,
  CARDBOARD_UI_DISABLED: false,
  ROTATE_INSTRUCTIONS_DISABLED: false,
  YAW_ONLY: false,
  BUFFER_SCALE: 0.5,
  DIRTY_SUBMIT_FRAME_BINDINGS: false
};
var Eye = {
  LEFT: 'left',
  RIGHT: 'right'
};
function CardboardVRDisplay(config$$1) {
  var defaults = extend({}, config);
  config$$1 = extend(defaults, config$$1 || {});
  VRDisplay.call(this, {
    wakelock: config$$1.MOBILE_WAKE_LOCK
  });
  this.config = config$$1;
  this.displayName = 'Cardboard VRDisplay';
  this.capabilities = new VRDisplayCapabilities({
    hasPosition: false,
    hasOrientation: true,
    hasExternalDisplay: false,
    canPresent: true,
    maxLayers: 1
  });
  this.stageParameters = null;
  this.bufferScale_ = this.config.BUFFER_SCALE;
  this.poseSensor_ = new PoseSensor(this.config);
  this.distorter_ = null;
  this.cardboardUI_ = null;
  this.dpdb_ = new Dpdb(this.config.DPDB_URL, this.onDeviceParamsUpdated_.bind(this));
  this.deviceInfo_ = new DeviceInfo(this.dpdb_.getDeviceParams(), config$$1.ADDITIONAL_VIEWERS);
  this.viewerSelector_ = new ViewerSelector(config$$1.DEFAULT_VIEWER);
  this.viewerSelector_.onChange(this.onViewerChanged_.bind(this));
  this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer());
  if (!this.config.ROTATE_INSTRUCTIONS_DISABLED) {
    this.rotateInstructions_ = new RotateInstructions();
  }
  if (isIOS()) {
    window.addEventListener('resize', this.onResize_.bind(this));
  }
}
CardboardVRDisplay.prototype = Object.create(VRDisplay.prototype);
CardboardVRDisplay.prototype._getPose = function () {
  return {
    position: null,
    orientation: this.poseSensor_.getOrientation(),
    linearVelocity: null,
    linearAcceleration: null,
    angularVelocity: null,
    angularAcceleration: null
  };
};
CardboardVRDisplay.prototype._resetPose = function () {
  if (this.poseSensor_.resetPose) {
    this.poseSensor_.resetPose();
  }
};
CardboardVRDisplay.prototype._getFieldOfView = function (whichEye) {
  var fieldOfView;
  if (whichEye == Eye.LEFT) {
    fieldOfView = this.deviceInfo_.getFieldOfViewLeftEye();
  } else if (whichEye == Eye.RIGHT) {
    fieldOfView = this.deviceInfo_.getFieldOfViewRightEye();
  } else {
    console.error('Invalid eye provided: %s', whichEye);
    return null;
  }
  return fieldOfView;
};
CardboardVRDisplay.prototype._getEyeOffset = function (whichEye) {
  var offset;
  if (whichEye == Eye.LEFT) {
    offset = [-this.deviceInfo_.viewer.interLensDistance * 0.5, 0.0, 0.0];
  } else if (whichEye == Eye.RIGHT) {
    offset = [this.deviceInfo_.viewer.interLensDistance * 0.5, 0.0, 0.0];
  } else {
    console.error('Invalid eye provided: %s', whichEye);
    return null;
  }
  return offset;
};
CardboardVRDisplay.prototype.getEyeParameters = function (whichEye) {
  var offset = this._getEyeOffset(whichEye);
  var fieldOfView = this._getFieldOfView(whichEye);
  var eyeParams = {
    offset: offset,
    renderWidth: this.deviceInfo_.device.width * 0.5 * this.bufferScale_,
    renderHeight: this.deviceInfo_.device.height * this.bufferScale_
  };
  Object.defineProperty(eyeParams, 'fieldOfView', {
    enumerable: true,
    get: function get() {
      deprecateWarning('VRFieldOfView', 'VRFrameData\'s projection matrices');
      return fieldOfView;
    }
  });
  return eyeParams;
};
CardboardVRDisplay.prototype.onDeviceParamsUpdated_ = function (newParams) {
  if (this.config.DEBUG) {
    console.log('DPDB reported that device params were updated.');
  }
  this.deviceInfo_.updateDeviceParams(newParams);
  if (this.distorter_) {
    this.distorter_.updateDeviceInfo(this.deviceInfo_);
  }
};
CardboardVRDisplay.prototype.updateBounds_ = function () {
  if (this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds)) {
    this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds);
  }
};
CardboardVRDisplay.prototype.beginPresent_ = function () {
  var gl = this.layer_.source.getContext('webgl');
  if (!gl) gl = this.layer_.source.getContext('experimental-webgl');
  if (!gl) gl = this.layer_.source.getContext('webgl2');
  if (!gl) return;
  if (this.layer_.predistorted) {
    if (!this.config.CARDBOARD_UI_DISABLED) {
      gl.canvas.width = getScreenWidth() * this.bufferScale_;
      gl.canvas.height = getScreenHeight() * this.bufferScale_;
      this.cardboardUI_ = new CardboardUI(gl);
    }
  } else {
    if (!this.config.CARDBOARD_UI_DISABLED) {
      this.cardboardUI_ = new CardboardUI(gl);
    }
    this.distorter_ = new CardboardDistorter(gl, this.cardboardUI_, this.config.BUFFER_SCALE, this.config.DIRTY_SUBMIT_FRAME_BINDINGS);
    this.distorter_.updateDeviceInfo(this.deviceInfo_);
  }
  if (this.cardboardUI_) {
    this.cardboardUI_.listen(function (e) {
      this.viewerSelector_.show(this.layer_.source.parentElement);
      e.stopPropagation();
      e.preventDefault();
    }.bind(this), function (e) {
      this.exitPresent();
      e.stopPropagation();
      e.preventDefault();
    }.bind(this));
  }
  if (this.rotateInstructions_) {
    if (isLandscapeMode() && isMobile()) {
      this.rotateInstructions_.showTemporarily(3000, this.layer_.source.parentElement);
    } else {
      this.rotateInstructions_.update();
    }
  }
  this.orientationHandler = this.onOrientationChange_.bind(this);
  window.addEventListener('orientationchange', this.orientationHandler);
  this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this);
  window.addEventListener('vrdisplaypresentchange', this.vrdisplaypresentchangeHandler);
  this.fireVRDisplayDeviceParamsChange_();
};
CardboardVRDisplay.prototype.endPresent_ = function () {
  if (this.distorter_) {
    this.distorter_.destroy();
    this.distorter_ = null;
  }
  if (this.cardboardUI_) {
    this.cardboardUI_.destroy();
    this.cardboardUI_ = null;
  }
  if (this.rotateInstructions_) {
    this.rotateInstructions_.hide();
  }
  this.viewerSelector_.hide();
  window.removeEventListener('orientationchange', this.orientationHandler);
  window.removeEventListener('vrdisplaypresentchange', this.vrdisplaypresentchangeHandler);
};
CardboardVRDisplay.prototype.updatePresent_ = function () {
  this.endPresent_();
  this.beginPresent_();
};
CardboardVRDisplay.prototype.submitFrame = function (pose) {
  if (this.distorter_) {
    this.updateBounds_();
    this.distorter_.submitFrame();
  } else if (this.cardboardUI_ && this.layer_) {
    var gl = this.layer_.source.getContext('webgl');
    if (!gl) gl = this.layer_.source.getContext('experimental-webgl');
    if (!gl) gl = this.layer_.source.getContext('webgl2');
    var canvas = gl.canvas;
    if (canvas.width != this.lastWidth || canvas.height != this.lastHeight) {
      this.cardboardUI_.onResize();
    }
    this.lastWidth = canvas.width;
    this.lastHeight = canvas.height;
    this.cardboardUI_.render();
  }
};
CardboardVRDisplay.prototype.onOrientationChange_ = function (e) {
  this.viewerSelector_.hide();
  if (this.rotateInstructions_) {
    this.rotateInstructions_.update();
  }
  this.onResize_();
};
CardboardVRDisplay.prototype.onResize_ = function (e) {
  if (this.layer_) {
    var gl = this.layer_.source.getContext('webgl');
    if (!gl) gl = this.layer_.source.getContext('experimental-webgl');
    if (!gl) gl = this.layer_.source.getContext('webgl2');
    var cssProperties = ['position: absolute', 'top: 0', 'left: 0',
    'width: 100vw', 'height: 100vh', 'border: 0', 'margin: 0',
    'padding: 0px', 'box-sizing: content-box'];
    gl.canvas.setAttribute('style', cssProperties.join('; ') + ';');
    safariCssSizeWorkaround(gl.canvas);
  }
};
CardboardVRDisplay.prototype.onViewerChanged_ = function (viewer) {
  this.deviceInfo_.setViewer(viewer);
  if (this.distorter_) {
    this.distorter_.updateDeviceInfo(this.deviceInfo_);
  }
  this.fireVRDisplayDeviceParamsChange_();
};
CardboardVRDisplay.prototype.fireVRDisplayDeviceParamsChange_ = function () {
  var event = new CustomEvent('vrdisplaydeviceparamschange', {
    detail: {
      vrdisplay: this,
      deviceInfo: this.deviceInfo_
    }
  });
  window.dispatchEvent(event);
};
CardboardVRDisplay.VRFrameData = VRFrameData;
CardboardVRDisplay.VRDisplay = VRDisplay;
return CardboardVRDisplay;
})));
});
var CardboardVRDisplay = unwrapExports(cardboardVrDisplay);

var version = "0.10.12";

var DefaultConfig = {
  ADDITIONAL_VIEWERS: [],
  DEFAULT_VIEWER: '',
  PROVIDE_MOBILE_VRDISPLAY: true,
  MOBILE_WAKE_LOCK: true,
  DEBUG: false,
  DPDB_URL: 'https://dpdb.webvr.rocks/dpdb.json',
  K_FILTER: 0.98,
  PREDICTION_TIME_S: 0.040,
  CARDBOARD_UI_DISABLED: false,
  ROTATE_INSTRUCTIONS_DISABLED: false,
  YAW_ONLY: false,
  BUFFER_SCALE: 0.5,
  DIRTY_SUBMIT_FRAME_BINDINGS: false
};

function WebVRPolyfill(config) {
  this.config = extend(extend({}, DefaultConfig), config);
  this.polyfillDisplays = [];
  this.enabled = false;
  this.hasNative = 'getVRDisplays' in navigator;
  this.native = {};
  this.native.getVRDisplays = navigator.getVRDisplays;
  this.native.VRFrameData = window.VRFrameData;
  this.native.VRDisplay = window.VRDisplay;
  if (!this.hasNative || this.config.PROVIDE_MOBILE_VRDISPLAY && isMobile()) {
    this.enable();
    this.getVRDisplays().then(function (displays) {
      if (displays && displays[0] && displays[0].fireVRDisplayConnect_) {
        displays[0].fireVRDisplayConnect_();
      }
    });
  }
}
WebVRPolyfill.prototype.getPolyfillDisplays = function () {
  if (this._polyfillDisplaysPopulated) {
    return this.polyfillDisplays;
  }
  if (isMobile()) {
    var vrDisplay = new CardboardVRDisplay({
      ADDITIONAL_VIEWERS: this.config.ADDITIONAL_VIEWERS,
      DEFAULT_VIEWER: this.config.DEFAULT_VIEWER,
      MOBILE_WAKE_LOCK: this.config.MOBILE_WAKE_LOCK,
      DEBUG: this.config.DEBUG,
      DPDB_URL: this.config.DPDB_URL,
      CARDBOARD_UI_DISABLED: this.config.CARDBOARD_UI_DISABLED,
      K_FILTER: this.config.K_FILTER,
      PREDICTION_TIME_S: this.config.PREDICTION_TIME_S,
      ROTATE_INSTRUCTIONS_DISABLED: this.config.ROTATE_INSTRUCTIONS_DISABLED,
      YAW_ONLY: this.config.YAW_ONLY,
      BUFFER_SCALE: this.config.BUFFER_SCALE,
      DIRTY_SUBMIT_FRAME_BINDINGS: this.config.DIRTY_SUBMIT_FRAME_BINDINGS
    });
    this.polyfillDisplays.push(vrDisplay);
  }
  this._polyfillDisplaysPopulated = true;
  return this.polyfillDisplays;
};
WebVRPolyfill.prototype.enable = function () {
  this.enabled = true;
  if (this.hasNative && this.native.VRFrameData) {
    var NativeVRFrameData = this.native.VRFrameData;
    var nativeFrameData = new this.native.VRFrameData();
    var nativeGetFrameData = this.native.VRDisplay.prototype.getFrameData;
    window.VRDisplay.prototype.getFrameData = function (frameData) {
      if (frameData instanceof NativeVRFrameData) {
        nativeGetFrameData.call(this, frameData);
        return;
      }
      nativeGetFrameData.call(this, nativeFrameData);
      frameData.pose = nativeFrameData.pose;
      copyArray(nativeFrameData.leftProjectionMatrix, frameData.leftProjectionMatrix);
      copyArray(nativeFrameData.rightProjectionMatrix, frameData.rightProjectionMatrix);
      copyArray(nativeFrameData.leftViewMatrix, frameData.leftViewMatrix);
      copyArray(nativeFrameData.rightViewMatrix, frameData.rightViewMatrix);
    };
  }
  navigator.getVRDisplays = this.getVRDisplays.bind(this);
  window.VRDisplay = CardboardVRDisplay.VRDisplay;
  window.VRFrameData = CardboardVRDisplay.VRFrameData;
};
WebVRPolyfill.prototype.getVRDisplays = function () {
  var _this = this;
  var config = this.config;
  if (!this.hasNative) {
    return Promise.resolve(this.getPolyfillDisplays());
  }
  return this.native.getVRDisplays.call(navigator).then(function (nativeDisplays) {
    return nativeDisplays.length > 0 ? nativeDisplays : _this.getPolyfillDisplays();
  });
};
WebVRPolyfill.version = version;
WebVRPolyfill.VRFrameData = CardboardVRDisplay.VRFrameData;
WebVRPolyfill.VRDisplay = CardboardVRDisplay.VRDisplay;


var webvrPolyfill = Object.freeze({
	default: WebVRPolyfill
});

var require$$0 = ( webvrPolyfill && WebVRPolyfill ) || webvrPolyfill;

if (typeof commonjsGlobal !== 'undefined' && commonjsGlobal.window) {
  if (!commonjsGlobal.document) {
    commonjsGlobal.document = commonjsGlobal.window.document;
  }
  if (!commonjsGlobal.navigator) {
    commonjsGlobal.navigator = commonjsGlobal.window.navigator;
  }
}
var src = require$$0;

return src;

})));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/demo/App.js":
/*!*************************!*\
  !*** ./src/demo/App.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib */ "./src/lib/index.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/* eslint no-magic-numbers: 0 */



var App = /*#__PURE__*/function (_Component) {
  _inherits(App, _Component);

  var _super = _createSuper(App);

  function App() {
    var _this;

    _classCallCheck(this, App);

    _this = _super.call(this);
    _this.setProps = _this.setProps.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(App, [{
    key: "setProps",
    value: function setProps(newProps) {
      this.setState(newProps);
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_lib__WEBPACK_IMPORTED_MODULE_1__["VtkView"], {
        setProps: this.setProps,
        background: [0.1, 0.1, 0.1]
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_lib__WEBPACK_IMPORTED_MODULE_1__["VtkGeometryRepresentation"], {
        colorBy: ['pointData', 'Temperature']
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_lib__WEBPACK_IMPORTED_MODULE_1__["VtkPolyDataSource"], {
        points: [0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0],
        polys: [4, 0, 1, 2, 3]
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_lib__WEBPACK_IMPORTED_MODULE_1__["VtkPointData"], null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_lib__WEBPACK_IMPORTED_MODULE_1__["VtkDataArray"], {
        name: "Temperature",
        values: [0, 3, 2, 1]
      }))))));
    }
  }]);

  return App;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

/* harmony default export */ __webpack_exports__["default"] = (App);

/***/ }),

/***/ "./src/lib/components/VtkCellData.react.js":
/*!*************************************************!*\
  !*** ./src/lib/components/VtkCellData.react.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VtkCellData; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



/**
 * VtkCellData is exposing a VtkCellData to a downstream element
 * It provides the following properties to its children:
 *   - pass along: 'view', 'representation`, `setProps`
 *   - `fields` == `VtkCellData`
 */

var VtkCellData = /*#__PURE__*/function (_Component) {
  _inherits(VtkCellData, _Component);

  var _super = _createSuper(VtkCellData);

  function VtkCellData() {
    _classCallCheck(this, VtkCellData);

    return _super.apply(this, arguments);
  }

  _createClass(VtkCellData, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          id = _this$props.id,
          setProps = _this$props.setProps,
          children = _this$props.children,
          view = _this$props.view,
          representation = _this$props.representation,
          dataset = _this$props.dataset;
      var addOnProps = {
        fields: dataset.getCellData(),
        dataset: dataset,
        representation: representation,
        view: view,
        setProps: setProps
      };
      var childrenWithViewProp = react__WEBPACK_IMPORTED_MODULE_0___default.a.Children.map(children, function (child) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.cloneElement(child, addOnProps);
      });
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: id
      }, childrenWithViewProp);
    }
  }]);

  return VtkCellData;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);


VtkCellData.defaultProps = {};
VtkCellData.propTypes = {
  /**
   * The ID used to identify this component in Dash callbacks.
   */
  id: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,

  /**
   * Dash-assigned callback that should be called to report property changes
   * to Dash, to make them available for callbacks.
   */
  setProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,

  /**
   * List of representation to show
   */
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node), prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node]),

  /**
   * Passed by parent
   */
  view: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,

  /**
   * Passed by parent
   */
  representation: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,

  /**
   * Passed by parent
   */
  dataset: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object
};

/***/ }),

/***/ "./src/lib/components/VtkDataArray.react.js":
/*!**************************************************!*\
  !*** ./src/lib/components/VtkDataArray.react.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VtkDataArray; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/Core/DataArray */ "./node_modules/vtk.js/Sources/Common/Core/DataArray/index.js");
/* harmony import */ var vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/macro */ "./node_modules/vtk.js/Sources/macro.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





/**
 * VtkDataArray is creating a vtkDataArray for the container fields
 * It takes the following set of properties:
 *   - type: 'Float32Array', 'Float64Array', 'Uint16Array', ...
 *   - values: [number, number, ...]
 *   - numberOfComponents: 1,
 *   - registration: 'addArray', 'setScalars', ...
 */

var VtkDataArray = /*#__PURE__*/function (_Component) {
  _inherits(VtkDataArray, _Component);

  var _super = _createSuper(VtkDataArray);

  function VtkDataArray(props) {
    var _this;

    _classCallCheck(this, VtkDataArray);

    _this = _super.call(this, props); // Create vtk.js data array

    _this.array = vtk_js_Sources_Common_Core_DataArray__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance({
      empty: true
    });
    return _this;
  }

  _createClass(VtkDataArray, [{
    key: "render",
    value: function render() {
      console.log('VtkDataArray', this.props);
      return null;
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props = this.props,
          fields = _this$props.fields,
          registration = _this$props.registration;
      this.update(this.props);
      fields[registration](this.array);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState, snapshot) {
      this.update(this.props, prevProps);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var fields = this.props.fields;
      fields.removeArray(this.array);
      this.array["delete"]();
      this.array = null;
    }
  }, {
    key: "update",
    value: function update(props, previous) {
      var name = props.name,
          type = props.type,
          values = props.values,
          numberOfComponents = props.numberOfComponents;
      var klass = vtk_js_Sources_macro__WEBPACK_IMPORTED_MODULE_3__["TYPED_ARRAYS"][type];
      this.array.setName(name);
      var changeDetected = false;

      if (type && (!previous || type !== previous.type)) {
        changeDetected = true;
      }

      if (numberOfComponents && (!previous || numberOfComponents !== previous.numberOfComponents)) {
        changeDetected = true;
      }

      if (values && (changeDetected || !previous || values !== previous.values)) {
        this.array.setData(klass.from(values), numberOfComponents);
      }
    }
  }]);

  return VtkDataArray;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);


VtkDataArray.defaultProps = {
  name: 'scalars',
  type: 'Float32Array',
  values: [],
  numberOfComponents: 1,
  registration: 'addArray'
};
VtkDataArray.propTypes = {
  /**
   * The ID used to identify this component in Dash callbacks.
   */
  id: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,

  /**
   * Dash-assigned callback that should be called to report property changes
   * to Dash, to make them available for callbacks.
   */
  setProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
  // -- vtk.js exposed properties

  /**
   * Typed array name
   */
  type: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,

  /**
   * Field name
   */
  name: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,

  /**
   * Actual values to use inside our array
   */
  values: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number),

  /**
   * Number of components / Tuple size
   */
  numberOfComponents: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,

  /**
   * Name of the method to call on the fieldData (addArray, setScalars, setVectors...)
   */
  registration: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,

  /**
   * List of representation to show
   */
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node), prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node]),

  /**
   * Passed by parent
   */
  fields: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object
};

/***/ }),

/***/ "./src/lib/components/VtkFieldData.react.js":
/*!**************************************************!*\
  !*** ./src/lib/components/VtkFieldData.react.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VtkFieldData; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



/**
 * VtkFieldData is exposing a VtkFieldData to a downstream element
 * It provides the following properties to its children:
 *   - pass along: 'view', 'representation`, `setProps`
 *   - `fields` == `VtkFieldData`
 */

var VtkFieldData = /*#__PURE__*/function (_Component) {
  _inherits(VtkFieldData, _Component);

  var _super = _createSuper(VtkFieldData);

  function VtkFieldData() {
    _classCallCheck(this, VtkFieldData);

    return _super.apply(this, arguments);
  }

  _createClass(VtkFieldData, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          id = _this$props.id,
          setProps = _this$props.setProps,
          children = _this$props.children,
          view = _this$props.view,
          representation = _this$props.representation,
          dataset = _this$props.dataset;
      var addOnProps = {
        fields: dataset.getFieldData(),
        dataset: dataset,
        representation: representation,
        view: view,
        setProps: setProps
      };
      var childrenWithViewProp = react__WEBPACK_IMPORTED_MODULE_0___default.a.Children.map(children, function (child) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.cloneElement(child, addOnProps);
      });
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: id
      }, childrenWithViewProp);
    }
  }]);

  return VtkFieldData;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);


VtkFieldData.defaultProps = {};
VtkFieldData.propTypes = {
  /**
   * The ID used to identify this component in Dash callbacks.
   */
  id: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,

  /**
   * Dash-assigned callback that should be called to report property changes
   * to Dash, to make them available for callbacks.
   */
  setProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,

  /**
   * List of representation to show
   */
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node), prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node]),

  /**
   * Passed by parent
   */
  view: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,

  /**
   * Passed by parent
   */
  representation: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,

  /**
   * Passed by parent
   */
  dataset: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object
};

/***/ }),

/***/ "./src/lib/components/VtkGeometryRepresentation.react.js":
/*!***************************************************************!*\
  !*** ./src/lib/components/VtkGeometryRepresentation.react.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VtkGeometryRepresentation; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vtk_js_Sources_Rendering_Core_Actor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Actor */ "./node_modules/vtk.js/Sources/Rendering/Core/Actor/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Mapper */ "./node_modules/vtk.js/Sources/Rendering/Core/Mapper/index.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }





/**
 * VtkGeometryRepresentation is responsible to convert a vtkPolyData into rendering
 * It takes the following set of properties:
 *   - colorBy: ['POINTS', ''],
 *   - pointSize: 1,
 *   - color: [1,1,1],
 * It provides the following properties to its children:
 *   - 'representation`: this
 *   - `downstream` == `mapper` which should be used to call setInputConnection/setInputData
 */

var VtkGeometryRepresentation = /*#__PURE__*/function (_Component) {
  _inherits(VtkGeometryRepresentation, _Component);

  var _super = _createSuper(VtkGeometryRepresentation);

  function VtkGeometryRepresentation(props) {
    var _this;

    _classCallCheck(this, VtkGeometryRepresentation);

    _this = _super.call(this, props); // Create vtk.js actor/mapper

    _this.actor = vtk_js_Sources_Rendering_Core_Actor__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
    _this.mapper = vtk_js_Sources_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();

    _this.actor.setMapper(_this.mapper);

    return _this;
  }

  _createClass(VtkGeometryRepresentation, [{
    key: "render",
    value: function render() {
      console.log('VtkGeometryRepresentation', this.props);
      var _this$props = this.props,
          id = _this$props.id,
          setProps = _this$props.setProps,
          children = _this$props.children,
          view = _this$props.view;
      var addOnProps = {
        downstream: this.mapper,
        representation: this,
        view: view,
        setProps: setProps
      };
      var childrenWithViewProp = react__WEBPACK_IMPORTED_MODULE_0___default.a.Children.map(children, function (child) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.cloneElement(child, addOnProps);
      });
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: id
      }, childrenWithViewProp);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var renderer = this.props.view.renderer;
      renderer.addActor(this.actor);
      this.update(this.props);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState, snapshot) {
      this.update(this.props, prevProps);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      var renderer = this.props.view.renderer;
      renderer.remoteActor(this.actor);
      this.actor["delete"]();
      this.actor = null;
      this.mapper["delete"]();
      this.mapper = null;
    }
  }, {
    key: "update",
    value: function update(props, previous) {
      var pointSize = props.pointSize,
          color = props.color,
          colorBy = props.colorBy;

      if (pointSize && (!previous || pointSize !== previous.pointSize)) {
        this.actor.getProperty().setPointSize(pointSize);
      }

      if (color && (!previous || color !== previous.color)) {
        this.actor.getProperty().setColor(color);
      }

      if (colorBy && (!previous || colorBy !== previous.colorBy)) {
        this.setColorBy.apply(this, _toConsumableArray(colorBy));
      }
    }
  }, {
    key: "setColorBy",
    value: function setColorBy(arrayLocation, arrayName) {
      var colorMode = vtk_js_Sources_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_3__["default"].ColorMode.DEFAULT;
      var scalarMode = vtk_js_Sources_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_3__["default"].ScalarMode.DEFAULT;
      var colorByArrayName = arrayName;
      var fields = this.mapper.getInputData().getReferenceByName(arrayLocation);
      var activeArray = fields && fields.getArray(arrayName);
      var scalarVisibility = !!activeArray;

      if (scalarVisibility) {
        colorMode = vtk_js_Sources_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_3__["default"].ColorMode.MAP_SCALARS;
        scalarMode = arrayLocation === 'pointData' ? vtk_js_Sources_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_3__["default"].ScalarMode.USE_POINT_FIELD_DATA : vtk_js_Sources_Rendering_Core_Mapper__WEBPACK_IMPORTED_MODULE_3__["default"].ScalarMode.USE_CELL_FIELD_DATA;
      } // Not all mappers have those fields


      this.mapper.set({
        colorByArrayName: colorByArrayName,
        colorMode: colorMode,
        scalarMode: scalarMode,
        scalarVisibility: scalarVisibility
      }, true);
    }
  }]);

  return VtkGeometryRepresentation;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);


VtkGeometryRepresentation.defaultProps = {
  colorBy: ['pointData', ''],
  pointSize: 1,
  color: [1, 1, 1]
};
VtkGeometryRepresentation.propTypes = {
  /**
   * The ID used to identify this component in Dash callbacks.
   */
  id: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,

  /**
   * Dash-assigned callback that should be called to report property changes
   * to Dash, to make them available for callbacks.
   */
  setProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
  // -- vtk.js exposed properties

  /**
   * Choose which array to color the output with.
   * - ['pointData', 'temperature']
   * - ['cellData', 'pressure']
   */
  colorBy: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string),

  /**
   * pointSize for vertex rendering
   */
  pointSize: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,

  /**
   * When no colorBy array is provided use provided solid color
   */
  color: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number),

  /**
   * List of representation to show
   */
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node), prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node]),

  /**
   * Passed by parent
   */
  view: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object
};

/***/ }),

/***/ "./src/lib/components/VtkPointData.react.js":
/*!**************************************************!*\
  !*** ./src/lib/components/VtkPointData.react.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VtkPointData; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }



/**
 * VtkPointData is exposing a vtkPointData to a downstream element
 * It provides the following properties to its children:
 *   - pass along: 'view', 'representation`, `setProps`
 *   - `fields` == `vtkPointData`
 */

var VtkPointData = /*#__PURE__*/function (_Component) {
  _inherits(VtkPointData, _Component);

  var _super = _createSuper(VtkPointData);

  function VtkPointData() {
    _classCallCheck(this, VtkPointData);

    return _super.apply(this, arguments);
  }

  _createClass(VtkPointData, [{
    key: "render",
    value: function render() {
      console.log('VtkPointData', this.props);
      var _this$props = this.props,
          id = _this$props.id,
          setProps = _this$props.setProps,
          children = _this$props.children,
          view = _this$props.view,
          representation = _this$props.representation,
          dataset = _this$props.dataset;
      var addOnProps = {
        fields: dataset.getPointData(),
        dataset: dataset,
        representation: representation,
        view: view,
        setProps: setProps
      };
      var childrenWithViewProp = react__WEBPACK_IMPORTED_MODULE_0___default.a.Children.map(children, function (child) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.cloneElement(child, addOnProps);
      });
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: id
      }, childrenWithViewProp);
    }
  }]);

  return VtkPointData;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);


VtkPointData.defaultProps = {};
VtkPointData.propTypes = {
  /**
   * The ID used to identify this component in Dash callbacks.
   */
  id: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,

  /**
   * Dash-assigned callback that should be called to report property changes
   * to Dash, to make them available for callbacks.
   */
  setProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,

  /**
   * List of representation to show
   */
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node), prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node]),

  /**
   * Passed by parent
   */
  view: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,

  /**
   * Passed by parent
   */
  representation: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,

  /**
   * Passed by parent
   */
  dataset: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object
};

/***/ }),

/***/ "./src/lib/components/VtkPolyDataSource.react.js":
/*!*******************************************************!*\
  !*** ./src/lib/components/VtkPolyDataSource.react.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VtkPolyDataSource; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vtk_js_Sources_Common_DataModel_PolyData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Common/DataModel/PolyData */ "./node_modules/vtk.js/Sources/Common/DataModel/PolyData/index.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




/**
 * VtkPolyDataSource is exposing a polydata to a downstream filter or representation
 * It takes the following set of properties:
 *   - points: [x, y, z, x, y, z, ...],
 *   - verts: [cellSize, pointId0, pointId1, ..., cellSize, pointId0, ...]
 *   - lines: [cellSize, pointId0, pointId1, ..., cellSize, pointId0, ...]
 *   - polys: [cellSize, pointId0, pointId1, ..., cellSize, pointId0, ...]
 *   - strips: [cellSize, pointId0, pointId1, ..., cellSize, pointId0, ...]
 *   - pointCloud: false/true (if on it will generate verts automatically)
 * It provides the following properties to its children:
 *   - pass along: 'view', 'representation`, `setProps`
 *   - `dataset` == `this.dataset`
 */

var VtkPolyDataSource = /*#__PURE__*/function (_Component) {
  _inherits(VtkPolyDataSource, _Component);

  var _super = _createSuper(VtkPolyDataSource);

  function VtkPolyDataSource(props) {
    var _this;

    _classCallCheck(this, VtkPolyDataSource);

    _this = _super.call(this, props); // Create vtk.js polydata

    _this.polydata = vtk_js_Sources_Common_DataModel_PolyData__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();
    return _this;
  }

  _createClass(VtkPolyDataSource, [{
    key: "render",
    value: function render() {
      console.log('VtkPolyDataSource', this.props);
      var _this$props = this.props,
          id = _this$props.id,
          setProps = _this$props.setProps,
          children = _this$props.children,
          view = _this$props.view,
          representation = _this$props.representation;
      var addOnProps = {
        dataset: this.polydata,
        representation: representation,
        view: view,
        setProps: setProps
      };
      var childrenWithViewProp = react__WEBPACK_IMPORTED_MODULE_0___default.a.Children.map(children, function (child) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.cloneElement(child, addOnProps);
      });
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: id
      }, childrenWithViewProp);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props2 = this.props,
          downstream = _this$props2.downstream,
          port = _this$props2.port;
      this.update(this.props);
      downstream.setInputData(this.polydata, port);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState, snapshot) {
      this.update(this.props, prevProps);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.polydata["delete"]();
      this.polydata = null;
    }
  }, {
    key: "update",
    value: function update(props, previous) {
      var pointCloud = props.pointCloud,
          points = props.points,
          verts = props.verts,
          lines = props.lines,
          polys = props.polys,
          strips = props.strips;
      var changeDetected = false;
      var pointChanged = false;

      if (points && (!previous || points !== previous.points)) {
        this.polydata.getPoints().setData(Float32Array.from(points), 3);
        pointChanged = true;
        changeDetected = true;
      }

      if (verts && (!previous || verts !== previous.verts)) {
        this.polydata.getVerts().setData(Uint16Array.from(verts));
        changeDetected = true;
      }

      if (lines && (!previous || lines !== previous.lines)) {
        this.polydata.getLines().setData(Uint16Array.from(lines));
        changeDetected = true;
      }

      if (polys && (!previous || polys !== previous.polys)) {
        this.polydata.getPolys().setData(Uint16Array.from(polys));
        changeDetected = true;
      }

      if (strips && (!previous || strips !== previous.strips)) {
        this.polydata.getStrips().setData(Uint16Array.from(strips));
        changeDetected = true;
      }

      if (pointCloud && (pointChanged || !previous || pointCloud !== previous.pointCloud)) {
        var nbPoints = points.length / 3;
        var values = new Uint16Array(nbPoints + 1);
        values[0] = nbPoints;

        for (var i = 0; i < nbPoints; i++) {
          values[i + 1] = i;
        }

        this.polydata.getVerts().setData(values);
        changeDetected = true;
      }

      if (changeDetected) {
        this.polydata.modified();
      }
    }
  }]);

  return VtkPolyDataSource;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);


VtkPolyDataSource.defaultProps = {
  port: 0,
  points: [],
  pointCloud: false
};
VtkPolyDataSource.propTypes = {
  /**
   * The ID used to identify this component in Dash callbacks.
   */
  id: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,

  /**
   * Dash-assigned callback that should be called to report property changes
   * to Dash, to make them available for callbacks.
   */
  setProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
  // -- vtk.js exposed properties

  /**
   * downstream connection port
   */
  port: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,

  /**
   * xyz coordinates
   */
  points: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number),

  /**
   * verts cells
   */
  verts: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number),

  /**
   * lines cells
   */
  lines: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number),

  /**
   * polys cells
   */
  polys: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number),

  /**
   * strips cells
   */
  strips: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number),

  /**
   * Is it point cloud
   */
  pointCloud: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,

  /**
   * List of representation to show
   */
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node), prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node]),

  /**
   * Passed by parent
   */
  view: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,

  /**
   * Passed by parent
   */
  representation: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object
};

/***/ }),

/***/ "./src/lib/components/VtkView.react.js":
/*!*********************************************!*\
  !*** ./src/lib/components/VtkView.react.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VtkView; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vtk_js_Sources_Rendering_OpenGL_RenderWindow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vtk.js/Sources/Rendering/OpenGL/RenderWindow */ "./node_modules/vtk.js/Sources/Rendering/OpenGL/RenderWindow/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_RenderWindow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/RenderWindow */ "./node_modules/vtk.js/Sources/Rendering/Core/RenderWindow/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_RenderWindowInteractor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/RenderWindowInteractor */ "./node_modules/vtk.js/Sources/Rendering/Core/RenderWindowInteractor/index.js");
/* harmony import */ var vtk_js_Sources_Rendering_Core_Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vtk.js/Sources/Rendering/Core/Renderer */ "./node_modules/vtk.js/Sources/Rendering/Core/Renderer/index.js");
/* harmony import */ var vtk_js_Sources_Interaction_Style_InteractorStyleTrackballCamera__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vtk.js/Sources/Interaction/Style/InteractorStyleTrackballCamera */ "./node_modules/vtk.js/Sources/Interaction/Style/InteractorStyleTrackballCamera/index.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }








var CONTAINER_STYLE = {
  width: '100%',
  height: '100%',
  position: 'relative'
};
var RENDERER_STYLE = {
  position: 'absolute',
  width: '100%',
  height: '100%',
  overflow: 'hidden'
};
var HIDDEN_STYLE = {
  display: 'none'
};
/**
 * VtkView is responsible to render vtk.js data.
 * It takes the following set of properties:
 *   - `background`:
 */

var VtkView = /*#__PURE__*/function (_Component) {
  _inherits(VtkView, _Component);

  var _super = _createSuper(VtkView);

  function VtkView(props) {
    var _this;

    _classCallCheck(this, VtkView);

    _this = _super.call(this, props);
    _this.containerRef = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createRef(); // Create vtk.js view

    _this.renderWindow = vtk_js_Sources_Rendering_Core_RenderWindow__WEBPACK_IMPORTED_MODULE_3__["default"].newInstance();
    _this.renderer = vtk_js_Sources_Rendering_Core_Renderer__WEBPACK_IMPORTED_MODULE_5__["default"].newInstance({
      background: props.background
    });

    _this.renderWindow.addRenderer(_this.renderer);

    _this.openglRenderWindow = vtk_js_Sources_Rendering_OpenGL_RenderWindow__WEBPACK_IMPORTED_MODULE_2__["default"].newInstance();

    _this.renderWindow.addView(_this.openglRenderWindow);

    _this.interactor = vtk_js_Sources_Rendering_Core_RenderWindowInteractor__WEBPACK_IMPORTED_MODULE_4__["default"].newInstance();

    _this.interactor.setView(_this.openglRenderWindow);

    _this.interactor.initialize(); // We may want something different


    _this.interactor.setInteractorStyle(vtk_js_Sources_Interaction_Style_InteractorStyleTrackballCamera__WEBPACK_IMPORTED_MODULE_6__["default"].newInstance()); // Resize handling


    _this.resizeObserver = new ResizeObserver(function () {
      return _this.onResize();
    });
    return _this;
  }

  _createClass(VtkView, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          id = _this$props.id,
          children = _this$props.children,
          setProps = _this$props.setProps;
      var addOnProps = {
        view: this,
        setProps: setProps
      };
      var childrenWithViewProp = react__WEBPACK_IMPORTED_MODULE_0___default.a.Children.map(children, function (child) {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.cloneElement(child, addOnProps);
      });
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: id,
        style: CONTAINER_STYLE
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        style: RENDERER_STYLE,
        ref: this.containerRef
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        style: HIDDEN_STYLE
      }, childrenWithViewProp));
    }
  }, {
    key: "onResize",
    value: function onResize() {
      var container = this.containerRef.current;

      if (container) {
        var _container$getBoundin = container.getBoundingClientRect(),
            width = _container$getBoundin.width,
            height = _container$getBoundin.height;

        this.openglRenderWindow.setSize(Math.max(width, 10), Math.max(height, 10));
        this.renderWindow.render();
      }
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var container = this.containerRef.current;
      this.openglRenderWindow.setContainer(container);
      this.interactor.bindEvents(container);
      this.onResize();
      this.resizeObserver.observe(container);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      // Stop size listening
      this.resizeObserver.disconnect();
      this.resizeObserver = null; // Detatch from DOM

      this.interactor.unbindEvents();
      this.openglRenderWindow.setContainer(null); // Free memory

      this.renderWindow.removeRenderer(this.renderer);
      this.renderWindow.removeView(this.openglRenderWindow);
      this.interactor["delete"]();
      this.interactor = null;
      this.renderer["delete"]();
      this.renderer = null;
      this.renderWindow["delete"]();
      this.renderWindow = null;
      this.openglRenderWindow["delete"]();
      this.openglRenderWindow = null;
    }
  }]);

  return VtkView;
}(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);


VtkView.defaultProps = {
  background: [0.2, 0.3, 0.4]
};
VtkView.propTypes = {
  /**
   * The ID used to identify this component in Dash callbacks.
   */
  id: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,

  /**
   * The color of the view background using 3 floating numbers
   * between 0-1 of Red, Green, Blue component.
   */
  background: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.array,

  /**
   * Dash-assigned callback that should be called to report property changes
   * to Dash, to make them available for callbacks.
   */
  setProps: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,

  /**
   * List of representation to show
   */
  children: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node), prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.node])
};

/***/ }),

/***/ "./src/lib/index.js":
/*!**************************!*\
  !*** ./src/lib/index.js ***!
  \**************************/
/*! exports provided: VtkCellData, VtkDataArray, VtkFieldData, VtkGeometryRepresentation, VtkPointData, VtkPolyDataSource, VtkView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_VtkCellData_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/VtkCellData.react */ "./src/lib/components/VtkCellData.react.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VtkCellData", function() { return _components_VtkCellData_react__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _components_VtkDataArray_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/VtkDataArray.react */ "./src/lib/components/VtkDataArray.react.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VtkDataArray", function() { return _components_VtkDataArray_react__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _components_VtkFieldData_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/VtkFieldData.react */ "./src/lib/components/VtkFieldData.react.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VtkFieldData", function() { return _components_VtkFieldData_react__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _components_VtkGeometryRepresentation_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/VtkGeometryRepresentation.react */ "./src/lib/components/VtkGeometryRepresentation.react.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VtkGeometryRepresentation", function() { return _components_VtkGeometryRepresentation_react__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _components_VtkPointData_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./components/VtkPointData.react */ "./src/lib/components/VtkPointData.react.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VtkPointData", function() { return _components_VtkPointData_react__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _components_VtkPolyDataSource_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./components/VtkPolyDataSource.react */ "./src/lib/components/VtkPolyDataSource.react.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VtkPolyDataSource", function() { return _components_VtkPolyDataSource_react__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _components_VtkView_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/VtkView.react */ "./src/lib/components/VtkView.react.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VtkView", function() { return _components_VtkView_react__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* eslint-disable import/prefer-default-export */









/***/ }),

/***/ 1:
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

})
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy9ibHVlaW1wLW1kNS9qcy9tZDUuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9jb21tb24uanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL21hdDIuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9tYXQyZC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL21hdDMuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9tYXQ0LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vcXVhdC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3F1YXQyLmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vdmVjMi5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3ZlYzMuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWM0LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi9hbGVhLmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3R5Y2hlaS5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3IxMjguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yNDA5Ni5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi94b3JzaGlmdDcuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yd293LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vc2VlZHJhbmRvbS5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9DZWxsQXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvRGF0YUFycmF5L0NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9EYXRhQXJyYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvTG9va3VwVGFibGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvTWF0aC9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9NYXRyaXhCdWlsZGVyL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL1BvaW50cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9TY2FsYXJzVG9Db2xvcnMvQ29uc3RhbnRzLmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL1NjYWxhcnNUb0NvbG9ycy9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0JvdW5kaW5nQm94L2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvQ2VsbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0NlbGxMaW5rcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0NlbGxUeXBlcy9Db25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9DZWxsVHlwZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9EYXRhU2V0L0NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0RhdGFTZXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9EYXRhU2V0QXR0cmlidXRlcy9Db25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9EYXRhU2V0QXR0cmlidXRlcy9GaWVsZERhdGEuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9EYXRhU2V0QXR0cmlidXRlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0ltYWdlRGF0YS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0xpbmUvQ29uc3RhbnRzLmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvTGluZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL1BsYW5lL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvUG9pbnRTZXQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9Qb2x5RGF0YS9Db25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9Qb2x5RGF0YS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL1NlbGVjdGlvbk5vZGUvQ29uc3RhbnRzLmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvU2VsZWN0aW9uTm9kZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL1N0cnVjdHVyZWREYXRhL0NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL1N0cnVjdHVyZWREYXRhL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvVHJpYW5nbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvSW50ZXJhY3Rpb24vU3R5bGUvSW50ZXJhY3RvclN0eWxlVHJhY2tiYWxsQ2FtZXJhL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL0Fic3RyYWN0TWFwcGVyL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL0Fic3RyYWN0TWFwcGVyM0QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvQWN0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvQ2FtZXJhL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL0ltYWdlTWFwcGVyL0NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9JbWFnZVByb3BlcnR5L0NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9JbnRlcmFjdG9yT2JzZXJ2ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvSW50ZXJhY3RvclN0eWxlL0NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9JbnRlcmFjdG9yU3R5bGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvTGlnaHQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvTWFwcGVyL0NvaW5jaWRlbnRUb3BvbG9neUhlbHBlci5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9NYXBwZXIvQ29uc3RhbnRzLmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL01hcHBlci9TdGF0aWMuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvTWFwcGVyL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL1Byb3AvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvUHJvcDNEL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL1Byb3BlcnR5L0NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9Qcm9wZXJ0eS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9SZW5kZXJXaW5kb3cvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvUmVuZGVyV2luZG93SW50ZXJhY3Rvci9Db25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvUmVuZGVyV2luZG93SW50ZXJhY3Rvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9SZW5kZXJlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9WaWV3cG9ydC9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9Wb2x1bWVNYXBwZXIvQ29uc3RhbnRzLmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL1ZvbHVtZVByb3BlcnR5L0NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML0FjdG9yL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvQWN0b3IyRC9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML0J1ZmZlck9iamVjdC9Db25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9CdWZmZXJPYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9DYW1lcmEvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9DZWxsQXJyYXlCdWZmZXJPYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9Gb3J3YXJkUGFzcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML0ZyYW1lYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvR2x5cGgzRE1hcHBlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML0hhcmR3YXJlU2VsZWN0b3IvQ29uc3RhbnRzLmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvSGFyZHdhcmVTZWxlY3Rvci9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML0hlbHBlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML0ltYWdlTWFwcGVyL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvSW1hZ2VTbGljZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1BpeGVsU3BhY2VDYWxsYmFja01hcHBlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1BvbHlEYXRhTWFwcGVyL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvUmVuZGVyV2luZG93L2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvUmVuZGVyZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9SZXBsYWNlbWVudFNoYWRlck1hcHBlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1NoYWRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1NoYWRlckNhY2hlL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvU2hhZGVyUHJvZ3JhbS9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1NreWJveC9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1NwaGVyZU1hcHBlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1N0aWNrTWFwcGVyL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvVGV4dHVyZS9Db25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9UZXh0dXJlL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvVGV4dHVyZVVuaXRNYW5hZ2VyL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvVmVydGV4QXJyYXlPYmplY3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9WaWV3Tm9kZUZhY3RvcnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9Wb2x1bWUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9Wb2x1bWVNYXBwZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9nbHNsL3Z0a1BvbHlEYXRhRlMuZ2xzbCIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL25vZGVfbW9kdWxlcy92dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML2dsc2wvdnRrUG9seURhdGFWUy5nbHNsIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvZ2xzbC92dGtTcGhlcmVNYXBwZXJWUy5nbHNsIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvZ2xzbC92dGtTdGlja01hcHBlclZTLmdsc2wiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9nbHNsL3Z0a1ZvbHVtZUZTLmdsc2wiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9nbHNsL3Z0a1ZvbHVtZVZTLmdsc2wiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL1NjZW5lR3JhcGgvR2VuZXJpY1dpZGdldFJlcHJlc2VudGF0aW9uL2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9TY2VuZUdyYXBoL1JlbmRlclBhc3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL1NjZW5lR3JhcGgvVmlld05vZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvdnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL1NjZW5lR3JhcGgvVmlld05vZGVGYWN0b3J5L2luZGV4LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL21hY3JvLmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vbm9kZV9tb2R1bGVzL3Z0ay5qcy9Tb3VyY2VzL3Z0ay5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8od2VicGFjaykvYnVpbGRpbi9hbWQtZGVmaW5lLmpzIiwid2VicGFjazovL2Rhc2hfdnRrLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzIiwid2VicGFjazovL2Rhc2hfdnRrLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9ub2RlX21vZHVsZXMvd2VidnItcG9seWZpbGwvYnVpbGQvd2VidnItcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9zcmMvZGVtby9BcHAuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9zcmMvbGliL2NvbXBvbmVudHMvVnRrQ2VsbERhdGEucmVhY3QuanMiLCJ3ZWJwYWNrOi8vZGFzaF92dGsvLi9zcmMvbGliL2NvbXBvbmVudHMvVnRrRGF0YUFycmF5LnJlYWN0LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vc3JjL2xpYi9jb21wb25lbnRzL1Z0a0ZpZWxkRGF0YS5yZWFjdC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL3NyYy9saWIvY29tcG9uZW50cy9WdGtHZW9tZXRyeVJlcHJlc2VudGF0aW9uLnJlYWN0LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vc3JjL2xpYi9jb21wb25lbnRzL1Z0a1BvaW50RGF0YS5yZWFjdC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL3NyYy9saWIvY29tcG9uZW50cy9WdGtQb2x5RGF0YVNvdXJjZS5yZWFjdC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay8uL3NyYy9saWIvY29tcG9uZW50cy9WdGtWaWV3LnJlYWN0LmpzIiwid2VicGFjazovL2Rhc2hfdnRrLy4vc3JjL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9kYXNoX3Z0ay9jcnlwdG8gKGlnbm9yZWQpIl0sIm5hbWVzIjpbIkFwcCIsInNldFByb3BzIiwiYmluZCIsIm5ld1Byb3BzIiwic2V0U3RhdGUiLCJDb21wb25lbnQiLCJWdGtDZWxsRGF0YSIsInByb3BzIiwiaWQiLCJjaGlsZHJlbiIsInZpZXciLCJyZXByZXNlbnRhdGlvbiIsImRhdGFzZXQiLCJhZGRPblByb3BzIiwiZmllbGRzIiwiZ2V0Q2VsbERhdGEiLCJjaGlsZHJlbldpdGhWaWV3UHJvcCIsIlJlYWN0IiwiQ2hpbGRyZW4iLCJtYXAiLCJjaGlsZCIsImNsb25lRWxlbWVudCIsImRlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsIlByb3BUeXBlcyIsInN0cmluZyIsImZ1bmMiLCJvbmVPZlR5cGUiLCJhcnJheU9mIiwibm9kZSIsIm9iamVjdCIsIlZ0a0RhdGFBcnJheSIsImFycmF5IiwidnRrRGF0YUFycmF5IiwibmV3SW5zdGFuY2UiLCJlbXB0eSIsImNvbnNvbGUiLCJsb2ciLCJyZWdpc3RyYXRpb24iLCJ1cGRhdGUiLCJwcmV2UHJvcHMiLCJwcmV2U3RhdGUiLCJzbmFwc2hvdCIsInJlbW92ZUFycmF5IiwicHJldmlvdXMiLCJuYW1lIiwidHlwZSIsInZhbHVlcyIsIm51bWJlck9mQ29tcG9uZW50cyIsImtsYXNzIiwiVFlQRURfQVJSQVlTIiwic2V0TmFtZSIsImNoYW5nZURldGVjdGVkIiwic2V0RGF0YSIsImZyb20iLCJudW1iZXIiLCJWdGtGaWVsZERhdGEiLCJnZXRGaWVsZERhdGEiLCJWdGtHZW9tZXRyeVJlcHJlc2VudGF0aW9uIiwiYWN0b3IiLCJ2dGtBY3RvciIsIm1hcHBlciIsInZ0a01hcHBlciIsInNldE1hcHBlciIsImRvd25zdHJlYW0iLCJyZW5kZXJlciIsImFkZEFjdG9yIiwicmVtb3RlQWN0b3IiLCJwb2ludFNpemUiLCJjb2xvciIsImNvbG9yQnkiLCJnZXRQcm9wZXJ0eSIsInNldFBvaW50U2l6ZSIsInNldENvbG9yIiwic2V0Q29sb3JCeSIsImFycmF5TG9jYXRpb24iLCJhcnJheU5hbWUiLCJjb2xvck1vZGUiLCJDb2xvck1vZGUiLCJERUZBVUxUIiwic2NhbGFyTW9kZSIsIlNjYWxhck1vZGUiLCJjb2xvckJ5QXJyYXlOYW1lIiwiZ2V0SW5wdXREYXRhIiwiZ2V0UmVmZXJlbmNlQnlOYW1lIiwiYWN0aXZlQXJyYXkiLCJnZXRBcnJheSIsInNjYWxhclZpc2liaWxpdHkiLCJNQVBfU0NBTEFSUyIsIlVTRV9QT0lOVF9GSUVMRF9EQVRBIiwiVVNFX0NFTExfRklFTERfREFUQSIsInNldCIsIlZ0a1BvaW50RGF0YSIsImdldFBvaW50RGF0YSIsIlZ0a1BvbHlEYXRhU291cmNlIiwicG9seWRhdGEiLCJ2dGtQb2x5RGF0YSIsInBvcnQiLCJzZXRJbnB1dERhdGEiLCJwb2ludENsb3VkIiwicG9pbnRzIiwidmVydHMiLCJsaW5lcyIsInBvbHlzIiwic3RyaXBzIiwicG9pbnRDaGFuZ2VkIiwiZ2V0UG9pbnRzIiwiRmxvYXQzMkFycmF5IiwiZ2V0VmVydHMiLCJVaW50MTZBcnJheSIsImdldExpbmVzIiwiZ2V0UG9seXMiLCJnZXRTdHJpcHMiLCJuYlBvaW50cyIsImxlbmd0aCIsImkiLCJtb2RpZmllZCIsImJvb2wiLCJDT05UQUlORVJfU1RZTEUiLCJ3aWR0aCIsImhlaWdodCIsInBvc2l0aW9uIiwiUkVOREVSRVJfU1RZTEUiLCJvdmVyZmxvdyIsIkhJRERFTl9TVFlMRSIsImRpc3BsYXkiLCJWdGtWaWV3IiwiY29udGFpbmVyUmVmIiwiY3JlYXRlUmVmIiwicmVuZGVyV2luZG93IiwidnRrUmVuZGVyV2luZG93IiwidnRrUmVuZGVyZXIiLCJiYWNrZ3JvdW5kIiwiYWRkUmVuZGVyZXIiLCJvcGVuZ2xSZW5kZXJXaW5kb3ciLCJ2dGtPcGVuR0xSZW5kZXJXaW5kb3ciLCJhZGRWaWV3IiwiaW50ZXJhY3RvciIsInZ0a1JlbmRlcldpbmRvd0ludGVyYWN0b3IiLCJzZXRWaWV3IiwiaW5pdGlhbGl6ZSIsInNldEludGVyYWN0b3JTdHlsZSIsInZ0a0ludGVyYWN0b3JTdHlsZVRyYWNrYmFsbENhbWVyYSIsInJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJvblJlc2l6ZSIsImNvbnRhaW5lciIsImN1cnJlbnQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzZXRTaXplIiwiTWF0aCIsIm1heCIsInJlbmRlciIsInNldENvbnRhaW5lciIsImJpbmRFdmVudHMiLCJvYnNlcnZlIiwiZGlzY29ubmVjdCIsInVuYmluZEV2ZW50cyIsInJlbW92ZVJlbmRlcmVyIiwicmVtb3ZlVmlldyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE9BQU87QUFDcEIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrREFBZ0IsK0JBQStCLGtEQUFnQiwrQkFBK0Isa0RBQWdCO0FBQy9JO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsT0FBTztBQUNwQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFh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QUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxhQUFhO0FBQ3hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsYUFBYTtBQUN4QixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FB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LElBQUksSUFBcUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkJBQTZCO0FBQzdCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsNEJBQTRCO0FBQzVCLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVLEtBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNCQUFzQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyw0RkFBNEYsU0FBTTtBQUM3STtBQUNBOztBQUVBLG1CQUFtQixnQ0FBZ0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFFTztBQUNQLEVBQUUsaURBQVUsSUFBSSxLQUFLLElBQUksZUFBZTtBQUN4QztBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFTzs7QUFFUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1AsaUJBQWlCLE9BQU87QUFDeEIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1AsaUJBQWlCLE9BQU87QUFDeEIsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixlQUFlLE9BQU87QUFDdEI7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsVUFBVTtBQUMzQixtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0IsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDLG1DQUFtQztBQUNuQyxrQ0FBa0M7QUFDbEMsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7O0FBRUEsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxlQUFlLFlBQVk7QUFDM0I7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFlBQVk7QUFDekIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0EsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEIsd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDTzs7QUFFQTtBQUNQO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLDRFQUFZO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFFBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDRFQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRU8sb0RBQW9EO0FBQzNEOztBQUVBLEVBQUUsNERBQUs7O0FBRVA7QUFDQTs7QUFFQTs7QUFFTyxvQkFBb0IsNERBQUs7O0FBRWhDOztBQUVlLGdFQUFDLHNCQUFzQixFQUFDOzs7Ozs7Ozs7Ozs7O0FDdFF2QztBQUFBO0FBQUE7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixrRkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrRkFBMEI7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDhDQUFJOztBQUVSLElBQUksOENBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksOENBQUk7QUFDUixJQUFJLDhDQUFJO0FBQ1I7O0FBRUE7QUFDQTtBQUNBLElBQUksOENBQUk7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksOENBQUk7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLDhDQUFJO0FBQ1IsSUFBSSw4Q0FBSTtBQUNSLElBQUksOENBQUk7QUFDUjs7QUFFQSxJQUFJLDhDQUFJO0FBQ1IsSUFBSSw4Q0FBSTtBQUNSLElBQUksOENBQUk7QUFDUjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSw4Q0FBSTs7QUFFUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOENBQUk7QUFDVjtBQUNBLE1BQU0sOENBQUk7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiw4Q0FBSTs7QUFFdkIsSUFBSSw4Q0FBSTtBQUNSO0FBQ0EsTUFBTSw4Q0FBSTtBQUNWLE1BQU0sOENBQUk7QUFDVixNQUFNLDhDQUFJO0FBQ1Y7O0FBRUEsSUFBSSw4Q0FBSTs7QUFFUixJQUFJLDhDQUFJO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsOENBQUk7O0FBRXZCO0FBQ0E7QUFDQSxNQUFNLDhDQUFJOztBQUVWLE1BQU0sOENBQUk7QUFDVixNQUFNLDhDQUFJO0FBQ1YsTUFBTSw4Q0FBSTtBQUNWO0FBQ0E7O0FBRUEsSUFBSSw4Q0FBSTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU0sOENBQUk7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsYUFBYTtBQUNwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVc7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGFBQWE7QUFDckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isa0ZBQTBCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0ZBQTBCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBOztBQUVPLG9EQUFvRDtBQUMzRDs7QUFFQTtBQUNBLEVBQUUsNERBQUs7O0FBRVAsRUFBRSw0REFBSztBQUNQO0FBQ0EsSUFBSSw0REFBSztBQUNUOztBQUVBO0FBQ0EsRUFBRSw0REFBSztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLDREQUFLO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVPLG9CQUFvQiw0REFBSztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsZ0VBQUMsd0NBQXdDLHNHQUFTLEVBQUUsRUFBQzs7Ozs7Ozs7Ozs7OztBQ3ppQ3BFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXVDOztBQUVPO0FBQ2U7QUFDRjtBQUNBO0FBQ007QUFDUTs7QUFFekUsT0FBTyxnREFBZ0QsR0FBRyxpREFBSzs7QUFFL0Q7QUFDQSw2Q0FBNkMsT0FBTztBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRDtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDRFQUFTO0FBQzVCLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsMkVBQVE7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksOENBQUk7QUFDUixJQUFJLDhDQUFJOztBQUVSO0FBQ0EsbUJBQW1CLDhDQUFJO0FBQ3ZCLElBQUksOENBQUk7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSw4Q0FBSTtBQUNSLElBQUksOENBQUk7O0FBRVI7QUFDQSxtQkFBbUIsOENBQUk7QUFDdkIsSUFBSSw4Q0FBSTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSw4Q0FBSTs7QUFFUixtQkFBbUIsOENBQUk7QUFDdkIsSUFBSSw4Q0FBSTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLDhDQUFJOztBQUVSLG1CQUFtQiw4Q0FBSTtBQUN2QixJQUFJLDhDQUFJO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixtRkFBYztBQUN2Qyx5QkFBeUIsbUZBQWM7QUFDdkMseUJBQXlCLG1GQUFjO0FBQ3ZDLHlCQUF5QixtRkFBYztBQUN2Qyx5QkFBeUIsbUZBQWM7QUFDdkMseUJBQXlCLG1GQUFjO0FBQ3ZDOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0ZBQTRCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sa0ZBQTBCO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxvRkFBNEI7QUFDckM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0ZBQTBCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixtRUFBVztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMsb0ZBQTRCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQixrRkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhDQUFJO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsMEZBQTJCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLHFEQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsc0ZBQWE7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsMkZBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyRkFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixtQ0FBbUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLDREQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUE4QztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxPQUFPLFNBQVM7QUFDakY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLE9BQU8sU0FBUztBQUNqRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTyw0RUFBb0Isa0JBQWtCLDRFQUFvQjtBQUNqRTtBQUNBO0FBQ0EsUUFBUSxpRkFBeUI7QUFDakM7QUFDQTtBQUNBLFFBQVEsaUZBQXlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFTzs7QUFFQTtBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUCxhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7Ozs7QUNybkRGO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ0RBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUMsS0FBNEQ7QUFDN0QsQ0FBQyxTQUNrQztBQUNuQyxDQUFDLHFCQUFxQjs7QUFFdEI7Ozs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsWUFBWSxFQUFFO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsK0JBQStCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLCtCQUErQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixXQUFXLFdBQVc7QUFDdkMsaUJBQWlCLFdBQVcsV0FBVztBQUN2QyxpQkFBaUIsV0FBVyxZQUFZO0FBQ3hDLG1CQUFtQixhQUFhLGFBQWE7QUFDN0MsbUJBQW1CLGFBQWEsYUFBYTtBQUM3QyxtQkFBbUIsYUFBYSxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QixtQkFBbUIsWUFBWTtBQUMvQixxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCLG1CQUFtQixZQUFZO0FBQy9CLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywrQkFBK0IsaUJBQWlCLGdFQUFnRSxLQUFLO0FBQzFKLHFDQUFxQyx1QkFBdUIsaUJBQWlCLDJCQUEyQixLQUFLO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOEJBQThCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkNBQTZDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQ0FBb0M7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWSxFQUFFO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtEQUErRDtBQUM3SDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFO0FBQ2pqQixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFO0FBQ3ZKO0FBQ0Esb0ZBQW9GLElBQUksUUFBUSxJQUFJO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUM7QUFDakMsT0FBTztBQUNQO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxRQUFRO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLFFBQVE7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFVBQVUsZ0JBQWdCLEVBQUU7QUFDckY7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFVBQVUsZ0JBQWdCLEVBQUU7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztB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QTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNQQSxlIiwiZmlsZSI6ImFkMDc4ODgtbWFpbi13cHMtaG1yLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEphdmFTY3JpcHQgTUQ1XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LU1ENVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiBCYXNlZCBvblxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4yIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwOVxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuLyogZXNsaW50LWRpc2FibGUgc3RyaWN0ICovXG5cbjsoZnVuY3Rpb24gKCQpIHtcbiAgJ3VzZSBzdHJpY3QnXG5cbiAgLyoqXG4gICAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi5cbiAgICogVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHkgdG8gd29yayBhcm91bmQgYnVncyBpbiBpbnRlcnByZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IEZpcnN0IGludGVnZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHkgU2Vjb25kIGludGVnZXJcbiAgICogQHJldHVybnMge251bWJlcn0gU3VtXG4gICAqL1xuICBmdW5jdGlvbiBzYWZlQWRkKHgsIHkpIHtcbiAgICB2YXIgbHN3ID0gKHggJiAweGZmZmYpICsgKHkgJiAweGZmZmYpXG4gICAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpXG4gICAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4ZmZmZilcbiAgfVxuXG4gIC8qKlxuICAgKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBudW0gMzItYml0IG51bWJlclxuICAgKiBAcGFyYW0ge251bWJlcn0gY250IFJvdGF0aW9uIGNvdW50XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJvdGF0ZWQgbnVtYmVyXG4gICAqL1xuICBmdW5jdGlvbiBiaXRSb3RhdGVMZWZ0KG51bSwgY250KSB7XG4gICAgcmV0dXJuIChudW0gPDwgY250KSB8IChudW0gPj4+ICgzMiAtIGNudCkpXG4gIH1cblxuICAvKipcbiAgICogQmFzaWMgb3BlcmF0aW9uIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHEgcVxuICAgKiBAcGFyYW0ge251bWJlcn0gYSBhXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiIGJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggeFxuICAgKiBAcGFyYW0ge251bWJlcn0gcyBzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IHRcbiAgICogQHJldHVybnMge251bWJlcn0gUmVzdWx0XG4gICAqL1xuICBmdW5jdGlvbiBtZDVjbW4ocSwgYSwgYiwgeCwgcywgdCkge1xuICAgIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpXG4gIH1cbiAgLyoqXG4gICAqIEJhc2ljIG9wZXJhdGlvbiB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhIGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IGIgYlxuICAgKiBAcGFyYW0ge251bWJlcn0gYyBjXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkIGRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggeFxuICAgKiBAcGFyYW0ge251bWJlcn0gcyBzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IHRcbiAgICogQHJldHVybnMge251bWJlcn0gUmVzdWx0XG4gICAqL1xuICBmdW5jdGlvbiBtZDVmZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIG1kNWNtbigoYiAmIGMpIHwgKH5iICYgZCksIGEsIGIsIHgsIHMsIHQpXG4gIH1cbiAgLyoqXG4gICAqIEJhc2ljIG9wZXJhdGlvbiB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhIGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IGIgYlxuICAgKiBAcGFyYW0ge251bWJlcn0gYyBjXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkIGRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggeFxuICAgKiBAcGFyYW0ge251bWJlcn0gcyBzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IHRcbiAgICogQHJldHVybnMge251bWJlcn0gUmVzdWx0XG4gICAqL1xuICBmdW5jdGlvbiBtZDVnZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIG1kNWNtbigoYiAmIGQpIHwgKGMgJiB+ZCksIGEsIGIsIHgsIHMsIHQpXG4gIH1cbiAgLyoqXG4gICAqIEJhc2ljIG9wZXJhdGlvbiB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhIGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IGIgYlxuICAgKiBAcGFyYW0ge251bWJlcn0gYyBjXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkIGRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggeFxuICAgKiBAcGFyYW0ge251bWJlcn0gcyBzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IHRcbiAgICogQHJldHVybnMge251bWJlcn0gUmVzdWx0XG4gICAqL1xuICBmdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIG1kNWNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpXG4gIH1cbiAgLyoqXG4gICAqIEJhc2ljIG9wZXJhdGlvbiB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhIGFcbiAgICogQHBhcmFtIHtudW1iZXJ9IGIgYlxuICAgKiBAcGFyYW0ge251bWJlcn0gYyBjXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkIGRcbiAgICogQHBhcmFtIHtudW1iZXJ9IHggeFxuICAgKiBAcGFyYW0ge251bWJlcn0gcyBzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0IHRcbiAgICogQHJldHVybnMge251bWJlcn0gUmVzdWx0XG4gICAqL1xuICBmdW5jdGlvbiBtZDVpaShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIG1kNWNtbihjIF4gKGIgfCB+ZCksIGEsIGIsIHgsIHMsIHQpXG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0geCBBcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gQml0IGxlbmd0aFxuICAgKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gTUQ1IEFycmF5XG4gICAqL1xuICBmdW5jdGlvbiBiaW5sTUQ1KHgsIGxlbikge1xuICAgIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gICAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCBsZW4gJSAzMlxuICAgIHhbKCgobGVuICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGxlblxuXG4gICAgdmFyIGlcbiAgICB2YXIgb2xkYVxuICAgIHZhciBvbGRiXG4gICAgdmFyIG9sZGNcbiAgICB2YXIgb2xkZFxuICAgIHZhciBhID0gMTczMjU4NDE5M1xuICAgIHZhciBiID0gLTI3MTczMzg3OVxuICAgIHZhciBjID0gLTE3MzI1ODQxOTRcbiAgICB2YXIgZCA9IDI3MTczMzg3OFxuXG4gICAgZm9yIChpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICBvbGRhID0gYVxuICAgICAgb2xkYiA9IGJcbiAgICAgIG9sZGMgPSBjXG4gICAgICBvbGRkID0gZFxuXG4gICAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpXSwgNywgLTY4MDg3NjkzNilcbiAgICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpXG4gICAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE3LCA2MDYxMDU4MTkpXG4gICAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgM10sIDIyLCAtMTA0NDUyNTMzMClcbiAgICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5NylcbiAgICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA1XSwgMTIsIDEyMDAwODA0MjYpXG4gICAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE3LCAtMTQ3MzIzMTM0MSlcbiAgICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4MylcbiAgICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNywgMTc3MDAzNTQxNilcbiAgICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA5XSwgMTIsIC0xOTU4NDE0NDE3KVxuICAgICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2MylcbiAgICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxMV0sIDIyLCAtMTk5MDQwNDE2MilcbiAgICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDcsIDE4MDQ2MDM2ODIpXG4gICAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKVxuICAgICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTcsIC0xNTAyMDAyMjkwKVxuICAgICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDE1XSwgMjIsIDEyMzY1MzUzMjkpXG5cbiAgICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNSwgLTE2NTc5NjUxMClcbiAgICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpXG4gICAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNCwgNjQzNzE3NzEzKVxuICAgICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaV0sIDIwLCAtMzczODk3MzAyKVxuICAgICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKVxuICAgICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDEwXSwgOSwgMzgwMTYwODMpXG4gICAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSlcbiAgICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpXG4gICAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgOV0sIDUsIDU2ODQ0NjQzOClcbiAgICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxNF0sIDksIC0xMDE5ODAzNjkwKVxuICAgICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSlcbiAgICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA4XSwgMjAsIDExNjM1MzE1MDEpXG4gICAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMTNdLCA1LCAtMTQ0NDY4MTQ2NylcbiAgICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KVxuICAgICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNCwgMTczNTMyODQ3MylcbiAgICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyAxMl0sIDIwLCAtMTkyNjYwNzczNClcblxuICAgICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA0LCAtMzc4NTU4KVxuICAgICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpXG4gICAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNiwgMTgzOTAzMDU2MilcbiAgICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxNF0sIDIzLCAtMzUzMDk1NTYpXG4gICAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKVxuICAgICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDRdLCAxMSwgMTI3Mjg5MzM1MylcbiAgICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTYsIC0xNTU0OTc2MzIpXG4gICAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApXG4gICAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMTNdLCA0LCA2ODEyNzkxNzQpXG4gICAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpXSwgMTEsIC0zNTg1MzcyMjIpXG4gICAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KVxuICAgICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDZdLCAyMywgNzYwMjkxODkpXG4gICAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgOV0sIDQsIC02NDAzNjQ0ODcpXG4gICAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSlcbiAgICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE2LCA1MzA3NDI1MjApXG4gICAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMl0sIDIzLCAtOTk1MzM4NjUxKVxuXG4gICAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpXSwgNiwgLTE5ODYzMDg0NClcbiAgICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpXG4gICAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNSwgLTE0MTYzNTQ5MDUpXG4gICAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgNV0sIDIxLCAtNTc0MzQwNTUpXG4gICAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKVxuICAgICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDNdLCAxMCwgLTE4OTQ5ODY2MDYpXG4gICAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNSwgLTEwNTE1MjMpXG4gICAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSlcbiAgICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNiwgMTg3MzMxMzM1OSlcbiAgICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxNV0sIDEwLCAtMzA2MTE3NDQpXG4gICAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MClcbiAgICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxM10sIDIxLCAxMzA5MTUxNjQ5KVxuICAgICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA2LCAtMTQ1NTIzMDcwKVxuICAgICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KVxuICAgICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNSwgNzE4Nzg3MjU5KVxuICAgICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDldLCAyMSwgLTM0MzQ4NTU1MSlcblxuICAgICAgYSA9IHNhZmVBZGQoYSwgb2xkYSlcbiAgICAgIGIgPSBzYWZlQWRkKGIsIG9sZGIpXG4gICAgICBjID0gc2FmZUFkZChjLCBvbGRjKVxuICAgICAgZCA9IHNhZmVBZGQoZCwgb2xkZClcbiAgICB9XG4gICAgcmV0dXJuIFthLCBiLCBjLCBkXVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhIHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGlucHV0IE1ENSBBcnJheVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBNRDUgc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiBiaW5sMnJzdHIoaW5wdXQpIHtcbiAgICB2YXIgaVxuICAgIHZhciBvdXRwdXQgPSAnJ1xuICAgIHZhciBsZW5ndGgzMiA9IGlucHV0Lmxlbmd0aCAqIDMyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDMyOyBpICs9IDgpIHtcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnB1dFtpID4+IDVdID4+PiBpICUgMzIpICYgMHhmZilcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dFxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAgICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBSYXcgaW5wdXQgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBBcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gICAqL1xuICBmdW5jdGlvbiByc3RyMmJpbmwoaW5wdXQpIHtcbiAgICB2YXIgaVxuICAgIHZhciBvdXRwdXQgPSBbXVxuICAgIG91dHB1dFsoaW5wdXQubGVuZ3RoID4+IDIpIC0gMV0gPSB1bmRlZmluZWRcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBvdXRwdXRbaV0gPSAwXG4gICAgfVxuICAgIHZhciBsZW5ndGg4ID0gaW5wdXQubGVuZ3RoICogOFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg4OyBpICs9IDgpIHtcbiAgICAgIG91dHB1dFtpID4+IDVdIHw9IChpbnB1dC5jaGFyQ29kZUF0KGkgLyA4KSAmIDB4ZmYpIDw8IGkgJSAzMlxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYSByYXcgc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzIElucHV0IHN0cmluZ1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSYXcgTUQ1IHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gcnN0ck1ENShzKSB7XG4gICAgcmV0dXJuIGJpbmwycnN0cihiaW5sTUQ1KHJzdHIyYmlubChzKSwgcy5sZW5ndGggKiA4KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBITUFDLU1ENSBvZiBhIGtleSBhbmQgc29tZSBkYXRhIChyYXcgc3RyaW5ncylcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBITUFDIGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YSBSYXcgaW5wdXQgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJhdyBNRDUgc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiByc3RySE1BQ01ENShrZXksIGRhdGEpIHtcbiAgICB2YXIgaVxuICAgIHZhciBia2V5ID0gcnN0cjJiaW5sKGtleSlcbiAgICB2YXIgaXBhZCA9IFtdXG4gICAgdmFyIG9wYWQgPSBbXVxuICAgIHZhciBoYXNoXG4gICAgaXBhZFsxNV0gPSBvcGFkWzE1XSA9IHVuZGVmaW5lZFxuICAgIGlmIChia2V5Lmxlbmd0aCA+IDE2KSB7XG4gICAgICBia2V5ID0gYmlubE1ENShia2V5LCBrZXkubGVuZ3RoICogOClcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIGlwYWRbaV0gPSBia2V5W2ldIF4gMHgzNjM2MzYzNlxuICAgICAgb3BhZFtpXSA9IGJrZXlbaV0gXiAweDVjNWM1YzVjXG4gICAgfVxuICAgIGhhc2ggPSBiaW5sTUQ1KGlwYWQuY29uY2F0KHJzdHIyYmlubChkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogOClcbiAgICByZXR1cm4gYmlubDJyc3RyKGJpbmxNRDUob3BhZC5jb25jYXQoaGFzaCksIDUxMiArIDEyOCkpXG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYSBoZXggc3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBSYXcgaW5wdXQgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEhleCBlbmNvZGVkIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gcnN0cjJoZXgoaW5wdXQpIHtcbiAgICB2YXIgaGV4VGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gICAgdmFyIG91dHB1dCA9ICcnXG4gICAgdmFyIHhcbiAgICB2YXIgaVxuICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgeCA9IGlucHV0LmNoYXJDb2RlQXQoaSlcbiAgICAgIG91dHB1dCArPSBoZXhUYWIuY2hhckF0KCh4ID4+PiA0KSAmIDB4MGYpICsgaGV4VGFiLmNoYXJBdCh4ICYgMHgwZilcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dFxuICB9XG5cbiAgLyoqXG4gICAqIEVuY29kZSBhIHN0cmluZyBhcyBVVEYtOFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgSW5wdXQgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFVURjggc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiBzdHIycnN0clVURjgoaW5wdXQpIHtcbiAgICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGVzIGlucHV0IHN0cmluZyBhcyByYXcgTUQ1IHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcyBJbnB1dCBzdHJpbmdcbiAgICogQHJldHVybnMge3N0cmluZ30gUmF3IE1ENSBzdHJpbmdcbiAgICovXG4gIGZ1bmN0aW9uIHJhd01ENShzKSB7XG4gICAgcmV0dXJuIHJzdHJNRDUoc3RyMnJzdHJVVEY4KHMpKVxuICB9XG4gIC8qKlxuICAgKiBFbmNvZGVzIGlucHV0IHN0cmluZyBhcyBIZXggZW5jb2RlZCBzdHJpbmdcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgSW5wdXQgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IEhleCBlbmNvZGVkIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gaGV4TUQ1KHMpIHtcbiAgICByZXR1cm4gcnN0cjJoZXgocmF3TUQ1KHMpKVxuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSByYXcgSE1BQy1NRDUgZm9yIHRoZSBnaXZlbiBrZXkgYW5kIGRhdGFcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGsgSE1BQyBrZXlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGQgSW5wdXQgc3RyaW5nXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJhdyBNRDUgc3RyaW5nXG4gICAqL1xuICBmdW5jdGlvbiByYXdITUFDTUQ1KGssIGQpIHtcbiAgICByZXR1cm4gcnN0ckhNQUNNRDUoc3RyMnJzdHJVVEY4KGspLCBzdHIycnN0clVURjgoZCkpXG4gIH1cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIEhleCBlbmNvZGVkIEhNQUMtTUQ1IGZvciB0aGUgZ2l2ZW4ga2V5IGFuZCBkYXRhXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrIEhNQUMga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkIElucHV0IHN0cmluZ1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSYXcgTUQ1IHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gaGV4SE1BQ01ENShrLCBkKSB7XG4gICAgcmV0dXJuIHJzdHIyaGV4KHJhd0hNQUNNRDUoaywgZCkpXG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBNRDUgdmFsdWUgZm9yIGEgZ2l2ZW4gc3RyaW5nLlxuICAgKiBJZiBhIGtleSBpcyBwcm92aWRlZCwgY2FsY3VsYXRlcyB0aGUgSE1BQy1NRDUgdmFsdWUuXG4gICAqIFJldHVybnMgYSBIZXggZW5jb2RlZCBzdHJpbmcgdW5sZXNzIHRoZSByYXcgYXJndW1lbnQgaXMgZ2l2ZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgSW5wdXQgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBITUFDIGtleVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyYXddIFJhdyBvdXRwdXQgc3dpdGNoXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IE1ENSBvdXRwdXRcbiAgICovXG4gIGZ1bmN0aW9uIG1kNShzdHJpbmcsIGtleSwgcmF3KSB7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIGlmICghcmF3KSB7XG4gICAgICAgIHJldHVybiBoZXhNRDUoc3RyaW5nKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJhd01ENShzdHJpbmcpXG4gICAgfVxuICAgIGlmICghcmF3KSB7XG4gICAgICByZXR1cm4gaGV4SE1BQ01ENShrZXksIHN0cmluZylcbiAgICB9XG4gICAgcmV0dXJuIHJhd0hNQUNNRDUoa2V5LCBzdHJpbmcpXG4gIH1cblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtZDVcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtZDVcbiAgfSBlbHNlIHtcbiAgICAkLm1kNSA9IG1kNVxuICB9XG59KSh0aGlzKVxuIiwiLyoqXHJcbiAqIENvbW1vbiB1dGlsaXRpZXNcclxuICogQG1vZHVsZSBnbE1hdHJpeFxyXG4gKi9cbi8vIENvbmZpZ3VyYXRpb24gQ29uc3RhbnRzXG5leHBvcnQgdmFyIEVQU0lMT04gPSAwLjAwMDAwMTtcbmV4cG9ydCB2YXIgQVJSQVlfVFlQRSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gRmxvYXQzMkFycmF5IDogQXJyYXk7XG5leHBvcnQgdmFyIFJBTkRPTSA9IE1hdGgucmFuZG9tO1xuLyoqXHJcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheUNvbnN0cnVjdG9yIHwgQXJyYXlDb25zdHJ1Y3Rvcn0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldE1hdHJpeEFycmF5VHlwZSh0eXBlKSB7XG4gIEFSUkFZX1RZUEUgPSB0eXBlO1xufVxudmFyIGRlZ3JlZSA9IE1hdGguUEkgLyAxODA7XG4vKipcclxuICogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIEFuZ2xlIGluIERlZ3JlZXNcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b1JhZGlhbihhKSB7XG4gIHJldHVybiBhICogZGVncmVlO1xufVxuLyoqXHJcbiAqIFRlc3RzIHdoZXRoZXIgb3Igbm90IHRoZSBhcmd1bWVudHMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHZhbHVlLCB3aXRoaW4gYW4gYWJzb2x1dGVcclxuICogb3IgcmVsYXRpdmUgdG9sZXJhbmNlIG9mIGdsTWF0cml4LkVQU0lMT04gKGFuIGFic29sdXRlIHRvbGVyYW5jZSBpcyB1c2VkIGZvciB2YWx1ZXMgbGVzc1xyXG4gKiB0aGFuIG9yIGVxdWFsIHRvIDEuMCwgYW5kIGEgcmVsYXRpdmUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIGxhcmdlciB2YWx1ZXMpXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBhIFRoZSBmaXJzdCBudW1iZXIgdG8gdGVzdC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgVGhlIHNlY29uZCBudW1iZXIgdG8gdGVzdC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG51bWJlcnMgYXJlIGFwcHJveGltYXRlbHkgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICByZXR1cm4gTWF0aC5hYnMoYSAtIGIpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEpLCBNYXRoLmFicyhiKSk7XG59XG5pZiAoIU1hdGguaHlwb3QpIE1hdGguaHlwb3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB5ID0gMCxcbiAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB5ICs9IGFyZ3VtZW50c1tpXSAqIGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIHJldHVybiBNYXRoLnNxcnQoeSk7XG59OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuaW1wb3J0ICogYXMgbWF0MiBmcm9tIFwiLi9tYXQyLmpzXCI7XG5pbXBvcnQgKiBhcyBtYXQyZCBmcm9tIFwiLi9tYXQyZC5qc1wiO1xuaW1wb3J0ICogYXMgbWF0MyBmcm9tIFwiLi9tYXQzLmpzXCI7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gXCIuL21hdDQuanNcIjtcbmltcG9ydCAqIGFzIHF1YXQgZnJvbSBcIi4vcXVhdC5qc1wiO1xuaW1wb3J0ICogYXMgcXVhdDIgZnJvbSBcIi4vcXVhdDIuanNcIjtcbmltcG9ydCAqIGFzIHZlYzIgZnJvbSBcIi4vdmVjMi5qc1wiO1xuaW1wb3J0ICogYXMgdmVjMyBmcm9tIFwiLi92ZWMzLmpzXCI7XG5pbXBvcnQgKiBhcyB2ZWM0IGZyb20gXCIuL3ZlYzQuanNcIjtcbmV4cG9ydCB7IGdsTWF0cml4LCBtYXQyLCBtYXQyZCwgbWF0MywgbWF0NCwgcXVhdCwgcXVhdDIsIHZlYzIsIHZlYzMsIHZlYzQgfTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiAyeDIgTWF0cml4XHJcbiAqIEBtb2R1bGUgbWF0MlxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuXG4gIG91dFswXSA9IDE7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIG1hdHJpeCB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0MiB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0IEEgbmV3IDJ4MiBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZVxuICAvLyBzb21lIHZhbHVlc1xuICBpZiAob3V0ID09PSBhKSB7XG4gICAgdmFyIGExID0gYVsxXTtcbiAgICBvdXRbMV0gPSBhWzJdO1xuICAgIG91dFsyXSA9IGExO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsyXTtcbiAgICBvdXRbMl0gPSBhWzFdO1xuICAgIG91dFszXSA9IGFbM107XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICB2YXIgZGV0ID0gYTAgKiBhMyAtIGEyICogYTE7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYTMgKiBkZXQ7XG4gIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgb3V0WzJdID0gLWEyICogZGV0O1xuICBvdXRbM10gPSBhMCAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgdmFyIGEwID0gYVswXTtcbiAgb3V0WzBdID0gYVszXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV07XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gbWF0MidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQyIGJ5IHRoZSBnaXZlbiBhbmdsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBhMCAqIGMgKyBhMiAqIHM7XG4gIG91dFsxXSA9IGExICogYyArIGEzICogcztcbiAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgb3V0WzNdID0gYTEgKiAtcyArIGEzICogYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgdjAgPSB2WzBdLFxuICAgICAgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMCAqIHYwO1xuICBvdXRbMV0gPSBhMSAqIHYwO1xuICBvdXRbMl0gPSBhMiAqIHYxO1xuICBvdXRbM10gPSBhMyAqIHYxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDIucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IGM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0Mi5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwibWF0MihcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdKTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gRCB0aGUgZGlhZ29uYWwgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBVIHRoZSB1cHBlciB0cmlhbmd1bGFyIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIExEVShMLCBELCBVLCBhKSB7XG4gIExbMl0gPSBhWzJdIC8gYVswXTtcbiAgVVswXSA9IGFbMF07XG4gIFVbMV0gPSBhWzFdO1xuICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdO1xuICByZXR1cm4gW0wsIEQsIFVdO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSk7XG59XG4vKipcclxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDIncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiAyeDMgTWF0cml4XHJcbiAqIEBtb2R1bGUgbWF0MmRcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIEEgbWF0MmQgY29udGFpbnMgc2l4IGVsZW1lbnRzIGRlZmluZWQgYXM6XHJcbiAqIDxwcmU+XHJcbiAqIFthLCBiLFxyXG4gKiAgYywgZCxcclxuICogIHR4LCB0eV1cclxuICogPC9wcmU+XHJcbiAqIFRoaXMgaXMgYSBzaG9ydCBmb3JtIGZvciB0aGUgM3gzIG1hdHJpeDpcclxuICogPHByZT5cclxuICogW2EsIGIsIDAsXHJcbiAqICBjLCBkLCAwLFxyXG4gKiAgdHgsIHR5LCAxXVxyXG4gKiA8L3ByZT5cclxuICogVGhlIGxhc3QgY29sdW1uIGlzIGlnbm9yZWQgc28gdGhlIGFycmF5IGlzIHNob3J0ZXIgYW5kIG9wZXJhdGlvbnMgYXJlIGZhc3Rlci5cclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJkXHJcbiAqXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MmQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIG1hdHJpeCB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MmQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQyZCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtYXQyZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIENvbXBvbmVudCBCIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eCBDb21wb25lbnQgVFggKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gQSBuZXcgbWF0MmRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gIG91dFswXSA9IGE7XG4gIG91dFsxXSA9IGI7XG4gIG91dFsyXSA9IGM7XG4gIG91dFszXSA9IGQ7XG4gIG91dFs0XSA9IHR4O1xuICBvdXRbNV0gPSB0eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyZCB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBDb21wb25lbnQgQSAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gZCBDb21wb25lbnQgRCAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgb3V0WzBdID0gYTtcbiAgb3V0WzFdID0gYjtcbiAgb3V0WzJdID0gYztcbiAgb3V0WzNdID0gZDtcbiAgb3V0WzRdID0gdHg7XG4gIG91dFs1XSA9IHR5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYWEgPSBhWzBdLFxuICAgICAgYWIgPSBhWzFdLFxuICAgICAgYWMgPSBhWzJdLFxuICAgICAgYWQgPSBhWzNdO1xuICB2YXIgYXR4ID0gYVs0XSxcbiAgICAgIGF0eSA9IGFbNV07XG4gIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBhZCAqIGRldDtcbiAgb3V0WzFdID0gLWFiICogZGV0O1xuICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gIG91dFszXSA9IGFhICogZGV0O1xuICBvdXRbNF0gPSAoYWMgKiBhdHkgLSBhZCAqIGF0eCkgKiBkZXQ7XG4gIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJkXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzFdICogYVsyXTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQyZCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdO1xuICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgb3V0WzFdID0gYTEgKiBiMCArIGEzICogYjE7XG4gIG91dFsyXSA9IGEwICogYjIgKyBhMiAqIGIzO1xuICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgb3V0WzRdID0gYTAgKiBiNCArIGEyICogYjUgKyBhNDtcbiAgb3V0WzVdID0gYTEgKiBiNCArIGEzICogYjUgKyBhNTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0MmQgYnkgdGhlIGdpdmVuIGFuZ2xlXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGEwICogYyArIGEyICogcztcbiAgb3V0WzFdID0gYTEgKiBjICsgYTMgKiBzO1xuICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICBvdXRbNF0gPSBhNDtcbiAgb3V0WzVdID0gYTU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICoqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV07XG4gIHZhciB2MCA9IHZbMF0sXG4gICAgICB2MSA9IHZbMV07XG4gIG91dFswXSA9IGEwICogdjA7XG4gIG91dFsxXSA9IGExICogdjA7XG4gIG91dFsyXSA9IGEyICogdjE7XG4gIG91dFszXSA9IGEzICogdjE7XG4gIG91dFs0XSA9IGE0O1xuICBvdXRbNV0gPSBhNTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2xhdGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IHRoZSB2ZWMyIHRvIHRyYW5zbGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIHYwID0gdlswXSxcbiAgICAgIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTA7XG4gIG91dFsxXSA9IGExO1xuICBvdXRbMl0gPSBhMjtcbiAgb3V0WzNdID0gYTM7XG4gIG91dFs0XSA9IGEwICogdjAgKyBhMiAqIHYxICsgYTQ7XG4gIG91dFs1XSA9IGExICogdjAgKyBhMyAqIHYxICsgYTU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDJkLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSBjO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyZC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gdlsxXTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDJkLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSB2WzBdO1xuICBvdXRbNV0gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcIm1hdDJkKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJkXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5oeXBvdChhWzBdLCBhWzFdLCBhWzJdLCBhWzNdLCBhWzRdLCBhWzVdLCAxKTtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQyZCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQyZCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiAzeDMgTWF0cml4XHJcbiAqIEBtb2R1bGUgbWF0M1xyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgICB0aGUgc291cmNlIDR4NCBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXQ0KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzRdO1xuICBvdXRbNF0gPSBhWzVdO1xuICBvdXRbNV0gPSBhWzZdO1xuICBvdXRbNl0gPSBhWzhdO1xuICBvdXRbN10gPSBhWzldO1xuICBvdXRbOF0gPSBhWzEwXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOSk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDMgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0MyB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHJldHVybnMge21hdDN9IEEgbmV3IG1hdDNcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMTA7XG4gIG91dFs0XSA9IG0xMTtcbiAgb3V0WzVdID0gbTEyO1xuICBvdXRbNl0gPSBtMjA7XG4gIG91dFs3XSA9IG0yMTtcbiAgb3V0WzhdID0gbTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDMgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMTA7XG4gIG91dFs0XSA9IG0xMTtcbiAgb3V0WzVdID0gbTEyO1xuICBvdXRbNl0gPSBtMjA7XG4gIG91dFs3XSA9IG0yMTtcbiAgb3V0WzhdID0gbTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMTIgPSBhWzVdO1xuICAgIG91dFsxXSA9IGFbM107XG4gICAgb3V0WzJdID0gYVs2XTtcbiAgICBvdXRbM10gPSBhMDE7XG4gICAgb3V0WzVdID0gYVs3XTtcbiAgICBvdXRbNl0gPSBhMDI7XG4gICAgb3V0WzddID0gYTEyO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVszXTtcbiAgICBvdXRbMl0gPSBhWzZdO1xuICAgIG91dFszXSA9IGFbMV07XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzddO1xuICAgIG91dFs2XSA9IGFbMl07XG4gICAgb3V0WzddID0gYVs1XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICB2YXIgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxO1xuICB2YXIgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMDtcbiAgdmFyIGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMDsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHZhciBkZXQgPSBhMDAgKiBiMDEgKyBhMDEgKiBiMTEgKyBhMDIgKiBiMjE7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYjAxICogZGV0O1xuICBvdXRbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMTIgKiBhMDEgLSBhMDIgKiBhMTEpICogZGV0O1xuICBvdXRbM10gPSBiMTEgKiBkZXQ7XG4gIG91dFs0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0O1xuICBvdXRbNV0gPSAoLWExMiAqIGEwMCArIGEwMiAqIGExMCkgKiBkZXQ7XG4gIG91dFs2XSA9IGIyMSAqIGRldDtcbiAgb3V0WzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0O1xuICBvdXRbOF0gPSAoYTExICogYTAwIC0gYTAxICogYTEwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIG91dFswXSA9IGExMSAqIGEyMiAtIGExMiAqIGEyMTtcbiAgb3V0WzFdID0gYTAyICogYTIxIC0gYTAxICogYTIyO1xuICBvdXRbMl0gPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIG91dFszXSA9IGExMiAqIGEyMCAtIGExMCAqIGEyMjtcbiAgb3V0WzRdID0gYTAwICogYTIyIC0gYTAyICogYTIwO1xuICBvdXRbNV0gPSBhMDIgKiBhMTAgLSBhMDAgKiBhMTI7XG4gIG91dFs2XSA9IGExMCAqIGEyMSAtIGExMSAqIGEyMDtcbiAgb3V0WzddID0gYTAxICogYTIwIC0gYTAwICogYTIxO1xuICBvdXRbOF0gPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIHJldHVybiBhMDAgKiAoYTIyICogYTExIC0gYTEyICogYTIxKSArIGEwMSAqICgtYTIyICogYTEwICsgYTEyICogYTIwKSArIGEwMiAqIChhMjEgKiBhMTAgLSBhMTEgKiBhMjApO1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICB2YXIgYjAwID0gYlswXSxcbiAgICAgIGIwMSA9IGJbMV0sXG4gICAgICBiMDIgPSBiWzJdO1xuICB2YXIgYjEwID0gYlszXSxcbiAgICAgIGIxMSA9IGJbNF0sXG4gICAgICBiMTIgPSBiWzVdO1xuICB2YXIgYjIwID0gYls2XSxcbiAgICAgIGIyMSA9IGJbN10sXG4gICAgICBiMjIgPSBiWzhdO1xuICBvdXRbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgb3V0WzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gIG91dFs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuICBvdXRbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gIG91dFs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zbGF0ZSBhIG1hdDMgYnkgdGhlIGdpdmVuIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV0sXG4gICAgICBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF0sXG4gICAgICB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdO1xuICBvdXRbMF0gPSBhMDA7XG4gIG91dFsxXSA9IGEwMTtcbiAgb3V0WzJdID0gYTAyO1xuICBvdXRbM10gPSBhMTA7XG4gIG91dFs0XSA9IGExMTtcbiAgb3V0WzVdID0gYTEyO1xuICBvdXRbNl0gPSB4ICogYTAwICsgeSAqIGExMCArIGEyMDtcbiAgb3V0WzddID0geCAqIGEwMSArIHkgKiBhMTEgKyBhMjE7XG4gIG91dFs4XSA9IHggKiBhMDIgKyB5ICogYTEyICsgYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQzIGJ5IHRoZSBnaXZlbiBhbmdsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV0sXG4gICAgICBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF0sXG4gICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjICogYTAwICsgcyAqIGExMDtcbiAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gIG91dFsyXSA9IGMgKiBhMDIgKyBzICogYTEyO1xuICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgb3V0WzRdID0gYyAqIGExMSAtIHMgKiBhMDE7XG4gIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuICBvdXRbNl0gPSBhMjA7XG4gIG91dFs3XSA9IGEyMTtcbiAgb3V0WzhdID0gYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICoqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdO1xuICBvdXRbMF0gPSB4ICogYVswXTtcbiAgb3V0WzFdID0geCAqIGFbMV07XG4gIG91dFsyXSA9IHggKiBhWzJdO1xuICBvdXRbM10gPSB5ICogYVszXTtcbiAgb3V0WzRdID0geSAqIGFbNF07XG4gIG91dFs1XSA9IHkgKiBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICBvdXRbOF0gPSBhWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDMuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQzLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSB2WzBdO1xuICBvdXRbN10gPSB2WzFdO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDMucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gLXM7XG4gIG91dFs0XSA9IGM7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0My5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gdlsxXTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBmcm9tIGEgbWF0MmQgaW50byBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJkfSBhIHRoZSBtYXRyaXggdG8gY29weVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXQyZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gYVsyXTtcbiAgb3V0WzRdID0gYVszXTtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gYVs0XTtcbiAgb3V0WzddID0gYVs1XTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGEgM3gzIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cclxuICpcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHl4ID0geSAqIHgyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB6eCA9IHogKiB4MjtcbiAgdmFyIHp5ID0geiAqIHkyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbM10gPSB5eCAtIHd6O1xuICBvdXRbNl0gPSB6eCArIHd5O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbNF0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzddID0genkgLSB3eDtcbiAgb3V0WzJdID0genggLSB3eTtcbiAgb3V0WzVdID0genkgKyB3eDtcbiAgb3V0WzhdID0gMSAtIHh4IC0geXk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBhIDN4MyBub3JtYWwgbWF0cml4ICh0cmFuc3Bvc2UgaW52ZXJzZSkgZnJvbSB0aGUgNHg0IG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIE1hdDQgdG8gZGVyaXZlIHRoZSBub3JtYWwgbWF0cml4IGZyb21cclxuICpcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbEZyb21NYXQ0KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgdmFyIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgdmFyIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMDtcbiAgdmFyIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMDtcbiAgdmFyIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgdmFyIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMTtcbiAgdmFyIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMjtcbiAgdmFyIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgdmFyIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMDtcbiAgdmFyIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMDtcbiAgdmFyIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgdmFyIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMTtcbiAgdmFyIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHZhciBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsxXSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICBvdXRbMl0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgb3V0WzNdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFs0XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzZdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gIG91dFs3XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICBvdXRbOF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSAyRCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggV2lkdGggb2YgeW91ciBnbCBjb250ZXh0XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgSGVpZ2h0IG9mIGdsIGNvbnRleHRcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2plY3Rpb24ob3V0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIG91dFswXSA9IDIgLyB3aWR0aDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gLTIgLyBoZWlnaHQ7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IC0xO1xuICBvdXRbN10gPSAxO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJtYXQzKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIiwgXCIgKyBhWzhdICsgXCIpXCI7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgdGhlIG1hdHJpeCB0byBjYWxjdWxhdGUgRnJvYmVuaXVzIG5vcm0gb2ZcclxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9iKGEpIHtcbiAgcmV0dXJuIE1hdGguaHlwb3QoYVswXSwgYVsxXSwgYVsyXSwgYVszXSwgYVs0XSwgYVs1XSwgYVs2XSwgYVs3XSwgYVs4XSk7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyBtYXRyaXggYiBmcm9tIG1hdHJpeCBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MydzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XSAqIHNjYWxlO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XSAqIHNjYWxlO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XSAqIHNjYWxlO1xuICBvdXRbN10gPSBhWzddICsgYls3XSAqIHNjYWxlO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJiBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgYVs4XSA9PT0gYls4XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XSxcbiAgICAgIGE2ID0gYVs2XSxcbiAgICAgIGE3ID0gYVs3XSxcbiAgICAgIGE4ID0gYVs4XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXSxcbiAgICAgIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XSxcbiAgICAgIGI2ID0gYls2XSxcbiAgICAgIGI3ID0gYls3XSxcbiAgICAgIGI4ID0gYls4XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJiBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiYgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0My5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXHJcbiAqIDR4NCBNYXRyaXg8YnI+Rm9ybWF0OiBjb2x1bW4tbWFqb3IsIHdoZW4gdHlwZWQgb3V0IGl0IGxvb2tzIGxpa2Ugcm93LW1ham9yPGJyPlRoZSBtYXRyaWNlcyBhcmUgYmVpbmcgcG9zdCBtdWx0aXBsaWVkLlxyXG4gKiBAbW9kdWxlIG1hdDRcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDRcclxuICpcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgb3V0WzldID0gYVs5XTtcbiAgb3V0WzEwXSA9IGFbMTBdO1xuICBvdXRbMTFdID0gYVsxMV07XG4gIG91dFsxMl0gPSBhWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdO1xuICBvdXRbMTRdID0gYVsxNF07XG4gIG91dFsxNV0gPSBhWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0NCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gQSBuZXcgbWF0NFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMobTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQ0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMyBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEzIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDMgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjAgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMSBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAxIHBvc2l0aW9uIChpbmRleCA5KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIyIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDIgcG9zaXRpb24gKGluZGV4IDEwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIzIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDMgcG9zaXRpb24gKGluZGV4IDExKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMwIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDAgcG9zaXRpb24gKGluZGV4IDEyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMxIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDEgcG9zaXRpb24gKGluZGV4IDEzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMyIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDIgcG9zaXRpb24gKGluZGV4IDE0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTMzIENvbXBvbmVudCBpbiBjb2x1bW4gMywgcm93IDMgcG9zaXRpb24gKGluZGV4IDE1KVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTAzLCBtMTAsIG0xMSwgbTEyLCBtMTMsIG0yMCwgbTIxLCBtMjIsIG0yMywgbTMwLCBtMzEsIG0zMiwgbTMzKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMDI7XG4gIG91dFszXSA9IG0wMztcbiAgb3V0WzRdID0gbTEwO1xuICBvdXRbNV0gPSBtMTE7XG4gIG91dFs2XSA9IG0xMjtcbiAgb3V0WzddID0gbTEzO1xuICBvdXRbOF0gPSBtMjA7XG4gIG91dFs5XSA9IG0yMTtcbiAgb3V0WzEwXSA9IG0yMjtcbiAgb3V0WzExXSA9IG0yMztcbiAgb3V0WzEyXSA9IG0zMDtcbiAgb3V0WzEzXSA9IG0zMTtcbiAgb3V0WzE0XSA9IG0zMjtcbiAgb3V0WzE1XSA9IG0zMztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXTtcbiAgICB2YXIgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcbiAgICB2YXIgYTIzID0gYVsxMV07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGEwMTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGEwMjtcbiAgICBvdXRbOV0gPSBhMTI7XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhMDM7XG4gICAgb3V0WzEzXSA9IGExMztcbiAgICBvdXRbMTRdID0gYTIzO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVs0XTtcbiAgICBvdXRbMl0gPSBhWzhdO1xuICAgIG91dFszXSA9IGFbMTJdO1xuICAgIG91dFs0XSA9IGFbMV07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzldO1xuICAgIG91dFs3XSA9IGFbMTNdO1xuICAgIG91dFs4XSA9IGFbMl07XG4gICAgb3V0WzldID0gYVs2XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTRdO1xuICAgIG91dFsxMl0gPSBhWzNdO1xuICAgIG91dFsxM10gPSBhWzddO1xuICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICBvdXRbMF0gPSBhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMik7XG4gIG91dFsxXSA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgb3V0WzJdID0gYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpO1xuICBvdXRbM10gPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs0XSA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgb3V0WzVdID0gYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpO1xuICBvdXRbNl0gPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gIG91dFs3XSA9IGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKTtcbiAgb3V0WzhdID0gYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpO1xuICBvdXRbOV0gPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gIG91dFsxMF0gPSBhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSk7XG4gIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gIG91dFsxM10gPSBhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSk7XG4gIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gIG91dFsxNV0gPSBhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0c1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTsgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG5cbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgb3V0WzBdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzNdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls0XTtcbiAgYjEgPSBiWzVdO1xuICBiMiA9IGJbNl07XG4gIGIzID0gYls3XTtcbiAgb3V0WzRdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFs1XSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbNl0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzddID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIGIwID0gYls4XTtcbiAgYjEgPSBiWzldO1xuICBiMiA9IGJbMTBdO1xuICBiMyA9IGJbMTFdO1xuICBvdXRbOF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgb3V0WzldID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsxMF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzExXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbMTJdO1xuICBiMSA9IGJbMTNdO1xuICBiMiA9IGJbMTRdO1xuICBiMyA9IGJbMTVdO1xuICBvdXRbMTJdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFsxM10gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzE0XSA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyO1xuICBvdXRbMTVdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV0sXG4gICAgICB6ID0gdlsyXTtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gIH0gZWxzZSB7XG4gICAgYTAwID0gYVswXTtcbiAgICBhMDEgPSBhWzFdO1xuICAgIGEwMiA9IGFbMl07XG4gICAgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdO1xuICAgIGExMSA9IGFbNV07XG4gICAgYTEyID0gYVs2XTtcbiAgICBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07XG4gICAgYTIxID0gYVs5XTtcbiAgICBhMjIgPSBhWzEwXTtcbiAgICBhMjMgPSBhWzExXTtcbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcbiAgICBvdXRbM10gPSBhMDM7XG4gICAgb3V0WzRdID0gYTEwO1xuICAgIG91dFs1XSA9IGExMTtcbiAgICBvdXRbNl0gPSBhMTI7XG4gICAgb3V0WzddID0gYTEzO1xuICAgIG91dFs4XSA9IGEyMDtcbiAgICBvdXRbOV0gPSBhMjE7XG4gICAgb3V0WzEwXSA9IGEyMjtcbiAgICBvdXRbMTFdID0gYTIzO1xuICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIG5vdCB1c2luZyB2ZWN0b3JpemF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgeCA9IHZbMF0sXG4gICAgICB5ID0gdlsxXSxcbiAgICAgIHogPSB2WzJdO1xuICBvdXRbMF0gPSBhWzBdICogeDtcbiAgb3V0WzFdID0gYVsxXSAqIHg7XG4gIG91dFsyXSA9IGFbMl0gKiB4O1xuICBvdXRbM10gPSBhWzNdICogeDtcbiAgb3V0WzRdID0gYVs0XSAqIHk7XG4gIG91dFs1XSA9IGFbNV0gKiB5O1xuICBvdXRbNl0gPSBhWzZdICogeTtcbiAgb3V0WzddID0gYVs3XSAqIHk7XG4gIG91dFs4XSA9IGFbOF0gKiB6O1xuICBvdXRbOV0gPSBhWzldICogejtcbiAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgb3V0WzExXSA9IGFbMTFdICogejtcbiAgb3V0WzEyXSA9IGFbMTJdO1xuICBvdXRbMTNdID0gYVsxM107XG4gIG91dFsxNF0gPSBhWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIGdpdmVuIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcbiAgdmFyIGIwMCwgYjAxLCBiMDI7XG4gIHZhciBiMTAsIGIxMSwgYjEyO1xuICB2YXIgYjIwLCBiMjEsIGIyMjtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7XG4gIGEwMCA9IGFbMF07XG4gIGEwMSA9IGFbMV07XG4gIGEwMiA9IGFbMl07XG4gIGEwMyA9IGFbM107XG4gIGExMCA9IGFbNF07XG4gIGExMSA9IGFbNV07XG4gIGExMiA9IGFbNl07XG4gIGExMyA9IGFbN107XG4gIGEyMCA9IGFbOF07XG4gIGEyMSA9IGFbOV07XG4gIGEyMiA9IGFbMTBdO1xuICBhMjMgPSBhWzExXTsgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG5cbiAgYjAwID0geCAqIHggKiB0ICsgYztcbiAgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBiMTAgPSB4ICogeSAqIHQgLSB6ICogcztcbiAgYjExID0geSAqIHkgKiB0ICsgYztcbiAgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIGIyMCA9IHggKiB6ICogdCArIHkgKiBzO1xuICBiMjEgPSB5ICogeiAqIHQgLSB4ICogcztcbiAgYjIyID0geiAqIHogKiB0ICsgYzsgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGExMCA9IGFbNF07XG4gIHZhciBhMTEgPSBhWzVdO1xuICB2YXIgYTEyID0gYVs2XTtcbiAgdmFyIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdO1xuICB2YXIgYTIxID0gYVs5XTtcbiAgdmFyIGEyMiA9IGFbMTBdO1xuICB2YXIgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMjAgPSBhWzhdO1xuICB2YXIgYTIxID0gYVs5XTtcbiAgdmFyIGEyMiA9IGFbMTBdO1xuICB2YXIgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTAyID0gYVsyXTtcbiAgdmFyIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdO1xuICB2YXIgYTExID0gYVs1XTtcbiAgdmFyIGExMiA9IGFbNl07XG4gIHZhciBhMTMgPSBhWzddO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgb3V0WzFdID0gYTAxICogYyArIGExMSAqIHM7XG4gIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgb3V0WzRdID0gYTEwICogYyAtIGEwMCAqIHM7XG4gIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgb3V0WzddID0gYTEzICogYyAtIGEwMyAqIHM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gdlsxXTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IHZbMl07XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIHZhciB4ID0gYXhpc1swXSxcbiAgICAgIHkgPSBheGlzWzFdLFxuICAgICAgeiA9IGF4aXNbMl07XG4gIHZhciBsZW4gPSBNYXRoLmh5cG90KHgsIHksIHopO1xuICB2YXIgcywgYywgdDtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWFJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gcztcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gLXM7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVlSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBzO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtcztcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB2KSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gIG91dFsxXSA9IHh5ICsgd3o7XG4gIG91dFsyXSA9IHh6IC0gd3k7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHh5IC0gd3o7XG4gIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gIG91dFs2XSA9IHl6ICsgd3g7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHh6ICsgd3k7XG4gIG91dFs5XSA9IHl6IC0gd3g7XG4gIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGZyb20gYSBkdWFsIHF1YXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IE1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQyKG91dCwgYSkge1xuICB2YXIgdHJhbnNsYXRpb24gPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XTtcbiAgdmFyIG1hZ25pdHVkZSA9IGJ4ICogYnggKyBieSAqIGJ5ICsgYnogKiBieiArIGJ3ICogYnc7IC8vT25seSBzY2FsZSBpZiBpdCBtYWtlcyBzZW5zZVxuXG4gIGlmIChtYWduaXR1ZGUgPiAwKSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyIC8gbWFnbml0dWRlO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMiAvIG1hZ25pdHVkZTtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDIgLyBtYWduaXR1ZGU7XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNsYXRpb25bMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyO1xuICAgIHRyYW5zbGF0aW9uWzFdID0gKGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnopICogMjtcbiAgICB0cmFuc2xhdGlvblsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDI7XG4gIH1cblxuICBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIGEsIHRyYW5zbGF0aW9uKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3IgY29tcG9uZW50IG9mIGEgdHJhbnNmb3JtYXRpb25cclxuICogIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aCBmcm9tUm90YXRpb25UcmFuc2xhdGlvbixcclxuICogIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgdHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgdHJhbnNsYXRpb24gY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LCBtYXQpIHtcbiAgb3V0WzBdID0gbWF0WzEyXTtcbiAgb3V0WzFdID0gbWF0WzEzXTtcbiAgb3V0WzJdID0gbWF0WzE0XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxyXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVcclxuICogIHdpdGggYSBub3JtYWxpemVkIFF1YXRlcm5pb24gcGFyYW10ZXIsIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZVxyXG4gKiAgdGhlIHNhbWUgYXMgdGhlIHNjYWxpbmcgdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5TWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NhbGluZyhvdXQsIG1hdCkge1xuICB2YXIgbTExID0gbWF0WzBdO1xuICB2YXIgbTEyID0gbWF0WzFdO1xuICB2YXIgbTEzID0gbWF0WzJdO1xuICB2YXIgbTIxID0gbWF0WzRdO1xuICB2YXIgbTIyID0gbWF0WzVdO1xuICB2YXIgbTIzID0gbWF0WzZdO1xuICB2YXIgbTMxID0gbWF0WzhdO1xuICB2YXIgbTMyID0gbWF0WzldO1xuICB2YXIgbTMzID0gbWF0WzEwXTtcbiAgb3V0WzBdID0gTWF0aC5oeXBvdChtMTEsIG0xMiwgbTEzKTtcbiAgb3V0WzFdID0gTWF0aC5oeXBvdChtMjEsIG0yMiwgbTIzKTtcbiAgb3V0WzJdID0gTWF0aC5oeXBvdChtMzEsIG0zMiwgbTMzKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgcXVhdGVybmlvbiByZXByZXNlbnRpbmcgdGhlIHJvdGF0aW9uYWwgY29tcG9uZW50XHJcbiAqICBvZiBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC4gSWYgYSBtYXRyaXggaXMgYnVpbHQgd2l0aFxyXG4gKiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24sIHRoZSByZXR1cm5lZCBxdWF0ZXJuaW9uIHdpbGwgYmUgdGhlXHJcbiAqICBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIG9yaWdpbmFsbHkgc3VwcGxpZWQuXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IFF1YXRlcm5pb24gdG8gcmVjZWl2ZSB0aGUgcm90YXRpb24gY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtYXQgTWF0cml4IHRvIGJlIGRlY29tcG9zZWQgKGlucHV0KVxyXG4gKiBAcmV0dXJuIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3RhdGlvbihvdXQsIG1hdCkge1xuICB2YXIgc2NhbGluZyA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBnZXRTY2FsaW5nKHNjYWxpbmcsIG1hdCk7XG4gIHZhciBpczEgPSAxIC8gc2NhbGluZ1swXTtcbiAgdmFyIGlzMiA9IDEgLyBzY2FsaW5nWzFdO1xuICB2YXIgaXMzID0gMSAvIHNjYWxpbmdbMl07XG4gIHZhciBzbTExID0gbWF0WzBdICogaXMxO1xuICB2YXIgc20xMiA9IG1hdFsxXSAqIGlzMjtcbiAgdmFyIHNtMTMgPSBtYXRbMl0gKiBpczM7XG4gIHZhciBzbTIxID0gbWF0WzRdICogaXMxO1xuICB2YXIgc20yMiA9IG1hdFs1XSAqIGlzMjtcbiAgdmFyIHNtMjMgPSBtYXRbNl0gKiBpczM7XG4gIHZhciBzbTMxID0gbWF0WzhdICogaXMxO1xuICB2YXIgc20zMiA9IG1hdFs5XSAqIGlzMjtcbiAgdmFyIHNtMzMgPSBtYXRbMTBdICogaXMzO1xuICB2YXIgdHJhY2UgPSBzbTExICsgc20yMiArIHNtMzM7XG4gIHZhciBTID0gMDtcblxuICBpZiAodHJhY2UgPiAwKSB7XG4gICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgIG91dFszXSA9IDAuMjUgKiBTO1xuICAgIG91dFswXSA9IChzbTIzIC0gc20zMikgLyBTO1xuICAgIG91dFsxXSA9IChzbTMxIC0gc20xMykgLyBTO1xuICAgIG91dFsyXSA9IChzbTEyIC0gc20yMSkgLyBTO1xuICB9IGVsc2UgaWYgKHNtMTEgPiBzbTIyICYmIHNtMTEgPiBzbTMzKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTExIC0gc20yMiAtIHNtMzMpICogMjtcbiAgICBvdXRbM10gPSAoc20yMyAtIHNtMzIpIC8gUztcbiAgICBvdXRbMF0gPSAwLjI1ICogUztcbiAgICBvdXRbMV0gPSAoc20xMiArIHNtMjEpIC8gUztcbiAgICBvdXRbMl0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgfSBlbHNlIGlmIChzbTIyID4gc20zMykge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgc20yMiAtIHNtMTEgLSBzbTMzKSAqIDI7XG4gICAgb3V0WzNdID0gKHNtMzEgLSBzbTEzKSAvIFM7XG4gICAgb3V0WzBdID0gKHNtMTIgKyBzbTIxKSAvIFM7XG4gICAgb3V0WzFdID0gMC4yNSAqIFM7XG4gICAgb3V0WzJdID0gKHNtMjMgKyBzbTMyKSAvIFM7XG4gIH0gZWxzZSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBzbTMzIC0gc20xMSAtIHNtMjIpICogMjtcbiAgICBvdXRbM10gPSAoc20xMiAtIHNtMjEpIC8gUztcbiAgICBvdXRbMF0gPSAoc20zMSArIHNtMTMpIC8gUztcbiAgICBvdXRbMV0gPSAoc20yMyArIHNtMzIpIC8gUztcbiAgICBvdXRbMl0gPSAwLjI1ICogUztcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGVcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHMgU2NhbGluZyB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUob3V0LCBxLCB2LCBzKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIHZhciBzeCA9IHNbMF07XG4gIHZhciBzeSA9IHNbMV07XG4gIHZhciBzeiA9IHNbMl07XG4gIG91dFswXSA9ICgxIC0gKHl5ICsgenopKSAqIHN4O1xuICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgb3V0WzJdID0gKHh6IC0gd3kpICogc3g7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICBvdXRbNV0gPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgb3V0WzZdID0gKHl6ICsgd3gpICogc3k7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9ICh4eiArIHd5KSAqIHN6O1xuICBvdXRbOV0gPSAoeXogLSB3eCkgKiBzejtcbiAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiwgdmVjdG9yIHRyYW5zbGF0aW9uIGFuZCB2ZWN0b3Igc2NhbGUsIHJvdGF0aW5nIGFuZCBzY2FsaW5nIGFyb3VuZCB0aGUgZ2l2ZW4gb3JpZ2luXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBvcmlnaW4pO1xyXG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBuZWdhdGl2ZU9yaWdpbik7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gcyBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gbyBUaGUgb3JpZ2luIHZlY3RvciBhcm91bmQgd2hpY2ggdG8gc2NhbGUgYW5kIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbihvdXQsIHEsIHYsIHMsIG8pIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeHkgPSB4ICogeTI7XG4gIHZhciB4eiA9IHggKiB6MjtcbiAgdmFyIHl5ID0geSAqIHkyO1xuICB2YXIgeXogPSB5ICogejI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgdmFyIHN4ID0gc1swXTtcbiAgdmFyIHN5ID0gc1sxXTtcbiAgdmFyIHN6ID0gc1syXTtcbiAgdmFyIG94ID0gb1swXTtcbiAgdmFyIG95ID0gb1sxXTtcbiAgdmFyIG96ID0gb1syXTtcbiAgdmFyIG91dDAgPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgdmFyIG91dDEgPSAoeHkgKyB3eikgKiBzeDtcbiAgdmFyIG91dDIgPSAoeHogLSB3eSkgKiBzeDtcbiAgdmFyIG91dDQgPSAoeHkgLSB3eikgKiBzeTtcbiAgdmFyIG91dDUgPSAoMSAtICh4eCArIHp6KSkgKiBzeTtcbiAgdmFyIG91dDYgPSAoeXogKyB3eCkgKiBzeTtcbiAgdmFyIG91dDggPSAoeHogKyB3eSkgKiBzejtcbiAgdmFyIG91dDkgPSAoeXogLSB3eCkgKiBzejtcbiAgdmFyIG91dDEwID0gKDEgLSAoeHggKyB5eSkpICogc3o7XG4gIG91dFswXSA9IG91dDA7XG4gIG91dFsxXSA9IG91dDE7XG4gIG91dFsyXSA9IG91dDI7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IG91dDQ7XG4gIG91dFs1XSA9IG91dDU7XG4gIG91dFs2XSA9IG91dDY7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IG91dDg7XG4gIG91dFs5XSA9IG91dDk7XG4gIG91dFsxMF0gPSBvdXQxMDtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdICsgb3ggLSAob3V0MCAqIG94ICsgb3V0NCAqIG95ICsgb3V0OCAqIG96KTtcbiAgb3V0WzEzXSA9IHZbMV0gKyBveSAtIChvdXQxICogb3ggKyBvdXQ1ICogb3kgKyBvdXQ5ICogb3opO1xuICBvdXRbMTRdID0gdlsyXSArIG96IC0gKG91dDIgKiBveCArIG91dDYgKiBveSArIG91dDEwICogb3opO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGEgNHg0IG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgUXVhdGVybmlvbiB0byBjcmVhdGUgbWF0cml4IGZyb21cclxuICpcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHl4ID0geSAqIHgyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB6eCA9IHogKiB4MjtcbiAgdmFyIHp5ID0geiAqIHkyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICBvdXRbMV0gPSB5eCArIHd6O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB5eCAtIHd6O1xuICBvdXRbNV0gPSAxIC0geHggLSB6ejtcbiAgb3V0WzZdID0genkgKyB3eDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0genggKyB3eTtcbiAgb3V0WzldID0genkgLSB3eDtcbiAgb3V0WzEwXSA9IDEgLSB4eCAtIHl5O1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgZnJ1c3R1bSBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtOdW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJ1c3R1bShvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KTtcbiAgdmFyIHRiID0gMSAvICh0b3AgLSBib3R0b20pO1xuICB2YXIgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMF0gPSBuZWFyICogMiAqIHJsO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBuZWFyICogMiAqIHRiO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gIG91dFsxMV0gPSAtMTtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAqIDIgKiBuZjtcbiAgb3V0WzE1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzLlxyXG4gKiBQYXNzaW5nIG51bGwvdW5kZWZpbmVkL25vIHZhbHVlIGZvciBmYXIgd2lsbCBnZW5lcmF0ZSBpbmZpbml0ZSBwcm9qZWN0aW9uIG1hdHJpeC5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eSBWZXJ0aWNhbCBmaWVsZCBvZiB2aWV3IGluIHJhZGlhbnNcclxuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bSwgY2FuIGJlIG51bGwgb3IgSW5maW5pdHlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICBuZjtcbiAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gZjtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNV0gPSAwO1xuXG4gIGlmIChmYXIgIT0gbnVsbCAmJiBmYXIgIT09IEluZmluaXR5KSB7XG4gICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTRdID0gMiAqIGZhciAqIG5lYXIgKiBuZjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMTBdID0gLTE7XG4gICAgb3V0WzE0XSA9IC0yICogbmVhcjtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cclxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxyXG4gKiB3aXRoIHRoZSBzdGlsbCBleHBlcmllbWVudGFsIFdlYlZSIEFQSS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge09iamVjdH0gZm92IE9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiB1cERlZ3JlZXMsIGRvd25EZWdyZWVzLCBsZWZ0RGVncmVlcywgcmlnaHREZWdyZWVzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgdmFyIHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciBkb3duVGFuID0gTWF0aC50YW4oZm92LmRvd25EZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIGxlZnRUYW4gPSBNYXRoLnRhbihmb3YubGVmdERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pO1xuICB2YXIgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG4gIG91dFswXSA9IHhTY2FsZTtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIG91dFszXSA9IDAuMDtcbiAgb3V0WzRdID0gMC4wO1xuICBvdXRbNV0gPSB5U2NhbGU7XG4gIG91dFs2XSA9IDAuMDtcbiAgb3V0WzddID0gMC4wO1xuICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgb3V0WzldID0gKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjU7XG4gIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gIG91dFsxMV0gPSAtMS4wO1xuICBvdXRbMTJdID0gMC4wO1xuICBvdXRbMTNdID0gMC4wO1xuICBvdXRbMTRdID0gZmFyICogbmVhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzE1XSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG9ydGhvKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpO1xuICB2YXIgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAyICogbmY7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXMuXHJcbiAqIElmIHlvdSB3YW50IGEgbWF0cml4IHRoYXQgYWN0dWFsbHkgbWFrZXMgYW4gb2JqZWN0IGxvb2sgYXQgYW5vdGhlciBvYmplY3QsIHlvdSBzaG91bGQgdXNlIHRhcmdldFRvIGluc3RlYWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsb29rQXQob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbjtcbiAgdmFyIGV5ZXggPSBleWVbMF07XG4gIHZhciBleWV5ID0gZXllWzFdO1xuICB2YXIgZXlleiA9IGV5ZVsyXTtcbiAgdmFyIHVweCA9IHVwWzBdO1xuICB2YXIgdXB5ID0gdXBbMV07XG4gIHZhciB1cHogPSB1cFsyXTtcbiAgdmFyIGNlbnRlcnggPSBjZW50ZXJbMF07XG4gIHZhciBjZW50ZXJ5ID0gY2VudGVyWzFdO1xuICB2YXIgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgZ2xNYXRyaXguRVBTSUxPTiAmJiBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICByZXR1cm4gaWRlbnRpdHkob3V0KTtcbiAgfVxuXG4gIHowID0gZXlleCAtIGNlbnRlcng7XG4gIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gIHoyID0gZXlleiAtIGNlbnRlcno7XG4gIGxlbiA9IDEgLyBNYXRoLmh5cG90KHowLCB6MSwgejIpO1xuICB6MCAqPSBsZW47XG4gIHoxICo9IGxlbjtcbiAgejIgKj0gbGVuO1xuICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSBNYXRoLmh5cG90KHgwLCB4MSwgeDIpO1xuXG4gIGlmICghbGVuKSB7XG4gICAgeDAgPSAwO1xuICAgIHgxID0gMDtcbiAgICB4MiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG4gIGxlbiA9IE1hdGguaHlwb3QoeTAsIHkxLCB5Mik7XG5cbiAgaWYgKCFsZW4pIHtcbiAgICB5MCA9IDA7XG4gICAgeTEgPSAwO1xuICAgIHkyID0gMDtcbiAgfSBlbHNlIHtcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHkwICo9IGxlbjtcbiAgICB5MSAqPSBsZW47XG4gICAgeTIgKj0gbGVuO1xuICB9XG5cbiAgb3V0WzBdID0geDA7XG4gIG91dFsxXSA9IHkwO1xuICBvdXRbMl0gPSB6MDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0geDE7XG4gIG91dFs1XSA9IHkxO1xuICBvdXRbNl0gPSB6MTtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0geDI7XG4gIG91dFs5XSA9IHkyO1xuICBvdXRbMTBdID0gejI7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBtYXRyaXggdGhhdCBtYWtlcyBzb21ldGhpbmcgbG9vayBhdCBzb21ldGhpbmcgZWxzZS5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRhcmdldFRvKG91dCwgZXllLCB0YXJnZXQsIHVwKSB7XG4gIHZhciBleWV4ID0gZXllWzBdLFxuICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICB1cHggPSB1cFswXSxcbiAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgdXB6ID0gdXBbMl07XG4gIHZhciB6MCA9IGV5ZXggLSB0YXJnZXRbMF0sXG4gICAgICB6MSA9IGV5ZXkgLSB0YXJnZXRbMV0sXG4gICAgICB6MiA9IGV5ZXogLSB0YXJnZXRbMl07XG4gIHZhciBsZW4gPSB6MCAqIHowICsgejEgKiB6MSArIHoyICogejI7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG4gIH1cblxuICB2YXIgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxLFxuICAgICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyLFxuICAgICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSB4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDI7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgeDAgKj0gbGVuO1xuICAgIHgxICo9IGxlbjtcbiAgICB4MiAqPSBsZW47XG4gIH1cblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geDE7XG4gIG91dFsyXSA9IHgyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgb3V0WzVdID0gejIgKiB4MCAtIHowICogeDI7XG4gIG91dFs2XSA9IHowICogeDEgLSB6MSAqIHgwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6MDtcbiAgb3V0WzldID0gejE7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSBleWV4O1xuICBvdXRbMTNdID0gZXlleTtcbiAgb3V0WzE0XSA9IGV5ZXo7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gXCJtYXQ0KFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIiwgXCIgKyBhWzhdICsgXCIsIFwiICsgYVs5XSArIFwiLCBcIiArIGFbMTBdICsgXCIsIFwiICsgYVsxMV0gKyBcIiwgXCIgKyBhWzEyXSArIFwiLCBcIiArIGFbMTNdICsgXCIsIFwiICsgYVsxNF0gKyBcIiwgXCIgKyBhWzE1XSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQ0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLmh5cG90KGFbMF0sIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV0sIGFbNl0sIGFbN10sIGFbOF0sIGFbOV0sIGFbMTBdLCBhWzExXSwgYVsxMl0sIGFbMTNdLCBhWzE0XSwgYVsxNV0pO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl07XG4gIG91dFs3XSA9IGFbN10gKyBiWzddO1xuICBvdXRbOF0gPSBhWzhdICsgYls4XTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSArIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gKyBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSArIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gKyBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgb3V0WzNdID0gYVszXSAtIGJbM107XG4gIG91dFs0XSA9IGFbNF0gLSBiWzRdO1xuICBvdXRbNV0gPSBhWzVdIC0gYls1XTtcbiAgb3V0WzZdID0gYVs2XSAtIGJbNl07XG4gIG91dFs3XSA9IGFbN10gLSBiWzddO1xuICBvdXRbOF0gPSBhWzhdIC0gYls4XTtcbiAgb3V0WzldID0gYVs5XSAtIGJbOV07XG4gIG91dFsxMF0gPSBhWzEwXSAtIGJbMTBdO1xuICBvdXRbMTFdID0gYVsxMV0gLSBiWzExXTtcbiAgb3V0WzEyXSA9IGFbMTJdIC0gYlsxMl07XG4gIG91dFsxM10gPSBhWzEzXSAtIGJbMTNdO1xuICBvdXRbMTRdID0gYVsxNF0gLSBiWzE0XTtcbiAgb3V0WzE1XSA9IGFbMTVdIC0gYlsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbHkgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggYnkgYSBzY2FsYXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgb3V0WzhdID0gYVs4XSAqIGI7XG4gIG91dFs5XSA9IGFbOV0gKiBiO1xuICBvdXRbMTBdID0gYVsxMF0gKiBiO1xuICBvdXRbMTFdID0gYVsxMV0gKiBiO1xuICBvdXRbMTJdID0gYVsxMl0gKiBiO1xuICBvdXRbMTNdID0gYVsxM10gKiBiO1xuICBvdXRbMTRdID0gYVsxNF0gKiBiO1xuICBvdXRbMTVdID0gYVsxNV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDQncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl0gKiBzY2FsZTtcbiAgb3V0WzddID0gYVs3XSArIGJbN10gKiBzY2FsZTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF0gKiBzY2FsZTtcbiAgb3V0WzldID0gYVs5XSArIGJbOV0gKiBzY2FsZTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF0gKiBzY2FsZTtcbiAgb3V0WzExXSA9IGFbMTFdICsgYlsxMV0gKiBzY2FsZTtcbiAgb3V0WzEyXSA9IGFbMTJdICsgYlsxMl0gKiBzY2FsZTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM10gKiBzY2FsZTtcbiAgb3V0WzE0XSA9IGFbMTRdICsgYlsxNF0gKiBzY2FsZTtcbiAgb3V0WzE1XSA9IGFbMTVdICsgYlsxNV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF0gJiYgYVs5XSA9PT0gYls5XSAmJiBhWzEwXSA9PT0gYlsxMF0gJiYgYVsxMV0gPT09IGJbMTFdICYmIGFbMTJdID09PSBiWzEyXSAmJiBhWzEzXSA9PT0gYlsxM10gJiYgYVsxNF0gPT09IGJbMTRdICYmIGFbMTVdID09PSBiWzE1XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XSxcbiAgICAgIGE2ID0gYVs2XSxcbiAgICAgIGE3ID0gYVs3XTtcbiAgdmFyIGE4ID0gYVs4XSxcbiAgICAgIGE5ID0gYVs5XSxcbiAgICAgIGExMCA9IGFbMTBdLFxuICAgICAgYTExID0gYVsxMV07XG4gIHZhciBhMTIgPSBhWzEyXSxcbiAgICAgIGExMyA9IGFbMTNdLFxuICAgICAgYTE0ID0gYVsxNF0sXG4gICAgICBhMTUgPSBhWzE1XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgdmFyIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XSxcbiAgICAgIGI2ID0gYls2XSxcbiAgICAgIGI3ID0gYls3XTtcbiAgdmFyIGI4ID0gYls4XSxcbiAgICAgIGI5ID0gYls5XSxcbiAgICAgIGIxMCA9IGJbMTBdLFxuICAgICAgYjExID0gYlsxMV07XG4gIHZhciBiMTIgPSBiWzEyXSxcbiAgICAgIGIxMyA9IGJbMTNdLFxuICAgICAgYjE0ID0gYlsxNF0sXG4gICAgICBiMTUgPSBiWzE1XTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKSAmJiBNYXRoLmFicyhhNCAtIGI0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNCksIE1hdGguYWJzKGI0KSkgJiYgTWF0aC5hYnMoYTUgLSBiNSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTUpLCBNYXRoLmFicyhiNSkpICYmIE1hdGguYWJzKGE2IC0gYjYpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE2KSwgTWF0aC5hYnMoYjYpKSAmJiBNYXRoLmFicyhhNyAtIGI3KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNyksIE1hdGguYWJzKGI3KSkgJiYgTWF0aC5hYnMoYTggLSBiOCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTgpLCBNYXRoLmFicyhiOCkpICYmIE1hdGguYWJzKGE5IC0gYjkpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE5KSwgTWF0aC5hYnMoYjkpKSAmJiBNYXRoLmFicyhhMTAgLSBiMTApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMCksIE1hdGguYWJzKGIxMCkpICYmIE1hdGguYWJzKGExMSAtIGIxMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTExKSwgTWF0aC5hYnMoYjExKSkgJiYgTWF0aC5hYnMoYTEyIC0gYjEyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTIpLCBNYXRoLmFicyhiMTIpKSAmJiBNYXRoLmFicyhhMTMgLSBiMTMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMyksIE1hdGguYWJzKGIxMykpICYmIE1hdGguYWJzKGExNCAtIGIxNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTE0KSwgTWF0aC5hYnMoYjE0KSkgJiYgTWF0aC5hYnMoYTE1IC0gYjE1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTUpLCBNYXRoLmFicyhiMTUpKTtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbmltcG9ydCAqIGFzIG1hdDMgZnJvbSBcIi4vbWF0My5qc1wiO1xuaW1wb3J0ICogYXMgdmVjMyBmcm9tIFwiLi92ZWMzLmpzXCI7XG5pbXBvcnQgKiBhcyB2ZWM0IGZyb20gXCIuL3ZlYzQuanNcIjtcbi8qKlxyXG4gKiBRdWF0ZXJuaW9uXHJcbiAqIEBtb2R1bGUgcXVhdFxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgcXVhdFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICB9XG5cbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXHJcbiAqIHRoZW4gcmV0dXJucyBpdC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEF4aXNBbmdsZShvdXQsIGF4aXMsIHJhZCkge1xuICByYWQgPSByYWQgKiAwLjU7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgb3V0WzBdID0gcyAqIGF4aXNbMF07XG4gIG91dFsxXSA9IHMgKiBheGlzWzFdO1xuICBvdXRbMl0gPSBzICogYXhpc1syXTtcbiAgb3V0WzNdID0gTWF0aC5jb3MocmFkKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXRzIHRoZSByb3RhdGlvbiBheGlzIGFuZCBhbmdsZSBmb3IgYSBnaXZlblxyXG4gKiAgcXVhdGVybmlvbi4gSWYgYSBxdWF0ZXJuaW9uIGlzIGNyZWF0ZWQgd2l0aFxyXG4gKiAgc2V0QXhpc0FuZ2xlLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZVxyXG4gKiAgdmFsdWVzIGFzIHByb3ZpZGllZCBpbiB0aGUgb3JpZ2luYWwgcGFyYW1ldGVyIGxpc3RcclxuICogIE9SIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHZhbHVlcy5cclxuICogRXhhbXBsZTogVGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5IGF4aXMgWzAsIDAsIDFdIGFuZFxyXG4gKiAgYW5nbGUgLTkwIGlzIHRoZSBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIGZvcm1lZCBieVxyXG4gKiAgWzAsIDAsIDFdIGFuZCAyNzAuIFRoaXMgbWV0aG9kIGZhdm9ycyB0aGUgbGF0dGVyLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXRfYXhpcyAgVmVjdG9yIHJlY2VpdmluZyB0aGUgYXhpcyBvZiByb3RhdGlvblxyXG4gKiBAcGFyYW0gIHtSZWFkb25seVF1YXR9IHEgICAgIFF1YXRlcm5pb24gdG8gYmUgZGVjb21wb3NlZFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBBbmdsZSwgaW4gcmFkaWFucywgb2YgdGhlIHJvdGF0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXhpc0FuZ2xlKG91dF9heGlzLCBxKSB7XG4gIHZhciByYWQgPSBNYXRoLmFjb3MocVszXSkgKiAyLjA7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkIC8gMi4wKTtcblxuICBpZiAocyA+IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICBvdXRfYXhpc1swXSA9IHFbMF0gLyBzO1xuICAgIG91dF9heGlzWzFdID0gcVsxXSAvIHM7XG4gICAgb3V0X2F4aXNbMl0gPSBxWzJdIC8gcztcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBzIGlzIHplcm8sIHJldHVybiBhbnkgYXhpcyAobm8gcm90YXRpb24gLSBheGlzIGRvZXMgbm90IG1hdHRlcilcbiAgICBvdXRfYXhpc1swXSA9IDE7XG4gICAgb3V0X2F4aXNbMV0gPSAwO1xuICAgIG91dF9heGlzWzJdID0gMDtcbiAgfVxuXG4gIHJldHVybiByYWQ7XG59XG4vKipcclxuICogR2V0cyB0aGUgYW5ndWxhciBkaXN0YW5jZSBiZXR3ZWVuIHR3byB1bml0IHF1YXRlcm5pb25zXHJcbiAqXHJcbiAqIEBwYXJhbSAge1JlYWRvbmx5UXVhdH0gYSAgICAgT3JpZ2luIHVuaXQgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0gIHtSZWFkb25seVF1YXR9IGIgICAgIERlc3RpbmF0aW9uIHVuaXQgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBBbmdsZSwgaW4gcmFkaWFucywgYmV0d2VlbiB0aGUgdHdvIHF1YXRlcm5pb25zXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QW5nbGUoYSwgYikge1xuICB2YXIgZG90cHJvZHVjdCA9IGRvdChhLCBiKTtcbiAgcmV0dXJuIE1hdGguYWNvcygyICogZG90cHJvZHVjdCAqIGRvdHByb2R1Y3QgLSAxKTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl0sXG4gICAgICBidyA9IGJbM107XG4gIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBYIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ4ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gIG91dFsxXSA9IGF5ICogYncgKyBheiAqIGJ4O1xuICBvdXRbMl0gPSBheiAqIGJ3IC0gYXkgKiBieDtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ5ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ6ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYXggKiBidyArIGF5ICogYno7XG4gIG91dFsxXSA9IGF5ICogYncgLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBiejtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgVyBjb21wb25lbnQgb2YgYSBxdWF0IGZyb20gdGhlIFgsIFksIGFuZCBaIGNvbXBvbmVudHMuXHJcbiAqIEFzc3VtZXMgdGhhdCBxdWF0ZXJuaW9uIGlzIDEgdW5pdCBpbiBsZW5ndGguXHJcbiAqIEFueSBleGlzdGluZyBXIGNvbXBvbmVudCB3aWxsIGJlIGlnbm9yZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBXIGNvbXBvbmVudCBvZlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlVyhvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gTWF0aC5zcXJ0KE1hdGguYWJzKDEuMCAtIHggKiB4IC0geSAqIHkgLSB6ICogeikpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgZXhwb25lbnRpYWwgb2YgYSB1bml0IHF1YXRlcm5pb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSB0aGUgZXhwb25lbnRpYWwgb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cChvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXSxcbiAgICAgIHcgPSBhWzNdO1xuICB2YXIgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICB2YXIgZXQgPSBNYXRoLmV4cCh3KTtcbiAgdmFyIHMgPSByID4gMCA/IGV0ICogTWF0aC5zaW4ocikgLyByIDogMDtcbiAgb3V0WzBdID0geCAqIHM7XG4gIG91dFsxXSA9IHkgKiBzO1xuICBvdXRbMl0gPSB6ICogcztcbiAgb3V0WzNdID0gZXQgKiBNYXRoLmNvcyhyKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIGEgdW5pdCBxdWF0ZXJuaW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgcXVhdCB0byBjYWxjdWxhdGUgdGhlIGV4cG9uZW50aWFsIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsbihvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXSxcbiAgICAgIHcgPSBhWzNdO1xuICB2YXIgciA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICB2YXIgdCA9IHIgPiAwID8gTWF0aC5hdGFuMihyLCB3KSAvIHIgOiAwO1xuICBvdXRbMF0gPSB4ICogdDtcbiAgb3V0WzFdID0geSAqIHQ7XG4gIG91dFsyXSA9IHogKiB0O1xuICBvdXRbM10gPSAwLjUgKiBNYXRoLmxvZyh4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdyk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlIHRoZSBzY2FsYXIgcG93ZXIgb2YgYSB1bml0IHF1YXRlcm5pb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSB0aGUgZXhwb25lbnRpYWwgb2ZcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBxdWF0ZXJuaW9uIGJ5XHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBwb3cob3V0LCBhLCBiKSB7XG4gIGxuKG91dCwgYSk7XG4gIHNjYWxlKG91dCwgb3V0LCBiKTtcbiAgZXhwKG91dCwgb3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2xlcnAob3V0LCBhLCBiLCB0KSB7XG4gIC8vIGJlbmNobWFya3M6XG4gIC8vICAgIGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tc2xlcnAtaW1wbGVtZW50YXRpb25zXG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl0sXG4gICAgICBidyA9IGJbM107XG4gIHZhciBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTsgLy8gY2FsYyBjb3NpbmVcblxuICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7IC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxuXG4gIGlmIChjb3NvbSA8IDAuMCkge1xuICAgIGNvc29tID0gLWNvc29tO1xuICAgIGJ4ID0gLWJ4O1xuICAgIGJ5ID0gLWJ5O1xuICAgIGJ6ID0gLWJ6O1xuICAgIGJ3ID0gLWJ3O1xuICB9IC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHNcblxuXG4gIGlmICgxLjAgLSBjb3NvbSA+IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICBvbWVnYSA9IE1hdGguYWNvcyhjb3NvbSk7XG4gICAgc2lub20gPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICB9IGVsc2Uge1xuICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgcXVhdGVybmlvbnMgYXJlIHZlcnkgY2xvc2VcbiAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICBzY2FsZTEgPSB0O1xuICB9IC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcblxuXG4gIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHVuaXQgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQpIHtcbiAgLy8gSW1wbGVtZW50YXRpb24gb2YgaHR0cDovL3BsYW5uaW5nLmNzLnVpdWMuZWR1L25vZGUxOTguaHRtbFxuICAvLyBUT0RPOiBDYWxsaW5nIHJhbmRvbSAzIHRpbWVzIGlzIHByb2JhYmx5IG5vdCB0aGUgZmFzdGVzdCBzb2x1dGlvblxuICB2YXIgdTEgPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgdmFyIHUyID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIHZhciB1MyA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICB2YXIgc3FydDFNaW51c1UxID0gTWF0aC5zcXJ0KDEgLSB1MSk7XG4gIHZhciBzcXJ0VTEgPSBNYXRoLnNxcnQodTEpO1xuICBvdXRbMF0gPSBzcXJ0MU1pbnVzVTEgKiBNYXRoLnNpbigyLjAgKiBNYXRoLlBJICogdTIpO1xuICBvdXRbMV0gPSBzcXJ0MU1pbnVzVTEgKiBNYXRoLmNvcygyLjAgKiBNYXRoLlBJICogdTIpO1xuICBvdXRbMl0gPSBzcXJ0VTEgKiBNYXRoLnNpbigyLjAgKiBNYXRoLlBJICogdTMpO1xuICBvdXRbM10gPSBzcXJ0VTEgKiBNYXRoLmNvcygyLjAgKiBNYXRoLlBJICogdTMpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBkb3QgPSBhMCAqIGEwICsgYTEgKiBhMSArIGEyICogYTIgKyBhMyAqIGEzO1xuICB2YXIgaW52RG90ID0gZG90ID8gMS4wIC8gZG90IDogMDsgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICBvdXRbMF0gPSAtYTAgKiBpbnZEb3Q7XG4gIG91dFsxXSA9IC1hMSAqIGludkRvdDtcbiAgb3V0WzJdID0gLWEyICogaW52RG90O1xuICBvdXRbM10gPSBhMyAqIGludkRvdDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBxdWF0XHJcbiAqIElmIHRoZSBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdC5pbnZlcnNlIGFuZCBwcm9kdWNlcyB0aGUgc2FtZSByZXN1bHQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmp1Z2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxyXG4gKlxyXG4gKiBOT1RFOiBUaGUgcmVzdWx0YW50IHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIHlvdSBzaG91bGQgYmUgc3VyZVxyXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSByb3RhdGlvbiBtYXRyaXhcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0MyhvdXQsIG0pIHtcbiAgLy8gQWxnb3JpdGhtIGluIEtlbiBTaG9lbWFrZSdzIGFydGljbGUgaW4gMTk4NyBTSUdHUkFQSCBjb3Vyc2Ugbm90ZXNcbiAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXG4gIHZhciBmVHJhY2UgPSBtWzBdICsgbVs0XSArIG1bOF07XG4gIHZhciBmUm9vdDtcblxuICBpZiAoZlRyYWNlID4gMC4wKSB7XG4gICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMlxuICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEuMCk7IC8vIDJ3XG5cbiAgICBvdXRbM10gPSAwLjUgKiBmUm9vdDtcbiAgICBmUm9vdCA9IDAuNSAvIGZSb290OyAvLyAxLyg0dylcblxuICAgIG91dFswXSA9IChtWzVdIC0gbVs3XSkgKiBmUm9vdDtcbiAgICBvdXRbMV0gPSAobVs2XSAtIG1bMl0pICogZlJvb3Q7XG4gICAgb3V0WzJdID0gKG1bMV0gLSBtWzNdKSAqIGZSb290O1xuICB9IGVsc2Uge1xuICAgIC8vIHx3fCA8PSAxLzJcbiAgICB2YXIgaSA9IDA7XG4gICAgaWYgKG1bNF0gPiBtWzBdKSBpID0gMTtcbiAgICBpZiAobVs4XSA+IG1baSAqIDMgKyBpXSkgaSA9IDI7XG4gICAgdmFyIGogPSAoaSArIDEpICUgMztcbiAgICB2YXIgayA9IChpICsgMikgJSAzO1xuICAgIGZSb290ID0gTWF0aC5zcXJ0KG1baSAqIDMgKyBpXSAtIG1baiAqIDMgKyBqXSAtIG1bayAqIDMgKyBrXSArIDEuMCk7XG4gICAgb3V0W2ldID0gMC41ICogZlJvb3Q7XG4gICAgZlJvb3QgPSAwLjUgLyBmUm9vdDtcbiAgICBvdXRbM10gPSAobVtqICogMyArIGtdIC0gbVtrICogMyArIGpdKSAqIGZSb290O1xuICAgIG91dFtqXSA9IChtW2ogKiAzICsgaV0gKyBtW2kgKiAzICsgal0pICogZlJvb3Q7XG4gICAgb3V0W2tdID0gKG1bayAqIDMgKyBpXSArIG1baSAqIDMgKyBrXSkgKiBmUm9vdDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIHF1YXRlcm5pb24gZnJvbSB0aGUgZ2l2ZW4gZXVsZXIgYW5nbGUgeCwgeSwgei5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7eH0gQW5nbGUgdG8gcm90YXRlIGFyb3VuZCBYIGF4aXMgaW4gZGVncmVlcy5cclxuICogQHBhcmFtIHt5fSBBbmdsZSB0byByb3RhdGUgYXJvdW5kIFkgYXhpcyBpbiBkZWdyZWVzLlxyXG4gKiBAcGFyYW0ge3p9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWiBheGlzIGluIGRlZ3JlZXMuXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbUV1bGVyKG91dCwgeCwgeSwgeikge1xuICB2YXIgaGFsZlRvUmFkID0gMC41ICogTWF0aC5QSSAvIDE4MC4wO1xuICB4ICo9IGhhbGZUb1JhZDtcbiAgeSAqPSBoYWxmVG9SYWQ7XG4gIHogKj0gaGFsZlRvUmFkO1xuICB2YXIgc3ggPSBNYXRoLnNpbih4KTtcbiAgdmFyIGN4ID0gTWF0aC5jb3MoeCk7XG4gIHZhciBzeSA9IE1hdGguc2luKHkpO1xuICB2YXIgY3kgPSBNYXRoLmNvcyh5KTtcbiAgdmFyIHN6ID0gTWF0aC5zaW4oeik7XG4gIHZhciBjeiA9IE1hdGguY29zKHopO1xuICBvdXRbMF0gPSBzeCAqIGN5ICogY3ogLSBjeCAqIHN5ICogc3o7XG4gIG91dFsxXSA9IGN4ICogc3kgKiBjeiArIHN4ICogY3kgKiBzejtcbiAgb3V0WzJdID0gY3ggKiBjeSAqIHN6IC0gc3ggKiBzeSAqIGN6O1xuICBvdXRbM10gPSBjeCAqIGN5ICogY3ogKyBzeCAqIHN5ICogc3o7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHF1YXRlbmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwicXVhdChcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXRlcm5pb24gdG8gY2xvbmVcclxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGNsb25lID0gdmVjNC5jbG9uZTtcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBmcm9tVmFsdWVzID0gdmVjNC5mcm9tVmFsdWVzO1xuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBxdWF0IHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBjb3B5ID0gdmVjNC5jb3B5O1xuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc2V0ID0gdmVjNC5zZXQ7XG4vKipcclxuICogQWRkcyB0d28gcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgYWRkID0gdmVjNC5hZGQ7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Lm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzY2FsZSA9IHZlYzQuc2NhbGU7XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZG90ID0gdmVjNC5kb3Q7XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGxlcnAgPSB2ZWM0LmxlcnA7XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW5ndGggPSB2ZWM0Lmxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxdWFyZWRMZW5ndGggPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0LnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG5vcm1hbGl6ZSA9IHZlYzQubm9ybWFsaXplO1xuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IGEgVGhlIGZpcnN0IHF1YXRlcm5pb24uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIFRoZSBzZWNvbmQgcXVhdGVybmlvbi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgdmFyIGV4YWN0RXF1YWxzID0gdmVjNC5leGFjdEVxdWFscztcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBxdWF0ZXJuaW9ucyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCB2YXIgZXF1YWxzID0gdmVjNC5lcXVhbHM7XG4vKipcclxuICogU2V0cyBhIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IHRoZSBzaG9ydGVzdCByb3RhdGlvbiBmcm9tIG9uZVxyXG4gKiB2ZWN0b3IgdG8gYW5vdGhlci5cclxuICpcclxuICogQm90aCB2ZWN0b3JzIGFyZSBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb24uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBpbml0aWFsIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgZGVzdGluYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCB2YXIgcm90YXRpb25UbyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRtcHZlYzMgPSB2ZWMzLmNyZWF0ZSgpO1xuICB2YXIgeFVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDEsIDAsIDApO1xuICB2YXIgeVVuaXRWZWMzID0gdmVjMy5mcm9tVmFsdWVzKDAsIDEsIDApO1xuICByZXR1cm4gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBkb3QgPSB2ZWMzLmRvdChhLCBiKTtcblxuICAgIGlmIChkb3QgPCAtMC45OTk5OTkpIHtcbiAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgeFVuaXRWZWMzLCBhKTtcbiAgICAgIGlmICh2ZWMzLmxlbih0bXB2ZWMzKSA8IDAuMDAwMDAxKSB2ZWMzLmNyb3NzKHRtcHZlYzMsIHlVbml0VmVjMywgYSk7XG4gICAgICB2ZWMzLm5vcm1hbGl6ZSh0bXB2ZWMzLCB0bXB2ZWMzKTtcbiAgICAgIHNldEF4aXNBbmdsZShvdXQsIHRtcHZlYzMsIE1hdGguUEkpO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2UgaWYgKGRvdCA+IDAuOTk5OTk5KSB7XG4gICAgICBvdXRbMF0gPSAwO1xuICAgICAgb3V0WzFdID0gMDtcbiAgICAgIG91dFsyXSA9IDA7XG4gICAgICBvdXRbM10gPSAxO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCBhLCBiKTtcbiAgICAgIG91dFswXSA9IHRtcHZlYzNbMF07XG4gICAgICBvdXRbMV0gPSB0bXB2ZWMzWzFdO1xuICAgICAgb3V0WzJdID0gdG1wdmVjM1syXTtcbiAgICAgIG91dFszXSA9IDEgKyBkb3Q7XG4gICAgICByZXR1cm4gbm9ybWFsaXplKG91dCwgb3V0KTtcbiAgICB9XG4gIH07XG59KCk7XG4vKipcclxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gYyB0aGUgdGhpcmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gZCB0aGUgZm91cnRoIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxbGVycCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlbXAxID0gY3JlYXRlKCk7XG4gIHZhciB0ZW1wMiA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICAgIHNsZXJwKHRlbXAxLCBhLCBkLCB0KTtcbiAgICBzbGVycCh0ZW1wMiwgYiwgYywgdCk7XG4gICAgc2xlcnAob3V0LCB0ZW1wMSwgdGVtcDIsIDIgKiB0ICogKDEgLSB0KSk7XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcbn0oKTtcbi8qKlxyXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgcXVhdGVybmlvbiB3aXRoIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxyXG4gKiBheGVzLiBFYWNoIGF4aXMgaXMgYSB2ZWMzIGFuZCBpcyBleHBlY3RlZCB0byBiZSB1bml0IGxlbmd0aCBhbmRcclxuICogcGVycGVuZGljdWxhciB0byBhbGwgb3RoZXIgc3BlY2lmaWVkIGF4ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB2aWV3ICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgdmlld2luZyBkaXJlY3Rpb25cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHJpZ2h0IHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInJpZ2h0XCIgZGlyZWN0aW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB1cCAgICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJ1cFwiIGRpcmVjdGlvblxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgdmFyIHNldEF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtYXRyID0gbWF0My5jcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIHZpZXcsIHJpZ2h0LCB1cCkge1xuICAgIG1hdHJbMF0gPSByaWdodFswXTtcbiAgICBtYXRyWzNdID0gcmlnaHRbMV07XG4gICAgbWF0cls2XSA9IHJpZ2h0WzJdO1xuICAgIG1hdHJbMV0gPSB1cFswXTtcbiAgICBtYXRyWzRdID0gdXBbMV07XG4gICAgbWF0cls3XSA9IHVwWzJdO1xuICAgIG1hdHJbMl0gPSAtdmlld1swXTtcbiAgICBtYXRyWzVdID0gLXZpZXdbMV07XG4gICAgbWF0cls4XSA9IC12aWV3WzJdO1xuICAgIHJldHVybiBub3JtYWxpemUob3V0LCBmcm9tTWF0MyhvdXQsIG1hdHIpKTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbmltcG9ydCAqIGFzIHF1YXQgZnJvbSBcIi4vcXVhdC5qc1wiO1xuaW1wb3J0ICogYXMgbWF0NCBmcm9tIFwiLi9tYXQ0LmpzXCI7XG4vKipcclxuICogRHVhbCBRdWF0ZXJuaW9uPGJyPlxyXG4gKiBGb3JtYXQ6IFtyZWFsLCBkdWFsXTxicj5cclxuICogUXVhdGVybmlvbiBmb3JtYXQ6IFhZWlc8YnI+XHJcbiAqIE1ha2Ugc3VyZSB0byBoYXZlIG5vcm1hbGl6ZWQgZHVhbCBxdWF0ZXJuaW9ucywgb3RoZXJ3aXNlIHRoZSBmdW5jdGlvbnMgbWF5IG5vdCB3b3JrIGFzIGludGVuZGVkLjxicj5cclxuICogQG1vZHVsZSBxdWF0MlxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgZHVhbCBxdWF0XHJcbiAqXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gYSBuZXcgZHVhbCBxdWF0ZXJuaW9uIFtyZWFsIC0+IHJvdGF0aW9uLCBkdWFsIC0+IHRyYW5zbGF0aW9uXVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIGRxID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOCk7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgZHFbMF0gPSAwO1xuICAgIGRxWzFdID0gMDtcbiAgICBkcVsyXSA9IDA7XG4gICAgZHFbNF0gPSAwO1xuICAgIGRxWzVdID0gMDtcbiAgICBkcVs2XSA9IDA7XG4gICAgZHFbN10gPSAwO1xuICB9XG5cbiAgZHFbM10gPSAxO1xuICByZXR1cm4gZHE7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0ZXJuaW9uIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gbmV3IGR1YWwgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBkcSA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDgpO1xuICBkcVswXSA9IGFbMF07XG4gIGRxWzFdID0gYVsxXTtcbiAgZHFbMl0gPSBhWzJdO1xuICBkcVszXSA9IGFbM107XG4gIGRxWzRdID0gYVs0XTtcbiAgZHFbNV0gPSBhWzVdO1xuICBkcVs2XSA9IGFbNl07XG4gIGRxWzddID0gYVs3XTtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgZHVhbCBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geDEgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkxIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MSBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzEgVyBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgyIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MiBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejIgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcyIFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gbmV3IGR1YWwgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgxLCB5MSwgejEsIHcxLCB4MiwgeTIsIHoyLCB3Mikge1xuICB2YXIgZHEgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg4KTtcbiAgZHFbMF0gPSB4MTtcbiAgZHFbMV0gPSB5MTtcbiAgZHFbMl0gPSB6MTtcbiAgZHFbM10gPSB3MTtcbiAgZHFbNF0gPSB4MjtcbiAgZHFbNV0gPSB5MjtcbiAgZHFbNl0gPSB6MjtcbiAgZHFbN10gPSB3MjtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgZHVhbCBxdWF0IGZyb20gdGhlIGdpdmVuIHZhbHVlcyAocXVhdCBhbmQgdHJhbnNsYXRpb24pXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MSBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geTEgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHoxIFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3MSBXIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geDIgWCBjb21wb25lbnQgKHRyYW5zbGF0aW9uKVxyXG4gKiBAcGFyYW0ge051bWJlcn0geTIgWSBjb21wb25lbnQgKHRyYW5zbGF0aW9uKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gejIgWiBjb21wb25lbnQgKHRyYW5zbGF0aW9uKVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG5ldyBkdWFsIHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25WYWx1ZXMoeDEsIHkxLCB6MSwgdzEsIHgyLCB5MiwgejIpIHtcbiAgdmFyIGRxID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOCk7XG4gIGRxWzBdID0geDE7XG4gIGRxWzFdID0geTE7XG4gIGRxWzJdID0gejE7XG4gIGRxWzNdID0gdzE7XG4gIHZhciBheCA9IHgyICogMC41LFxuICAgICAgYXkgPSB5MiAqIDAuNSxcbiAgICAgIGF6ID0gejIgKiAwLjU7XG4gIGRxWzRdID0gYXggKiB3MSArIGF5ICogejEgLSBheiAqIHkxO1xuICBkcVs1XSA9IGF5ICogdzEgKyBheiAqIHgxIC0gYXggKiB6MTtcbiAgZHFbNl0gPSBheiAqIHcxICsgYXggKiB5MSAtIGF5ICogeDE7XG4gIGRxWzddID0gLWF4ICogeDEgLSBheSAqIHkxIC0gYXogKiB6MTtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkdWFsIHF1YXQgZnJvbSBhIHF1YXRlcm5pb24gYW5kIGEgdHJhbnNsYXRpb25cclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgYSBub3JtYWxpemVkIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHQgdHJhbmxhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge3F1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB0KSB7XG4gIHZhciBheCA9IHRbMF0gKiAwLjUsXG4gICAgICBheSA9IHRbMV0gKiAwLjUsXG4gICAgICBheiA9IHRbMl0gKiAwLjUsXG4gICAgICBieCA9IHFbMF0sXG4gICAgICBieSA9IHFbMV0sXG4gICAgICBieiA9IHFbMl0sXG4gICAgICBidyA9IHFbM107XG4gIG91dFswXSA9IGJ4O1xuICBvdXRbMV0gPSBieTtcbiAgb3V0WzJdID0gYno7XG4gIG91dFszXSA9IGJ3O1xuICBvdXRbNF0gPSBheCAqIGJ3ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFs1XSA9IGF5ICogYncgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzZdID0gYXogKiBidyArIGF4ICogYnkgLSBheSAqIGJ4O1xuICBvdXRbN10gPSAtYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkdWFsIHF1YXQgZnJvbSBhIHRyYW5zbGF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSB0IHRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB0KSB7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IHRbMF0gKiAwLjU7XG4gIG91dFs1XSA9IHRbMV0gKiAwLjU7XG4gIG91dFs2XSA9IHRbMl0gKiAwLjU7XG4gIG91dFs3XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIGR1YWwgcXVhdCBmcm9tIGEgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSB0aGUgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCBxKSB7XG4gIG91dFswXSA9IHFbMF07XG4gIG91dFsxXSA9IHFbMV07XG4gIG91dFsyXSA9IHFbMl07XG4gIG91dFszXSA9IHFbM107XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBkdWFsIHF1YXQgZnJvbSBhIG1hdHJpeCAoNHg0KVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0NH0gYSB0aGUgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gZHVhbCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21NYXQ0KG91dCwgYSkge1xuICAvL1RPRE8gT3B0aW1pemUgdGhpc1xuICB2YXIgb3V0ZXIgPSBxdWF0LmNyZWF0ZSgpO1xuICBtYXQ0LmdldFJvdGF0aW9uKG91dGVyLCBhKTtcbiAgdmFyIHQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgbWF0NC5nZXRUcmFuc2xhdGlvbih0LCBhKTtcbiAgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBvdXRlciwgdCk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIGR1YWwgcXVhdCB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIHNvdXJjZSBkdWFsIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBkdWFsIHF1YXQgdG8gdGhlIGlkZW50aXR5IGR1YWwgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDA7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgZHVhbCBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0geDEgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkxIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MSBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzEgVyBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgyIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MiBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejIgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcyIFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgxLCB5MSwgejEsIHcxLCB4MiwgeTIsIHoyLCB3Mikge1xuICBvdXRbMF0gPSB4MTtcbiAgb3V0WzFdID0geTE7XG4gIG91dFsyXSA9IHoxO1xuICBvdXRbM10gPSB3MTtcbiAgb3V0WzRdID0geDI7XG4gIG91dFs1XSA9IHkyO1xuICBvdXRbNl0gPSB6MjtcbiAgb3V0WzddID0gdzI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2V0cyB0aGUgcmVhbCBwYXJ0IG9mIGEgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSAge3F1YXR9IG91dCByZWFsIHBhcnRcclxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb25cclxuICogQHJldHVybiB7cXVhdH0gcmVhbCBwYXJ0XHJcbiAqL1xuXG5leHBvcnQgdmFyIGdldFJlYWwgPSBxdWF0LmNvcHk7XG4vKipcclxuICogR2V0cyB0aGUgZHVhbCBwYXJ0IG9mIGEgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSAge3F1YXR9IG91dCBkdWFsIHBhcnRcclxuICogQHBhcmFtICB7UmVhZG9ubHlRdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb25cclxuICogQHJldHVybiB7cXVhdH0gZHVhbCBwYXJ0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RHVhbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVs0XTtcbiAgb3V0WzFdID0gYVs1XTtcbiAgb3V0WzJdID0gYVs2XTtcbiAgb3V0WzNdID0gYVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIHJlYWwgY29tcG9uZW50IG9mIGEgZHVhbCBxdWF0IHRvIHRoZSBnaXZlbiBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgYSBxdWF0ZXJuaW9uIHJlcHJlc2VudGluZyB0aGUgcmVhbCBwYXJ0XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzZXRSZWFsID0gcXVhdC5jb3B5O1xuLyoqXHJcbiAqIFNldCB0aGUgZHVhbCBjb21wb25lbnQgb2YgYSBkdWFsIHF1YXQgdG8gdGhlIGdpdmVuIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdH0gcSBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSBkdWFsIHBhcnRcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0RHVhbChvdXQsIHEpIHtcbiAgb3V0WzRdID0gcVswXTtcbiAgb3V0WzVdID0gcVsxXTtcbiAgb3V0WzZdID0gcVsyXTtcbiAgb3V0WzddID0gcVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXRzIHRoZSB0cmFuc2xhdGlvbiBvZiBhIG5vcm1hbGl6ZWQgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSAge3ZlYzN9IG91dCB0cmFuc2xhdGlvblxyXG4gKiBAcGFyYW0gIHtSZWFkb25seVF1YXQyfSBhIER1YWwgUXVhdGVybmlvbiB0byBiZSBkZWNvbXBvc2VkXHJcbiAqIEByZXR1cm4ge3ZlYzN9IHRyYW5zbGF0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LCBhKSB7XG4gIHZhciBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN10sXG4gICAgICBieCA9IC1hWzBdLFxuICAgICAgYnkgPSAtYVsxXSxcbiAgICAgIGJ6ID0gLWFbMl0sXG4gICAgICBidyA9IGFbM107XG4gIG91dFswXSA9IChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5KSAqIDI7XG4gIG91dFsxXSA9IChheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6KSAqIDI7XG4gIG91dFsyXSA9IChheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4KSAqIDI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlcyBhIGR1YWwgcXVhdCBieSB0aGUgZ2l2ZW4gdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byB0cmFuc2xhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIGF4MSA9IGFbMF0sXG4gICAgICBheTEgPSBhWzFdLFxuICAgICAgYXoxID0gYVsyXSxcbiAgICAgIGF3MSA9IGFbM10sXG4gICAgICBieDEgPSB2WzBdICogMC41LFxuICAgICAgYnkxID0gdlsxXSAqIDAuNSxcbiAgICAgIGJ6MSA9IHZbMl0gKiAwLjUsXG4gICAgICBheDIgPSBhWzRdLFxuICAgICAgYXkyID0gYVs1XSxcbiAgICAgIGF6MiA9IGFbNl0sXG4gICAgICBhdzIgPSBhWzddO1xuICBvdXRbMF0gPSBheDE7XG4gIG91dFsxXSA9IGF5MTtcbiAgb3V0WzJdID0gYXoxO1xuICBvdXRbM10gPSBhdzE7XG4gIG91dFs0XSA9IGF3MSAqIGJ4MSArIGF5MSAqIGJ6MSAtIGF6MSAqIGJ5MSArIGF4MjtcbiAgb3V0WzVdID0gYXcxICogYnkxICsgYXoxICogYngxIC0gYXgxICogYnoxICsgYXkyO1xuICBvdXRbNl0gPSBhdzEgKiBiejEgKyBheDEgKiBieTEgLSBheTEgKiBieDEgKyBhejI7XG4gIG91dFs3XSA9IC1heDEgKiBieDEgLSBheTEgKiBieTEgLSBhejEgKiBiejEgKyBhdzI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBhcm91bmQgdGhlIFggYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgaG93IGZhciBzaG91bGQgdGhlIHJvdGF0aW9uIGJlXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYXgxID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSxcbiAgICAgIGF5MSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnosXG4gICAgICBhejEgPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LFxuICAgICAgYXcxID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcXVhdC5yb3RhdGVYKG91dCwgYSwgcmFkKTtcbiAgYnggPSBvdXRbMF07XG4gIGJ5ID0gb3V0WzFdO1xuICBieiA9IG91dFsyXTtcbiAgYncgPSBvdXRbM107XG4gIG91dFs0XSA9IGF4MSAqIGJ3ICsgYXcxICogYnggKyBheTEgKiBieiAtIGF6MSAqIGJ5O1xuICBvdXRbNV0gPSBheTEgKiBidyArIGF3MSAqIGJ5ICsgYXoxICogYnggLSBheDEgKiBiejtcbiAgb3V0WzZdID0gYXoxICogYncgKyBhdzEgKiBieiArIGF4MSAqIGJ5IC0gYXkxICogYng7XG4gIG91dFs3XSA9IGF3MSAqIGJ3IC0gYXgxICogYnggLSBheTEgKiBieSAtIGF6MSAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYXJvdW5kIHRoZSBZIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGhvdyBmYXIgc2hvdWxkIHRoZSByb3RhdGlvbiBiZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XSxcbiAgICAgIGF4MSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnksXG4gICAgICBheTEgPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6LFxuICAgICAgYXoxID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCxcbiAgICAgIGF3MSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHF1YXQucm90YXRlWShvdXQsIGEsIHJhZCk7XG4gIGJ4ID0gb3V0WzBdO1xuICBieSA9IG91dFsxXTtcbiAgYnogPSBvdXRbMl07XG4gIGJ3ID0gb3V0WzNdO1xuICBvdXRbNF0gPSBheDEgKiBidyArIGF3MSAqIGJ4ICsgYXkxICogYnogLSBhejEgKiBieTtcbiAgb3V0WzVdID0gYXkxICogYncgKyBhdzEgKiBieSArIGF6MSAqIGJ4IC0gYXgxICogYno7XG4gIG91dFs2XSA9IGF6MSAqIGJ3ICsgYXcxICogYnogKyBheDEgKiBieSAtIGF5MSAqIGJ4O1xuICBvdXRbN10gPSBhdzEgKiBidyAtIGF4MSAqIGJ4IC0gYXkxICogYnkgLSBhejEgKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGFyb3VuZCB0aGUgWiBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBob3cgZmFyIHNob3VsZCB0aGUgcm90YXRpb24gYmVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIHZhciBieCA9IC1hWzBdLFxuICAgICAgYnkgPSAtYVsxXSxcbiAgICAgIGJ6ID0gLWFbMl0sXG4gICAgICBidyA9IGFbM10sXG4gICAgICBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN10sXG4gICAgICBheDEgPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5LFxuICAgICAgYXkxID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieixcbiAgICAgIGF6MSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngsXG4gICAgICBhdzEgPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICBxdWF0LnJvdGF0ZVoob3V0LCBhLCByYWQpO1xuICBieCA9IG91dFswXTtcbiAgYnkgPSBvdXRbMV07XG4gIGJ6ID0gb3V0WzJdO1xuICBidyA9IG91dFszXTtcbiAgb3V0WzRdID0gYXgxICogYncgKyBhdzEgKiBieCArIGF5MSAqIGJ6IC0gYXoxICogYnk7XG4gIG91dFs1XSA9IGF5MSAqIGJ3ICsgYXcxICogYnkgKyBhejEgKiBieCAtIGF4MSAqIGJ6O1xuICBvdXRbNl0gPSBhejEgKiBidyArIGF3MSAqIGJ6ICsgYXgxICogYnkgLSBheTEgKiBieDtcbiAgb3V0WzddID0gYXcxICogYncgLSBheDEgKiBieCAtIGF5MSAqIGJ5IC0gYXoxICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBieSBhIGdpdmVuIHF1YXRlcm5pb24gKGEgKiBxKVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHF1YXRlcm5pb24gdG8gcm90YXRlIGJ5XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlQnlRdWF0QXBwZW5kKG91dCwgYSwgcSkge1xuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdLFxuICAgICAgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICBvdXRbMF0gPSBheCAqIHF3ICsgYXcgKiBxeCArIGF5ICogcXogLSBheiAqIHF5O1xuICBvdXRbMV0gPSBheSAqIHF3ICsgYXcgKiBxeSArIGF6ICogcXggLSBheCAqIHF6O1xuICBvdXRbMl0gPSBheiAqIHF3ICsgYXcgKiBxeiArIGF4ICogcXkgLSBheSAqIHF4O1xuICBvdXRbM10gPSBhdyAqIHF3IC0gYXggKiBxeCAtIGF5ICogcXkgLSBheiAqIHF6O1xuICBheCA9IGFbNF07XG4gIGF5ID0gYVs1XTtcbiAgYXogPSBhWzZdO1xuICBhdyA9IGFbN107XG4gIG91dFs0XSA9IGF4ICogcXcgKyBhdyAqIHF4ICsgYXkgKiBxeiAtIGF6ICogcXk7XG4gIG91dFs1XSA9IGF5ICogcXcgKyBhdyAqIHF5ICsgYXogKiBxeCAtIGF4ICogcXo7XG4gIG91dFs2XSA9IGF6ICogcXcgKyBhdyAqIHF6ICsgYXggKiBxeSAtIGF5ICogcXg7XG4gIG91dFs3XSA9IGF3ICogcXcgLSBheCAqIHF4IC0gYXkgKiBxeSAtIGF6ICogcXo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBieSBhIGdpdmVuIHF1YXRlcm5pb24gKHEgKiBhKVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXR9IHEgcXVhdGVybmlvbiB0byByb3RhdGUgYnlcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlQnlRdWF0UHJlcGVuZChvdXQsIHEsIGEpIHtcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXSxcbiAgICAgIGJ4ID0gYVswXSxcbiAgICAgIGJ5ID0gYVsxXSxcbiAgICAgIGJ6ID0gYVsyXSxcbiAgICAgIGJ3ID0gYVszXTtcbiAgb3V0WzBdID0gcXggKiBidyArIHF3ICogYnggKyBxeSAqIGJ6IC0gcXogKiBieTtcbiAgb3V0WzFdID0gcXkgKiBidyArIHF3ICogYnkgKyBxeiAqIGJ4IC0gcXggKiBiejtcbiAgb3V0WzJdID0gcXogKiBidyArIHF3ICogYnogKyBxeCAqIGJ5IC0gcXkgKiBieDtcbiAgb3V0WzNdID0gcXcgKiBidyAtIHF4ICogYnggLSBxeSAqIGJ5IC0gcXogKiBiejtcbiAgYnggPSBhWzRdO1xuICBieSA9IGFbNV07XG4gIGJ6ID0gYVs2XTtcbiAgYncgPSBhWzddO1xuICBvdXRbNF0gPSBxeCAqIGJ3ICsgcXcgKiBieCArIHF5ICogYnogLSBxeiAqIGJ5O1xuICBvdXRbNV0gPSBxeSAqIGJ3ICsgcXcgKiBieSArIHF6ICogYnggLSBxeCAqIGJ6O1xuICBvdXRbNl0gPSBxeiAqIGJ3ICsgcXcgKiBieiArIHF4ICogYnkgLSBxeSAqIGJ4O1xuICBvdXRbN10gPSBxdyAqIGJ3IC0gcXggKiBieCAtIHF5ICogYnkgLSBxeiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYXJvdW5kIGEgZ2l2ZW4gYXhpcy4gRG9lcyB0aGUgbm9ybWFsaXNhdGlvbiBhdXRvbWF0aWNhbGx5XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIGhvdyBmYXIgdGhlIHJvdGF0aW9uIHNob3VsZCBiZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZUFyb3VuZEF4aXMob3V0LCBhLCBheGlzLCByYWQpIHtcbiAgLy9TcGVjaWFsIGNhc2UgZm9yIHJhZCA9IDBcbiAgaWYgKE1hdGguYWJzKHJhZCkgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIGNvcHkob3V0LCBhKTtcbiAgfVxuXG4gIHZhciBheGlzTGVuZ3RoID0gTWF0aC5oeXBvdChheGlzWzBdLCBheGlzWzFdLCBheGlzWzJdKTtcbiAgcmFkID0gcmFkICogMC41O1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBieCA9IHMgKiBheGlzWzBdIC8gYXhpc0xlbmd0aDtcbiAgdmFyIGJ5ID0gcyAqIGF4aXNbMV0gLyBheGlzTGVuZ3RoO1xuICB2YXIgYnogPSBzICogYXhpc1syXSAvIGF4aXNMZW5ndGg7XG4gIHZhciBidyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBheDEgPSBhWzBdLFxuICAgICAgYXkxID0gYVsxXSxcbiAgICAgIGF6MSA9IGFbMl0sXG4gICAgICBhdzEgPSBhWzNdO1xuICBvdXRbMF0gPSBheDEgKiBidyArIGF3MSAqIGJ4ICsgYXkxICogYnogLSBhejEgKiBieTtcbiAgb3V0WzFdID0gYXkxICogYncgKyBhdzEgKiBieSArIGF6MSAqIGJ4IC0gYXgxICogYno7XG4gIG91dFsyXSA9IGF6MSAqIGJ3ICsgYXcxICogYnogKyBheDEgKiBieSAtIGF5MSAqIGJ4O1xuICBvdXRbM10gPSBhdzEgKiBidyAtIGF4MSAqIGJ4IC0gYXkxICogYnkgLSBhejEgKiBiejtcbiAgdmFyIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XTtcbiAgb3V0WzRdID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzVdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgb3V0WzZdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgb3V0WzddID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBkdWFsIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gZHVhbCBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBheDAgPSBhWzBdLFxuICAgICAgYXkwID0gYVsxXSxcbiAgICAgIGF6MCA9IGFbMl0sXG4gICAgICBhdzAgPSBhWzNdLFxuICAgICAgYngxID0gYls0XSxcbiAgICAgIGJ5MSA9IGJbNV0sXG4gICAgICBiejEgPSBiWzZdLFxuICAgICAgYncxID0gYls3XSxcbiAgICAgIGF4MSA9IGFbNF0sXG4gICAgICBheTEgPSBhWzVdLFxuICAgICAgYXoxID0gYVs2XSxcbiAgICAgIGF3MSA9IGFbN10sXG4gICAgICBieDAgPSBiWzBdLFxuICAgICAgYnkwID0gYlsxXSxcbiAgICAgIGJ6MCA9IGJbMl0sXG4gICAgICBidzAgPSBiWzNdO1xuICBvdXRbMF0gPSBheDAgKiBidzAgKyBhdzAgKiBieDAgKyBheTAgKiBiejAgLSBhejAgKiBieTA7XG4gIG91dFsxXSA9IGF5MCAqIGJ3MCArIGF3MCAqIGJ5MCArIGF6MCAqIGJ4MCAtIGF4MCAqIGJ6MDtcbiAgb3V0WzJdID0gYXowICogYncwICsgYXcwICogYnowICsgYXgwICogYnkwIC0gYXkwICogYngwO1xuICBvdXRbM10gPSBhdzAgKiBidzAgLSBheDAgKiBieDAgLSBheTAgKiBieTAgLSBhejAgKiBiejA7XG4gIG91dFs0XSA9IGF4MCAqIGJ3MSArIGF3MCAqIGJ4MSArIGF5MCAqIGJ6MSAtIGF6MCAqIGJ5MSArIGF4MSAqIGJ3MCArIGF3MSAqIGJ4MCArIGF5MSAqIGJ6MCAtIGF6MSAqIGJ5MDtcbiAgb3V0WzVdID0gYXkwICogYncxICsgYXcwICogYnkxICsgYXowICogYngxIC0gYXgwICogYnoxICsgYXkxICogYncwICsgYXcxICogYnkwICsgYXoxICogYngwIC0gYXgxICogYnowO1xuICBvdXRbNl0gPSBhejAgKiBidzEgKyBhdzAgKiBiejEgKyBheDAgKiBieTEgLSBheTAgKiBieDEgKyBhejEgKiBidzAgKyBhdzEgKiBiejAgKyBheDEgKiBieTAgLSBheTEgKiBieDA7XG4gIG91dFs3XSA9IGF3MCAqIGJ3MSAtIGF4MCAqIGJ4MSAtIGF5MCAqIGJ5MSAtIGF6MCAqIGJ6MSArIGF3MSAqIGJ3MCAtIGF4MSAqIGJ4MCAtIGF5MSAqIGJ5MCAtIGF6MSAqIGJ6MDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQyLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogU2NhbGVzIGEgZHVhbCBxdWF0IGJ5IGEgc2NhbGFyIG51bWJlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBkdWFsIHF1YXQgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBkdWFsIHF1YXQgYnlcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gZHVhbCBxdWF0J3MgKFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgcmVhbCBwYXJ0cylcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZG90ID0gcXVhdC5kb3Q7XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBkdWFsIHF1YXRzJ3NcclxuICogTk9URTogVGhlIHJlc3VsdGluZyBkdWFsIHF1YXRlcm5pb25zIHdvbid0IGFsd2F5cyBiZSBub3JtYWxpemVkIChUaGUgZXJyb3IgaXMgbW9zdCBub3RpY2VhYmxlIHdoZW4gdCA9IDAuNSlcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgbXQgPSAxIC0gdDtcbiAgaWYgKGRvdChhLCBiKSA8IDApIHQgPSAtdDtcbiAgb3V0WzBdID0gYVswXSAqIG10ICsgYlswXSAqIHQ7XG4gIG91dFsxXSA9IGFbMV0gKiBtdCArIGJbMV0gKiB0O1xuICBvdXRbMl0gPSBhWzJdICogbXQgKyBiWzJdICogdDtcbiAgb3V0WzNdID0gYVszXSAqIG10ICsgYlszXSAqIHQ7XG4gIG91dFs0XSA9IGFbNF0gKiBtdCArIGJbNF0gKiB0O1xuICBvdXRbNV0gPSBhWzVdICogbXQgKyBiWzVdICogdDtcbiAgb3V0WzZdID0gYVs2XSAqIG10ICsgYls2XSAqIHQ7XG4gIG91dFs3XSA9IGFbN10gKiBtdCArIGJbN10gKiB0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGludmVyc2Ugb2YgYSBkdWFsIHF1YXQuIElmIHRoZXkgYXJlIG5vcm1hbGl6ZWQsIGNvbmp1Z2F0ZSBpcyBjaGVhcGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICB2YXIgc3FsZW4gPSBzcXVhcmVkTGVuZ3RoKGEpO1xuICBvdXRbMF0gPSAtYVswXSAvIHNxbGVuO1xuICBvdXRbMV0gPSAtYVsxXSAvIHNxbGVuO1xuICBvdXRbMl0gPSAtYVsyXSAvIHNxbGVuO1xuICBvdXRbM10gPSBhWzNdIC8gc3FsZW47XG4gIG91dFs0XSA9IC1hWzRdIC8gc3FsZW47XG4gIG91dFs1XSA9IC1hWzVdIC8gc3FsZW47XG4gIG91dFs2XSA9IC1hWzZdIC8gc3FsZW47XG4gIG91dFs3XSA9IGFbN10gLyBzcWxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBkdWFsIHF1YXRcclxuICogSWYgdGhlIGR1YWwgcXVhdGVybmlvbiBpcyBub3JtYWxpemVkLCB0aGlzIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuIHF1YXQyLmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgcXVhdCB0byBjYWxjdWxhdGUgY29uanVnYXRlIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29uanVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSAtYVs0XTtcbiAgb3V0WzVdID0gLWFbNV07XG4gIG91dFs2XSA9IC1hWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIGR1YWwgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0IHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGxlbmd0aCA9IHF1YXQubGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdDIubGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbGVuID0gbGVuZ3RoO1xuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgZHVhbCBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBkdWFsIHF1YXQgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxdWFyZWRMZW5ndGggPSBxdWF0LnNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0Mi5zcXVhcmVkTGVuZ3RofVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyTGVuID0gc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSBkdWFsIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYSBkdWFsIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIG1hZ25pdHVkZSA9IHNxdWFyZWRMZW5ndGgoYSk7XG5cbiAgaWYgKG1hZ25pdHVkZSA+IDApIHtcbiAgICBtYWduaXR1ZGUgPSBNYXRoLnNxcnQobWFnbml0dWRlKTtcbiAgICB2YXIgYTAgPSBhWzBdIC8gbWFnbml0dWRlO1xuICAgIHZhciBhMSA9IGFbMV0gLyBtYWduaXR1ZGU7XG4gICAgdmFyIGEyID0gYVsyXSAvIG1hZ25pdHVkZTtcbiAgICB2YXIgYTMgPSBhWzNdIC8gbWFnbml0dWRlO1xuICAgIHZhciBiMCA9IGFbNF07XG4gICAgdmFyIGIxID0gYVs1XTtcbiAgICB2YXIgYjIgPSBhWzZdO1xuICAgIHZhciBiMyA9IGFbN107XG4gICAgdmFyIGFfZG90X2IgPSBhMCAqIGIwICsgYTEgKiBiMSArIGEyICogYjIgKyBhMyAqIGIzO1xuICAgIG91dFswXSA9IGEwO1xuICAgIG91dFsxXSA9IGExO1xuICAgIG91dFsyXSA9IGEyO1xuICAgIG91dFszXSA9IGEzO1xuICAgIG91dFs0XSA9IChiMCAtIGEwICogYV9kb3RfYikgLyBtYWduaXR1ZGU7XG4gICAgb3V0WzVdID0gKGIxIC0gYTEgKiBhX2RvdF9iKSAvIG1hZ25pdHVkZTtcbiAgICBvdXRbNl0gPSAoYjIgLSBhMiAqIGFfZG90X2IpIC8gbWFnbml0dWRlO1xuICAgIG91dFs3XSA9IChiMyAtIGEzICogYV9kb3RfYikgLyBtYWduaXR1ZGU7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBkdWFsIHF1YXRlbmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgZHVhbCBxdWF0ZXJuaW9uIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGR1YWwgcXVhdFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInF1YXQyKFwiICsgYVswXSArIFwiLCBcIiArIGFbMV0gKyBcIiwgXCIgKyBhWzJdICsgXCIsIFwiICsgYVszXSArIFwiLCBcIiArIGFbNF0gKyBcIiwgXCIgKyBhWzVdICsgXCIsIFwiICsgYVs2XSArIFwiLCBcIiArIGFbN10gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBkdWFsIHF1YXRlcm5pb25zIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBhIHRoZSBmaXJzdCBkdWFsIHF1YXRlcm5pb24uXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0Mn0gYiB0aGUgc2Vjb25kIGR1YWwgcXVhdGVybmlvbi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGR1YWwgcXVhdGVybmlvbnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGR1YWwgcXVhdGVybmlvbnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5UXVhdDJ9IGEgdGhlIGZpcnN0IGR1YWwgcXVhdC5cclxuICogQHBhcmFtIHtSZWFkb25seVF1YXQyfSBiIHRoZSBzZWNvbmQgZHVhbCBxdWF0LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGUgZHVhbCBxdWF0cyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdLFxuICAgICAgYTYgPSBhWzZdLFxuICAgICAgYTcgPSBhWzddO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdLFxuICAgICAgYjYgPSBiWzZdLFxuICAgICAgYjcgPSBiWzddO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiYgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKTtcbn0iLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiAyIERpbWVuc2lvbmFsIFZlY3RvclxyXG4gKiBAbW9kdWxlIHZlYzJcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMyXHJcbiAqXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHkpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBEaXZpZGVzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjZWlsXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB2ZWN0b3IgdG8gZmxvb3JcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byByb3VuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMyJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICB5ID0gYlsxXSAtIGFbMV07XG4gIHJldHVybiB4ICogeCArIHkgKiB5O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHk7XG59XG4vKipcclxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIGludmVydFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHZlY3RvciB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXTtcbn1cbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXHJcbiAqIE5vdGUgdGhhdCB0aGUgY3Jvc3MgcHJvZHVjdCBtdXN0IGJ5IGRlZmluaXRpb24gcHJvZHVjZSBhIDNEIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIG91dFswXSA9IG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7XG4gIHZhciByID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyLjAgKiBNYXRoLlBJO1xuICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xuICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyZChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXHJcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQzfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVszXSAqIHkgKyBtWzZdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XHJcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzAnXHJcbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzVdICogeSArIG1bMTNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZSBhIDJEIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzJcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgVGhlIHZlYzIgcG9pbnQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMyfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uIGluIHJhZGlhbnNcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIGIsIHJhZCkge1xuICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIHZhciBwMCA9IGFbMF0gLSBiWzBdLFxuICAgICAgcDEgPSBhWzFdIC0gYlsxXSxcbiAgICAgIHNpbkMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgY29zQyA9IE1hdGguY29zKHJhZCk7IC8vcGVyZm9ybSByb3RhdGlvbiBhbmQgdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblxuICBvdXRbMF0gPSBwMCAqIGNvc0MgLSBwMSAqIHNpbkMgKyBiWzBdO1xuICBvdXRbMV0gPSBwMCAqIHNpbkMgKyBwMSAqIGNvc0MgKyBiWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gMkQgdmVjdG9yc1xyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHZhciB4MSA9IGFbMF0sXG4gICAgICB5MSA9IGFbMV0sXG4gICAgICB4MiA9IGJbMF0sXG4gICAgICB5MiA9IGJbMV0sXG4gICAgICAvLyBtYWcgaXMgdGhlIHByb2R1Y3Qgb2YgdGhlIG1hZ25pdHVkZXMgb2YgYSBhbmQgYlxuICBtYWcgPSBNYXRoLnNxcnQoeDEgKiB4MSArIHkxICogeTEpICogTWF0aC5zcXJ0KHgyICogeDIgKyB5MiAqIHkyKSxcbiAgICAgIC8vIG1hZyAmJi4uIHNob3J0IGNpcmN1aXRzIGlmIG1hZyA9PSAwXG4gIGNvc2luZSA9IG1hZyAmJiAoeDEgKiB4MiArIHkxICogeTIpIC8gbWFnOyAvLyBNYXRoLm1pbihNYXRoLm1heChjb3NpbmUsIC0xKSwgMSkgY2xhbXBzIHRoZSBjb3NpbmUgYmV0d2VlbiAtMSBhbmQgMVxuXG4gIHJldHVybiBNYXRoLmFjb3MoTWF0aC5taW4oTWF0aC5tYXgoY29zaW5lLCAtMSksIDEpKTtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyIHRvIHplcm9cclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzJ9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzIoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiKVwiO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgZXhhY3RseSBoYXZlIHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGl2aWRlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZERpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZExlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuXG4gICAgaWYgKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDI7XG4gICAgfVxuXG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldO1xuICAgICAgdmVjWzFdID0gYVtpICsgMV07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiAzIERpbWVuc2lvbmFsIFZlY3RvclxyXG4gKiBAbW9kdWxlIHZlYzNcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXHJcbiAqXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHJldHVybiBNYXRoLmh5cG90KHgsIHksIHopO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeikge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHopIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJ0cmFjdChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICBvdXRbMl0gPSBhWzJdIC0gYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZChhWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeik7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWRMZW5ndGgoYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6O1xufVxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuXG4gIGlmIChsZW4gPiAwKSB7XG4gICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXTtcbiAgdmFyIGJ4ID0gYlswXSxcbiAgICAgIGJ5ID0gYlsxXSxcbiAgICAgIGJ6ID0gYlsyXTtcbiAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGMgdGhlIHRoaXJkIG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGhlcm1pdGUob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdDtcbiAgdmFyIGZhY3RvcjEgPSBmYWN0b3JUaW1lczIgKiAoMiAqIHQgLSAzKSArIDE7XG4gIHZhciBmYWN0b3IyID0gZmFjdG9yVGltZXMyICogKHQgLSAyKSArIHQ7XG4gIHZhciBmYWN0b3IzID0gZmFjdG9yVGltZXMyICogKHQgLSAxKTtcbiAgdmFyIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiAoMyAtIDIgKiB0KTtcbiAgb3V0WzBdID0gYVswXSAqIGZhY3RvcjEgKyBiWzBdICogZmFjdG9yMiArIGNbMF0gKiBmYWN0b3IzICsgZFswXSAqIGZhY3RvcjQ7XG4gIG91dFsxXSA9IGFbMV0gKiBmYWN0b3IxICsgYlsxXSAqIGZhY3RvcjIgKyBjWzFdICogZmFjdG9yMyArIGRbMV0gKiBmYWN0b3I0O1xuICBvdXRbMl0gPSBhWzJdICogZmFjdG9yMSArIGJbMl0gKiBmYWN0b3IyICsgY1syXSAqIGZhY3RvcjMgKyBkWzJdICogZmFjdG9yNDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGJlemllciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYmV6aWVyKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgaW52ZXJzZUZhY3RvciA9IDEgLSB0O1xuICB2YXIgaW52ZXJzZUZhY3RvclRpbWVzVHdvID0gaW52ZXJzZUZhY3RvciAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdDtcbiAgdmFyIGZhY3RvcjEgPSBpbnZlcnNlRmFjdG9yVGltZXNUd28gKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yMiA9IDMgKiB0ICogaW52ZXJzZUZhY3RvclRpbWVzVHdvO1xuICB2YXIgZmFjdG9yMyA9IDMgKiBmYWN0b3JUaW1lczIgKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqIHQ7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgdmFyIHogPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAtIDEuMDtcbiAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAgLSB6ICogeikgKiBzY2FsZTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cclxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtSZWFkb25seU1hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICB2YXIgdyA9IG1bM10gKiB4ICsgbVs3XSAqIHkgKyBtWzExXSAqIHogKyBtWzE1XTtcbiAgdyA9IHcgfHwgMS4wO1xuICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgb3V0WzFdID0gKG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdKSAvIHc7XG4gIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5TWF0M30gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdO1xuICBvdXRbMV0gPSB4ICogbVsxXSArIHkgKiBtWzRdICsgeiAqIG1bN107XG4gIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XHJcbiAqIENhbiBhbHNvIGJlIHVzZWQgZm9yIGR1YWwgcXVhdGVybmlvbnMuIChNdWx0aXBseSBpdCB3aXRoIHRoZSByZWFsIHBhcnQpXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIC8vIGJlbmNobWFya3M6IGh0dHBzOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9ucy1maXhlZFxuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdO1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdOyAvLyB2YXIgcXZlYyA9IFtxeCwgcXksIHF6XTtcbiAgLy8gdmFyIHV2ID0gdmVjMy5jcm9zcyhbXSwgcXZlYywgYSk7XG5cbiAgdmFyIHV2eCA9IHF5ICogeiAtIHF6ICogeSxcbiAgICAgIHV2eSA9IHF6ICogeCAtIHF4ICogeixcbiAgICAgIHV2eiA9IHF4ICogeSAtIHF5ICogeDsgLy8gdmFyIHV1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIHV2KTtcblxuICB2YXIgdXV2eCA9IHF5ICogdXZ6IC0gcXogKiB1dnksXG4gICAgICB1dXZ5ID0gcXogKiB1dnggLSBxeCAqIHV2eixcbiAgICAgIHV1dnogPSBxeCAqIHV2eSAtIHF5ICogdXZ4OyAvLyB2ZWMzLnNjYWxlKHV2LCB1diwgMiAqIHcpO1xuXG4gIHZhciB3MiA9IHF3ICogMjtcbiAgdXZ4ICo9IHcyO1xuICB1dnkgKj0gdzI7XG4gIHV2eiAqPSB3MjsgLy8gdmVjMy5zY2FsZSh1dXYsIHV1diwgMik7XG5cbiAgdXV2eCAqPSAyO1xuICB1dXZ5ICo9IDI7XG4gIHV1dnogKj0gMjsgLy8gcmV0dXJuIHZlYzMuYWRkKG91dCwgYSwgdmVjMy5hZGQob3V0LCB1diwgdXV2KSk7XG5cbiAgb3V0WzBdID0geCArIHV2eCArIHV1dng7XG4gIG91dFsxXSA9IHkgKyB1dnkgKyB1dXZ5O1xuICBvdXRbMl0gPSB6ICsgdXZ6ICsgdXV2ejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFswXTtcbiAgclsxXSA9IHBbMV0gKiBNYXRoLmNvcyhyYWQpIC0gcFsyXSAqIE1hdGguc2luKHJhZCk7XG4gIHJbMl0gPSBwWzFdICogTWF0aC5zaW4ocmFkKSArIHBbMl0gKiBNYXRoLmNvcyhyYWQpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFsyXSAqIE1hdGguc2luKHJhZCkgKyBwWzBdICogTWF0aC5jb3MocmFkKTtcbiAgclsxXSA9IHBbMV07XG4gIHJbMl0gPSBwWzJdICogTWF0aC5jb3MocmFkKSAtIHBbMF0gKiBNYXRoLnNpbihyYWQpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIFRoZSBhbmdsZSBvZiByb3RhdGlvbiBpbiByYWRpYW5zXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgYiwgcmFkKSB7XG4gIHZhciBwID0gW10sXG4gICAgICByID0gW107IC8vVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cblxuICBwWzBdID0gYVswXSAtIGJbMF07XG4gIHBbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcFsyXSA9IGFbMl0gLSBiWzJdOyAvL3BlcmZvcm0gcm90YXRpb25cblxuICByWzBdID0gcFswXSAqIE1hdGguY29zKHJhZCkgLSBwWzFdICogTWF0aC5zaW4ocmFkKTtcbiAgclsxXSA9IHBbMF0gKiBNYXRoLnNpbihyYWQpICsgcFsxXSAqIE1hdGguY29zKHJhZCk7XG4gIHJbMl0gPSBwWzJdOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdLFxuICAgICAgbWFnMSA9IE1hdGguc3FydChheCAqIGF4ICsgYXkgKiBheSArIGF6ICogYXopLFxuICAgICAgbWFnMiA9IE1hdGguc3FydChieCAqIGJ4ICsgYnkgKiBieSArIGJ6ICogYnopLFxuICAgICAgbWFnID0gbWFnMSAqIG1hZzIsXG4gICAgICBjb3NpbmUgPSBtYWcgJiYgZG90KGEsIGIpIC8gbWFnO1xuICByZXR1cm4gTWF0aC5hY29zKE1hdGgubWluKE1hdGgubWF4KGNvc2luZSwgLTEpLCAxKSk7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgdmVjdG9yIHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiBcInZlYzMoXCIgKyBhWzBdICsgXCIsIFwiICsgYVsxXSArIFwiLCBcIiArIGFbMl0gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXZpZGV9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkRGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAzO1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICAgIGFbaSArIDJdID0gdmVjWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSgpOyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXHJcbiAqIDQgRGltZW5zaW9uYWwgVmVjdG9yXHJcbiAqIEBtb2R1bGUgdmVjNFxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzRcclxuICpcclxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeiwgdykge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIG91dFszXSA9IHc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgc291cmNlIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIHgsIHksIHosIHcpIHtcbiAgb3V0WzBdID0geDtcbiAgb3V0WzFdID0geTtcbiAgb3V0WzJdID0gejtcbiAgb3V0WzNdID0gdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKiBiWzJdO1xuICBvdXRbM10gPSBhWzNdICogYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIG91dFszXSA9IGFbM10gLyBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGguY2VpbCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNlaWxcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIG91dFszXSA9IE1hdGguY2VpbChhWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gZmxvb3JcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmZsb29yKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWF4KGFbMl0sIGJbMl0pO1xuICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gcm91bmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLnJvdW5kKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLnJvdW5kKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyBhIHZlYzQgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWM0J3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgdmFyIHcgPSBiWzNdIC0gYVszXTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoeCwgeSwgeiwgdyk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHZhciB3ID0gYlszXSAtIGFbM107XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICByZXR1cm4gTWF0aC5oeXBvdCh4LCB5LCB6LCB3KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3O1xufVxuLyoqXHJcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gLWFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdmVjdG9yIHRvIGludmVydFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgb3V0WzNdID0gMS4wIC8gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBOb3JtYWxpemUgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHZlY3RvciB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICB2YXIgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gIH1cblxuICBvdXRbMF0gPSB4ICogbGVuO1xuICBvdXRbMV0gPSB5ICogbGVuO1xuICBvdXRbMl0gPSB6ICogbGVuO1xuICBvdXRbM10gPSB3ICogbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgY3Jvc3MtcHJvZHVjdCBvZiB0aHJlZSB2ZWN0b3JzIGluIGEgNC1kaW1lbnNpb25hbCBzcGFjZVxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gcmVzdWx0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBVIHRoZSBmaXJzdCB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IFYgdGhlIHNlY29uZCB2ZWN0b3JcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IFcgdGhlIHRoaXJkIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7dmVjNH0gcmVzdWx0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3Jvc3Mob3V0LCB1LCB2LCB3KSB7XG4gIHZhciBBID0gdlswXSAqIHdbMV0gLSB2WzFdICogd1swXSxcbiAgICAgIEIgPSB2WzBdICogd1syXSAtIHZbMl0gKiB3WzBdLFxuICAgICAgQyA9IHZbMF0gKiB3WzNdIC0gdlszXSAqIHdbMF0sXG4gICAgICBEID0gdlsxXSAqIHdbMl0gLSB2WzJdICogd1sxXSxcbiAgICAgIEUgPSB2WzFdICogd1szXSAtIHZbM10gKiB3WzFdLFxuICAgICAgRiA9IHZbMl0gKiB3WzNdIC0gdlszXSAqIHdbMl07XG4gIHZhciBHID0gdVswXTtcbiAgdmFyIEggPSB1WzFdO1xuICB2YXIgSSA9IHVbMl07XG4gIHZhciBKID0gdVszXTtcbiAgb3V0WzBdID0gSCAqIEYgLSBJICogRSArIEogKiBEO1xuICBvdXRbMV0gPSAtKEcgKiBGKSArIEkgKiBDIC0gSiAqIEI7XG4gIG91dFsyXSA9IEcgKiBFIC0gSCAqIEMgKyBKICogQTtcbiAgb3V0WzNdID0gLShHICogRCkgKyBIICogQiAtIEkgKiBBO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICB2YXIgYXggPSBhWzBdO1xuICB2YXIgYXkgPSBhWzFdO1xuICB2YXIgYXogPSBhWzJdO1xuICB2YXIgYXcgPSBhWzNdO1xuICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopO1xuICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKG91dCwgc2NhbGUpIHtcbiAgc2NhbGUgPSBzY2FsZSB8fCAxLjA7IC8vIE1hcnNhZ2xpYSwgR2VvcmdlLiBDaG9vc2luZyBhIFBvaW50IGZyb20gdGhlIFN1cmZhY2Ugb2YgYVxuICAvLyBTcGhlcmUuIEFubi4gTWF0aC4gU3RhdGlzdC4gNDMgKDE5NzIpLCBuby4gMiwgNjQ1LS02NDYuXG4gIC8vIGh0dHA6Ly9wcm9qZWN0ZXVjbGlkLm9yZy9ldWNsaWQuYW9tcy8xMTc3NjkyNjQ0O1xuXG4gIHZhciB2MSwgdjIsIHYzLCB2NDtcbiAgdmFyIHMxLCBzMjtcblxuICBkbyB7XG4gICAgdjEgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHYyID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICBzMSA9IHYxICogdjEgKyB2MiAqIHYyO1xuICB9IHdoaWxlIChzMSA+PSAxKTtcblxuICBkbyB7XG4gICAgdjMgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIgLSAxO1xuICAgIHY0ID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICBzMiA9IHYzICogdjMgKyB2NCAqIHY0O1xuICB9IHdoaWxlIChzMiA+PSAxKTtcblxuICB2YXIgZCA9IE1hdGguc3FydCgoMSAtIHMxKSAvIHMyKTtcbiAgb3V0WzBdID0gc2NhbGUgKiB2MTtcbiAgb3V0WzFdID0gc2NhbGUgKiB2MjtcbiAgb3V0WzJdID0gc2NhbGUgKiB2MyAqIGQ7XG4gIG91dFszXSA9IHNjYWxlICogdjQgKiBkO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIG1hdDQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlNYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXSxcbiAgICAgIHcgPSBhWzNdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgb3V0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlRdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM107IC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG5cbiAgdmFyIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5O1xuICB2YXIgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gIHZhciBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcbiAgdmFyIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejsgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuXG4gIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICBvdXRbM10gPSAwLjA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge1JlYWRvbmx5VmVjNH0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuIFwidmVjNChcIiArIGFbMF0gKyBcIiwgXCIgKyBhWzFdICsgXCIsIFwiICsgYVsyXSArIFwiLCBcIiArIGFbM10gKyBcIilcIjtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHtSZWFkb25seVZlYzR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7UmVhZG9ubHlWZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXZpZGV9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWM0cy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWM0LiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzRzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSA0O1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICB2ZWNbM10gPSBhW2kgKyAzXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgICAgYVtpICsgMl0gPSB2ZWNbMl07XG4gICAgICBhW2kgKyAzXSA9IHZlY1szXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgcHJvcCBvbiBgJyArIGNvbXBvbmVudE5hbWUgICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICAgICAgICAgICAgJ0EgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzLCBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBTdHJpbmcocHJvcFZhbHVlKSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoaGFzKHByb3BWYWx1ZSwga2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RJcyA9IHJlcXVpcmUoJ3JlYWN0LWlzJyk7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShSZWFjdElzLmlzRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiIsIi8vIEEgbGlicmFyeSBvZiBzZWVkYWJsZSBSTkdzIGltcGxlbWVudGVkIGluIEphdmFzY3JpcHQuXG4vL1xuLy8gVXNhZ2U6XG4vL1xuLy8gdmFyIHNlZWRyYW5kb20gPSByZXF1aXJlKCdzZWVkcmFuZG9tJyk7XG4vLyB2YXIgcmFuZG9tID0gc2VlZHJhbmRvbSgxKTsgLy8gb3IgYW55IHNlZWQuXG4vLyB2YXIgeCA9IHJhbmRvbSgpOyAgICAgICAvLyAwIDw9IHggPCAxLiAgRXZlcnkgYml0IGlzIHJhbmRvbS5cbi8vIHZhciB4ID0gcmFuZG9tLnF1aWNrKCk7IC8vIDAgPD0geCA8IDEuICAzMiBiaXRzIG9mIHJhbmRvbW5lc3MuXG5cbi8vIGFsZWEsIGEgNTMtYml0IG11bHRpcGx5LXdpdGgtY2FycnkgZ2VuZXJhdG9yIGJ5IEpvaGFubmVzIEJhYWfDuGUuXG4vLyBQZXJpb2Q6IH4yXjExNlxuLy8gUmVwb3J0ZWQgdG8gcGFzcyBhbGwgQmlnQ3J1c2ggdGVzdHMuXG52YXIgYWxlYSA9IHJlcXVpcmUoJy4vbGliL2FsZWEnKTtcblxuLy8geG9yMTI4LCBhIHB1cmUgeG9yLXNoaWZ0IGdlbmVyYXRvciBieSBHZW9yZ2UgTWFyc2FnbGlhLlxuLy8gUGVyaW9kOiAyXjEyOC0xLlxuLy8gUmVwb3J0ZWQgdG8gZmFpbDogTWF0cml4UmFuayBhbmQgTGluZWFyQ29tcC5cbnZhciB4b3IxMjggPSByZXF1aXJlKCcuL2xpYi94b3IxMjgnKTtcblxuLy8geG9yd293LCBHZW9yZ2UgTWFyc2FnbGlhJ3MgMTYwLWJpdCB4b3Itc2hpZnQgY29tYmluZWQgcGx1cyB3ZXlsLlxuLy8gUGVyaW9kOiAyXjE5Mi0yXjMyXG4vLyBSZXBvcnRlZCB0byBmYWlsOiBDb2xsaXNpb25PdmVyLCBTaW1wUG9rZXIsIGFuZCBMaW5lYXJDb21wLlxudmFyIHhvcndvdyA9IHJlcXVpcmUoJy4vbGliL3hvcndvdycpO1xuXG4vLyB4b3JzaGlmdDcsIGJ5IEZyYW7Dp29pcyBQYW5uZXRvbiBhbmQgUGllcnJlIEwnZWN1eWVyLCB0YWtlc1xuLy8gYSBkaWZmZXJlbnQgYXBwcm9hY2g6IGl0IGFkZHMgcm9idXN0bmVzcyBieSBhbGxvd2luZyBtb3JlIHNoaWZ0c1xuLy8gdGhhbiBNYXJzYWdsaWEncyBvcmlnaW5hbCB0aHJlZS4gIEl0IGlzIGEgNy1zaGlmdCBnZW5lcmF0b3Jcbi8vIHdpdGggMjU2IGJpdHMsIHRoYXQgcGFzc2VzIEJpZ0NydXNoIHdpdGggbm8gc3lzdG1hdGljIGZhaWx1cmVzLlxuLy8gUGVyaW9kIDJeMjU2LTEuXG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHhvcnNoaWZ0NyA9IHJlcXVpcmUoJy4vbGliL3hvcnNoaWZ0NycpO1xuXG4vLyB4b3I0MDk2LCBieSBSaWNoYXJkIEJyZW50LCBpcyBhIDQwOTYtYml0IHhvci1zaGlmdCB3aXRoIGFcbi8vIHZlcnkgbG9uZyBwZXJpb2QgdGhhdCBhbHNvIGFkZHMgYSBXZXlsIGdlbmVyYXRvci4gSXQgYWxzbyBwYXNzZXNcbi8vIEJpZ0NydXNoIHdpdGggbm8gc3lzdGVtYXRpYyBmYWlsdXJlcy4gIEl0cyBsb25nIHBlcmlvZCBtYXlcbi8vIGJlIHVzZWZ1bCBpZiB5b3UgaGF2ZSBtYW55IGdlbmVyYXRvcnMgYW5kIG5lZWQgdG8gYXZvaWRcbi8vIGNvbGxpc2lvbnMuXG4vLyBQZXJpb2Q6IDJeNDEyOC0yXjMyLlxuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB4b3I0MDk2ID0gcmVxdWlyZSgnLi9saWIveG9yNDA5NicpO1xuXG4vLyBUeWNoZS1pLCBieSBTYW11ZWwgTmV2ZXMgYW5kIEZpbGlwZSBBcmF1am8sIGlzIGEgYml0LXNoaWZ0aW5nIHJhbmRvbVxuLy8gbnVtYmVyIGdlbmVyYXRvciBkZXJpdmVkIGZyb20gQ2hhQ2hhLCBhIG1vZGVybiBzdHJlYW0gY2lwaGVyLlxuLy8gaHR0cHM6Ly9lZGVuLmRlaS51Yy5wdC9+c25ldmVzL3B1YnMvMjAxMS1zbmZhMi5wZGZcbi8vIFBlcmlvZDogfjJeMTI3XG4vLyBObyBzeXN0ZW1hdGljIEJpZ0NydXNoIGZhaWx1cmVzIHJlcG9ydGVkLlxudmFyIHR5Y2hlaSA9IHJlcXVpcmUoJy4vbGliL3R5Y2hlaScpO1xuXG4vLyBUaGUgb3JpZ2luYWwgQVJDNC1iYXNlZCBwcm5nIGluY2x1ZGVkIGluIHRoaXMgbGlicmFyeS5cbi8vIFBlcmlvZDogfjJeMTYwMFxudmFyIHNyID0gcmVxdWlyZSgnLi9zZWVkcmFuZG9tJyk7XG5cbnNyLmFsZWEgPSBhbGVhO1xuc3IueG9yMTI4ID0geG9yMTI4O1xuc3IueG9yd293ID0geG9yd293O1xuc3IueG9yc2hpZnQ3ID0geG9yc2hpZnQ3O1xuc3IueG9yNDA5NiA9IHhvcjQwOTY7XG5zci50eWNoZWkgPSB0eWNoZWk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3I7XG4iLCIvLyBBIHBvcnQgb2YgYW4gYWxnb3JpdGhtIGJ5IEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2UuY29tPiwgMjAxMFxuLy8gaHR0cDovL2JhYWdvZS5jb20vZW4vUmFuZG9tTXVzaW5ncy9qYXZhc2NyaXB0L1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL25xdWlubGFuL2JldHRlci1yYW5kb20tbnVtYmVycy1mb3ItamF2YXNjcmlwdC1taXJyb3Jcbi8vIE9yaWdpbmFsIHdvcmsgaXMgdW5kZXIgTUlUIGxpY2Vuc2UgLVxuXG4vLyBDb3B5cmlnaHQgKEMpIDIwMTAgYnkgSm9oYW5uZXMgQmFhZ8O4ZSA8YmFhZ29lQGJhYWdvZS5vcmc+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuLy8gaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuLy8gdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuLy8gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIEFsZWEoc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBtYXNoID0gTWFzaCgpO1xuXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IDIwOTE2MzkgKiBtZS5zMCArIG1lLmMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgIG1lLnMwID0gbWUuczE7XG4gICAgbWUuczEgPSBtZS5zMjtcbiAgICByZXR1cm4gbWUuczIgPSB0IC0gKG1lLmMgPSB0IHwgMCk7XG4gIH07XG5cbiAgLy8gQXBwbHkgdGhlIHNlZWRpbmcgYWxnb3JpdGhtIGZyb20gQmFhZ29lLlxuICBtZS5jID0gMTtcbiAgbWUuczAgPSBtYXNoKCcgJyk7XG4gIG1lLnMxID0gbWFzaCgnICcpO1xuICBtZS5zMiA9IG1hc2goJyAnKTtcbiAgbWUuczAgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMwIDwgMCkgeyBtZS5zMCArPSAxOyB9XG4gIG1lLnMxIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMSA8IDApIHsgbWUuczEgKz0gMTsgfVxuICBtZS5zMiAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczIgPCAwKSB7IG1lLnMyICs9IDE7IH1cbiAgbWFzaCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmMgPSBmLmM7XG4gIHQuczAgPSBmLnMwO1xuICB0LnMxID0gZi5zMTtcbiAgdC5zMiA9IGYuczI7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IEFsZWEoc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSB4Zy5uZXh0O1xuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpICogMHgxMDAwMDAwMDApIHwgMDsgfVxuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcm5nKCkgKyAocHJuZygpICogMHgyMDAwMDAgfCAwKSAqIDEuMTEwMjIzMDI0NjI1MTU2NWUtMTY7IC8vIDJeLTUzXG4gIH07XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5mdW5jdGlvbiBNYXNoKCkge1xuICB2YXIgbiA9IDB4ZWZjODI0OWQ7XG5cbiAgdmFyIG1hc2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgZGF0YSA9IFN0cmluZyhkYXRhKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgaCAqPSBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgIH1cbiAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgfTtcblxuICByZXR1cm4gbWFzaDtcbn1cblxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLmFsZWEgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcIlR5Y2hlLWlcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLlxuLy8gU2VlIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGIgPSBtZS5iLCBjID0gbWUuYywgZCA9IG1lLmQsIGEgPSBtZS5hO1xuICAgIGIgPSAoYiA8PCAyNSkgXiAoYiA+Pj4gNykgXiBjO1xuICAgIGMgPSAoYyAtIGQpIHwgMDtcbiAgICBkID0gKGQgPDwgMjQpIF4gKGQgPj4+IDgpIF4gYTtcbiAgICBhID0gKGEgLSBiKSB8IDA7XG4gICAgbWUuYiA9IGIgPSAoYiA8PCAyMCkgXiAoYiA+Pj4gMTIpIF4gYztcbiAgICBtZS5jID0gYyA9IChjIC0gZCkgfCAwO1xuICAgIG1lLmQgPSAoZCA8PCAxNikgXiAoYyA+Pj4gMTYpIF4gYTtcbiAgICByZXR1cm4gbWUuYSA9IChhIC0gYikgfCAwO1xuICB9O1xuXG4gIC8qIFRoZSBmb2xsb3dpbmcgaXMgbm9uLWludmVydGVkIHR5Y2hlLCB3aGljaCBoYXMgYmV0dGVyIGludGVybmFsXG4gICAqIGJpdCBkaWZmdXNpb24sIGJ1dCB3aGljaCBpcyBhYm91dCAyNSUgc2xvd2VyIHRoYW4gdHljaGUtaSBpbiBKUy5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gbWUuYSwgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZDtcbiAgICBhID0gKG1lLmEgKyBtZS5iIHwgMCkgPj4+IDA7XG4gICAgZCA9IG1lLmQgXiBhOyBkID0gZCA8PCAxNiBeIGQgPj4+IDE2O1xuICAgIGMgPSBtZS5jICsgZCB8IDA7XG4gICAgYiA9IG1lLmIgXiBjOyBiID0gYiA8PCAxMiBeIGQgPj4+IDIwO1xuICAgIG1lLmEgPSBhID0gYSArIGIgfCAwO1xuICAgIGQgPSBkIF4gYTsgbWUuZCA9IGQgPSBkIDw8IDggXiBkID4+PiAyNDtcbiAgICBtZS5jID0gYyA9IGMgKyBkIHwgMDtcbiAgICBiID0gYiBeIGM7XG4gICAgcmV0dXJuIG1lLmIgPSAoYiA8PCA3IF4gYiA+Pj4gMjUpO1xuICB9XG4gICovXG5cbiAgbWUuYSA9IDA7XG4gIG1lLmIgPSAwO1xuICBtZS5jID0gMjY1NDQzNTc2OSB8IDA7XG4gIG1lLmQgPSAxMzY3MTMwNTUxO1xuXG4gIGlmIChzZWVkID09PSBNYXRoLmZsb29yKHNlZWQpKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLmEgPSAoc2VlZCAvIDB4MTAwMDAwMDAwKSB8IDA7XG4gICAgbWUuYiA9IHNlZWQgfCAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgMjA7IGsrKykge1xuICAgIG1lLmIgXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYSA9IGYuYTtcbiAgdC5iID0gZi5iO1xuICB0LmMgPSBmLmM7XG4gIHQuZCA9IGYuZDtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnR5Y2hlaSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yMTI4XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG1lLnggXiAobWUueCA8PCAxMSk7XG4gICAgbWUueCA9IG1lLnk7XG4gICAgbWUueSA9IG1lLno7XG4gICAgbWUueiA9IG1lLnc7XG4gICAgcmV0dXJuIG1lLncgXj0gKG1lLncgPj4+IDE5KSBeIHQgXiAodCA+Pj4gOCk7XG4gIH07XG5cbiAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUueCA9IHNlZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgbWUueCBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54O1xuICB0LnkgPSBmLnk7XG4gIHQueiA9IGYuejtcbiAgdC53ID0gZi53O1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3IxMjggPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIFJpY2hhcmQgQnJlbnQncyBYb3JnZW5zIHhvcjQwOTYgYWxnb3JpdGhtLlxuLy9cbi8vIFRoaXMgZmFzdCBub24tY3J5cHRvZ3JhcGhpYyByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBpcyBkZXNpZ25lZCBmb3Jcbi8vIHVzZSBpbiBNb250ZS1DYXJsbyBhbGdvcml0aG1zLiBJdCBjb21iaW5lcyBhIGxvbmctcGVyaW9kIHhvcnNoaWZ0XG4vLyBnZW5lcmF0b3Igd2l0aCBhIFdleWwgZ2VuZXJhdG9yLCBhbmQgaXQgcGFzc2VzIGFsbCBjb21tb24gYmF0dGVyaWVzXG4vLyBvZiBzdGFzdGljaWFsIHRlc3RzIGZvciByYW5kb21uZXNzIHdoaWxlIGNvbnN1bWluZyBvbmx5IGEgZmV3IG5hbm9zZWNvbmRzXG4vLyBmb3IgZWFjaCBwcm5nIGdlbmVyYXRlZC4gIEZvciBiYWNrZ3JvdW5kIG9uIHRoZSBnZW5lcmF0b3IsIHNlZSBCcmVudCdzXG4vLyBwYXBlcjogXCJTb21lIGxvbmctcGVyaW9kIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9ycyB1c2luZyBzaGlmdHMgYW5kIHhvcnMuXCJcbi8vIGh0dHA6Ly9hcnhpdi5vcmcvcGRmLzEwMDQuMzExNXYxLnBkZlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciB4b3I0MDk2ID0gcmVxdWlyZSgneG9yNDA5NicpO1xuLy8gcmFuZG9tID0geG9yNDA5NigxKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVkIHdpdGggaW50MzIgb3Igc3RyaW5nLlxuLy8gYXNzZXJ0LmVxdWFsKHJhbmRvbSgpLCAwLjE1MjA0MzY0NTA1Mzg1NDcpOyAvLyAoMCwgMSkgcmFuZ2UsIDUzIGJpdHMuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tLmludDMyKCksIDE4MDY1MzQ4OTcpOyAgIC8vIHNpZ25lZCBpbnQzMiwgMzIgYml0cy5cbi8vXG4vLyBGb3Igbm9uemVybyBudW1lcmljIGtleXMsIHRoaXMgaW1wZWxlbWVudGF0aW9uIHByb3ZpZGVzIGEgc2VxdWVuY2Vcbi8vIGlkZW50aWNhbCB0byB0aGF0IGJ5IEJyZW50J3MgeG9yZ2VucyAzIGltcGxlbWVudGFpb24gaW4gQy4gIFRoaXNcbi8vIGltcGxlbWVudGF0aW9uIGFsc28gcHJvdmlkZXMgZm9yIGluaXRhbGl6aW5nIHRoZSBnZW5lcmF0b3Igd2l0aFxuLy8gc3RyaW5nIHNlZWRzLCBvciBmb3Igc2F2aW5nIGFuZCByZXN0b3JpbmcgdGhlIHN0YXRlIG9mIHRoZSBnZW5lcmF0b3IuXG4vL1xuLy8gT24gQ2hyb21lLCB0aGlzIHBybmcgYmVuY2htYXJrcyBhYm91dCAyLjEgdGltZXMgc2xvd2VyIHRoYW5cbi8vIEphdmFzY3JpcHQncyBidWlsdC1pbiBNYXRoLnJhbmRvbSgpLlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdyA9IG1lLncsXG4gICAgICAgIFggPSBtZS5YLCBpID0gbWUuaSwgdCwgdjtcbiAgICAvLyBVcGRhdGUgV2V5bCBnZW5lcmF0b3IuXG4gICAgbWUudyA9IHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2ID0gWFsoaSArIDM0KSAmIDEyN107XG4gICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgdiBePSB2IDw8IDEzO1xuICAgIHQgXj0gdCA8PCAxNztcbiAgICB2IF49IHYgPj4+IDE1O1xuICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgLy8gVXBkYXRlIFhvciBnZW5lcmF0b3IgYXJyYXkgc3RhdGUuXG4gICAgdiA9IFhbaV0gPSB2IF4gdDtcbiAgICBtZS5pID0gaTtcbiAgICAvLyBSZXN1bHQgaXMgdGhlIGNvbWJpbmF0aW9uLlxuICAgIHJldHVybiAodiArICh3IF4gKHcgPj4+IDE2KSkpIHwgMDtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIHQsIHYsIGksIGosIHcsIFggPSBbXSwgbGltaXQgPSAxMjg7XG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIE51bWVyaWMgc2VlZHMgaW5pdGlhbGl6ZSB2LCB3aGljaCBpcyB1c2VkIHRvIGdlbmVyYXRlcyBYLlxuICAgICAgdiA9IHNlZWQ7XG4gICAgICBzZWVkID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RyaW5nIHNlZWRzIGFyZSBtaXhlZCBpbnRvIHYgYW5kIFggb25lIGNoYXJhY3RlciBhdCBhIHRpbWUuXG4gICAgICBzZWVkID0gc2VlZCArICdcXDAnO1xuICAgICAgdiA9IDA7XG4gICAgICBsaW1pdCA9IE1hdGgubWF4KGxpbWl0LCBzZWVkLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIEluaXRpYWxpemUgY2lyY3VsYXIgYXJyYXkgYW5kIHdleWwgdmFsdWUuXG4gICAgZm9yIChpID0gMCwgaiA9IC0zMjsgaiA8IGxpbWl0OyArK2opIHtcbiAgICAgIC8vIFB1dCB0aGUgdW5pY29kZSBjaGFyYWN0ZXJzIGludG8gdGhlIGFycmF5LCBhbmQgc2h1ZmZsZSB0aGVtLlxuICAgICAgaWYgKHNlZWQpIHYgXj0gc2VlZC5jaGFyQ29kZUF0KChqICsgMzIpICUgc2VlZC5sZW5ndGgpO1xuICAgICAgLy8gQWZ0ZXIgMzIgc2h1ZmZsZXMsIHRha2UgdiBhcyB0aGUgc3RhcnRpbmcgdyB2YWx1ZS5cbiAgICAgIGlmIChqID09PSAwKSB3ID0gdjtcbiAgICAgIHYgXj0gdiA8PCAxMDtcbiAgICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgICB2IF49IHYgPDwgNDtcbiAgICAgIHYgXj0gdiA+Pj4gMTM7XG4gICAgICBpZiAoaiA+PSAwKSB7XG4gICAgICAgIHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDsgICAgIC8vIFdleWwuXG4gICAgICAgIHQgPSAoWFtqICYgMTI3XSBePSAodiArIHcpKTsgIC8vIENvbWJpbmUgeG9yIGFuZCB3ZXlsIHRvIGluaXQgYXJyYXkuXG4gICAgICAgIGkgPSAoMCA9PSB0KSA/IGkgKyAxIDogMDsgICAgIC8vIENvdW50IHplcm9lcy5cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBkZXRlY3RlZCBhbGwgemVyb2VzOyBtYWtlIHRoZSBrZXkgbm9uemVyby5cbiAgICBpZiAoaSA+PSAxMjgpIHtcbiAgICAgIFhbKHNlZWQgJiYgc2VlZC5sZW5ndGggfHwgMCkgJiAxMjddID0gLTE7XG4gICAgfVxuICAgIC8vIFJ1biB0aGUgZ2VuZXJhdG9yIDUxMiB0aW1lcyB0byBmdXJ0aGVyIG1peCB0aGUgc3RhdGUgYmVmb3JlIHVzaW5nIGl0LlxuICAgIC8vIEZhY3RvcmluZyB0aGlzIGFzIGEgZnVuY3Rpb24gc2xvd3MgdGhlIG1haW4gZ2VuZXJhdG9yLCBzbyBpdCBpcyBqdXN0XG4gICAgLy8gdW5yb2xsZWQgaGVyZS4gIFRoZSB3ZXlsIGdlbmVyYXRvciBpcyBub3QgYWR2YW5jZWQgd2hpbGUgd2FybWluZyB1cC5cbiAgICBpID0gMTI3O1xuICAgIGZvciAoaiA9IDQgKiAxMjg7IGogPiAwOyAtLWopIHtcbiAgICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICAgIHQgPSBYW2kgPSAoKGkgKyAxKSAmIDEyNyldO1xuICAgICAgdiBePSB2IDw8IDEzO1xuICAgICAgdCBePSB0IDw8IDE3O1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgICBYW2ldID0gdiBeIHQ7XG4gICAgfVxuICAgIC8vIFN0b3Jpbmcgc3RhdGUgYXMgb2JqZWN0IG1lbWJlcnMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMuXG4gICAgbWUudyA9IHc7XG4gICAgbWUuWCA9IFg7XG4gICAgbWUuaSA9IGk7XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC53ID0gZi53O1xuICB0LlggPSBmLlguc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5YKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yNDA5NiA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cgb2JqZWN0IG9yIGdsb2JhbFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3JzaGlmdDdcIiBhbGdvcml0aG0gYnlcbi8vIEZyYW7Dp29pcyBQYW5uZXRvbiBhbmQgUGllcnJlIEwnZWN1eWVyOlxuLy8gXCJPbiB0aGUgWG9yZ3NoaWZ0IFJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yc1wiXG4vLyBodHRwOi8vc2FsdWMuZW5nci51Y29ubi5lZHUvcmVmcy9jcnlwdG8vcm5nL3Bhbm5ldG9uMDVvbnRoZXhvcnNoaWZ0LnBkZlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2YXIgWCA9IG1lLngsIGkgPSBtZS5pLCB0LCB2LCB3O1xuICAgIHQgPSBYW2ldOyB0IF49ICh0ID4+PiA3KTsgdiA9IHQgXiAodCA8PCAyNCk7XG4gICAgdCA9IFhbKGkgKyAxKSAmIDddOyB2IF49IHQgXiAodCA+Pj4gMTApO1xuICAgIHQgPSBYWyhpICsgMykgJiA3XTsgdiBePSB0IF4gKHQgPj4+IDMpO1xuICAgIHQgPSBYWyhpICsgNCkgJiA3XTsgdiBePSB0IF4gKHQgPDwgNyk7XG4gICAgdCA9IFhbKGkgKyA3KSAmIDddOyB0ID0gdCBeICh0IDw8IDEzKTsgdiBePSB0IF4gKHQgPDwgOSk7XG4gICAgWFtpXSA9IHY7XG4gICAgbWUuaSA9IChpICsgMSkgJiA3O1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXQobWUsIHNlZWQpIHtcbiAgICB2YXIgaiwgdywgWCA9IFtdO1xuXG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIFNlZWQgc3RhdGUgYXJyYXkgdXNpbmcgYSAzMi1iaXQgaW50ZWdlci5cbiAgICAgIHcgPSBYWzBdID0gc2VlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VlZCBzdGF0ZSB1c2luZyBhIHN0cmluZy5cbiAgICAgIHNlZWQgPSAnJyArIHNlZWQ7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc2VlZC5sZW5ndGg7ICsraikge1xuICAgICAgICBYW2ogJiA3XSA9IChYW2ogJiA3XSA8PCAxNSkgXlxuICAgICAgICAgICAgKHNlZWQuY2hhckNvZGVBdChqKSArIFhbKGogKyAxKSAmIDddIDw8IDEzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRW5mb3JjZSBhbiBhcnJheSBsZW5ndGggb2YgOCwgbm90IGFsbCB6ZXJvZXMuXG4gICAgd2hpbGUgKFgubGVuZ3RoIDwgOCkgWC5wdXNoKDApO1xuICAgIGZvciAoaiA9IDA7IGogPCA4ICYmIFhbal0gPT09IDA7ICsraik7XG4gICAgaWYgKGogPT0gOCkgdyA9IFhbN10gPSAtMTsgZWxzZSB3ID0gWFtqXTtcblxuICAgIG1lLnggPSBYO1xuICAgIG1lLmkgPSAwO1xuXG4gICAgLy8gRGlzY2FyZCBhbiBpbml0aWFsIDI1NiB2YWx1ZXMuXG4gICAgZm9yIChqID0gMjU2OyBqID4gMDsgLS1qKSB7XG4gICAgICBtZS5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgaW5pdChtZSwgc2VlZCk7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLnguc2xpY2UoKTtcbiAgdC5pID0gZi5pO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIGlmIChzZWVkID09IG51bGwpIHNlZWQgPSArKG5ldyBEYXRlKTtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUueCkgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcnNoaWZ0NyA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcndvd1wiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBHZW9yZ2UgTWFyc2FnbGlhLiAgU2VlIGh0dHA6Ly93d3cuanN0YXRzb2Z0Lm9yZy92MDgvaTE0L3BhcGVyXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSAobWUueCBeIChtZS54ID4+PiAyKSk7XG4gICAgbWUueCA9IG1lLnk7IG1lLnkgPSBtZS56OyBtZS56ID0gbWUudzsgbWUudyA9IG1lLnY7XG4gICAgcmV0dXJuIChtZS5kID0gKG1lLmQgKyAzNjI0MzcgfCAwKSkgK1xuICAgICAgIChtZS52ID0gKG1lLnYgXiAobWUudiA8PCA0KSkgXiAodCBeICh0IDw8IDEpKSkgfCAwO1xuICB9O1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuICBtZS52ID0gMDtcblxuICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS54ID0gc2VlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDY0OyBrKyspIHtcbiAgICBtZS54IF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgaWYgKGsgPT0gc3Ryc2VlZC5sZW5ndGgpIHtcbiAgICAgIG1lLmQgPSBtZS54IDw8IDEwIF4gbWUueCA+Pj4gNDtcbiAgICB9XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLng7XG4gIHQueSA9IGYueTtcbiAgdC56ID0gZi56O1xuICB0LncgPSBmLnc7XG4gIHQudiA9IGYudjtcbiAgdC5kID0gZi5kO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3J3b3cgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxOSBEYXZpZCBCYXUuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbkNMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG5UT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBwb29sLCBtYXRoKSB7XG4vL1xuLy8gVGhlIGZvbGxvd2luZyBjb25zdGFudHMgYXJlIHJlbGF0ZWQgdG8gSUVFRSA3NTQgbGltaXRzLlxuLy9cblxudmFyIHdpZHRoID0gMjU2LCAgICAgICAgLy8gZWFjaCBSQzQgb3V0cHV0IGlzIDAgPD0geCA8IDI1NlxuICAgIGNodW5rcyA9IDYsICAgICAgICAgLy8gYXQgbGVhc3Qgc2l4IFJDNCBvdXRwdXRzIGZvciBlYWNoIGRvdWJsZVxuICAgIGRpZ2l0cyA9IDUyLCAgICAgICAgLy8gdGhlcmUgYXJlIDUyIHNpZ25pZmljYW50IGRpZ2l0cyBpbiBhIGRvdWJsZVxuICAgIHJuZ25hbWUgPSAncmFuZG9tJywgLy8gcm5nbmFtZTogbmFtZSBmb3IgTWF0aC5yYW5kb20gYW5kIE1hdGguc2VlZHJhbmRvbVxuICAgIHN0YXJ0ZGVub20gPSBtYXRoLnBvdyh3aWR0aCwgY2h1bmtzKSxcbiAgICBzaWduaWZpY2FuY2UgPSBtYXRoLnBvdygyLCBkaWdpdHMpLFxuICAgIG92ZXJmbG93ID0gc2lnbmlmaWNhbmNlICogMixcbiAgICBtYXNrID0gd2lkdGggLSAxLFxuICAgIG5vZGVjcnlwdG87ICAgICAgICAgLy8gbm9kZS5qcyBjcnlwdG8gbW9kdWxlLCBpbml0aWFsaXplZCBhdCB0aGUgYm90dG9tLlxuXG4vL1xuLy8gc2VlZHJhbmRvbSgpXG4vLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cbi8vXG5mdW5jdGlvbiBzZWVkcmFuZG9tKHNlZWQsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gIHZhciBrZXkgPSBbXTtcbiAgb3B0aW9ucyA9IChvcHRpb25zID09IHRydWUpID8geyBlbnRyb3B5OiB0cnVlIH0gOiAob3B0aW9ucyB8fCB7fSk7XG5cbiAgLy8gRmxhdHRlbiB0aGUgc2VlZCBzdHJpbmcgb3IgYnVpbGQgb25lIGZyb20gbG9jYWwgZW50cm9weSBpZiBuZWVkZWQuXG4gIHZhciBzaG9ydHNlZWQgPSBtaXhrZXkoZmxhdHRlbihcbiAgICBvcHRpb25zLmVudHJvcHkgPyBbc2VlZCwgdG9zdHJpbmcocG9vbCldIDpcbiAgICAoc2VlZCA9PSBudWxsKSA/IGF1dG9zZWVkKCkgOiBzZWVkLCAzKSwga2V5KTtcblxuICAvLyBVc2UgdGhlIHNlZWQgdG8gaW5pdGlhbGl6ZSBhbiBBUkM0IGdlbmVyYXRvci5cbiAgdmFyIGFyYzQgPSBuZXcgQVJDNChrZXkpO1xuXG4gIC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHJhbmRvbSBkb3VibGUgaW4gWzAsIDEpIHRoYXQgY29udGFpbnNcbiAgLy8gcmFuZG9tbmVzcyBpbiBldmVyeSBiaXQgb2YgdGhlIG1hbnRpc3NhIG9mIHRoZSBJRUVFIDc1NCB2YWx1ZS5cbiAgdmFyIHBybmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbiA9IGFyYzQuZyhjaHVua3MpLCAgICAgICAgICAgICAvLyBTdGFydCB3aXRoIGEgbnVtZXJhdG9yIG4gPCAyIF4gNDhcbiAgICAgICAgZCA9IHN0YXJ0ZGVub20sICAgICAgICAgICAgICAgICAvLyAgIGFuZCBkZW5vbWluYXRvciBkID0gMiBeIDQ4LlxuICAgICAgICB4ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgYW5kIG5vICdleHRyYSBsYXN0IGJ5dGUnLlxuICAgIHdoaWxlIChuIDwgc2lnbmlmaWNhbmNlKSB7ICAgICAgICAgIC8vIEZpbGwgdXAgYWxsIHNpZ25pZmljYW50IGRpZ2l0cyBieVxuICAgICAgbiA9IChuICsgeCkgKiB3aWR0aDsgICAgICAgICAgICAgIC8vICAgc2hpZnRpbmcgbnVtZXJhdG9yIGFuZFxuICAgICAgZCAqPSB3aWR0aDsgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZGVub21pbmF0b3IgYW5kIGdlbmVyYXRpbmcgYVxuICAgICAgeCA9IGFyYzQuZygxKTsgICAgICAgICAgICAgICAgICAgIC8vICAgbmV3IGxlYXN0LXNpZ25pZmljYW50LWJ5dGUuXG4gICAgfVxuICAgIHdoaWxlIChuID49IG92ZXJmbG93KSB7ICAgICAgICAgICAgIC8vIFRvIGF2b2lkIHJvdW5kaW5nIHVwLCBiZWZvcmUgYWRkaW5nXG4gICAgICBuIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBsYXN0IGJ5dGUsIHNoaWZ0IGV2ZXJ5dGhpbmdcbiAgICAgIGQgLz0gMjsgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHJpZ2h0IHVzaW5nIGludGVnZXIgbWF0aCB1bnRpbFxuICAgICAgeCA+Pj49IDE7ICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgd2UgaGF2ZSBleGFjdGx5IHRoZSBkZXNpcmVkIGJpdHMuXG4gICAgfVxuICAgIHJldHVybiAobiArIHgpIC8gZDsgICAgICAgICAgICAgICAgIC8vIEZvcm0gdGhlIG51bWJlciB3aXRoaW4gWzAsIDEpLlxuICB9O1xuXG4gIHBybmcuaW50MzIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyYzQuZyg0KSB8IDA7IH1cbiAgcHJuZy5xdWljayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJjNC5nKDQpIC8gMHgxMDAwMDAwMDA7IH1cbiAgcHJuZy5kb3VibGUgPSBwcm5nO1xuXG4gIC8vIE1peCB0aGUgcmFuZG9tbmVzcyBpbnRvIGFjY3VtdWxhdGVkIGVudHJvcHkuXG4gIG1peGtleSh0b3N0cmluZyhhcmM0LlMpLCBwb29sKTtcblxuICAvLyBDYWxsaW5nIGNvbnZlbnRpb246IHdoYXQgdG8gcmV0dXJuIGFzIGEgZnVuY3Rpb24gb2YgcHJuZywgc2VlZCwgaXNfbWF0aC5cbiAgcmV0dXJuIChvcHRpb25zLnBhc3MgfHwgY2FsbGJhY2sgfHxcbiAgICAgIGZ1bmN0aW9uKHBybmcsIHNlZWQsIGlzX21hdGhfY2FsbCwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgLy8gTG9hZCB0aGUgYXJjNCBzdGF0ZSBmcm9tIHRoZSBnaXZlbiBzdGF0ZSBpZiBpdCBoYXMgYW4gUyBhcnJheS5cbiAgICAgICAgICBpZiAoc3RhdGUuUykgeyBjb3B5KHN0YXRlLCBhcmM0KTsgfVxuICAgICAgICAgIC8vIE9ubHkgcHJvdmlkZSB0aGUgLnN0YXRlIG1ldGhvZCBpZiByZXF1ZXN0ZWQgdmlhIG9wdGlvbnMuc3RhdGUuXG4gICAgICAgICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weShhcmM0LCB7fSk7IH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGNhbGxlZCBhcyBhIG1ldGhvZCBvZiBNYXRoIChNYXRoLnNlZWRyYW5kb20oKSksIG11dGF0ZVxuICAgICAgICAvLyBNYXRoLnJhbmRvbSBiZWNhdXNlIHRoYXQgaXMgaG93IHNlZWRyYW5kb20uanMgaGFzIHdvcmtlZCBzaW5jZSB2MS4wLlxuICAgICAgICBpZiAoaXNfbWF0aF9jYWxsKSB7IG1hdGhbcm5nbmFtZV0gPSBwcm5nOyByZXR1cm4gc2VlZDsgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgaXQgaXMgYSBuZXdlciBjYWxsaW5nIGNvbnZlbnRpb24sIHNvIHJldHVybiB0aGVcbiAgICAgICAgLy8gcHJuZyBkaXJlY3RseS5cbiAgICAgICAgZWxzZSByZXR1cm4gcHJuZztcbiAgICAgIH0pKFxuICBwcm5nLFxuICBzaG9ydHNlZWQsXG4gICdnbG9iYWwnIGluIG9wdGlvbnMgPyBvcHRpb25zLmdsb2JhbCA6ICh0aGlzID09IG1hdGgpLFxuICBvcHRpb25zLnN0YXRlKTtcbn1cblxuLy9cbi8vIEFSQzRcbi8vXG4vLyBBbiBBUkM0IGltcGxlbWVudGF0aW9uLiAgVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEga2V5IGluIHRoZSBmb3JtIG9mXG4vLyBhbiBhcnJheSBvZiBhdCBtb3N0ICh3aWR0aCkgaW50ZWdlcnMgdGhhdCBzaG91bGQgYmUgMCA8PSB4IDwgKHdpZHRoKS5cbi8vXG4vLyBUaGUgZyhjb3VudCkgbWV0aG9kIHJldHVybnMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciB0aGF0IGNvbmNhdGVuYXRlc1xuLy8gdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGZyb20gQVJDNC4gIEl0cyByZXR1cm4gdmFsdWUgaXMgYSBudW1iZXIgeFxuLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxuLy9cbmZ1bmN0aW9uIEFSQzQoa2V5KSB7XG4gIHZhciB0LCBrZXlsZW4gPSBrZXkubGVuZ3RoLFxuICAgICAgbWUgPSB0aGlzLCBpID0gMCwgaiA9IG1lLmkgPSBtZS5qID0gMCwgcyA9IG1lLlMgPSBbXTtcblxuICAvLyBUaGUgZW1wdHkga2V5IFtdIGlzIHRyZWF0ZWQgYXMgWzBdLlxuICBpZiAoIWtleWxlbikgeyBrZXkgPSBba2V5bGVuKytdOyB9XG5cbiAgLy8gU2V0IHVwIFMgdXNpbmcgdGhlIHN0YW5kYXJkIGtleSBzY2hlZHVsaW5nIGFsZ29yaXRobS5cbiAgd2hpbGUgKGkgPCB3aWR0aCkge1xuICAgIHNbaV0gPSBpKys7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICBzW2ldID0gc1tqID0gbWFzayAmIChqICsga2V5W2kgJSBrZXlsZW5dICsgKHQgPSBzW2ldKSldO1xuICAgIHNbal0gPSB0O1xuICB9XG5cbiAgLy8gVGhlIFwiZ1wiIG1ldGhvZCByZXR1cm5zIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBhcyBvbmUgbnVtYmVyLlxuICAobWUuZyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgLy8gVXNpbmcgaW5zdGFuY2UgbWVtYmVycyBpbnN0ZWFkIG9mIGNsb3N1cmUgc3RhdGUgbmVhcmx5IGRvdWJsZXMgc3BlZWQuXG4gICAgdmFyIHQsIHIgPSAwLFxuICAgICAgICBpID0gbWUuaSwgaiA9IG1lLmosIHMgPSBtZS5TO1xuICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICB0ID0gc1tpID0gbWFzayAmIChpICsgMSldO1xuICAgICAgciA9IHIgKiB3aWR0aCArIHNbbWFzayAmICgoc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIHQpXSkgKyAoc1tqXSA9IHQpKV07XG4gICAgfVxuICAgIG1lLmkgPSBpOyBtZS5qID0gajtcbiAgICByZXR1cm4gcjtcbiAgICAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHksIHRoZSBmdW5jdGlvbiBjYWxsIGJlbG93IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBkaXNjYXJkcyBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy4gIFRoaXMgaXMgY2FsbGVkIFJDNC1kcm9wWzI1Nl0uXG4gICAgLy8gU2VlIGh0dHA6Ly9nb29nbGUuY29tL3NlYXJjaD9xPXJzYStmbHVocmVyK3Jlc3BvbnNlJmJ0bklcbiAgfSkod2lkdGgpO1xufVxuXG4vL1xuLy8gY29weSgpXG4vLyBDb3BpZXMgaW50ZXJuYWwgc3RhdGUgb2YgQVJDNCB0byBvciBmcm9tIGEgcGxhaW4gb2JqZWN0LlxuLy9cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmkgPSBmLmk7XG4gIHQuaiA9IGYuajtcbiAgdC5TID0gZi5TLnNsaWNlKCk7XG4gIHJldHVybiB0O1xufTtcblxuLy9cbi8vIGZsYXR0ZW4oKVxuLy8gQ29udmVydHMgYW4gb2JqZWN0IHRyZWUgdG8gbmVzdGVkIGFycmF5cyBvZiBzdHJpbmdzLlxuLy9cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCkge1xuICB2YXIgcmVzdWx0ID0gW10sIHR5cCA9ICh0eXBlb2Ygb2JqKSwgcHJvcDtcbiAgaWYgKGRlcHRoICYmIHR5cCA9PSAnb2JqZWN0Jykge1xuICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgIHRyeSB7IHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTsgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbiAgcmV0dXJuIChyZXN1bHQubGVuZ3RoID8gcmVzdWx0IDogdHlwID09ICdzdHJpbmcnID8gb2JqIDogb2JqICsgJ1xcMCcpO1xufVxuXG4vL1xuLy8gbWl4a2V5KClcbi8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcbi8vIHJldHVybnMgYSBzaG9ydGVuZWQgc3RyaW5nIHNlZWQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQga2V5LlxuLy9cbmZ1bmN0aW9uIG1peGtleShzZWVkLCBrZXkpIHtcbiAgdmFyIHN0cmluZ3NlZWQgPSBzZWVkICsgJycsIHNtZWFyLCBqID0gMDtcbiAgd2hpbGUgKGogPCBzdHJpbmdzZWVkLmxlbmd0aCkge1xuICAgIGtleVttYXNrICYgal0gPVxuICAgICAgbWFzayAmICgoc21lYXIgXj0ga2V5W21hc2sgJiBqXSAqIDE5KSArIHN0cmluZ3NlZWQuY2hhckNvZGVBdChqKyspKTtcbiAgfVxuICByZXR1cm4gdG9zdHJpbmcoa2V5KTtcbn1cblxuLy9cbi8vIGF1dG9zZWVkKClcbi8vIFJldHVybnMgYW4gb2JqZWN0IGZvciBhdXRvc2VlZGluZywgdXNpbmcgd2luZG93LmNyeXB0byBhbmQgTm9kZSBjcnlwdG9cbi8vIG1vZHVsZSBpZiBhdmFpbGFibGUuXG4vL1xuZnVuY3Rpb24gYXV0b3NlZWQoKSB7XG4gIHRyeSB7XG4gICAgdmFyIG91dDtcbiAgICBpZiAobm9kZWNyeXB0byAmJiAob3V0ID0gbm9kZWNyeXB0by5yYW5kb21CeXRlcykpIHtcbiAgICAgIC8vIFRoZSB1c2Ugb2YgJ291dCcgdG8gcmVtZW1iZXIgcmFuZG9tQnl0ZXMgbWFrZXMgdGlnaHQgbWluaWZpZWQgY29kZS5cbiAgICAgIG91dCA9IG91dCh3aWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoKTtcbiAgICAgIChnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKG91dCk7XG4gICAgfVxuICAgIHJldHVybiB0b3N0cmluZyhvdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGJyb3dzZXIgPSBnbG9iYWwubmF2aWdhdG9yLFxuICAgICAgICBwbHVnaW5zID0gYnJvd3NlciAmJiBicm93c2VyLnBsdWdpbnM7XG4gICAgcmV0dXJuIFsrbmV3IERhdGUsIGdsb2JhbCwgcGx1Z2lucywgZ2xvYmFsLnNjcmVlbiwgdG9zdHJpbmcocG9vbCldO1xuICB9XG59XG5cbi8vXG4vLyB0b3N0cmluZygpXG4vLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBjaGFyY29kZXMgdG8gYSBzdHJpbmdcbi8vXG5mdW5jdGlvbiB0b3N0cmluZyhhKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsIGEpO1xufVxuXG4vL1xuLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbi8vIGZyb20gdGhlIGJ1aWx0LWluIFJORyBpbnRvIHRoZSBlbnRyb3B5IHBvb2wuICBCZWNhdXNlIHdlIGRvXG4vLyBub3Qgd2FudCB0byBpbnRlcmZlcmUgd2l0aCBkZXRlcm1pbmlzdGljIFBSTkcgc3RhdGUgbGF0ZXIsXG4vLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxuLy8gaW5pdGlhbGl6YXRpb24uXG4vL1xubWl4a2V5KG1hdGgucmFuZG9tKCksIHBvb2wpO1xuXG4vL1xuLy8gTm9kZWpzIGFuZCBBTUQgc3VwcG9ydDogZXhwb3J0IHRoZSBpbXBsZW1lbnRhdGlvbiBhcyBhIG1vZHVsZSB1c2luZ1xuLy8gZWl0aGVyIGNvbnZlbnRpb24uXG4vL1xuaWYgKCh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHNlZWRyYW5kb207XG4gIC8vIFdoZW4gaW4gbm9kZS5qcywgdHJ5IHVzaW5nIGNyeXB0byBwYWNrYWdlIGZvciBhdXRvc2VlZGluZy5cbiAgdHJ5IHtcbiAgICBub2RlY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gIH0gY2F0Y2ggKGV4KSB7fVxufSBlbHNlIGlmICgodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHNlZWRyYW5kb207IH0pO1xufSBlbHNlIHtcbiAgLy8gV2hlbiBpbmNsdWRlZCBhcyBhIHBsYWluIHNjcmlwdCwgc2V0IHVwIE1hdGguc2VlZHJhbmRvbSBnbG9iYWwuXG4gIG1hdGhbJ3NlZWQnICsgcm5nbmFtZV0gPSBzZWVkcmFuZG9tO1xufVxuXG5cbi8vIEVuZCBhbm9ueW1vdXMgc2NvcGUsIGFuZCBwYXNzIGluaXRpYWwgdmFsdWVzLlxufSkoXG4gIC8vIGdsb2JhbDogYHNlbGZgIGluIGJyb3dzZXJzIChpbmNsdWRpbmcgc3RyaWN0IG1vZGUgYW5kIHdlYiB3b3JrZXJzKSxcbiAgLy8gb3RoZXJ3aXNlIGB0aGlzYCBpbiBOb2RlIGFuZCBvdGhlciBlbnZpcm9ubWVudHNcbiAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykgPyBzZWxmIDogdGhpcyxcbiAgW10sICAgICAvLyBwb29sOiBlbnRyb3B5IHBvb2wgc3RhcnRzIGVtcHR5XG4gIE1hdGggICAgLy8gbWF0aDogcGFja2FnZSBjb250YWluaW5nIHJhbmRvbSwgcG93LCBhbmQgc2VlZHJhbmRvbVxuKTtcbiIsImltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgdnRrRGF0YUFycmF5IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL0RhdGFBcnJheSc7XG5pbXBvcnQgeyBWdGtEYXRhVHlwZXMgfSBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9EYXRhQXJyYXkvQ29uc3RhbnRzJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gR2xvYmFsIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gZXh0cmFjdENlbGxTaXplcyhjZWxsQXJyYXkpIHtcbiAgbGV0IGN1cnJlbnRJZHggPSAwO1xuICByZXR1cm4gY2VsbEFycmF5LmZpbHRlcigodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgaWYgKGluZGV4ID09PSBjdXJyZW50SWR4KSB7XG4gICAgICBjdXJyZW50SWR4ICs9IHZhbHVlICsgMTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXROdW1iZXJPZkNlbGxzKGNlbGxBcnJheSkge1xuICByZXR1cm4gZXh0cmFjdENlbGxTaXplcyhjZWxsQXJyYXkpLmxlbmd0aDtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU3RhdGljIEFQSVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgU1RBVElDID0ge1xuICBleHRyYWN0Q2VsbFNpemVzLFxuICBnZXROdW1iZXJPZkNlbGxzLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrQ2VsbEFycmF5IG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrQ2VsbEFycmF5KHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrQ2VsbEFycmF5Jyk7XG5cbiAgcHVibGljQVBJLmdldE51bWJlck9mQ2VsbHMgPSAocmVjb21wdXRlKSA9PiB7XG4gICAgaWYgKG1vZGVsLm51bWJlck9mQ2VsbHMgIT09IHVuZGVmaW5lZCAmJiAhcmVjb21wdXRlKSB7XG4gICAgICByZXR1cm4gbW9kZWwubnVtYmVyT2ZDZWxscztcbiAgICB9XG5cbiAgICBtb2RlbC5jZWxsU2l6ZXMgPSBleHRyYWN0Q2VsbFNpemVzKG1vZGVsLnZhbHVlcyk7XG4gICAgbW9kZWwubnVtYmVyT2ZDZWxscyA9IG1vZGVsLmNlbGxTaXplcy5sZW5ndGg7XG4gICAgcmV0dXJuIG1vZGVsLm51bWJlck9mQ2VsbHM7XG4gIH07XG5cbiAgcHVibGljQVBJLmdldENlbGxTaXplcyA9IChyZWNvbXB1dGUpID0+IHtcbiAgICBpZiAobW9kZWwuY2VsbFNpemVzICE9PSB1bmRlZmluZWQgJiYgIXJlY29tcHV0ZSkge1xuICAgICAgcmV0dXJuIG1vZGVsLmNlbGxTaXplcztcbiAgICB9XG5cbiAgICBtb2RlbC5jZWxsU2l6ZXMgPSBleHRyYWN0Q2VsbFNpemVzKG1vZGVsLnZhbHVlcyk7XG4gICAgcmV0dXJuIG1vZGVsLmNlbGxTaXplcztcbiAgfTtcblxuICBjb25zdCBzdXBlclNldERhdGEgPSBwdWJsaWNBUEkuc2V0RGF0YTtcbiAgcHVibGljQVBJLnNldERhdGEgPSAodHlwZWRBcnJheSkgPT4ge1xuICAgIHN1cGVyU2V0RGF0YSh0eXBlZEFycmF5LCAxKTtcbiAgICBtb2RlbC5udW1iZXJPZkNlbGxzID0gdW5kZWZpbmVkO1xuICAgIG1vZGVsLmNlbGxTaXplcyA9IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcG9pbnQgaW5kZXhlcyBhdCB0aGUgZ2l2ZW4gbG9jYXRpb24gYXMgYSBzdWJhcnJheS5cbiAgICovXG4gIHB1YmxpY0FQSS5nZXRDZWxsID0gKGxvYykgPT4ge1xuICAgIGxldCBjZWxsTG9jID0gbG9jO1xuICAgIGNvbnN0IG51bWJlck9mUG9pbnRzID0gbW9kZWwudmFsdWVzW2NlbGxMb2MrK107XG4gICAgcmV0dXJuIG1vZGVsLnZhbHVlcy5zdWJhcnJheShjZWxsTG9jLCBjZWxsTG9jICsgbnVtYmVyT2ZQb2ludHMpO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgZW1wdHk6IHRydWUsXG4gIG51bWJlck9mQ29tcG9uZW50czogMSxcbiAgZGF0YVR5cGU6IFZ0a0RhdGFUeXBlcy5VTlNJR05FRF9JTlQsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICB2dGtEYXRhQXJyYXkuZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMpO1xuICB2dGtDZWxsQXJyYXkocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrQ2VsbEFycmF5Jyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kLCAuLi5TVEFUSUMgfTtcbiIsImV4cG9ydCBjb25zdCBEYXRhVHlwZUJ5dGVTaXplID0ge1xuICBJbnQ4QXJyYXk6IDEsXG4gIFVpbnQ4QXJyYXk6IDEsXG4gIFVpbnQ4Q2xhbXBlZEFycmF5OiAxLFxuICBJbnQxNkFycmF5OiAyLFxuICBVaW50MTZBcnJheTogMixcbiAgSW50MzJBcnJheTogNCxcbiAgVWludDMyQXJyYXk6IDQsXG4gIEZsb2F0MzJBcnJheTogNCxcbiAgRmxvYXQ2NEFycmF5OiA4LFxufTtcblxuZXhwb3J0IGNvbnN0IFZ0a0RhdGFUeXBlcyA9IHtcbiAgVk9JRDogJycsIC8vIG5vdCBzdXJlIHRvIGtub3cgd2hhdCB0aGF0IHNob3VsZCBiZVxuICBDSEFSOiAnSW50OEFycmF5JyxcbiAgU0lHTkVEX0NIQVI6ICdJbnQ4QXJyYXknLFxuICBVTlNJR05FRF9DSEFSOiAnVWludDhBcnJheScsXG4gIFNIT1JUOiAnSW50MTZBcnJheScsXG4gIFVOU0lHTkVEX1NIT1JUOiAnVWludDE2QXJyYXknLFxuICBJTlQ6ICdJbnQzMkFycmF5JyxcbiAgVU5TSUdORURfSU5UOiAnVWludDMyQXJyYXknLFxuICBGTE9BVDogJ0Zsb2F0MzJBcnJheScsXG4gIERPVUJMRTogJ0Zsb2F0NjRBcnJheScsXG59O1xuXG5leHBvcnQgY29uc3QgRGVmYXVsdERhdGFUeXBlID0gVnRrRGF0YVR5cGVzLkZMT0FUO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIERlZmF1bHREYXRhVHlwZSxcbiAgRGF0YVR5cGVCeXRlU2l6ZSxcbiAgVnRrRGF0YVR5cGVzLFxufTtcbiIsImltcG9ydCBDb25zdGFudHMgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvRGF0YUFycmF5L0NvbnN0YW50cyc7XG5pbXBvcnQgKiBhcyBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgKiBhcyB2dGtNYXRoIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL01hdGgnO1xuXG5jb25zdCB7IERlZmF1bHREYXRhVHlwZSB9ID0gQ29uc3RhbnRzO1xuY29uc3QgVFVQTEVfSE9MREVSID0gW107XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdsb2JhbCBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGNyZWF0ZVJhbmdlSGVscGVyKCkge1xuICBsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgbGV0IG1heCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgc3VtID0gMDtcblxuICByZXR1cm4ge1xuICAgIGFkZCh2YWx1ZSkge1xuICAgICAgaWYgKG1pbiA+IHZhbHVlKSB7XG4gICAgICAgIG1pbiA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKG1heCA8IHZhbHVlKSB7XG4gICAgICAgIG1heCA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgY291bnQrKztcbiAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB7IG1pbiwgbWF4LCBjb3VudCwgc3VtLCBtZWFuOiBzdW0gLyBjb3VudCB9O1xuICAgIH0sXG4gICAgZ2V0UmFuZ2UoKSB7XG4gICAgICByZXR1cm4geyBtaW4sIG1heCB9O1xuICAgIH0sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVSYW5nZSh2YWx1ZXMsIGNvbXBvbmVudCA9IDAsIG51bWJlck9mQ29tcG9uZW50cyA9IDEpIHtcbiAgY29uc3QgaGVscGVyID0gY3JlYXRlUmFuZ2VIZWxwZXIoKTtcbiAgY29uc3Qgc2l6ZSA9IHZhbHVlcy5sZW5ndGg7XG4gIGxldCB2YWx1ZSA9IDA7XG5cbiAgaWYgKGNvbXBvbmVudCA8IDAgJiYgbnVtYmVyT2ZDb21wb25lbnRzID4gMSkge1xuICAgIC8vIENvbXB1dGUgbWFnbml0dWRlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpICs9IG51bWJlck9mQ29tcG9uZW50cykge1xuICAgICAgdmFsdWUgPSAwO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1iZXJPZkNvbXBvbmVudHM7IGorKykge1xuICAgICAgICB2YWx1ZSArPSB2YWx1ZXNbaSArIGpdICogdmFsdWVzW2kgKyBqXTtcbiAgICAgIH1cbiAgICAgIHZhbHVlICoqPSAwLjU7XG4gICAgICBoZWxwZXIuYWRkKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlbHBlci5nZXRSYW5nZSgpO1xuICB9XG5cbiAgY29uc3Qgb2Zmc2V0ID0gY29tcG9uZW50IDwgMCA/IDAgOiBjb21wb25lbnQ7XG4gIGZvciAobGV0IGkgPSBvZmZzZXQ7IGkgPCBzaXplOyBpICs9IG51bWJlck9mQ29tcG9uZW50cykge1xuICAgIGhlbHBlci5hZGQodmFsdWVzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBoZWxwZXIuZ2V0UmFuZ2UoKTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlUmFuZ2VTaXplKHJhbmdlQXJyYXksIHNpemUgPSAwKSB7XG4gIGNvbnN0IHJhbmdlcyA9IHJhbmdlQXJyYXkgfHwgW107XG4gIC8vIFBhZCByYW5nZXMgd2l0aCBudWxsIHZhbHVlIHRvIGdldCB0aGVcbiAgd2hpbGUgKHJhbmdlcy5sZW5ndGggPD0gc2l6ZSkge1xuICAgIHJhbmdlcy5wdXNoKG51bGwpO1xuICB9XG4gIHJldHVybiByYW5nZXM7XG59XG5cbmZ1bmN0aW9uIGdldERhdGFUeXBlKHR5cGVkQXJyYXkpIHtcbiAgLy8gRXhwZWN0cyB0b1N0cmluZygpIHRvIHJldHVybiBcIltvYmplY3QgLi4uQXJyYXldXCJcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0eXBlZEFycmF5KS5zbGljZSg4LCAtMSk7XG59XG5cbmZ1bmN0aW9uIGdldE1heE5vcm0obm9ybUFycmF5KSB7XG4gIGNvbnN0IG51bUNvbXBzID0gbm9ybUFycmF5LmdldE51bWJlck9mQ29tcG9uZW50cygpO1xuICBsZXQgbWF4Tm9ybSA9IDAuMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub3JtQXJyYXkuZ2V0TnVtYmVyT2ZUdXBsZXMoKTsgKytpKSB7XG4gICAgY29uc3Qgbm9ybSA9IHZ0a01hdGgubm9ybShub3JtQXJyYXkuZ2V0VHVwbGUoaSksIG51bUNvbXBzKTtcbiAgICBpZiAobm9ybSA+IG1heE5vcm0pIHtcbiAgICAgIG1heE5vcm0gPSBub3JtO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWF4Tm9ybTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU3RhdGljIEFQSVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgU1RBVElDID0ge1xuICBjb21wdXRlUmFuZ2UsXG4gIGNyZWF0ZVJhbmdlSGVscGVyLFxuICBnZXREYXRhVHlwZSxcbiAgZ2V0TWF4Tm9ybSxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a0RhdGFBcnJheSBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a0RhdGFBcnJheShwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a0RhdGFBcnJheScpO1xuXG4gIGZ1bmN0aW9uIGRhdGFDaGFuZ2UoKSB7XG4gICAgbW9kZWwucmFuZ2VzID0gbnVsbDtcbiAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgfVxuXG4gIHB1YmxpY0FQSS5nZXRFbGVtZW50Q29tcG9uZW50U2l6ZSA9ICgpID0+IG1vZGVsLnZhbHVlcy5CWVRFU19QRVJfRUxFTUVOVDtcblxuICAvLyBEZXNjcmlwdGlvbjpcbiAgLy8gUmV0dXJuIHRoZSBkYXRhIGNvbXBvbmVudCBhdCB0aGUgbG9jYXRpb24gc3BlY2lmaWVkIGJ5IHR1cGxlSWR4IGFuZFxuICAvLyBjb21wSWR4LlxuICBwdWJsaWNBUEkuZ2V0Q29tcG9uZW50ID0gKHR1cGxlSWR4LCBjb21wSWR4ID0gMCkgPT5cbiAgICBtb2RlbC52YWx1ZXNbdHVwbGVJZHggKiBtb2RlbC5udW1iZXJPZkNvbXBvbmVudHMgKyBjb21wSWR4XTtcblxuICAvLyBEZXNjcmlwdGlvbjpcbiAgLy8gU2V0IHRoZSBkYXRhIGNvbXBvbmVudCBhdCB0aGUgbG9jYXRpb24gc3BlY2lmaWVkIGJ5IHR1cGxlSWR4IGFuZCBjb21wSWR4XG4gIC8vIHRvIHZhbHVlLlxuICAvLyBOb3RlIHRoYXQgaSBpcyBsZXNzIHRoYW4gTnVtYmVyT2ZUdXBsZXMgYW5kIGogaXMgbGVzcyB0aGFuXG4gIC8vICBOdW1iZXJPZkNvbXBvbmVudHMuIE1ha2Ugc3VyZSBlbm91Z2ggbWVtb3J5IGhhcyBiZWVuIGFsbG9jYXRlZFxuICAvLyAodXNlIFNldE51bWJlck9mVHVwbGVzKCkgYW5kIFNldE51bWJlck9mQ29tcG9uZW50cygpKS5cbiAgcHVibGljQVBJLnNldENvbXBvbmVudCA9ICh0dXBsZUlkeCwgY29tcElkeCwgdmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgIT09IG1vZGVsLnZhbHVlc1t0dXBsZUlkeCAqIG1vZGVsLm51bWJlck9mQ29tcG9uZW50cyArIGNvbXBJZHhdKSB7XG4gICAgICBtb2RlbC52YWx1ZXNbdHVwbGVJZHggKiBtb2RlbC5udW1iZXJPZkNvbXBvbmVudHMgKyBjb21wSWR4XSA9IHZhbHVlO1xuICAgICAgZGF0YUNoYW5nZSgpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0RGF0YSA9ICgpID0+IG1vZGVsLnZhbHVlcztcblxuICBwdWJsaWNBUEkuZ2V0UmFuZ2UgPSAoY29tcG9uZW50SW5kZXggPSAtMSkgPT4ge1xuICAgIGNvbnN0IHJhbmdlSWR4ID1cbiAgICAgIGNvbXBvbmVudEluZGV4IDwgMCA/IG1vZGVsLm51bWJlck9mQ29tcG9uZW50cyA6IGNvbXBvbmVudEluZGV4O1xuICAgIGxldCByYW5nZSA9IG51bGw7XG5cbiAgICBpZiAoIW1vZGVsLnJhbmdlcykge1xuICAgICAgbW9kZWwucmFuZ2VzID0gZW5zdXJlUmFuZ2VTaXplKG1vZGVsLnJhbmdlcywgbW9kZWwubnVtYmVyT2ZDb21wb25lbnRzKTtcbiAgICB9XG4gICAgcmFuZ2UgPSBtb2RlbC5yYW5nZXNbcmFuZ2VJZHhdO1xuXG4gICAgaWYgKHJhbmdlKSB7XG4gICAgICBtb2RlbC5yYW5nZVR1cGxlWzBdID0gcmFuZ2UubWluO1xuICAgICAgbW9kZWwucmFuZ2VUdXBsZVsxXSA9IHJhbmdlLm1heDtcbiAgICAgIHJldHVybiBtb2RlbC5yYW5nZVR1cGxlO1xuICAgIH1cblxuICAgIC8vIE5lZWQgdG8gY29tcHV0ZSByYW5nZXMuLi5cbiAgICByYW5nZSA9IGNvbXB1dGVSYW5nZShcbiAgICAgIG1vZGVsLnZhbHVlcyxcbiAgICAgIGNvbXBvbmVudEluZGV4LFxuICAgICAgbW9kZWwubnVtYmVyT2ZDb21wb25lbnRzXG4gICAgKTtcbiAgICBtb2RlbC5yYW5nZXNbcmFuZ2VJZHhdID0gcmFuZ2U7XG4gICAgbW9kZWwucmFuZ2VUdXBsZVswXSA9IHJhbmdlLm1pbjtcbiAgICBtb2RlbC5yYW5nZVR1cGxlWzFdID0gcmFuZ2UubWF4O1xuICAgIHJldHVybiBtb2RlbC5yYW5nZVR1cGxlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRSYW5nZSA9IChyYW5nZVZhbHVlLCBjb21wb25lbnRJbmRleCkgPT4ge1xuICAgIGlmICghbW9kZWwucmFuZ2VzKSB7XG4gICAgICBtb2RlbC5yYW5nZXMgPSBlbnN1cmVSYW5nZVNpemUobW9kZWwucmFuZ2VzLCBtb2RlbC5udW1iZXJPZkNvbXBvbmVudHMpO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IHsgbWluOiByYW5nZVZhbHVlLm1pbiwgbWF4OiByYW5nZVZhbHVlLm1heCB9O1xuXG4gICAgbW9kZWwucmFuZ2VzW2NvbXBvbmVudEluZGV4XSA9IHJhbmdlO1xuICAgIG1vZGVsLnJhbmdlVHVwbGVbMF0gPSByYW5nZS5taW47XG4gICAgbW9kZWwucmFuZ2VUdXBsZVsxXSA9IHJhbmdlLm1heDtcblxuICAgIHJldHVybiBtb2RlbC5yYW5nZVR1cGxlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRUdXBsZSA9IChpZHgsIHR1cGxlKSA9PiB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gaWR4ICogbW9kZWwubnVtYmVyT2ZDb21wb25lbnRzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kZWwubnVtYmVyT2ZDb21wb25lbnRzOyBpKyspIHtcbiAgICAgIG1vZGVsLnZhbHVlc1tvZmZzZXQgKyBpXSA9IHR1cGxlW2ldO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0VHVwbGUgPSAoaWR4LCB0dXBsZVRvRmlsbCA9IFRVUExFX0hPTERFUikgPT4ge1xuICAgIGNvbnN0IG51bWJlck9mQ29tcG9uZW50cyA9IG1vZGVsLm51bWJlck9mQ29tcG9uZW50cyB8fCAxO1xuICAgIGlmICh0dXBsZVRvRmlsbC5sZW5ndGggIT09IG51bWJlck9mQ29tcG9uZW50cykge1xuICAgICAgdHVwbGVUb0ZpbGwubGVuZ3RoID0gbnVtYmVyT2ZDb21wb25lbnRzO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXQgPSBpZHggKiBudW1iZXJPZkNvbXBvbmVudHM7XG4gICAgLy8gQ2hlY2sgbW9zdCBjb21tb24gY29tcG9uZW50IHNpemVzIGZpcnN0XG4gICAgLy8gdG8gYXZvaWQgZG9pbmcgYSBmb3IgbG9vcCBpZiBwb3NzaWJsZVxuICAgIGlmIChudW1iZXJPZkNvbXBvbmVudHMgPT09IDEpIHtcbiAgICAgIHR1cGxlVG9GaWxsWzBdID0gbW9kZWwudmFsdWVzW29mZnNldF07XG4gICAgfSBlbHNlIGlmIChudW1iZXJPZkNvbXBvbmVudHMgPT09IDIpIHtcbiAgICAgIHR1cGxlVG9GaWxsWzBdID0gbW9kZWwudmFsdWVzW29mZnNldF07XG4gICAgICB0dXBsZVRvRmlsbFsxXSA9IG1vZGVsLnZhbHVlc1tvZmZzZXQgKyAxXTtcbiAgICB9IGVsc2UgaWYgKG51bWJlck9mQ29tcG9uZW50cyA9PT0gMykge1xuICAgICAgdHVwbGVUb0ZpbGxbMF0gPSBtb2RlbC52YWx1ZXNbb2Zmc2V0XTtcbiAgICAgIHR1cGxlVG9GaWxsWzFdID0gbW9kZWwudmFsdWVzW29mZnNldCArIDFdO1xuICAgICAgdHVwbGVUb0ZpbGxbMl0gPSBtb2RlbC52YWx1ZXNbb2Zmc2V0ICsgMl07XG4gICAgfSBlbHNlIGlmIChudW1iZXJPZkNvbXBvbmVudHMgPT09IDQpIHtcbiAgICAgIHR1cGxlVG9GaWxsWzBdID0gbW9kZWwudmFsdWVzW29mZnNldF07XG4gICAgICB0dXBsZVRvRmlsbFsxXSA9IG1vZGVsLnZhbHVlc1tvZmZzZXQgKyAxXTtcbiAgICAgIHR1cGxlVG9GaWxsWzJdID0gbW9kZWwudmFsdWVzW29mZnNldCArIDJdO1xuICAgICAgdHVwbGVUb0ZpbGxbM10gPSBtb2RlbC52YWx1ZXNbb2Zmc2V0ICsgM107XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDb21wb25lbnRzOyBpKyspIHtcbiAgICAgICAgdHVwbGVUb0ZpbGxbaV0gPSBtb2RlbC52YWx1ZXNbb2Zmc2V0ICsgaV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0dXBsZVRvRmlsbDtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0VHVwbGVMb2NhdGlvbiA9IChpZHggPSAxKSA9PiBpZHggKiBtb2RlbC5udW1iZXJPZkNvbXBvbmVudHM7XG4gIHB1YmxpY0FQSS5nZXROdW1iZXJPZkNvbXBvbmVudHMgPSAoKSA9PiBtb2RlbC5udW1iZXJPZkNvbXBvbmVudHM7XG4gIHB1YmxpY0FQSS5nZXROdW1iZXJPZlZhbHVlcyA9ICgpID0+IG1vZGVsLnZhbHVlcy5sZW5ndGg7XG4gIHB1YmxpY0FQSS5nZXROdW1iZXJPZlR1cGxlcyA9ICgpID0+XG4gICAgbW9kZWwudmFsdWVzLmxlbmd0aCAvIG1vZGVsLm51bWJlck9mQ29tcG9uZW50cztcbiAgcHVibGljQVBJLmdldERhdGFUeXBlID0gKCkgPT4gbW9kZWwuZGF0YVR5cGU7XG4gIC8qIGVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG4gIHB1YmxpY0FQSS5uZXdDbG9uZSA9ICgpID0+XG4gICAgbmV3SW5zdGFuY2Uoe1xuICAgICAgZW1wdHk6IHRydWUsXG4gICAgICBuYW1lOiBtb2RlbC5uYW1lLFxuICAgICAgZGF0YVR5cGU6IG1vZGVsLmRhdGFUeXBlLFxuICAgICAgbnVtYmVyT2ZDb21wb25lbnRzOiBtb2RlbC5udW1iZXJPZkNvbXBvbmVudHMsXG4gICAgfSk7XG4gIC8qIGVzbGludC1lbmFibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cblxuICBwdWJsaWNBUEkuZ2V0TmFtZSA9ICgpID0+IHtcbiAgICBpZiAoIW1vZGVsLm5hbWUpIHtcbiAgICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICAgICAgbW9kZWwubmFtZSA9IGB2dGtEYXRhQXJyYXkke3B1YmxpY0FQSS5nZXRNVGltZSgpfWA7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbC5uYW1lO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXREYXRhID0gKHR5cGVkQXJyYXksIG51bWJlck9mQ29tcG9uZW50cykgPT4ge1xuICAgIG1vZGVsLnZhbHVlcyA9IHR5cGVkQXJyYXk7XG4gICAgbW9kZWwuc2l6ZSA9IHR5cGVkQXJyYXkubGVuZ3RoO1xuICAgIG1vZGVsLmRhdGFUeXBlID0gZ2V0RGF0YVR5cGUodHlwZWRBcnJheSk7XG4gICAgaWYgKG51bWJlck9mQ29tcG9uZW50cykge1xuICAgICAgbW9kZWwubnVtYmVyT2ZDb21wb25lbnRzID0gbnVtYmVyT2ZDb21wb25lbnRzO1xuICAgIH1cbiAgICBpZiAobW9kZWwuc2l6ZSAlIG1vZGVsLm51bWJlck9mQ29tcG9uZW50cyAhPT0gMCkge1xuICAgICAgbW9kZWwubnVtYmVyT2ZDb21wb25lbnRzID0gMTtcbiAgICB9XG4gICAgZGF0YUNoYW5nZSgpO1xuICB9O1xuXG4gIC8vIE92ZXJyaWRlIHNlcmlhbGl6YXRpb24gc3VwcG9ydFxuICBwdWJsaWNBUEkuZ2V0U3RhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QganNvbkFyY2hpdmUgPSB7IC4uLm1vZGVsLCB2dGtDbGFzczogcHVibGljQVBJLmdldENsYXNzTmFtZSgpIH07XG5cbiAgICAvLyBDb252ZXJ0IHR5cGVkIGFycmF5IHRvIHJlZ3VsYXIgYXJyYXlcbiAgICBqc29uQXJjaGl2ZS52YWx1ZXMgPSBBcnJheS5mcm9tKGpzb25BcmNoaXZlLnZhbHVlcyk7XG4gICAgZGVsZXRlIGpzb25BcmNoaXZlLmJ1ZmZlcjtcblxuICAgIC8vIENsZWFuIGFueSBlbXB0eSBkYXRhXG4gICAgT2JqZWN0LmtleXMoanNvbkFyY2hpdmUpLmZvckVhY2goKGtleU5hbWUpID0+IHtcbiAgICAgIGlmICghanNvbkFyY2hpdmVba2V5TmFtZV0pIHtcbiAgICAgICAgZGVsZXRlIGpzb25BcmNoaXZlW2tleU5hbWVdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU29ydCByZXN1bHRpbmcgb2JqZWN0IGJ5IGtleSBuYW1lXG4gICAgY29uc3Qgc29ydGVkT2JqID0ge307XG4gICAgT2JqZWN0LmtleXMoanNvbkFyY2hpdmUpXG4gICAgICAuc29ydCgpXG4gICAgICAuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICBzb3J0ZWRPYmpbbmFtZV0gPSBqc29uQXJjaGl2ZVtuYW1lXTtcbiAgICAgIH0pO1xuXG4gICAgLy8gUmVtb3ZlIG10aW1lXG4gICAgaWYgKHNvcnRlZE9iai5tdGltZSkge1xuICAgICAgZGVsZXRlIHNvcnRlZE9iai5tdGltZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc29ydGVkT2JqO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgbmFtZTogJycsXG4gIG51bWJlck9mQ29tcG9uZW50czogMSxcbiAgc2l6ZTogMCxcbiAgZGF0YVR5cGU6IERlZmF1bHREYXRhVHlwZSxcbiAgcmFuZ2VUdXBsZTogWzAsIDBdLFxuICAvLyB2YWx1ZXM6IG51bGwsXG4gIC8vIHJhbmdlczogbnVsbCxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIGlmICghbW9kZWwuZW1wdHkgJiYgIW1vZGVsLnZhbHVlcyAmJiAhbW9kZWwuc2l6ZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnQ2Fubm90IGNyZWF0ZSB2dGtEYXRhQXJyYXkgb2JqZWN0IHdpdGhvdXQ6IHNpemUgPiAwLCB2YWx1ZXMnXG4gICAgKTtcbiAgfVxuXG4gIGlmICghbW9kZWwudmFsdWVzKSB7XG4gICAgbW9kZWwudmFsdWVzID0gbmV3IHdpbmRvd1ttb2RlbC5kYXRhVHlwZV0obW9kZWwuc2l6ZSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtb2RlbC52YWx1ZXMpKSB7XG4gICAgbW9kZWwudmFsdWVzID0gd2luZG93W21vZGVsLmRhdGFUeXBlXS5mcm9tKG1vZGVsLnZhbHVlcyk7XG4gIH1cblxuICBpZiAobW9kZWwudmFsdWVzKSB7XG4gICAgbW9kZWwuc2l6ZSA9IG1vZGVsLnZhbHVlcy5sZW5ndGg7XG4gICAgbW9kZWwuZGF0YVR5cGUgPSBnZXREYXRhVHlwZShtb2RlbC52YWx1ZXMpO1xuICB9XG5cbiAgLy8gT2JqZWN0IG1ldGhvZHNcbiAgbWFjcm8ub2JqKHB1YmxpY0FQSSwgbW9kZWwpO1xuICBtYWNyby5zZXQocHVibGljQVBJLCBtb2RlbCwgWyduYW1lJywgJ251bWJlck9mQ29tcG9uZW50cyddKTtcblxuICAvLyBPYmplY3Qgc3BlY2lmaWMgbWV0aG9kc1xuICB2dGtEYXRhQXJyYXkocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrRGF0YUFycmF5Jyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kLCAuLi5TVEFUSUMsIC4uLkNvbnN0YW50cyB9O1xuIiwiaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCAqIGFzIHZ0a01hdGggZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvTWF0aCc7XG5pbXBvcnQgdnRrU2NhbGFyc1RvQ29sb3JzIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL1NjYWxhcnNUb0NvbG9ycyc7XG5pbXBvcnQgeyBTY2FsYXJNYXBwaW5nVGFyZ2V0IH0gZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvU2NhbGFyc1RvQ29sb3JzL0NvbnN0YW50cyc7XG5cbmltcG9ydCB7IFZ0a0RhdGFUeXBlcyB9IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL0RhdGFBcnJheS9Db25zdGFudHMnO1xuXG5jb25zdCB7IHZ0a0Vycm9yTWFjcm8gfSA9IG1hY3JvO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBHbG9iYWwgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyBBZGQgbW9kdWxlLWxldmVsIGZ1bmN0aW9ucyBvciBhcGkgdGhhdCB5b3Ugd2FudCB0byBleHBvc2Ugc3RhdGljYWxseSB2aWFcbi8vIHRoZSBuZXh0IHNlY3Rpb24uLi5cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU3RhdGljIEFQSVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBCRUxPV19SQU5HRV9DT0xPUl9JTkRFWCA9IDA7XG5jb25zdCBBQk9WRV9SQU5HRV9DT0xPUl9JTkRFWCA9IDE7XG5jb25zdCBOQU5fQ09MT1JfSU5ERVggPSAyO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtNeUNsYXNzIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrTG9va3VwVGFibGUocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtMb29rdXBUYWJsZScpO1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBEZXNjcmlwdGlvbjpcbiAgLy8gUmV0dXJuIHRydWUgaWYgYWxsIG9mIHRoZSB2YWx1ZXMgZGVmaW5pbmcgdGhlIG1hcHBpbmcgaGF2ZSBhbiBvcGFjaXR5XG4gIC8vIGVxdWFsIHRvIDEuIERlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJuIHRydWUuXG4gIHB1YmxpY0FQSS5pc09wYXF1ZSA9ICgpID0+IHtcbiAgICBpZiAobW9kZWwub3BhcXVlRmxhZ0J1aWxkVGltZS5nZXRNVGltZSgpIDwgcHVibGljQVBJLmdldE1UaW1lKCkpIHtcbiAgICAgIGxldCBvcGFxdWUgPSB0cnVlO1xuICAgICAgaWYgKG1vZGVsLm5hbkNvbG9yWzNdIDwgMS4wKSB7XG4gICAgICAgIG9wYXF1ZSA9IDA7XG4gICAgICB9XG4gICAgICBpZiAobW9kZWwudXNlQmVsb3dSYW5nZUNvbG9yICYmIG1vZGVsLmJlbG93UmFuZ2VDb2xvclszXSA8IDEuMCkge1xuICAgICAgICBvcGFxdWUgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKG1vZGVsLnVzZUFib3ZlUmFuZ2VDb2xvciAmJiBtb2RlbC5hYm92ZVJhbmdlQ29sb3JbM10gPCAxLjApIHtcbiAgICAgICAgb3BhcXVlID0gMDtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAzOyBpIDwgbW9kZWwudGFibGUubGVuZ3RoICYmIG9wYXF1ZTsgaSArPSA0KSB7XG4gICAgICAgIGlmIChtb2RlbC50YWJsZVtpXSA8IDI1NSkge1xuICAgICAgICAgIG9wYXF1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtb2RlbC5vcGFxdWVGbGFnID0gb3BhcXVlO1xuICAgICAgbW9kZWwub3BhcXVlRmxhZ0J1aWxkVGltZS5tb2RpZmllZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlbC5vcGFxdWVGbGFnO1xuICB9O1xuXG4gIHB1YmxpY0FQSS51c2luZ0xvZ1NjYWxlID0gKCkgPT4gZmFsc2U7XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5nZXROdW1iZXJPZkF2YWlsYWJsZUNvbG9ycyA9ICgpID0+IG1vZGVsLnRhYmxlLmxlbmd0aDtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQXBwbHkgc2hpZnQvc2NhbGUgdG8gdGhlIHNjYWxhciB2YWx1ZSB2IGFuZCByZXR1cm4gdGhlIGluZGV4LlxuICBwdWJsaWNBUEkubGluZWFySW5kZXhMb29rdXAgPSAodiwgcCkgPT4ge1xuICAgIGxldCBkSW5kZXggPSAwO1xuXG4gICAgaWYgKHYgPCBwLnJhbmdlWzBdKSB7XG4gICAgICBkSW5kZXggPSBwLm1heEluZGV4ICsgQkVMT1dfUkFOR0VfQ09MT1JfSU5ERVggKyAxLjU7XG4gICAgfSBlbHNlIGlmICh2ID4gcC5yYW5nZVsxXSkge1xuICAgICAgZEluZGV4ID0gcC5tYXhJbmRleCArIEFCT1ZFX1JBTkdFX0NPTE9SX0lOREVYICsgMS41O1xuICAgIH0gZWxzZSB7XG4gICAgICBkSW5kZXggPSAodiArIHAuc2hpZnQpICogcC5zY2FsZTtcblxuICAgICAgLy8gVGhpcyBjb25kaXRpb25hbCBpcyBuZWVkZWQgYmVjYXVzZSB3aGVuIHYgaXMgdmVyeSBjbG9zZSB0b1xuICAgICAgLy8gcC5SYW5nZVsxXSwgaXQgbWF5IG1hcCBhYm92ZSBwLk1heEluZGV4IGluIHRoZSBsaW5lYXIgbWFwcGluZ1xuICAgICAgLy8gYWJvdmUuXG4gICAgICBkSW5kZXggPSBkSW5kZXggPCBwLm1heEluZGV4ID8gZEluZGV4IDogcC5tYXhJbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcihkSW5kZXgpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5saW5lYXJMb29rdXAgPSAodiwgdGFibGUsIHApID0+IHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGlmICh2dGtNYXRoLmlzTmFuKHYpKSB7XG4gICAgICBpbmRleCA9IE1hdGguZmxvb3IocC5tYXhJbmRleCArIDEuNSArIE5BTl9DT0xPUl9JTkRFWCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gcHVibGljQVBJLmxpbmVhckluZGV4TG9va3VwKHYsIHApO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXQgPSA0ICogaW5kZXg7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRhYmxlW29mZnNldF0sXG4gICAgICB0YWJsZVtvZmZzZXQgKyAxXSxcbiAgICAgIHRhYmxlW29mZnNldCArIDJdLFxuICAgICAgdGFibGVbb2Zmc2V0ICsgM10sXG4gICAgXTtcbiAgfTtcblxuICBwdWJsaWNBUEkuaW5kZXhlZExvb2t1cEZ1bmN0aW9uID0gKHYsIHRhYmxlLCBwKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gcHVibGljQVBJLmdldEFubm90YXRlZFZhbHVlSW5kZXhJbnRlcm5hbCh2KTtcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICBpbmRleCA9IG1vZGVsLm51bWJlck9mQ29sb3JzICsgTkFOX0NPTE9SX0lOREVYO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXQgPSA0ICogaW5kZXg7XG4gICAgcmV0dXJuIFtcbiAgICAgIHRhYmxlW29mZnNldF0sXG4gICAgICB0YWJsZVtvZmZzZXQgKyAxXSxcbiAgICAgIHRhYmxlW29mZnNldCArIDJdLFxuICAgICAgdGFibGVbb2Zmc2V0ICsgM10sXG4gICAgXTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmxvb2t1cFNoaWZ0QW5kU2NhbGUgPSAocmFuZ2UsIHApID0+IHtcbiAgICBwLnNoaWZ0ID0gLXJhbmdlWzBdO1xuICAgIHAuc2NhbGUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGlmIChyYW5nZVsxXSA+IHJhbmdlWzBdKSB7XG4gICAgICBwLnNjYWxlID0gKHAubWF4SW5kZXggKyAxKSAvIChyYW5nZVsxXSAtIHJhbmdlWzBdKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUHVibGljIEFQSSBtZXRob2RzXG4gIHB1YmxpY0FQSS5tYXBTY2FsYXJzVGhyb3VnaFRhYmxlID0gKFxuICAgIGlucHV0LFxuICAgIG91dHB1dCxcbiAgICBvdXRGb3JtYXQsXG4gICAgaW5wdXRPZmZzZXRcbiAgKSA9PiB7XG4gICAgbGV0IGxvb2t1cEZ1bmMgPSBwdWJsaWNBUEkubGluZWFyTG9va3VwO1xuICAgIGlmIChtb2RlbC5pbmRleGVkTG9va3VwKSB7XG4gICAgICBsb29rdXBGdW5jID0gcHVibGljQVBJLmluZGV4ZWRMb29rdXBGdW5jdGlvbjtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuZ2UgPSBwdWJsaWNBUEkuZ2V0TWFwcGluZ1JhbmdlKCk7XG5cbiAgICBjb25zdCBwID0ge1xuICAgICAgbWF4SW5kZXg6IHB1YmxpY0FQSS5nZXROdW1iZXJPZkNvbG9ycygpIC0gMSxcbiAgICAgIHJhbmdlOiB0cmFuZ2UsXG4gICAgICBzaGlmdDogMC4wLFxuICAgICAgc2NhbGU6IDAuMCxcbiAgICB9O1xuICAgIHB1YmxpY0FQSS5sb29rdXBTaGlmdEFuZFNjYWxlKHRyYW5nZSwgcCk7XG5cbiAgICBjb25zdCBhbHBoYSA9IHB1YmxpY0FQSS5nZXRBbHBoYSgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0LmdldE51bWJlck9mVHVwbGVzKCk7XG4gICAgY29uc3QgaW5JbmNyID0gaW5wdXQuZ2V0TnVtYmVyT2ZDb21wb25lbnRzKCk7XG5cbiAgICBjb25zdCBvdXRwdXRWID0gb3V0cHV0LmdldERhdGEoKTtcbiAgICBjb25zdCBpbnB1dFYgPSBpbnB1dC5nZXREYXRhKCk7XG5cbiAgICBpZiAoYWxwaGEgPj0gMS4wKSB7XG4gICAgICBpZiAob3V0Rm9ybWF0ID09PSBTY2FsYXJNYXBwaW5nVGFyZ2V0LlJHQkEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNwdHIgPSBsb29rdXBGdW5jKFxuICAgICAgICAgICAgaW5wdXRWW2kgKiBpbkluY3IgKyBpbnB1dE9mZnNldF0sXG4gICAgICAgICAgICBtb2RlbC50YWJsZSxcbiAgICAgICAgICAgIHBcbiAgICAgICAgICApO1xuICAgICAgICAgIG91dHB1dFZbaSAqIDRdID0gY3B0clswXTtcbiAgICAgICAgICBvdXRwdXRWW2kgKiA0ICsgMV0gPSBjcHRyWzFdO1xuICAgICAgICAgIG91dHB1dFZbaSAqIDQgKyAyXSA9IGNwdHJbMl07XG4gICAgICAgICAgb3V0cHV0VltpICogNCArIDNdID0gY3B0clszXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1sb25lbHktaWYgKi9cbiAgICAgIGlmIChvdXRGb3JtYXQgPT09IFNjYWxhck1hcHBpbmdUYXJnZXQuUkdCQSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY3B0ciA9IGxvb2t1cEZ1bmMoXG4gICAgICAgICAgICBpbnB1dFZbaSAqIGluSW5jciArIGlucHV0T2Zmc2V0XSxcbiAgICAgICAgICAgIG1vZGVsLnRhYmxlLFxuICAgICAgICAgICAgcFxuICAgICAgICAgICk7XG4gICAgICAgICAgb3V0cHV0VltpICogNF0gPSBjcHRyWzBdO1xuICAgICAgICAgIG91dHB1dFZbaSAqIDQgKyAxXSA9IGNwdHJbMV07XG4gICAgICAgICAgb3V0cHV0VltpICogNCArIDJdID0gY3B0clsyXTtcbiAgICAgICAgICBvdXRwdXRWW2kgKiA0ICsgM10gPSBNYXRoLmZsb29yKGNwdHJbM10gKiBhbHBoYSArIDAuNSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIGFscGhhIGJsZW5kaW5nXG4gIH07XG5cbiAgcHVibGljQVBJLmZvcmNlQnVpbGQgPSAoKSA9PiB7XG4gICAgbGV0IGhpbmMgPSAwLjA7XG4gICAgbGV0IHNpbmMgPSAwLjA7XG4gICAgbGV0IHZpbmMgPSAwLjA7XG4gICAgbGV0IGFpbmMgPSAwLjA7XG5cbiAgICBjb25zdCBtYXhJbmRleCA9IG1vZGVsLm51bWJlck9mQ29sb3JzIC0gMTtcblxuICAgIGlmIChtYXhJbmRleCkge1xuICAgICAgaGluYyA9IChtb2RlbC5odWVSYW5nZVsxXSAtIG1vZGVsLmh1ZVJhbmdlWzBdKSAvIG1heEluZGV4O1xuICAgICAgc2luYyA9IChtb2RlbC5zYXR1cmF0aW9uUmFuZ2VbMV0gLSBtb2RlbC5zYXR1cmF0aW9uUmFuZ2VbMF0pIC8gbWF4SW5kZXg7XG4gICAgICB2aW5jID0gKG1vZGVsLnZhbHVlUmFuZ2VbMV0gLSBtb2RlbC52YWx1ZVJhbmdlWzBdKSAvIG1heEluZGV4O1xuICAgICAgYWluYyA9IChtb2RlbC5hbHBoYVJhbmdlWzFdIC0gbW9kZWwuYWxwaGFSYW5nZVswXSkgLyBtYXhJbmRleDtcbiAgICB9XG5cbiAgICBjb25zdCBoc3YgPSBbXTtcbiAgICBjb25zdCByZ2JhID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gbWF4SW5kZXg7IGkrKykge1xuICAgICAgaHN2WzBdID0gbW9kZWwuaHVlUmFuZ2VbMF0gKyBpICogaGluYztcbiAgICAgIGhzdlsxXSA9IG1vZGVsLnNhdHVyYXRpb25SYW5nZVswXSArIGkgKiBzaW5jO1xuICAgICAgaHN2WzJdID0gbW9kZWwudmFsdWVSYW5nZVswXSArIGkgKiB2aW5jO1xuXG4gICAgICB2dGtNYXRoLmhzdjJyZ2IoaHN2LCByZ2JhKTtcbiAgICAgIHJnYmFbM10gPSBtb2RlbC5hbHBoYVJhbmdlWzBdICsgaSAqIGFpbmM7XG5cbiAgICAgIC8vICBjYXNlIFZUS19SQU1QX0xJTkVBUjpcbiAgICAgIG1vZGVsLnRhYmxlW2kgKiA0XSA9IHJnYmFbMF0gKiAyNTUuMCArIDAuNTtcbiAgICAgIG1vZGVsLnRhYmxlW2kgKiA0ICsgMV0gPSByZ2JhWzFdICogMjU1LjAgKyAwLjU7XG4gICAgICBtb2RlbC50YWJsZVtpICogNCArIDJdID0gcmdiYVsyXSAqIDI1NS4wICsgMC41O1xuICAgICAgbW9kZWwudGFibGVbaSAqIDQgKyAzXSA9IHJnYmFbM10gKiAyNTUuMCArIDAuNTtcbiAgICB9XG5cbiAgICBwdWJsaWNBUEkuYnVpbGRTcGVjaWFsQ29sb3JzKCk7XG5cbiAgICBtb2RlbC5idWlsZFRpbWUubW9kaWZpZWQoKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0VGFibGUgPSAodGFibGUpID0+IHtcbiAgICBpZiAodGFibGUuZ2V0TnVtYmVyT2ZDb21wb25lbnRzKCkgIT09IDQpIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oJ0V4cGVjdGVkIDQgY29tcG9uZW50cyBmb3IgUkdCQSBjb2xvcnMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRhYmxlLmdldERhdGFUeXBlKCkgIT09IFZ0a0RhdGFUeXBlcy5VTlNJR05FRF9DSEFSKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKCdFeHBlY3RlZCB1bnNpZ25lZCBjaGFyIHZhbHVlcyBmb3IgUkdCQSBjb2xvcnMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbW9kZWwubnVtYmVyT2ZDb2xvcnMgPSB0YWJsZS5nZXROdW1iZXJPZlR1cGxlcygpO1xuICAgIGNvbnN0IGRhdGEgPSB0YWJsZS5nZXREYXRhKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtb2RlbC50YWJsZVtpXSA9IGRhdGFbaV07XG4gICAgfVxuXG4gICAgcHVibGljQVBJLmJ1aWxkU3BlY2lhbENvbG9ycygpO1xuICAgIG1vZGVsLmluc2VydFRpbWUubW9kaWZpZWQoKTtcbiAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuYnVpbGRTcGVjaWFsQ29sb3JzID0gKCkgPT4ge1xuICAgIC8vIEFkZCBcInNwZWNpYWxcIiBjb2xvcnMgKE5hTiwgYmVsb3cgcmFuZ2UsIGFib3ZlIHJhbmdlKSB0byB0YWJsZSBoZXJlLlxuICAgIGNvbnN0IHsgbnVtYmVyT2ZDb2xvcnMgfSA9IG1vZGVsO1xuXG4gICAgY29uc3QgdHB0ciA9IG1vZGVsLnRhYmxlO1xuICAgIGxldCBiYXNlID0gKG51bWJlck9mQ29sb3JzICsgQkVMT1dfUkFOR0VfQ09MT1JfSU5ERVgpICogNDtcblxuICAgIC8vIEJlbG93IHJhbmdlIGNvbG9yXG4gICAgaWYgKG1vZGVsLnVzZUJlbG93UmFuZ2VDb2xvciB8fCBudW1iZXJPZkNvbG9ycyA9PT0gMCkge1xuICAgICAgdHB0cltiYXNlXSA9IG1vZGVsLmJlbG93UmFuZ2VDb2xvclswXSAqIDI1NS4wICsgMC41O1xuICAgICAgdHB0cltiYXNlICsgMV0gPSBtb2RlbC5iZWxvd1JhbmdlQ29sb3JbMV0gKiAyNTUuMCArIDAuNTtcbiAgICAgIHRwdHJbYmFzZSArIDJdID0gbW9kZWwuYmVsb3dSYW5nZUNvbG9yWzJdICogMjU1LjAgKyAwLjU7XG4gICAgICB0cHRyW2Jhc2UgKyAzXSA9IG1vZGVsLmJlbG93UmFuZ2VDb2xvclszXSAqIDI1NS4wICsgMC41O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEdXBsaWNhdGUgdGhlIGZpcnN0IGNvbG9yIGluIHRoZSB0YWJsZS5cbiAgICAgIHRwdHJbYmFzZV0gPSB0cHRyWzBdO1xuICAgICAgdHB0cltiYXNlICsgMV0gPSB0cHRyWzFdO1xuICAgICAgdHB0cltiYXNlICsgMl0gPSB0cHRyWzJdO1xuICAgICAgdHB0cltiYXNlICsgM10gPSB0cHRyWzNdO1xuICAgIH1cblxuICAgIC8vIEFib3ZlIHJhbmdlIGNvbG9yXG4gICAgYmFzZSA9IChudW1iZXJPZkNvbG9ycyArIEFCT1ZFX1JBTkdFX0NPTE9SX0lOREVYKSAqIDQ7XG4gICAgaWYgKG1vZGVsLnVzZUFib3ZlUmFuZ2VDb2xvciB8fCBudW1iZXJPZkNvbG9ycyA9PT0gMCkge1xuICAgICAgdHB0cltiYXNlXSA9IG1vZGVsLmFib3ZlUmFuZ2VDb2xvclswXSAqIDI1NS4wICsgMC41O1xuICAgICAgdHB0cltiYXNlICsgMV0gPSBtb2RlbC5hYm92ZVJhbmdlQ29sb3JbMV0gKiAyNTUuMCArIDAuNTtcbiAgICAgIHRwdHJbYmFzZSArIDJdID0gbW9kZWwuYWJvdmVSYW5nZUNvbG9yWzJdICogMjU1LjAgKyAwLjU7XG4gICAgICB0cHRyW2Jhc2UgKyAzXSA9IG1vZGVsLmFib3ZlUmFuZ2VDb2xvclszXSAqIDI1NS4wICsgMC41O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEdXBsaWNhdGUgdGhlIGxhc3QgY29sb3IgaW4gdGhlIHRhYmxlLlxuICAgICAgdHB0cltiYXNlXSA9IHRwdHJbNCAqIChudW1iZXJPZkNvbG9ycyAtIDEpICsgMF07XG4gICAgICB0cHRyW2Jhc2UgKyAxXSA9IHRwdHJbNCAqIChudW1iZXJPZkNvbG9ycyAtIDEpICsgMV07XG4gICAgICB0cHRyW2Jhc2UgKyAyXSA9IHRwdHJbNCAqIChudW1iZXJPZkNvbG9ycyAtIDEpICsgMl07XG4gICAgICB0cHRyW2Jhc2UgKyAzXSA9IHRwdHJbNCAqIChudW1iZXJPZkNvbG9ycyAtIDEpICsgM107XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIHVzZSBOYW5Db2xvclxuICAgIGJhc2UgPSAobnVtYmVyT2ZDb2xvcnMgKyBOQU5fQ09MT1JfSU5ERVgpICogNDtcbiAgICB0cHRyW2Jhc2VdID0gbW9kZWwubmFuQ29sb3JbMF0gKiAyNTUuMCArIDAuNTtcbiAgICB0cHRyW2Jhc2UgKyAxXSA9IG1vZGVsLm5hbkNvbG9yWzFdICogMjU1LjAgKyAwLjU7XG4gICAgdHB0cltiYXNlICsgMl0gPSBtb2RlbC5uYW5Db2xvclsyXSAqIDI1NS4wICsgMC41O1xuICAgIHRwdHJbYmFzZSArIDNdID0gbW9kZWwubmFuQ29sb3JbM10gKiAyNTUuMCArIDAuNTtcbiAgfTtcblxuICBwdWJsaWNBUEkuYnVpbGQgPSAoKSA9PiB7XG4gICAgaWYgKFxuICAgICAgbW9kZWwudGFibGUubGVuZ3RoIDwgMSB8fFxuICAgICAgKHB1YmxpY0FQSS5nZXRNVGltZSgpID4gbW9kZWwuYnVpbGRUaW1lLmdldE1UaW1lKCkgJiZcbiAgICAgICAgbW9kZWwuaW5zZXJ0VGltZS5nZXRNVGltZSgpIDw9IG1vZGVsLmJ1aWxkVGltZS5nZXRNVGltZSgpKVxuICAgICkge1xuICAgICAgcHVibGljQVBJLmZvcmNlQnVpbGQoKTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKG1vZGVsLnRhYmxlLmxlbmd0aCA+IDApIHtcbiAgICAvLyBlbnN1cmUgaW5zZXJ0VGltZSBpcyBtb3JlIHJlY2VudGx5IG1vZGlmaWVkIHRoYW4gYnVpbGRUaW1lIGlmXG4gICAgLy8gYSB0YWJsZSBpcyBwcm92aWRlZCB2aWEgdGhlIGNvbnN0cnVjdG9yXG4gICAgbW9kZWwuaW5zZXJ0VGltZS5tb2RpZmllZCgpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBudW1iZXJPZkNvbG9yczogMjU2LFxuICAvLyB0YWJsZTogbnVsbCxcblxuICBodWVSYW5nZTogWzAuMCwgMC42NjY2N10sXG4gIHNhdHVyYXRpb25SYW5nZTogWzEuMCwgMS4wXSxcbiAgdmFsdWVSYW5nZTogWzEuMCwgMS4wXSxcbiAgYWxwaGFSYW5nZTogWzEuMCwgMS4wXSxcblxuICBuYW5Db2xvcjogWzAuNSwgMC4wLCAwLjAsIDEuMF0sXG4gIGJlbG93UmFuZ2VDb2xvcjogWzAuMCwgMC4wLCAwLjAsIDEuMF0sXG4gIGFib3ZlUmFuZ2VDb2xvcjogWzEuMCwgMS4wLCAxLjAsIDEuMF0sXG4gIHVzZUFib3ZlUmFuZ2VDb2xvcjogZmFsc2UsXG4gIHVzZUJlbG93UmFuZ2VDb2xvcjogZmFsc2UsXG5cbiAgYWxwaGE6IDEuMCxcbiAgLy8gYnVpbGRUaW1lOiBudWxsLFxuICAvLyBvcGFxdWVGbGFnQnVpbGRUaW1lOiBudWxsLFxuICAvLyBpbnNlcnRUaW1lOiBudWxsLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gSW5oZXJpdGFuY2VcbiAgdnRrU2NhbGFyc1RvQ29sb3JzLmV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBJbnRlcm5hbCBvYmplY3RzIGluaXRpYWxpemF0aW9uXG4gIGlmICghbW9kZWwudGFibGUpIHtcbiAgICBtb2RlbC50YWJsZSA9IFtdO1xuICB9XG5cbiAgbW9kZWwuYnVpbGRUaW1lID0ge307XG4gIG1hY3JvLm9iaihtb2RlbC5idWlsZFRpbWUpO1xuXG4gIG1vZGVsLm9wYXF1ZUZsYWdCdWlsZFRpbWUgPSB7fTtcbiAgbWFjcm8ub2JqKG1vZGVsLm9wYXF1ZUZsYWdCdWlsZFRpbWUsIHsgbXRpbWU6IDAgfSk7XG5cbiAgbW9kZWwuaW5zZXJ0VGltZSA9IHt9O1xuICBtYWNyby5vYmoobW9kZWwuaW5zZXJ0VGltZSwgeyBtdGltZTogMCB9KTtcblxuICAvLyBDcmVhdGUgZ2V0LW9ubHkgbWFjcm9zXG4gIG1hY3JvLmdldChwdWJsaWNBUEksIG1vZGVsLCBbJ2J1aWxkVGltZSddKTtcblxuICAvLyBDcmVhdGUgZ2V0LXNldCBtYWNyb3NcbiAgbWFjcm8uc2V0R2V0KHB1YmxpY0FQSSwgbW9kZWwsIFtcbiAgICAnbnVtYmVyT2ZDb2xvcnMnLFxuICAgICd1c2VBYm92ZVJhbmdlQ29sb3InLFxuICAgICd1c2VCZWxvd1JhbmdlQ29sb3InLFxuICBdKTtcblxuICAvLyBDcmVhdGUgc2V0IG1hY3JvcyBmb3IgYXJyYXkgKG5lZWRzIHRvIGtub3cgc2l6ZSlcbiAgbWFjcm8uc2V0QXJyYXkoXG4gICAgcHVibGljQVBJLFxuICAgIG1vZGVsLFxuICAgIFsnYWxwaGFSYW5nZScsICdodWVSYW5nZScsICdzYXR1cmF0aW9uUmFuZ2UnLCAndmFsdWVSYW5nZSddLFxuICAgIDJcbiAgKTtcblxuICBtYWNyby5zZXRBcnJheShcbiAgICBwdWJsaWNBUEksXG4gICAgbW9kZWwsXG4gICAgWyduYW5Db2xvcicsICdiZWxvd1JhbmdlQ29sb3InLCAnYWJvdmVSYW5nZUNvbG9yJ10sXG4gICAgNFxuICApO1xuXG4gIC8vIENyZWF0ZSBnZXQgbWFjcm9zIGZvciBhcnJheVxuICBtYWNyby5nZXRBcnJheShwdWJsaWNBUEksIG1vZGVsLCBbXG4gICAgJ2h1ZVJhbmdlJyxcbiAgICAnc2F0dXJhdGlvblJhbmdlJyxcbiAgICAndmFsdWVSYW5nZScsXG4gICAgJ2FscGhhUmFuZ2UnLFxuICAgICduYW5Db2xvcicsXG4gICAgJ2JlbG93UmFuZ2VDb2xvcicsXG4gICAgJ2Fib3ZlUmFuZ2VDb2xvcicsXG4gIF0pO1xuXG4gIC8vIEZvciBtb3JlIG1hY3JvIG1ldGhvZHMsIHNlZSBcIlNvdXJjZXMvbWFjcm8uanNcIlxuXG4gIC8vIE9iamVjdCBzcGVjaWZpYyBtZXRob2RzXG4gIHZ0a0xvb2t1cFRhYmxlKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a0xvb2t1cFRhYmxlJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kIH07XG4iLCJpbXBvcnQgc2VlZHJhbmRvbSBmcm9tICdzZWVkcmFuZG9tJztcbmltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tY3ljbGVcbmltcG9ydCB2dGtNYXRyaXhCdWlsZGVyIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL01hdHJpeEJ1aWxkZXInO1xuXG5jb25zdCB7IHZ0a0Vycm9yTWFjcm8sIHZ0a1dhcm5pbmdNYWNybyB9ID0gbWFjcm87XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWNvbmQtYXNzaWduICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLWFzc2lnbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmxldCByYW5kb21TZWVkVmFsdWUgPSAwO1xuY29uc3QgVlRLX01BWF9ST1RBVElPTlMgPSAyMDtcbmNvbnN0IFZUS19TTUFMTF9OVU1CRVIgPSAxLjBlLTEyO1xuXG5mdW5jdGlvbiBub3RJbXBsZW1lbnRlZChtZXRob2QpIHtcbiAgcmV0dXJuICgpID0+IHZ0a0Vycm9yTWFjcm8oYHZ0a01hdGg6OiR7bWV0aG9kfSAtIE5PVCBJTVBMRU1FTlRFRGApO1xufVxuXG5mdW5jdGlvbiB2dGtTd2FwVmVjdG9yczModjEsIHYyKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgY29uc3QgdG1wID0gdjFbaV07XG4gICAgdjFbaV0gPSB2MltpXTtcbiAgICB2MltpXSA9IHRtcDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJheShzaXplID0gMykge1xuICBjb25zdCBhcnJheSA9IFtdO1xuICB3aGlsZSAoYXJyYXkubGVuZ3RoIDwgc2l6ZSkge1xuICAgIGFycmF5LnB1c2goMCk7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBHbG9iYWwgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgUGkgPSAoKSA9PiBNYXRoLlBJO1xuXG5leHBvcnQgZnVuY3Rpb24gcmFkaWFuc0Zyb21EZWdyZWVzKGRlZykge1xuICByZXR1cm4gKGRlZyAvIDE4MCkgKiBNYXRoLlBJO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVncmVlc0Zyb21SYWRpYW5zKHJhZCkge1xuICByZXR1cm4gKHJhZCAqIDE4MCkgLyBNYXRoLlBJO1xufVxuXG5leHBvcnQgY29uc3QgeyByb3VuZCwgZmxvb3IsIGNlaWwsIG1pbiwgbWF4IH0gPSBNYXRoO1xuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlNaW4oYXJyLCBvZmZzZXQgPSAwLCBzdHJpZGUgPSAxKSB7XG4gIGxldCBtaW5WYWx1ZSA9IEluZmluaXR5O1xuICBmb3IgKGxldCBpID0gb2Zmc2V0LCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpICs9IHN0cmlkZSkge1xuICAgIGlmIChhcnJbaV0gPCBtaW5WYWx1ZSkge1xuICAgICAgbWluVmFsdWUgPSBhcnJbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1pblZhbHVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlNYXgoYXJyLCBvZmZzZXQgPSAwLCBzdHJpZGUgPSAxKSB7XG4gIGxldCBtYXhWYWx1ZSA9IC1JbmZpbml0eTtcbiAgZm9yIChsZXQgaSA9IG9mZnNldCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSArPSBzdHJpZGUpIHtcbiAgICBpZiAobWF4VmFsdWUgPCBhcnJbaV0pIHtcbiAgICAgIG1heFZhbHVlID0gYXJyW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXhWYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5UmFuZ2UoYXJyLCBvZmZzZXQgPSAwLCBzdHJpZGUgPSAxKSB7XG4gIGxldCBtaW5WYWx1ZSA9IEluZmluaXR5O1xuICBsZXQgbWF4VmFsdWUgPSAtSW5maW5pdHk7XG4gIGZvciAobGV0IGkgPSBvZmZzZXQsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkgKz0gc3RyaWRlKSB7XG4gICAgaWYgKGFycltpXSA8IG1pblZhbHVlKSB7XG4gICAgICBtaW5WYWx1ZSA9IGFycltpXTtcbiAgICB9XG4gICAgaWYgKG1heFZhbHVlIDwgYXJyW2ldKSB7XG4gICAgICBtYXhWYWx1ZSA9IGFycltpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW21pblZhbHVlLCBtYXhWYWx1ZV07XG59XG5cbmV4cG9ydCBjb25zdCBjZWlsTG9nMiA9IG5vdEltcGxlbWVudGVkKCdjZWlsTG9nMicpO1xuZXhwb3J0IGNvbnN0IGZhY3RvcmlhbCA9IG5vdEltcGxlbWVudGVkKCdmYWN0b3JpYWwnKTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5lYXJlc3RQb3dlck9mVHdvKHhpKSB7XG4gIGxldCB2ID0gMTtcbiAgd2hpbGUgKHYgPCB4aSkge1xuICAgIHYgKj0gMjtcbiAgfVxuICByZXR1cm4gdjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUG93ZXJPZlR3byh4KSB7XG4gIHJldHVybiB4ID09PSBuZWFyZXN0UG93ZXJPZlR3byh4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbm9taWFsKG0sIG4pIHtcbiAgbGV0IHIgPSAxO1xuICBmb3IgKGxldCBpID0gMTsgaSA8PSBuOyArK2kpIHtcbiAgICByICo9IChtIC0gaSArIDEpIC8gaTtcbiAgfVxuICByZXR1cm4gTWF0aC5mbG9vcihyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJlZ2luQ29tYmluYXRpb24obSwgbikge1xuICBpZiAobSA8IG4pIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIGNvbnN0IHIgPSBjcmVhdGVBcnJheShuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICByW2ldID0gaTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5leHRDb21iaW5hdGlvbihtLCBuLCByKSB7XG4gIGxldCBzdGF0dXMgPSAwO1xuICBmb3IgKGxldCBpID0gbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKHJbaV0gPCBtIC0gbiArIGkpIHtcbiAgICAgIGxldCBqID0gcltpXSArIDE7XG4gICAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgICAgcltpKytdID0gaisrO1xuICAgICAgfVxuICAgICAgc3RhdHVzID0gMTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdHVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tU2VlZChzZWVkKSB7XG4gIHNlZWRyYW5kb20oYCR7c2VlZH1gLCB7IGdsb2JhbDogdHJ1ZSB9KTtcbiAgcmFuZG9tU2VlZFZhbHVlID0gc2VlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlZWQoKSB7XG4gIHJldHVybiByYW5kb21TZWVkVmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20obWluVmFsdWUgPSAwLCBtYXhWYWx1ZSA9IDEpIHtcbiAgY29uc3QgZGVsdGEgPSBtYXhWYWx1ZSAtIG1pblZhbHVlO1xuICByZXR1cm4gbWluVmFsdWUgKyBkZWx0YSAqIE1hdGgucmFuZG9tKCk7XG59XG5cbmV4cG9ydCBjb25zdCBnYXVzc2lhbiA9IG5vdEltcGxlbWVudGVkKCdnYXVzc2lhbicpO1xuXG4vLyBWZWN0MyBvcGVyYXRpb25zXG5leHBvcnQgZnVuY3Rpb24gYWRkKGEsIGIsIG91dCkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3QoYSwgYiwgb3V0KSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcih2ZWMsIHNjYWxhcikge1xuICB2ZWNbMF0gKj0gc2NhbGFyO1xuICB2ZWNbMV0gKj0gc2NhbGFyO1xuICB2ZWNbMl0gKj0gc2NhbGFyO1xuICByZXR1cm4gdmVjO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIyRCh2ZWMsIHNjYWxhcikge1xuICB2ZWNbMF0gKj0gc2NhbGFyO1xuICB2ZWNbMV0gKj0gc2NhbGFyO1xuICByZXR1cm4gdmVjO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlBY2N1bXVsYXRlKGEsIGIsIHNjYWxhciwgb3V0KSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGFyO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxhcjtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsYXI7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseUFjY3VtdWxhdGUyRChhLCBiLCBzY2FsYXIsIG91dCkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxhcjtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsYXI7XG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoeCwgeSkge1xuICByZXR1cm4geFswXSAqIHlbMF0gKyB4WzFdICogeVsxXSArIHhbMl0gKiB5WzJdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3V0ZXIoeCwgeSwgb3V0XzN4Mykge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICBvdXRfM3gzW2ldW2pdID0geFtpXSAqIHlbal07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyh4LCB5LCBvdXQpIHtcbiAgY29uc3QgWnggPSB4WzFdICogeVsyXSAtIHhbMl0gKiB5WzFdO1xuICBjb25zdCBaeSA9IHhbMl0gKiB5WzBdIC0geFswXSAqIHlbMl07XG4gIGNvbnN0IFp6ID0geFswXSAqIHlbMV0gLSB4WzFdICogeVswXTtcbiAgb3V0WzBdID0gWng7XG4gIG91dFsxXSA9IFp5O1xuICBvdXRbMl0gPSBaejtcbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm0oeCwgbiA9IDMpIHtcbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIE1hdGguYWJzKHgpO1xuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoeFswXSAqIHhbMF0gKyB4WzFdICogeFsxXSk7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIE1hdGguc3FydCh4WzBdICogeFswXSArIHhbMV0gKiB4WzFdICsgeFsyXSAqIHhbMl0pO1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgc3VtICs9IHhbaV0gKiB4W2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGguc3FydChzdW0pO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHgpIHtcbiAgY29uc3QgZGVuID0gbm9ybSh4KTtcbiAgaWYgKGRlbiAhPT0gMC4wKSB7XG4gICAgeFswXSAvPSBkZW47XG4gICAgeFsxXSAvPSBkZW47XG4gICAgeFsyXSAvPSBkZW47XG4gIH1cbiAgcmV0dXJuIGRlbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBlcnBlbmRpY3VsYXJzKHgsIHksIHosIHRoZXRhKSB7XG4gIGNvbnN0IHgyID0geFswXSAqIHhbMF07XG4gIGNvbnN0IHkyID0geFsxXSAqIHhbMV07XG4gIGNvbnN0IHoyID0geFsyXSAqIHhbMl07XG4gIGNvbnN0IHIgPSBNYXRoLnNxcnQoeDIgKyB5MiArIHoyKTtcblxuICBsZXQgZHg7XG4gIGxldCBkeTtcbiAgbGV0IGR6O1xuXG4gIC8vIHRyYW5zcG9zZSB0aGUgdmVjdG9yIHRvIGF2b2lkIGRpdmlkZS1ieS16ZXJvIGVycm9yXG4gIGlmICh4MiA+IHkyICYmIHgyID4gejIpIHtcbiAgICBkeCA9IDA7XG4gICAgZHkgPSAxO1xuICAgIGR6ID0gMjtcbiAgfSBlbHNlIGlmICh5MiA+IHoyKSB7XG4gICAgZHggPSAxO1xuICAgIGR5ID0gMjtcbiAgICBkeiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZHggPSAyO1xuICAgIGR5ID0gMDtcbiAgICBkeiA9IDE7XG4gIH1cblxuICBjb25zdCBhID0geFtkeF0gLyByO1xuICBjb25zdCBiID0geFtkeV0gLyByO1xuICBjb25zdCBjID0geFtkel0gLyByO1xuICBjb25zdCB0bXAgPSBNYXRoLnNxcnQoYSAqIGEgKyBjICogYyk7XG5cbiAgaWYgKHRoZXRhICE9PSAwKSB7XG4gICAgY29uc3Qgc2ludGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XG4gICAgY29uc3QgY29zdGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XG5cbiAgICBpZiAoeSkge1xuICAgICAgeVtkeF0gPSAoYyAqIGNvc3RoZXRhIC0gYSAqIGIgKiBzaW50aGV0YSkgLyB0bXA7XG4gICAgICB5W2R5XSA9IHNpbnRoZXRhICogdG1wO1xuICAgICAgeVtkel0gPSAoLShhICogY29zdGhldGEpIC0gYiAqIGMgKiBzaW50aGV0YSkgLyB0bXA7XG4gICAgfVxuXG4gICAgaWYgKHopIHtcbiAgICAgIHpbZHhdID0gKC0oYyAqIHNpbnRoZXRhKSAtIGEgKiBiICogY29zdGhldGEpIC8gdG1wO1xuICAgICAgeltkeV0gPSBjb3N0aGV0YSAqIHRtcDtcbiAgICAgIHpbZHpdID0gKGEgKiBzaW50aGV0YSAtIGIgKiBjICogY29zdGhldGEpIC8gdG1wO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoeSkge1xuICAgICAgeVtkeF0gPSBjIC8gdG1wO1xuICAgICAgeVtkeV0gPSAwO1xuICAgICAgeVtkel0gPSAtYSAvIHRtcDtcbiAgICB9XG5cbiAgICBpZiAoeikge1xuICAgICAgeltkeF0gPSAoLWEgKiBiKSAvIHRtcDtcbiAgICAgIHpbZHldID0gdG1wO1xuICAgICAgeltkel0gPSAoLWIgKiBjKSAvIHRtcDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2plY3RWZWN0b3IoYSwgYiwgcHJvamVjdGlvbikge1xuICBjb25zdCBiU3F1YXJlZCA9IGRvdChiLCBiKTtcblxuICBpZiAoYlNxdWFyZWQgPT09IDApIHtcbiAgICBwcm9qZWN0aW9uWzBdID0gMDtcbiAgICBwcm9qZWN0aW9uWzFdID0gMDtcbiAgICBwcm9qZWN0aW9uWzJdID0gMDtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBzY2FsZSA9IGRvdChhLCBiKSAvIGJTcXVhcmVkO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgcHJvamVjdGlvbltpXSA9IGJbaV07XG4gIH1cbiAgbXVsdGlwbHlTY2FsYXIocHJvamVjdGlvbiwgc2NhbGUpO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZG90MkQoeCwgeSkge1xuICByZXR1cm4geFswXSAqIHlbMF0gKyB4WzFdICogeVsxXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb2plY3RWZWN0b3IyRChhLCBiLCBwcm9qZWN0aW9uKSB7XG4gIGNvbnN0IGJTcXVhcmVkID0gZG90MkQoYiwgYik7XG5cbiAgaWYgKGJTcXVhcmVkID09PSAwKSB7XG4gICAgcHJvamVjdGlvblswXSA9IDA7XG4gICAgcHJvamVjdGlvblsxXSA9IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgc2NhbGUgPSBkb3QyRChhLCBiKSAvIGJTcXVhcmVkO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgcHJvamVjdGlvbltpXSA9IGJbaV07XG4gIH1cbiAgbXVsdGlwbHlTY2FsYXIyRChwcm9qZWN0aW9uLCBzY2FsZSk7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZTJCZXR3ZWVuUG9pbnRzKHgsIHkpIHtcbiAgcmV0dXJuIChcbiAgICAoeFswXSAtIHlbMF0pICogKHhbMF0gLSB5WzBdKSArXG4gICAgKHhbMV0gLSB5WzFdKSAqICh4WzFdIC0geVsxXSkgK1xuICAgICh4WzJdIC0geVsyXSkgKiAoeFsyXSAtIHlbMl0pXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZUJldHdlZW5WZWN0b3JzKHYxLCB2Mikge1xuICBjb25zdCBjcm9zc1ZlY3QgPSBbMCwgMCwgMF07XG4gIGNyb3NzKHYxLCB2MiwgY3Jvc3NWZWN0KTtcbiAgcmV0dXJuIE1hdGguYXRhbjIobm9ybShjcm9zc1ZlY3QpLCBkb3QodjEsIHYyKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnYXVzc2lhbkFtcGxpdHVkZShtZWFuLCB2YXJpYW5jZSwgcG9zaXRpb24pIHtcbiAgY29uc3QgZGlzdGFuY2VGcm9tTWVhbiA9IE1hdGguYWJzKG1lYW4gLSBwb3NpdGlvbik7XG4gIHJldHVybiAoXG4gICAgKDEgLyBNYXRoLnNxcnQoMiAqIE1hdGguUEkgKiB2YXJpYW5jZSkpICpcbiAgICBNYXRoLmV4cCgtKGRpc3RhbmNlRnJvbU1lYW4gKiogMikgLyAoMiAqIHZhcmlhbmNlKSlcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdhdXNzaWFuV2VpZ2h0KG1lYW4sIHZhcmlhbmNlLCBwb3NpdGlvbikge1xuICBjb25zdCBkaXN0YW5jZUZyb21NZWFuID0gTWF0aC5hYnMobWVhbiAtIHBvc2l0aW9uKTtcbiAgcmV0dXJuIE1hdGguZXhwKC0oZGlzdGFuY2VGcm9tTWVhbiAqKiAyKSAvICgyICogdmFyaWFuY2UpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG91dGVyMkQoeCwgeSwgb3V0XzJ4Mikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjsgaisrKSB7XG4gICAgICBvdXRfMngyW2ldW2pdID0geFtpXSAqIHlbal07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtMkQoeDJEKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoeDJEWzBdICogeDJEWzBdICsgeDJEWzFdICogeDJEWzFdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZTJEKHgpIHtcbiAgY29uc3QgZGVuID0gbm9ybTJEKHgpO1xuICBpZiAoZGVuICE9PSAwLjApIHtcbiAgICB4WzBdIC89IGRlbjtcbiAgICB4WzFdIC89IGRlbjtcbiAgfVxuICByZXR1cm4gZGVuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQyeDIoLi4uYXJncykge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gYXJnc1swXVswXSAqIGFyZ3NbMV1bMV0gLSBhcmdzWzFdWzBdICogYXJnc1swXVsxXTtcbiAgfVxuICBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICByZXR1cm4gYXJnc1swXSAqIGFyZ3NbM10gLSBhcmdzWzFdICogYXJnc1syXTtcbiAgfVxuICByZXR1cm4gTnVtYmVyLk5hTjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExVRmFjdG9yM3gzKG1hdF8zeDMsIGluZGV4XzMpIHtcbiAgbGV0IG1heEk7XG4gIGxldCB0bXA7XG4gIGxldCBsYXJnZXN0O1xuICBjb25zdCBzY2FsZSA9IFswLCAwLCAwXTtcblxuICAvLyBMb29wIG92ZXIgcm93cyB0byBnZXQgaW1wbGljaXQgc2NhbGluZyBpbmZvcm1hdGlvblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIGxhcmdlc3QgPSBNYXRoLmFicyhtYXRfM3gzW2ldWzBdKTtcbiAgICBpZiAoKHRtcCA9IE1hdGguYWJzKG1hdF8zeDNbaV1bMV0pKSA+IGxhcmdlc3QpIHtcbiAgICAgIGxhcmdlc3QgPSB0bXA7XG4gICAgfVxuICAgIGlmICgodG1wID0gTWF0aC5hYnMobWF0XzN4M1tpXVsyXSkpID4gbGFyZ2VzdCkge1xuICAgICAgbGFyZ2VzdCA9IHRtcDtcbiAgICB9XG4gICAgc2NhbGVbaV0gPSAxIC8gbGFyZ2VzdDtcbiAgfVxuXG4gIC8vIExvb3Agb3ZlciBhbGwgY29sdW1ucyB1c2luZyBDcm91dCdzIG1ldGhvZFxuXG4gIC8vIGZpcnN0IGNvbHVtblxuICBsYXJnZXN0ID0gc2NhbGVbMF0gKiBNYXRoLmFicyhtYXRfM3gzWzBdWzBdKTtcbiAgbWF4SSA9IDA7XG4gIGlmICgodG1wID0gc2NhbGVbMV0gKiBNYXRoLmFicyhtYXRfM3gzWzFdWzBdKSkgPj0gbGFyZ2VzdCkge1xuICAgIGxhcmdlc3QgPSB0bXA7XG4gICAgbWF4SSA9IDE7XG4gIH1cbiAgaWYgKCh0bXAgPSBzY2FsZVsyXSAqIE1hdGguYWJzKG1hdF8zeDNbMl1bMF0pKSA+PSBsYXJnZXN0KSB7XG4gICAgbWF4SSA9IDI7XG4gIH1cbiAgaWYgKG1heEkgIT09IDApIHtcbiAgICB2dGtTd2FwVmVjdG9yczMobWF0XzN4M1ttYXhJXSwgbWF0XzN4M1swXSk7XG4gICAgc2NhbGVbbWF4SV0gPSBzY2FsZVswXTtcbiAgfVxuICBpbmRleF8zWzBdID0gbWF4STtcblxuICBtYXRfM3gzWzFdWzBdIC89IG1hdF8zeDNbMF1bMF07XG4gIG1hdF8zeDNbMl1bMF0gLz0gbWF0XzN4M1swXVswXTtcblxuICAvLyBzZWNvbmQgY29sdW1uXG4gIG1hdF8zeDNbMV1bMV0gLT0gbWF0XzN4M1sxXVswXSAqIG1hdF8zeDNbMF1bMV07XG4gIG1hdF8zeDNbMl1bMV0gLT0gbWF0XzN4M1syXVswXSAqIG1hdF8zeDNbMF1bMV07XG4gIGxhcmdlc3QgPSBzY2FsZVsxXSAqIE1hdGguYWJzKG1hdF8zeDNbMV1bMV0pO1xuICBtYXhJID0gMTtcbiAgaWYgKCh0bXAgPSBzY2FsZVsyXSAqIE1hdGguYWJzKG1hdF8zeDNbMl1bMV0pKSA+PSBsYXJnZXN0KSB7XG4gICAgbWF4SSA9IDI7XG4gICAgdnRrU3dhcFZlY3RvcnMzKG1hdF8zeDNbMl0sIG1hdF8zeDNbMV0pO1xuICAgIHNjYWxlWzJdID0gc2NhbGVbMV07XG4gIH1cbiAgaW5kZXhfM1sxXSA9IG1heEk7XG4gIG1hdF8zeDNbMl1bMV0gLz0gbWF0XzN4M1sxXVsxXTtcblxuICAvLyB0aGlyZCBjb2x1bW5cbiAgbWF0XzN4M1sxXVsyXSAtPSBtYXRfM3gzWzFdWzBdICogbWF0XzN4M1swXVsyXTtcbiAgbWF0XzN4M1syXVsyXSAtPVxuICAgIG1hdF8zeDNbMl1bMF0gKiBtYXRfM3gzWzBdWzJdICsgbWF0XzN4M1syXVsxXSAqIG1hdF8zeDNbMV1bMl07XG4gIGluZGV4XzNbMl0gPSAyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gTFVTb2x2ZTN4MyhtYXRfM3gzLCBpbmRleF8zLCB4XzMpIHtcbiAgLy8gZm9yd2FyZCBzdWJzdGl0dXRpb25cbiAgbGV0IHN1bSA9IHhfM1tpbmRleF8zWzBdXTtcbiAgeF8zW2luZGV4XzNbMF1dID0geF8zWzBdO1xuICB4XzNbMF0gPSBzdW07XG5cbiAgc3VtID0geF8zW2luZGV4XzNbMV1dO1xuICB4XzNbaW5kZXhfM1sxXV0gPSB4XzNbMV07XG4gIHhfM1sxXSA9IHN1bSAtIG1hdF8zeDNbMV1bMF0gKiB4XzNbMF07XG5cbiAgc3VtID0geF8zW2luZGV4XzNbMl1dO1xuICB4XzNbaW5kZXhfM1syXV0gPSB4XzNbMl07XG4gIHhfM1syXSA9IHN1bSAtIG1hdF8zeDNbMl1bMF0gKiB4XzNbMF0gLSBtYXRfM3gzWzJdWzFdICogeF8zWzFdO1xuXG4gIC8vIGJhY2sgc3Vic3RpdHV0aW9uXG4gIHhfM1syXSAvPSBtYXRfM3gzWzJdWzJdO1xuICB4XzNbMV0gPSAoeF8zWzFdIC0gbWF0XzN4M1sxXVsyXSAqIHhfM1syXSkgLyBtYXRfM3gzWzFdWzFdO1xuICB4XzNbMF0gPVxuICAgICh4XzNbMF0gLSBtYXRfM3gzWzBdWzFdICogeF8zWzFdIC0gbWF0XzN4M1swXVsyXSAqIHhfM1syXSkgLyBtYXRfM3gzWzBdWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGluZWFyU29sdmUzeDMobWF0XzN4MywgeF8zLCB5XzMpIHtcbiAgY29uc3QgYTEgPSBtYXRfM3gzWzBdWzBdO1xuICBjb25zdCBiMSA9IG1hdF8zeDNbMF1bMV07XG4gIGNvbnN0IGMxID0gbWF0XzN4M1swXVsyXTtcbiAgY29uc3QgYTIgPSBtYXRfM3gzWzFdWzBdO1xuICBjb25zdCBiMiA9IG1hdF8zeDNbMV1bMV07XG4gIGNvbnN0IGMyID0gbWF0XzN4M1sxXVsyXTtcbiAgY29uc3QgYTMgPSBtYXRfM3gzWzJdWzBdO1xuICBjb25zdCBiMyA9IG1hdF8zeDNbMl1bMV07XG4gIGNvbnN0IGMzID0gbWF0XzN4M1syXVsyXTtcblxuICAvLyBDb21wdXRlIHRoZSBhZGpvaW50XG4gIGNvbnN0IGQxID0gK2RldGVybWluYW50MngyKGIyLCBiMywgYzIsIGMzKTtcbiAgY29uc3QgZDIgPSAtZGV0ZXJtaW5hbnQyeDIoYTIsIGEzLCBjMiwgYzMpO1xuICBjb25zdCBkMyA9ICtkZXRlcm1pbmFudDJ4MihhMiwgYTMsIGIyLCBiMyk7XG5cbiAgY29uc3QgZTEgPSAtZGV0ZXJtaW5hbnQyeDIoYjEsIGIzLCBjMSwgYzMpO1xuICBjb25zdCBlMiA9ICtkZXRlcm1pbmFudDJ4MihhMSwgYTMsIGMxLCBjMyk7XG4gIGNvbnN0IGUzID0gLWRldGVybWluYW50MngyKGExLCBhMywgYjEsIGIzKTtcblxuICBjb25zdCBmMSA9ICtkZXRlcm1pbmFudDJ4MihiMSwgYjIsIGMxLCBjMik7XG4gIGNvbnN0IGYyID0gLWRldGVybWluYW50MngyKGExLCBhMiwgYzEsIGMyKTtcbiAgY29uc3QgZjMgPSArZGV0ZXJtaW5hbnQyeDIoYTEsIGEyLCBiMSwgYjIpO1xuXG4gIC8vIENvbXB1dGUgdGhlIGRldGVybWluYW50XG4gIGNvbnN0IGRldCA9IGExICogZDEgKyBiMSAqIGQyICsgYzEgKiBkMztcblxuICAvLyBNdWx0aXBseSBieSB0aGUgYWRqb2ludFxuICBjb25zdCB2MSA9IGQxICogeF8zWzBdICsgZTEgKiB4XzNbMV0gKyBmMSAqIHhfM1syXTtcbiAgY29uc3QgdjIgPSBkMiAqIHhfM1swXSArIGUyICogeF8zWzFdICsgZjIgKiB4XzNbMl07XG4gIGNvbnN0IHYzID0gZDMgKiB4XzNbMF0gKyBlMyAqIHhfM1sxXSArIGYzICogeF8zWzJdO1xuXG4gIC8vIERpdmlkZSBieSB0aGUgZGV0ZXJtaW5hbnRcbiAgeV8zWzBdID0gdjEgLyBkZXQ7XG4gIHlfM1sxXSA9IHYyIC8gZGV0O1xuICB5XzNbMl0gPSB2MyAvIGRldDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5M3gzX3ZlY3QzKG1hdF8zeDMsIGluXzMsIG91dF8zKSB7XG4gIGNvbnN0IHggPVxuICAgIG1hdF8zeDNbMF1bMF0gKiBpbl8zWzBdICsgbWF0XzN4M1swXVsxXSAqIGluXzNbMV0gKyBtYXRfM3gzWzBdWzJdICogaW5fM1syXTtcbiAgY29uc3QgeSA9XG4gICAgbWF0XzN4M1sxXVswXSAqIGluXzNbMF0gKyBtYXRfM3gzWzFdWzFdICogaW5fM1sxXSArIG1hdF8zeDNbMV1bMl0gKiBpbl8zWzJdO1xuICBjb25zdCB6ID1cbiAgICBtYXRfM3gzWzJdWzBdICogaW5fM1swXSArIG1hdF8zeDNbMl1bMV0gKiBpbl8zWzFdICsgbWF0XzN4M1syXVsyXSAqIGluXzNbMl07XG5cbiAgb3V0XzNbMF0gPSB4O1xuICBvdXRfM1sxXSA9IHk7XG4gIG91dF8zWzJdID0gejtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5M3gzX21hdDMoYV8zeDMsIGJfM3gzLCBvdXRfM3gzKSB7XG4gIGNvbnN0IHRtcCA9IFtcbiAgICBbMCwgMCwgMF0sXG4gICAgWzAsIDAsIDBdLFxuICAgIFswLCAwLCAwXSxcbiAgXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHRtcFswXVtpXSA9XG4gICAgICBhXzN4M1swXVswXSAqIGJfM3gzWzBdW2ldICtcbiAgICAgIGFfM3gzWzBdWzFdICogYl8zeDNbMV1baV0gK1xuICAgICAgYV8zeDNbMF1bMl0gKiBiXzN4M1syXVtpXTtcbiAgICB0bXBbMV1baV0gPVxuICAgICAgYV8zeDNbMV1bMF0gKiBiXzN4M1swXVtpXSArXG4gICAgICBhXzN4M1sxXVsxXSAqIGJfM3gzWzFdW2ldICtcbiAgICAgIGFfM3gzWzFdWzJdICogYl8zeDNbMl1baV07XG4gICAgdG1wWzJdW2ldID1cbiAgICAgIGFfM3gzWzJdWzBdICogYl8zeDNbMF1baV0gK1xuICAgICAgYV8zeDNbMl1bMV0gKiBiXzN4M1sxXVtpXSArXG4gICAgICBhXzN4M1syXVsyXSAqIGJfM3gzWzJdW2ldO1xuICB9XG5cbiAgZm9yIChsZXQgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICBvdXRfM3gzW2pdWzBdID0gdG1wW2pdWzBdO1xuICAgIG91dF8zeDNbal1bMV0gPSB0bXBbal1bMV07XG4gICAgb3V0XzN4M1tqXVsyXSA9IHRtcFtqXVsyXTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlNYXRyaXgoYSwgYiwgcm93QSwgY29sQSwgcm93QiwgY29sQiwgb3V0X3Jvd1hjb2wpIHtcbiAgLy8gd2UgbmVlZCBjb2xBID09IHJvd0JcbiAgaWYgKGNvbEEgIT09IHJvd0IpIHtcbiAgICB2dGtFcnJvck1hY3JvKCdOdW1iZXIgb2YgY29sdW1ucyBvZiBBIG11c3QgbWF0Y2ggbnVtYmVyIG9mIHJvd3Mgb2YgQi4nKTtcbiAgfVxuXG4gIC8vIG91dHB1dCBtYXRyaXggaXMgcm93QSpjb2xCXG4gIC8vIG91dHB1dCByb3dcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dBOyBpKyspIHtcbiAgICAvLyBvdXRwdXQgY29sXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xCOyBqKyspIHtcbiAgICAgIG91dF9yb3dYY29sW2ldW2pdID0gMDtcbiAgICAgIC8vIHN1bSBmb3IgdGhpcyBwb2ludFxuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBjb2xBOyBrKyspIHtcbiAgICAgICAgb3V0X3Jvd1hjb2xbaV1bal0gKz0gYVtpXVtrXSAqIGJba11bal07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2UzeDMoaW5fM3gzLCBvdXRUXzN4Mykge1xuICBsZXQgdG1wO1xuICB0bXAgPSBpbl8zeDNbMV1bMF07XG4gIG91dFRfM3gzWzFdWzBdID0gaW5fM3gzWzBdWzFdO1xuICBvdXRUXzN4M1swXVsxXSA9IHRtcDtcbiAgdG1wID0gaW5fM3gzWzJdWzBdO1xuICBvdXRUXzN4M1syXVswXSA9IGluXzN4M1swXVsyXTtcbiAgb3V0VF8zeDNbMF1bMl0gPSB0bXA7XG4gIHRtcCA9IGluXzN4M1syXVsxXTtcbiAgb3V0VF8zeDNbMl1bMV0gPSBpbl8zeDNbMV1bMl07XG4gIG91dFRfM3gzWzFdWzJdID0gdG1wO1xuXG4gIG91dFRfM3gzWzBdWzBdID0gaW5fM3gzWzBdWzBdO1xuICBvdXRUXzN4M1sxXVsxXSA9IGluXzN4M1sxXVsxXTtcbiAgb3V0VF8zeDNbMl1bMl0gPSBpbl8zeDNbMl1bMl07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQzeDMoaW5fM3gzLCBvdXRJXzN4Mykge1xuICBjb25zdCBhMSA9IGluXzN4M1swXVswXTtcbiAgY29uc3QgYjEgPSBpbl8zeDNbMF1bMV07XG4gIGNvbnN0IGMxID0gaW5fM3gzWzBdWzJdO1xuICBjb25zdCBhMiA9IGluXzN4M1sxXVswXTtcbiAgY29uc3QgYjIgPSBpbl8zeDNbMV1bMV07XG4gIGNvbnN0IGMyID0gaW5fM3gzWzFdWzJdO1xuICBjb25zdCBhMyA9IGluXzN4M1syXVswXTtcbiAgY29uc3QgYjMgPSBpbl8zeDNbMl1bMV07XG4gIGNvbnN0IGMzID0gaW5fM3gzWzJdWzJdO1xuXG4gIC8vIENvbXB1dGUgdGhlIGFkam9pbnRcbiAgY29uc3QgZDEgPSArZGV0ZXJtaW5hbnQyeDIoYjIsIGIzLCBjMiwgYzMpO1xuICBjb25zdCBkMiA9IC1kZXRlcm1pbmFudDJ4MihhMiwgYTMsIGMyLCBjMyk7XG4gIGNvbnN0IGQzID0gK2RldGVybWluYW50MngyKGEyLCBhMywgYjIsIGIzKTtcblxuICBjb25zdCBlMSA9IC1kZXRlcm1pbmFudDJ4MihiMSwgYjMsIGMxLCBjMyk7XG4gIGNvbnN0IGUyID0gK2RldGVybWluYW50MngyKGExLCBhMywgYzEsIGMzKTtcbiAgY29uc3QgZTMgPSAtZGV0ZXJtaW5hbnQyeDIoYTEsIGEzLCBiMSwgYjMpO1xuXG4gIGNvbnN0IGYxID0gK2RldGVybWluYW50MngyKGIxLCBiMiwgYzEsIGMyKTtcbiAgY29uc3QgZjIgPSAtZGV0ZXJtaW5hbnQyeDIoYTEsIGEyLCBjMSwgYzIpO1xuICBjb25zdCBmMyA9ICtkZXRlcm1pbmFudDJ4MihhMSwgYTIsIGIxLCBiMik7XG5cbiAgLy8gRGl2aWRlIGJ5IHRoZSBkZXRlcm1pbmFudFxuICBjb25zdCBkZXQgPSBhMSAqIGQxICsgYjEgKiBkMiArIGMxICogZDM7XG5cbiAgb3V0SV8zeDNbMF1bMF0gPSBkMSAvIGRldDtcbiAgb3V0SV8zeDNbMV1bMF0gPSBkMiAvIGRldDtcbiAgb3V0SV8zeDNbMl1bMF0gPSBkMyAvIGRldDtcblxuICBvdXRJXzN4M1swXVsxXSA9IGUxIC8gZGV0O1xuICBvdXRJXzN4M1sxXVsxXSA9IGUyIC8gZGV0O1xuICBvdXRJXzN4M1syXVsxXSA9IGUzIC8gZGV0O1xuXG4gIG91dElfM3gzWzBdWzJdID0gZjEgLyBkZXQ7XG4gIG91dElfM3gzWzFdWzJdID0gZjIgLyBkZXQ7XG4gIG91dElfM3gzWzJdWzJdID0gZjMgLyBkZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eTN4MyhtYXRfM3gzKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgbWF0XzN4M1tpXVswXSA9IG1hdF8zeDNbaV1bMV0gPSBtYXRfM3gzW2ldWzJdID0gMDtcbiAgICBtYXRfM3gzW2ldW2ldID0gMTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQzeDMobWF0XzN4Mykge1xuICByZXR1cm4gKFxuICAgIG1hdF8zeDNbMF1bMF0gKiBtYXRfM3gzWzFdWzFdICogbWF0XzN4M1syXVsyXSArXG4gICAgbWF0XzN4M1sxXVswXSAqIG1hdF8zeDNbMl1bMV0gKiBtYXRfM3gzWzBdWzJdICtcbiAgICBtYXRfM3gzWzJdWzBdICogbWF0XzN4M1swXVsxXSAqIG1hdF8zeDNbMV1bMl0gLVxuICAgIG1hdF8zeDNbMF1bMF0gKiBtYXRfM3gzWzJdWzFdICogbWF0XzN4M1sxXVsyXSAtXG4gICAgbWF0XzN4M1sxXVswXSAqIG1hdF8zeDNbMF1bMV0gKiBtYXRfM3gzWzJdWzJdIC1cbiAgICBtYXRfM3gzWzJdWzBdICogbWF0XzN4M1sxXVsxXSAqIG1hdF8zeDNbMF1bMl1cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHF1YXRlcm5pb25Ub01hdHJpeDN4MyhxdWF0XzQsIG1hdF8zeDMpIHtcbiAgY29uc3Qgd3cgPSBxdWF0XzRbMF0gKiBxdWF0XzRbMF07XG4gIGNvbnN0IHd4ID0gcXVhdF80WzBdICogcXVhdF80WzFdO1xuICBjb25zdCB3eSA9IHF1YXRfNFswXSAqIHF1YXRfNFsyXTtcbiAgY29uc3Qgd3ogPSBxdWF0XzRbMF0gKiBxdWF0XzRbM107XG5cbiAgY29uc3QgeHggPSBxdWF0XzRbMV0gKiBxdWF0XzRbMV07XG4gIGNvbnN0IHl5ID0gcXVhdF80WzJdICogcXVhdF80WzJdO1xuICBjb25zdCB6eiA9IHF1YXRfNFszXSAqIHF1YXRfNFszXTtcblxuICBjb25zdCB4eSA9IHF1YXRfNFsxXSAqIHF1YXRfNFsyXTtcbiAgY29uc3QgeHogPSBxdWF0XzRbMV0gKiBxdWF0XzRbM107XG4gIGNvbnN0IHl6ID0gcXVhdF80WzJdICogcXVhdF80WzNdO1xuXG4gIGNvbnN0IHJyID0geHggKyB5eSArIHp6O1xuICAvLyBub3JtYWxpemF0aW9uIGZhY3RvciwganVzdCBpbiBjYXNlIHF1YXRlcm5pb24gd2FzIG5vdCBub3JtYWxpemVkXG4gIGxldCBmID0gMSAvICh3dyArIHJyKTtcbiAgY29uc3QgcyA9ICh3dyAtIHJyKSAqIGY7XG4gIGYgKj0gMjtcblxuICBtYXRfM3gzWzBdWzBdID0geHggKiBmICsgcztcbiAgbWF0XzN4M1sxXVswXSA9ICh4eSArIHd6KSAqIGY7XG4gIG1hdF8zeDNbMl1bMF0gPSAoeHogLSB3eSkgKiBmO1xuXG4gIG1hdF8zeDNbMF1bMV0gPSAoeHkgLSB3eikgKiBmO1xuICBtYXRfM3gzWzFdWzFdID0geXkgKiBmICsgcztcbiAgbWF0XzN4M1syXVsxXSA9ICh5eiArIHd4KSAqIGY7XG5cbiAgbWF0XzN4M1swXVsyXSA9ICh4eiArIHd5KSAqIGY7XG4gIG1hdF8zeDNbMV1bMl0gPSAoeXogLSB3eCkgKiBmO1xuICBtYXRfM3gzWzJdWzJdID0genogKiBmICsgcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgZWxlbWVudHMgb2YgYm90aCBhcnJheXMgYXJlIGVxdWFscy5cbiAqIEBwYXJhbSB7QXJyYXl9IGEgYW4gYXJyYXkgb2YgbnVtYmVycyAodmVjdG9yLCBwb2ludCwgbWF0cml4Li4uKVxuICogQHBhcmFtIHtBcnJheX0gYiBhbiBhcnJheSBvZiBudW1iZXJzICh2ZWN0b3IsIHBvaW50LCBtYXRyaXguLi4pXG4gKiBAcGFyYW0ge051bWJlcn0gZXBzIHRvbGVyYW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJlRXF1YWxzKGEsIGIsIGVwcyA9IDFlLTYpIHtcbiAgaWYgKCFhLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpc0VxdWFsKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGVsZW1lbnQgLSBiW2luZGV4XSkgPCBlcHM7XG4gIH1cbiAgcmV0dXJuIGEuZXZlcnkoaXNFcXVhbCk7XG59XG5cbmV4cG9ydCBjb25zdCBhcmVNYXRyaWNlc0VxdWFsID0gYXJlRXF1YWxzO1xuXG5leHBvcnQgZnVuY3Rpb24gamFjb2JpTihhLCBuLCB3LCB2KSB7XG4gIGxldCBpO1xuICBsZXQgajtcbiAgbGV0IGs7XG4gIGxldCBpcTtcbiAgbGV0IGlwO1xuICBsZXQgbnVtUG9zO1xuICBsZXQgdHJlc2g7XG4gIGxldCB0aGV0YTtcbiAgbGV0IHQ7XG4gIGxldCB0YXU7XG4gIGxldCBzbTtcbiAgbGV0IHM7XG4gIGxldCBoO1xuICBsZXQgZztcbiAgbGV0IGM7XG4gIGxldCB0bXA7XG4gIGNvbnN0IGIgPSBjcmVhdGVBcnJheShuKTtcbiAgY29uc3QgeiA9IGNyZWF0ZUFycmF5KG4pO1xuXG4gIGNvbnN0IHZ0a1JPVEFURSA9IChhYSwgaWksIGpqLCBraywgbGwpID0+IHtcbiAgICBnID0gYWFbaWldW2pqXTtcbiAgICBoID0gYWFba2tdW2xsXTtcbiAgICBhYVtpaV1bampdID0gZyAtIHMgKiAoaCArIGcgKiB0YXUpO1xuICAgIGFhW2trXVtsbF0gPSBoICsgcyAqIChnIC0gaCAqIHRhdSk7XG4gIH07XG5cbiAgLy8gaW5pdGlhbGl6ZVxuICBmb3IgKGlwID0gMDsgaXAgPCBuOyBpcCsrKSB7XG4gICAgZm9yIChpcSA9IDA7IGlxIDwgbjsgaXErKykge1xuICAgICAgdltpcF1baXFdID0gMC4wO1xuICAgIH1cbiAgICB2W2lwXVtpcF0gPSAxLjA7XG4gIH1cbiAgZm9yIChpcCA9IDA7IGlwIDwgbjsgaXArKykge1xuICAgIGJbaXBdID0gd1tpcF0gPSBhW2lwXVtpcF07XG4gICAgeltpcF0gPSAwLjA7XG4gIH1cblxuICAvLyBiZWdpbiByb3RhdGlvbiBzZXF1ZW5jZVxuICBmb3IgKGkgPSAwOyBpIDwgVlRLX01BWF9ST1RBVElPTlM7IGkrKykge1xuICAgIHNtID0gMC4wO1xuICAgIGZvciAoaXAgPSAwOyBpcCA8IG4gLSAxOyBpcCsrKSB7XG4gICAgICBmb3IgKGlxID0gaXAgKyAxOyBpcSA8IG47IGlxKyspIHtcbiAgICAgICAgc20gKz0gTWF0aC5hYnMoYVtpcF1baXFdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNtID09PSAwLjApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGZpcnN0IDMgc3dlZXBzXG4gICAgaWYgKGkgPCAzKSB7XG4gICAgICB0cmVzaCA9ICgwLjIgKiBzbSkgLyAobiAqIG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmVzaCA9IDAuMDtcbiAgICB9XG5cbiAgICBmb3IgKGlwID0gMDsgaXAgPCBuIC0gMTsgaXArKykge1xuICAgICAgZm9yIChpcSA9IGlwICsgMTsgaXEgPCBuOyBpcSsrKSB7XG4gICAgICAgIGcgPSAxMDAuMCAqIE1hdGguYWJzKGFbaXBdW2lxXSk7XG5cbiAgICAgICAgLy8gYWZ0ZXIgNCBzd2VlcHNcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGkgPiAzICYmXG4gICAgICAgICAgTWF0aC5hYnMod1tpcF0pICsgZyA9PT0gTWF0aC5hYnMod1tpcF0pICYmXG4gICAgICAgICAgTWF0aC5hYnMod1tpcV0pICsgZyA9PT0gTWF0aC5hYnMod1tpcV0pXG4gICAgICAgICkge1xuICAgICAgICAgIGFbaXBdW2lxXSA9IDAuMDtcbiAgICAgICAgfSBlbHNlIGlmIChNYXRoLmFicyhhW2lwXVtpcV0pID4gdHJlc2gpIHtcbiAgICAgICAgICBoID0gd1tpcV0gLSB3W2lwXTtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoaCkgKyBnID09PSBNYXRoLmFicyhoKSkge1xuICAgICAgICAgICAgdCA9IGFbaXBdW2lxXSAvIGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoZXRhID0gKDAuNSAqIGgpIC8gYVtpcF1baXFdO1xuICAgICAgICAgICAgdCA9IDEuMCAvIChNYXRoLmFicyh0aGV0YSkgKyBNYXRoLnNxcnQoMS4wICsgdGhldGEgKiB0aGV0YSkpO1xuICAgICAgICAgICAgaWYgKHRoZXRhIDwgMC4wKSB7XG4gICAgICAgICAgICAgIHQgPSAtdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYyA9IDEuMCAvIE1hdGguc3FydCgxICsgdCAqIHQpO1xuICAgICAgICAgIHMgPSB0ICogYztcbiAgICAgICAgICB0YXUgPSBzIC8gKDEuMCArIGMpO1xuICAgICAgICAgIGggPSB0ICogYVtpcF1baXFdO1xuICAgICAgICAgIHpbaXBdIC09IGg7XG4gICAgICAgICAgeltpcV0gKz0gaDtcbiAgICAgICAgICB3W2lwXSAtPSBoO1xuICAgICAgICAgIHdbaXFdICs9IGg7XG4gICAgICAgICAgYVtpcF1baXFdID0gMC4wO1xuXG4gICAgICAgICAgLy8gaXAgYWxyZWFkeSBzaGlmdGVkIGxlZnQgYnkgMSB1bml0XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8PSBpcCAtIDE7IGorKykge1xuICAgICAgICAgICAgdnRrUk9UQVRFKGEsIGosIGlwLCBqLCBpcSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGlwIGFuZCBpcSBhbHJlYWR5IHNoaWZ0ZWQgbGVmdCBieSAxIHVuaXRcbiAgICAgICAgICBmb3IgKGogPSBpcCArIDE7IGogPD0gaXEgLSAxOyBqKyspIHtcbiAgICAgICAgICAgIHZ0a1JPVEFURShhLCBpcCwgaiwgaiwgaXEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpcSBhbHJlYWR5IHNoaWZ0ZWQgbGVmdCBieSAxIHVuaXRcbiAgICAgICAgICBmb3IgKGogPSBpcSArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgIHZ0a1JPVEFURShhLCBpcCwgaiwgaXEsIGopO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICB2dGtST1RBVEUodiwgaiwgaXAsIGosIGlxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGlwID0gMDsgaXAgPCBuOyBpcCsrKSB7XG4gICAgICBiW2lwXSArPSB6W2lwXTtcbiAgICAgIHdbaXBdID0gYltpcF07XG4gICAgICB6W2lwXSA9IDAuMDtcbiAgICB9XG4gIH1cblxuICAvLyB0aGlzIGlzIE5FVkVSIGNhbGxlZFxuICBpZiAoaSA+PSBWVEtfTUFYX1JPVEFUSU9OUykge1xuICAgIHZ0a1dhcm5pbmdNYWNybygndnRrTWF0aDo6SmFjb2JpOiBFcnJvciBleHRyYWN0aW5nIGVpZ2VuZnVuY3Rpb25zJyk7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvLyBzb3J0IGVpZ2VuZnVuY3Rpb25zOiB0aGVzZSBjaGFuZ2VzIGRvIG5vdCBhZmZlY3QgYWNjdXJhY3lcbiAgZm9yIChqID0gMDsgaiA8IG4gLSAxOyBqKyspIHtcbiAgICAvLyBib3VuZGFyeSBpbmNvcnJlY3RcbiAgICBrID0gajtcbiAgICB0bXAgPSB3W2tdO1xuICAgIGZvciAoaSA9IGogKyAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAvLyBib3VuZGFyeSBpbmNvcnJlY3QsIHNoaWZ0ZWQgYWxyZWFkeVxuICAgICAgaWYgKHdbaV0gPj0gdG1wKSB7XG4gICAgICAgIC8vIHdoeSBleGNoYW5nZSBpZiBzYW1lP1xuICAgICAgICBrID0gaTtcbiAgICAgICAgdG1wID0gd1trXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGsgIT09IGopIHtcbiAgICAgIHdba10gPSB3W2pdO1xuICAgICAgd1tqXSA9IHRtcDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdG1wID0gdltpXVtqXTtcbiAgICAgICAgdltpXVtqXSA9IHZbaV1ba107XG4gICAgICAgIHZbaV1ba10gPSB0bXA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGVuc3VyZSBlaWdlbnZlY3RvciBjb25zaXN0ZW5jeSAoaS5lLiwgSmFjb2JpIGNhbiBjb21wdXRlIHZlY3RvcnMgdGhhdFxuICAvLyBhcmUgbmVnYXRpdmUgb2Ygb25lIGFub3RoZXIgKC43MDcsLjcwNywwKSBhbmQgKC0uNzA3LC0uNzA3LDApLiBUaGlzIGNhblxuICAvLyByZWVrIGhhdm9jIGluIGh5cGVyc3RyZWFtbGluZS9vdGhlciBzdHVmZi4gV2Ugd2lsbCBzZWxlY3QgdGhlIG1vc3RcbiAgLy8gcG9zaXRpdmUgZWlnZW52ZWN0b3IuXG4gIGNvbnN0IGNlaWxfaGFsZl9uID0gKG4gPj4gMSkgKyAobiAmIDEpO1xuICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgZm9yIChudW1Qb3MgPSAwLCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgaWYgKHZbaV1bal0gPj0gMC4wKSB7XG4gICAgICAgIG51bVBvcysrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyAgICBpZiAoIG51bVBvcyA8IGNlaWwoZG91YmxlKG4pL2RvdWJsZSgyLjApKSApXG4gICAgaWYgKG51bVBvcyA8IGNlaWxfaGFsZl9uKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZbaV1bal0gKj0gLTEuMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXRyaXgzeDNUb1F1YXRlcm5pb24obWF0XzN4MywgcXVhdF80KSB7XG4gIGNvbnN0IHRtcCA9IFtcbiAgICBbMCwgMCwgMCwgMF0sXG4gICAgWzAsIDAsIDAsIDBdLFxuICAgIFswLCAwLCAwLCAwXSxcbiAgICBbMCwgMCwgMCwgMF0sXG4gIF07XG5cbiAgLy8gb24tZGlhZ29uYWwgZWxlbWVudHNcbiAgdG1wWzBdWzBdID0gbWF0XzN4M1swXVswXSArIG1hdF8zeDNbMV1bMV0gKyBtYXRfM3gzWzJdWzJdO1xuICB0bXBbMV1bMV0gPSBtYXRfM3gzWzBdWzBdIC0gbWF0XzN4M1sxXVsxXSAtIG1hdF8zeDNbMl1bMl07XG4gIHRtcFsyXVsyXSA9IC1tYXRfM3gzWzBdWzBdICsgbWF0XzN4M1sxXVsxXSAtIG1hdF8zeDNbMl1bMl07XG4gIHRtcFszXVszXSA9IC1tYXRfM3gzWzBdWzBdIC0gbWF0XzN4M1sxXVsxXSArIG1hdF8zeDNbMl1bMl07XG5cbiAgLy8gb2ZmLWRpYWdvbmFsIGVsZW1lbnRzXG4gIHRtcFswXVsxXSA9IHRtcFsxXVswXSA9IG1hdF8zeDNbMl1bMV0gLSBtYXRfM3gzWzFdWzJdO1xuICB0bXBbMF1bMl0gPSB0bXBbMl1bMF0gPSBtYXRfM3gzWzBdWzJdIC0gbWF0XzN4M1syXVswXTtcbiAgdG1wWzBdWzNdID0gdG1wWzNdWzBdID0gbWF0XzN4M1sxXVswXSAtIG1hdF8zeDNbMF1bMV07XG5cbiAgdG1wWzFdWzJdID0gdG1wWzJdWzFdID0gbWF0XzN4M1sxXVswXSArIG1hdF8zeDNbMF1bMV07XG4gIHRtcFsxXVszXSA9IHRtcFszXVsxXSA9IG1hdF8zeDNbMF1bMl0gKyBtYXRfM3gzWzJdWzBdO1xuICB0bXBbMl1bM10gPSB0bXBbM11bMl0gPSBtYXRfM3gzWzJdWzFdICsgbWF0XzN4M1sxXVsyXTtcblxuICBjb25zdCBlaWdlbnZlY3RvcnMgPSBbXG4gICAgWzAsIDAsIDAsIDBdLFxuICAgIFswLCAwLCAwLCAwXSxcbiAgICBbMCwgMCwgMCwgMF0sXG4gICAgWzAsIDAsIDAsIDBdLFxuICBdO1xuICBjb25zdCBlaWdlbnZhbHVlcyA9IFswLCAwLCAwLCAwXTtcblxuICAvLyBjb252ZXJ0IGludG8gZm9ybWF0IHRoYXQgSmFjb2JpTiBjYW4gdXNlLFxuICAvLyB0aGVuIHVzZSBKYWNvYmkgdG8gZmluZCBlaWdlbnZhbHVlcyBhbmQgZWlnZW52ZWN0b3JzXG4gIGNvbnN0IE5UZW1wID0gWzAsIDAsIDAsIDBdO1xuICBjb25zdCBlaWdlbnZlY3RvcnNUZW1wID0gWzAsIDAsIDAsIDBdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIE5UZW1wW2ldID0gdG1wW2ldO1xuICAgIGVpZ2VudmVjdG9yc1RlbXBbaV0gPSBlaWdlbnZlY3RvcnNbaV07XG4gIH1cbiAgamFjb2JpTihOVGVtcCwgNCwgZWlnZW52YWx1ZXMsIGVpZ2VudmVjdG9yc1RlbXApO1xuXG4gIC8vIHRoZSBmaXJzdCBlaWdlbnZlY3RvciBpcyB0aGUgb25lIHdlIHdhbnRcbiAgcXVhdF80WzBdID0gZWlnZW52ZWN0b3JzWzBdWzBdO1xuICBxdWF0XzRbMV0gPSBlaWdlbnZlY3RvcnNbMV1bMF07XG4gIHF1YXRfNFsyXSA9IGVpZ2VudmVjdG9yc1syXVswXTtcbiAgcXVhdF80WzNdID0gZWlnZW52ZWN0b3JzWzNdWzBdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlRdWF0ZXJuaW9uKHF1YXRfMSwgcXVhdF8yLCBxdWF0X291dCkge1xuICBjb25zdCB3dyA9IHF1YXRfMVswXSAqIHF1YXRfMlswXTtcbiAgY29uc3Qgd3ggPSBxdWF0XzFbMF0gKiBxdWF0XzJbMV07XG4gIGNvbnN0IHd5ID0gcXVhdF8xWzBdICogcXVhdF8yWzJdO1xuICBjb25zdCB3eiA9IHF1YXRfMVswXSAqIHF1YXRfMlszXTtcblxuICBjb25zdCB4dyA9IHF1YXRfMVsxXSAqIHF1YXRfMlswXTtcbiAgY29uc3QgeHggPSBxdWF0XzFbMV0gKiBxdWF0XzJbMV07XG4gIGNvbnN0IHh5ID0gcXVhdF8xWzFdICogcXVhdF8yWzJdO1xuICBjb25zdCB4eiA9IHF1YXRfMVsxXSAqIHF1YXRfMlszXTtcblxuICBjb25zdCB5dyA9IHF1YXRfMVsyXSAqIHF1YXRfMlswXTtcbiAgY29uc3QgeXggPSBxdWF0XzFbMl0gKiBxdWF0XzJbMV07XG4gIGNvbnN0IHl5ID0gcXVhdF8xWzJdICogcXVhdF8yWzJdO1xuICBjb25zdCB5eiA9IHF1YXRfMVsyXSAqIHF1YXRfMlszXTtcblxuICBjb25zdCB6dyA9IHF1YXRfMVszXSAqIHF1YXRfMlswXTtcbiAgY29uc3QgenggPSBxdWF0XzFbM10gKiBxdWF0XzJbMV07XG4gIGNvbnN0IHp5ID0gcXVhdF8xWzNdICogcXVhdF8yWzJdO1xuICBjb25zdCB6eiA9IHF1YXRfMVszXSAqIHF1YXRfMlszXTtcblxuICBxdWF0X291dFswXSA9IHd3IC0geHggLSB5eSAtIHp6O1xuICBxdWF0X291dFsxXSA9IHd4ICsgeHcgKyB5eiAtIHp5O1xuICBxdWF0X291dFsyXSA9IHd5IC0geHogKyB5dyArIHp4O1xuICBxdWF0X291dFszXSA9IHd6ICsgeHkgLSB5eCArIHp3O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3J0aG9nb25hbGl6ZTN4MyhhXzN4Mywgb3V0XzN4Mykge1xuICAvLyBjb3B5IHRoZSBtYXRyaXhcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBvdXRfM3gzWzBdW2ldID0gYV8zeDNbMF1baV07XG4gICAgb3V0XzN4M1sxXVtpXSA9IGFfM3gzWzFdW2ldO1xuICAgIG91dF8zeDNbMl1baV0gPSBhXzN4M1syXVtpXTtcbiAgfVxuXG4gIC8vIFBpdm90IHRoZSBtYXRyaXggdG8gaW1wcm92ZSBhY2N1cmFjeVxuICBjb25zdCBzY2FsZSA9IGNyZWF0ZUFycmF5KDMpO1xuICBjb25zdCBpbmRleCA9IGNyZWF0ZUFycmF5KDMpO1xuICBsZXQgbGFyZ2VzdDtcblxuICAvLyBMb29wIG92ZXIgcm93cyB0byBnZXQgaW1wbGljaXQgc2NhbGluZyBpbmZvcm1hdGlvblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIGNvbnN0IHgxID0gTWF0aC5hYnMob3V0XzN4M1tpXVswXSk7XG4gICAgY29uc3QgeDIgPSBNYXRoLmFicyhvdXRfM3gzW2ldWzFdKTtcbiAgICBjb25zdCB4MyA9IE1hdGguYWJzKG91dF8zeDNbaV1bMl0pO1xuICAgIGxhcmdlc3QgPSB4MiA+IHgxID8geDIgOiB4MTtcbiAgICBsYXJnZXN0ID0geDMgPiBsYXJnZXN0ID8geDMgOiBsYXJnZXN0O1xuICAgIHNjYWxlW2ldID0gMTtcbiAgICBpZiAobGFyZ2VzdCAhPT0gMCkge1xuICAgICAgc2NhbGVbaV0gLz0gbGFyZ2VzdDtcbiAgICB9XG4gIH1cblxuICAvLyBmaXJzdCBjb2x1bW5cbiAgY29uc3QgeDEgPSBNYXRoLmFicyhvdXRfM3gzWzBdWzBdKSAqIHNjYWxlWzBdO1xuICBjb25zdCB4MiA9IE1hdGguYWJzKG91dF8zeDNbMV1bMF0pICogc2NhbGVbMV07XG4gIGNvbnN0IHgzID0gTWF0aC5hYnMob3V0XzN4M1syXVswXSkgKiBzY2FsZVsyXTtcbiAgaW5kZXhbMF0gPSAwO1xuICBsYXJnZXN0ID0geDE7XG4gIGlmICh4MiA+PSBsYXJnZXN0KSB7XG4gICAgbGFyZ2VzdCA9IHgyO1xuICAgIGluZGV4WzBdID0gMTtcbiAgfVxuICBpZiAoeDMgPj0gbGFyZ2VzdCkge1xuICAgIGluZGV4WzBdID0gMjtcbiAgfVxuICBpZiAoaW5kZXhbMF0gIT09IDApIHtcbiAgICB2dGtTd2FwVmVjdG9yczMob3V0XzN4M1tpbmRleFswXV0sIG91dF8zeDNbMF0pO1xuICAgIHNjYWxlW2luZGV4WzBdXSA9IHNjYWxlWzBdO1xuICB9XG5cbiAgLy8gc2Vjb25kIGNvbHVtblxuICBjb25zdCB5MiA9IE1hdGguYWJzKG91dF8zeDNbMV1bMV0pICogc2NhbGVbMV07XG4gIGNvbnN0IHkzID0gTWF0aC5hYnMob3V0XzN4M1syXVsxXSkgKiBzY2FsZVsyXTtcbiAgaW5kZXhbMV0gPSAxO1xuICBsYXJnZXN0ID0geTI7XG4gIGlmICh5MyA+PSBsYXJnZXN0KSB7XG4gICAgaW5kZXhbMV0gPSAyO1xuICAgIHZ0a1N3YXBWZWN0b3JzMyhvdXRfM3gzWzJdLCBvdXRfM3gzWzFdKTtcbiAgfVxuXG4gIC8vIHRoaXJkIGNvbHVtblxuICBpbmRleFsyXSA9IDI7XG5cbiAgLy8gQSBxdWF0ZXJuaW9uIGNhbiBvbmx5IGRlc2NyaWJlIGEgcHVyZSByb3RhdGlvbiwgbm90XG4gIC8vIGEgcm90YXRpb24gd2l0aCBhIGZsaXAsIHRoZXJlZm9yZSB0aGUgZmxpcCBtdXN0IGJlXG4gIC8vIHJlbW92ZWQgYmVmb3JlIHRoZSBtYXRyaXggaXMgY29udmVydGVkIHRvIGEgcXVhdGVybmlvbi5cbiAgbGV0IGZsaXAgPSAwO1xuICBpZiAoZGV0ZXJtaW5hbnQzeDMob3V0XzN4MykgPCAwKSB7XG4gICAgZmxpcCA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIG91dF8zeDNbMF1baV0gPSAtb3V0XzN4M1swXVtpXTtcbiAgICAgIG91dF8zeDNbMV1baV0gPSAtb3V0XzN4M1sxXVtpXTtcbiAgICAgIG91dF8zeDNbMl1baV0gPSAtb3V0XzN4M1syXVtpXTtcbiAgICB9XG4gIH1cblxuICAvLyBEbyBvcnRob2dvbmFsaXphdGlvbiB1c2luZyBhIHF1YXRlcm5pb24gaW50ZXJtZWRpYXRlXG4gIC8vICh0aGlzLCBlc3NlbnRpYWxseSwgZG9lcyB0aGUgb3J0aG9nb25hbGl6YXRpb24gdmlhXG4gIC8vIGRpYWdvbmFsaXphdGlvbiBvZiBhbiBhcHByb3ByaWF0ZWx5IGNvbnN0cnVjdGVkIHN5bW1ldHJpY1xuICAvLyA0eDQgbWF0cml4IHJhdGhlciB0aGFuIGJ5IGRvaW5nIFNWRCBvZiB0aGUgM3gzIG1hdHJpeClcbiAgY29uc3QgcXVhdCA9IGNyZWF0ZUFycmF5KDQpO1xuICBtYXRyaXgzeDNUb1F1YXRlcm5pb24ob3V0XzN4MywgcXVhdCk7XG4gIHF1YXRlcm5pb25Ub01hdHJpeDN4MyhxdWF0LCBvdXRfM3gzKTtcblxuICAvLyBQdXQgdGhlIGZsaXAgYmFjayBpbnRvIHRoZSBvcnRob2dvbmFsaXplZCBtYXRyaXguXG4gIGlmIChmbGlwKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIG91dF8zeDNbMF1baV0gPSAtb3V0XzN4M1swXVtpXTtcbiAgICAgIG91dF8zeDNbMV1baV0gPSAtb3V0XzN4M1sxXVtpXTtcbiAgICAgIG91dF8zeDNbMl1baV0gPSAtb3V0XzN4M1syXVtpXTtcbiAgICB9XG4gIH1cblxuICAvLyBVbmRvIHRoZSBwaXZvdGluZ1xuICBpZiAoaW5kZXhbMV0gIT09IDEpIHtcbiAgICB2dGtTd2FwVmVjdG9yczMob3V0XzN4M1tpbmRleFsxXV0sIG91dF8zeDNbMV0pO1xuICB9XG4gIGlmIChpbmRleFswXSAhPT0gMCkge1xuICAgIHZ0a1N3YXBWZWN0b3JzMyhvdXRfM3gzW2luZGV4WzBdXSwgb3V0XzN4M1swXSk7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpYWdvbmFsaXplM3gzKGFfM3gzLCB3XzMsIHZfM3gzKSB7XG4gIGxldCBpO1xuICBsZXQgajtcbiAgbGV0IGs7XG4gIGxldCBtYXhJO1xuICBsZXQgdG1wO1xuICBsZXQgbWF4VmFsO1xuXG4gIC8vIGRvIHRoZSBtYXRyaXhbM11bM10gdG8gKiptYXRyaXggY29udmVyc2lvbiBmb3IgSmFjb2JpXG4gIGNvbnN0IEMgPSBbY3JlYXRlQXJyYXkoMyksIGNyZWF0ZUFycmF5KDMpLCBjcmVhdGVBcnJheSgzKV07XG4gIGNvbnN0IEFUZW1wID0gY3JlYXRlQXJyYXkoMyk7XG4gIGNvbnN0IFZUZW1wID0gY3JlYXRlQXJyYXkoMyk7XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBDW2ldWzBdID0gYV8zeDNbaV1bMF07XG4gICAgQ1tpXVsxXSA9IGFfM3gzW2ldWzFdO1xuICAgIENbaV1bMl0gPSBhXzN4M1tpXVsyXTtcbiAgICBBVGVtcFtpXSA9IENbaV07XG4gICAgVlRlbXBbaV0gPSB2XzN4M1tpXTtcbiAgfVxuXG4gIC8vIGRpYWdvbmFsaXplIHVzaW5nIEphY29iaVxuICBqYWNvYmlOKEFUZW1wLCAzLCB3XzMsIFZUZW1wKTtcblxuICAvLyBpZiBhbGwgdGhlIGVpZ2VudmFsdWVzIGFyZSB0aGUgc2FtZSwgcmV0dXJuIGlkZW50aXR5IG1hdHJpeFxuICBpZiAod18zWzBdID09PSB3XzNbMV0gJiYgd18zWzBdID09PSB3XzNbMl0pIHtcbiAgICBpZGVudGl0eTN4Myh2XzN4Myk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gdHJhbnNwb3NlIHRlbXBvcmFyaWx5LCBpdCBtYWtlcyBpdCBlYXNpZXIgdG8gc29ydCB0aGUgZWlnZW52ZWN0b3JzXG4gIHRyYW5zcG9zZTN4Myh2XzN4Mywgdl8zeDMpO1xuXG4gIC8vIGlmIHR3byBlaWdlbnZhbHVlcyBhcmUgdGhlIHNhbWUsIHJlLW9ydGhvZ29uYWxpemUgdG8gb3B0aW1hbGx5IGxpbmVcbiAgLy8gdXAgdGhlIGVpZ2VudmVjdG9ycyB3aXRoIHRoZSB4LCB5LCBhbmQgeiBheGVzXG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAvLyB0d28gZWlnZW52YWx1ZXMgYXJlIHRoZSBzYW1lXG4gICAgaWYgKHdfM1soaSArIDEpICUgM10gPT09IHdfM1soaSArIDIpICUgM10pIHtcbiAgICAgIC8vIGZpbmQgbWF4aW11bSBlbGVtZW50IG9mIHRoZSBpbmRlcGVuZGVudCBlaWdlbnZlY3RvclxuICAgICAgbWF4VmFsID0gTWF0aC5hYnModl8zeDNbaV1bMF0pO1xuICAgICAgbWF4SSA9IDA7XG4gICAgICBmb3IgKGogPSAxOyBqIDwgMzsgaisrKSB7XG4gICAgICAgIGlmIChtYXhWYWwgPCAodG1wID0gTWF0aC5hYnModl8zeDNbaV1bal0pKSkge1xuICAgICAgICAgIG1heFZhbCA9IHRtcDtcbiAgICAgICAgICBtYXhJID0gajtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gc3dhcCB0aGUgZWlnZW52ZWN0b3IgaW50byBpdHMgcHJvcGVyIHBvc2l0aW9uXG4gICAgICBpZiAobWF4SSAhPT0gaSkge1xuICAgICAgICB0bXAgPSB3XzNbbWF4SV07XG4gICAgICAgIHdfM1ttYXhJXSA9IHdfM1tpXTtcbiAgICAgICAgd18zW2ldID0gdG1wO1xuICAgICAgICB2dGtTd2FwVmVjdG9yczModl8zeDNbaV0sIHZfM3gzW21heEldKTtcbiAgICAgIH1cbiAgICAgIC8vIG1heGltdW0gZWxlbWVudCBvZiBlaWdlbnZlY3RvciBzaG91bGQgYmUgcG9zaXRpdmVcbiAgICAgIGlmICh2XzN4M1ttYXhJXVttYXhJXSA8IDApIHtcbiAgICAgICAgdl8zeDNbbWF4SV1bMF0gPSAtdl8zeDNbbWF4SV1bMF07XG4gICAgICAgIHZfM3gzW21heEldWzFdID0gLXZfM3gzW21heEldWzFdO1xuICAgICAgICB2XzN4M1ttYXhJXVsyXSA9IC12XzN4M1ttYXhJXVsyXTtcbiAgICAgIH1cblxuICAgICAgLy8gcmUtb3J0aG9nb25hbGl6ZSB0aGUgb3RoZXIgdHdvIGVpZ2VudmVjdG9yc1xuICAgICAgaiA9IChtYXhJICsgMSkgJSAzO1xuICAgICAgayA9IChtYXhJICsgMikgJSAzO1xuXG4gICAgICB2XzN4M1tqXVswXSA9IDAuMDtcbiAgICAgIHZfM3gzW2pdWzFdID0gMC4wO1xuICAgICAgdl8zeDNbal1bMl0gPSAwLjA7XG4gICAgICB2XzN4M1tqXVtqXSA9IDEuMDtcbiAgICAgIGNyb3NzKHZfM3gzW21heEldLCB2XzN4M1tqXSwgdl8zeDNba10pO1xuICAgICAgbm9ybWFsaXplKHZfM3gzW2tdKTtcbiAgICAgIGNyb3NzKHZfM3gzW2tdLCB2XzN4M1ttYXhJXSwgdl8zeDNbal0pO1xuXG4gICAgICAvLyB0cmFuc3Bvc2UgdmVjdG9ycyBiYWNrIHRvIGNvbHVtbnNcbiAgICAgIHRyYW5zcG9zZTN4Myh2XzN4Mywgdl8zeDMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoZSB0aHJlZSBlaWdlbnZhbHVlcyBhcmUgZGlmZmVyZW50LCBqdXN0IHNvcnQgdGhlIGVpZ2VudmVjdG9yc1xuICAvLyB0byBhbGlnbiB0aGVtIHdpdGggdGhlIHgsIHksIGFuZCB6IGF4ZXNcblxuICAvLyBmaW5kIHRoZSB2ZWN0b3Igd2l0aCB0aGUgbGFyZ2VzdCB4IGVsZW1lbnQsIG1ha2UgdGhhdCB2ZWN0b3JcbiAgLy8gdGhlIGZpcnN0IHZlY3RvclxuICBtYXhWYWwgPSBNYXRoLmFicyh2XzN4M1swXVswXSk7XG4gIG1heEkgPSAwO1xuICBmb3IgKGkgPSAxOyBpIDwgMzsgaSsrKSB7XG4gICAgaWYgKG1heFZhbCA8ICh0bXAgPSBNYXRoLmFicyh2XzN4M1tpXVswXSkpKSB7XG4gICAgICBtYXhWYWwgPSB0bXA7XG4gICAgICBtYXhJID0gaTtcbiAgICB9XG4gIH1cbiAgLy8gc3dhcCBlaWdlbnZhbHVlIGFuZCBlaWdlbnZlY3RvclxuICBpZiAobWF4SSAhPT0gMCkge1xuICAgIHRtcCA9IHdfM1ttYXhJXTtcbiAgICB3XzNbbWF4SV0gPSB3XzNbMF07XG4gICAgd18zWzBdID0gdG1wO1xuICAgIHZ0a1N3YXBWZWN0b3JzMyh2XzN4M1ttYXhJXSwgdl8zeDNbMF0pO1xuICB9XG4gIC8vIGRvIHRoZSBzYW1lIGZvciB0aGUgeSBlbGVtZW50XG4gIGlmIChNYXRoLmFicyh2XzN4M1sxXVsxXSkgPCBNYXRoLmFicyh2XzN4M1syXVsxXSkpIHtcbiAgICB0bXAgPSB3XzNbMl07XG4gICAgd18zWzJdID0gd18zWzFdO1xuICAgIHdfM1sxXSA9IHRtcDtcbiAgICB2dGtTd2FwVmVjdG9yczModl8zeDNbMl0sIHZfM3gzWzFdKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSB0aGF0IHRoZSBzaWduIG9mIHRoZSBlaWdlbnZlY3RvcnMgaXMgY29ycmVjdFxuICBmb3IgKGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgaWYgKHZfM3gzW2ldW2ldIDwgMCkge1xuICAgICAgdl8zeDNbaV1bMF0gPSAtdl8zeDNbaV1bMF07XG4gICAgICB2XzN4M1tpXVsxXSA9IC12XzN4M1tpXVsxXTtcbiAgICAgIHZfM3gzW2ldWzJdID0gLXZfM3gzW2ldWzJdO1xuICAgIH1cbiAgfVxuICAvLyBzZXQgc2lnbiBvZiBmaW5hbCBlaWdlbnZlY3RvciB0byBlbnN1cmUgdGhhdCBkZXRlcm1pbmFudCBpcyBwb3NpdGl2ZVxuICBpZiAoZGV0ZXJtaW5hbnQzeDModl8zeDMpIDwgMCkge1xuICAgIHZfM3gzWzJdWzBdID0gLXZfM3gzWzJdWzBdO1xuICAgIHZfM3gzWzJdWzFdID0gLXZfM3gzWzJdWzFdO1xuICAgIHZfM3gzWzJdWzJdID0gLXZfM3gzWzJdWzJdO1xuICB9XG5cbiAgLy8gdHJhbnNwb3NlIHRoZSBlaWdlbnZlY3RvcnMgYmFjayBhZ2FpblxuICB0cmFuc3Bvc2UzeDModl8zeDMsIHZfM3gzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbmd1bGFyVmFsdWVEZWNvbXBvc2l0aW9uM3gzKGFfM3gzLCB1XzN4Mywgd18zLCB2VF8zeDMpIHtcbiAgbGV0IGk7XG4gIGNvbnN0IEIgPSBbY3JlYXRlQXJyYXkoMyksIGNyZWF0ZUFycmF5KDMpLCBjcmVhdGVBcnJheSgzKV07XG5cbiAgLy8gY29weSBzbyB0aGF0IEEgY2FuIGJlIHVzZWQgZm9yIFUgb3IgVlQgd2l0aG91dCByaXNrXG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBCWzBdW2ldID0gYV8zeDNbMF1baV07XG4gICAgQlsxXVtpXSA9IGFfM3gzWzFdW2ldO1xuICAgIEJbMl1baV0gPSBhXzN4M1syXVtpXTtcbiAgfVxuXG4gIC8vIHRlbXBvcmFyaWx5IGZsaXAgaWYgZGV0ZXJtaW5hbnQgaXMgbmVnYXRpdmVcbiAgY29uc3QgZCA9IGRldGVybWluYW50M3gzKEIpO1xuICBpZiAoZCA8IDApIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBCWzBdW2ldID0gLUJbMF1baV07XG4gICAgICBCWzFdW2ldID0gLUJbMV1baV07XG4gICAgICBCWzJdW2ldID0gLUJbMl1baV07XG4gICAgfVxuICB9XG5cbiAgLy8gb3J0aG9nb25hbGl6ZSwgZGlhZ29uYWxpemUsIGV0Yy5cbiAgb3J0aG9nb25hbGl6ZTN4MyhCLCB1XzN4Myk7XG4gIHRyYW5zcG9zZTN4MyhCLCBCKTtcbiAgbXVsdGlwbHkzeDNfbWF0MyhCLCB1XzN4MywgdlRfM3gzKTtcbiAgZGlhZ29uYWxpemUzeDModlRfM3gzLCB3XzMsIHZUXzN4Myk7XG4gIG11bHRpcGx5M3gzX21hdDModV8zeDMsIHZUXzN4MywgdV8zeDMpO1xuICB0cmFuc3Bvc2UzeDModlRfM3gzLCB2VF8zeDMpO1xuXG4gIC8vIHJlLWNyZWF0ZSB0aGUgZmxpcFxuICBpZiAoZCA8IDApIHtcbiAgICB3XzNbMF0gPSAtd18zWzBdO1xuICAgIHdfM1sxXSA9IC13XzNbMV07XG4gICAgd18zWzJdID0gLXdfM1syXTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbHVGYWN0b3JMaW5lYXJTeXN0ZW0oQSwgaW5kZXgsIHNpemUpIHtcbiAgbGV0IGk7XG4gIGxldCBqO1xuICBsZXQgaztcbiAgbGV0IGxhcmdlc3Q7XG4gIGxldCBtYXhJID0gMDtcbiAgbGV0IHN1bTtcbiAgbGV0IHRlbXAxO1xuICBsZXQgdGVtcDI7XG4gIGNvbnN0IHNjYWxlID0gY3JlYXRlQXJyYXkoc2l6ZSk7XG5cbiAgLy9cbiAgLy8gTG9vcCBvdmVyIHJvd3MgdG8gZ2V0IGltcGxpY2l0IHNjYWxpbmcgaW5mb3JtYXRpb25cbiAgLy9cbiAgZm9yIChpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGZvciAobGFyZ2VzdCA9IDAuMCwgaiA9IDA7IGogPCBzaXplOyBqKyspIHtcbiAgICAgIGlmICgodGVtcDIgPSBNYXRoLmFicyhBW2ldW2pdKSkgPiBsYXJnZXN0KSB7XG4gICAgICAgIGxhcmdlc3QgPSB0ZW1wMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGFyZ2VzdCA9PT0gMC4wKSB7XG4gICAgICB2dGtXYXJuaW5nTWFjcm8oJ1VuYWJsZSB0byBmYWN0b3IgbGluZWFyIHN5c3RlbScpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHNjYWxlW2ldID0gMS4wIC8gbGFyZ2VzdDtcbiAgfVxuICAvL1xuICAvLyBMb29wIG92ZXIgYWxsIGNvbHVtbnMgdXNpbmcgQ3JvdXQncyBtZXRob2RcbiAgLy9cbiAgZm9yIChqID0gMDsgaiA8IHNpemU7IGorKykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIHtcbiAgICAgIHN1bSA9IEFbaV1bal07XG4gICAgICBmb3IgKGsgPSAwOyBrIDwgaTsgaysrKSB7XG4gICAgICAgIHN1bSAtPSBBW2ldW2tdICogQVtrXVtqXTtcbiAgICAgIH1cbiAgICAgIEFbaV1bal0gPSBzdW07XG4gICAgfVxuICAgIC8vXG4gICAgLy8gQmVnaW4gc2VhcmNoIGZvciBsYXJnZXN0IHBpdm90IGVsZW1lbnRcbiAgICAvL1xuICAgIGZvciAobGFyZ2VzdCA9IDAuMCwgaSA9IGo7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIHN1bSA9IEFbaV1bal07XG4gICAgICBmb3IgKGsgPSAwOyBrIDwgajsgaysrKSB7XG4gICAgICAgIHN1bSAtPSBBW2ldW2tdICogQVtrXVtqXTtcbiAgICAgIH1cbiAgICAgIEFbaV1bal0gPSBzdW07XG5cbiAgICAgIGlmICgodGVtcDEgPSBzY2FsZVtpXSAqIE1hdGguYWJzKHN1bSkpID49IGxhcmdlc3QpIHtcbiAgICAgICAgbGFyZ2VzdCA9IHRlbXAxO1xuICAgICAgICBtYXhJID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy9cbiAgICAvLyBDaGVjayBmb3Igcm93IGludGVyY2hhbmdlXG4gICAgLy9cbiAgICBpZiAoaiAhPT0gbWF4SSkge1xuICAgICAgZm9yIChrID0gMDsgayA8IHNpemU7IGsrKykge1xuICAgICAgICB0ZW1wMSA9IEFbbWF4SV1ba107XG4gICAgICAgIEFbbWF4SV1ba10gPSBBW2pdW2tdO1xuICAgICAgICBBW2pdW2tdID0gdGVtcDE7XG4gICAgICB9XG4gICAgICBzY2FsZVttYXhJXSA9IHNjYWxlW2pdO1xuICAgIH1cbiAgICAvL1xuICAgIC8vIERpdmlkZSBieSBwaXZvdCBlbGVtZW50IGFuZCBwZXJmb3JtIGVsaW1pbmF0aW9uXG4gICAgLy9cbiAgICBpbmRleFtqXSA9IG1heEk7XG5cbiAgICBpZiAoTWF0aC5hYnMoQVtqXVtqXSkgPD0gVlRLX1NNQUxMX05VTUJFUikge1xuICAgICAgdnRrV2FybmluZ01hY3JvKCdVbmFibGUgdG8gZmFjdG9yIGxpbmVhciBzeXN0ZW0nKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmIChqICE9PSBzaXplIC0gMSkge1xuICAgICAgdGVtcDEgPSAxLjAgLyBBW2pdW2pdO1xuICAgICAgZm9yIChpID0gaiArIDE7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgQVtpXVtqXSAqPSB0ZW1wMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsdVNvbHZlTGluZWFyU3lzdGVtKEEsIGluZGV4LCB4LCBzaXplKSB7XG4gIGxldCBpO1xuICBsZXQgajtcbiAgbGV0IGlpO1xuICBsZXQgaWR4O1xuICBsZXQgc3VtO1xuICAvL1xuICAvLyBQcm9jZWVkIHdpdGggZm9yd2FyZCBhbmQgYmFja3N1YnN0aXR1dGlvbiBmb3IgTCBhbmQgVVxuICAvLyBtYXRyaWNlcy4gIEZpcnN0LCBmb3J3YXJkIHN1YnN0aXR1dGlvbi5cbiAgLy9cbiAgZm9yIChpaSA9IC0xLCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIGlkeCA9IGluZGV4W2ldO1xuICAgIHN1bSA9IHhbaWR4XTtcbiAgICB4W2lkeF0gPSB4W2ldO1xuXG4gICAgaWYgKGlpID49IDApIHtcbiAgICAgIGZvciAoaiA9IGlpOyBqIDw9IGkgLSAxOyBqKyspIHtcbiAgICAgICAgc3VtIC09IEFbaV1bal0gKiB4W2pdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc3VtICE9PSAwLjApIHtcbiAgICAgIGlpID0gaTtcbiAgICB9XG5cbiAgICB4W2ldID0gc3VtO1xuICB9XG4gIC8vXG4gIC8vIE5vdywgYmFjayBzdWJzdGl0dXRpb25cbiAgLy9cbiAgZm9yIChpID0gc2l6ZSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgc3VtID0geFtpXTtcbiAgICBmb3IgKGogPSBpICsgMTsgaiA8IHNpemU7IGorKykge1xuICAgICAgc3VtIC09IEFbaV1bal0gKiB4W2pdO1xuICAgIH1cbiAgICB4W2ldID0gc3VtIC8gQVtpXVtpXTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc29sdmVMaW5lYXJTeXN0ZW0oQSwgeCwgc2l6ZSkge1xuICAvLyBpZiB3ZSBzb2x2aW5nIHNvbWV0aGluZyBzaW1wbGUsIGp1c3Qgc29sdmUgaXRcbiAgaWYgKHNpemUgPT09IDIpIHtcbiAgICBjb25zdCB5ID0gY3JlYXRlQXJyYXkoMik7XG4gICAgY29uc3QgZGV0ID0gZGV0ZXJtaW5hbnQyeDIoQVswXVswXSwgQVswXVsxXSwgQVsxXVswXSwgQVsxXVsxXSk7XG5cbiAgICBpZiAoZGV0ID09PSAwLjApIHtcbiAgICAgIC8vIFVuYWJsZSB0byBzb2x2ZSBsaW5lYXIgc3lzdGVtXG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB5WzBdID0gKEFbMV1bMV0gKiB4WzBdIC0gQVswXVsxXSAqIHhbMV0pIC8gZGV0O1xuICAgIHlbMV0gPSAoLShBWzFdWzBdICogeFswXSkgKyBBWzBdWzBdICogeFsxXSkgLyBkZXQ7XG5cbiAgICB4WzBdID0geVswXTtcbiAgICB4WzFdID0geVsxXTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGlmIChzaXplID09PSAxKSB7XG4gICAgaWYgKEFbMF1bMF0gPT09IDAuMCkge1xuICAgICAgLy8gVW5hYmxlIHRvIHNvbHZlIGxpbmVhciBzeXN0ZW1cbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHhbMF0gLz0gQVswXVswXTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8vXG4gIC8vIFN5c3RlbSBvZiBlcXVhdGlvbnMgaXMgbm90IHRyaXZpYWwsIHVzZSBDcm91dCdzIG1ldGhvZFxuICAvL1xuXG4gIC8vIENoZWNrIG9uIGFsbG9jYXRpb24gb2Ygd29ya2luZyB2ZWN0b3JzXG4gIGNvbnN0IGluZGV4ID0gY3JlYXRlQXJyYXkoc2l6ZSk7XG5cbiAgLy8gRmFjdG9yIGFuZCBzb2x2ZSBtYXRyaXhcbiAgaWYgKGx1RmFjdG9yTGluZWFyU3lzdGVtKEEsIGluZGV4LCBzaXplKSA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGx1U29sdmVMaW5lYXJTeXN0ZW0oQSwgaW5kZXgsIHgsIHNpemUpO1xuXG4gIHJldHVybiAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0TWF0cml4KEEsIEFJLCBzaXplLCBpbmRleCA9IG51bGwsIGNvbHVtbiA9IG51bGwpIHtcbiAgY29uc3QgdG1wMVNpemUgPSBpbmRleCB8fCBjcmVhdGVBcnJheShzaXplKTtcbiAgY29uc3QgdG1wMlNpemUgPSBjb2x1bW4gfHwgY3JlYXRlQXJyYXkoc2l6ZSk7XG5cbiAgLy8gRmFjdG9yIG1hdHJpeDsgdGhlbiBiZWdpbiBzb2x2aW5nIGZvciBpbnZlcnNlIG9uZSBjb2x1bW4gYXQgYSB0aW1lLlxuICAvLyBOb3RlOiB0bXAxU2l6ZSByZXR1cm5lZCB2YWx1ZSBpcyB1c2VkIGxhdGVyLCB0bXAyU2l6ZSBpcyBqdXN0IHdvcmtpbmdcbiAgLy8gbWVtb3J5IHdob3NlIHZhbHVlcyBhcmUgbm90IHVzZWQgaW4gTFVTb2x2ZUxpbmVhclN5c3RlbVxuICBpZiAobHVGYWN0b3JMaW5lYXJTeXN0ZW0oQSwgdG1wMVNpemUsIHNpemUsIHRtcDJTaXplKSA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgZm9yIChsZXQgaiA9IDA7IGogPCBzaXplOyBqKyspIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgdG1wMlNpemVbaV0gPSAwLjA7XG4gICAgfVxuICAgIHRtcDJTaXplW2pdID0gMS4wO1xuXG4gICAgbHVTb2x2ZUxpbmVhclN5c3RlbShBLCB0bXAxU2l6ZSwgdG1wMlNpemUsIHNpemUpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgIEFJW2ldW2pdID0gdG1wMlNpemVbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlc3RpbWF0ZU1hdHJpeENvbmRpdGlvbihBLCBzaXplKSB7XG4gIGxldCBtaW5WYWx1ZSA9ICtOdW1iZXIuTUFYX1ZBTFVFO1xuICBsZXQgbWF4VmFsdWUgPSAtTnVtYmVyLk1BWF9WQUxVRTtcblxuICAvLyBmaW5kIHRoZSBtYXhpbXVtIHZhbHVlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IGk7IGogPCBzaXplOyBqKyspIHtcbiAgICAgIGlmIChNYXRoLmFicyhBW2ldW2pdKSA+IG1heCkge1xuICAgICAgICBtYXhWYWx1ZSA9IE1hdGguYWJzKEFbaV1bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmQgdGhlIG1pbmltdW0gZGlhZ29uYWwgdmFsdWVcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBpZiAoTWF0aC5hYnMoQVtpXVtpXSkgPCBtaW4pIHtcbiAgICAgIG1pblZhbHVlID0gTWF0aC5hYnMoQVtpXVtpXSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1pblZhbHVlID09PSAwLjApIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbiAgfVxuICByZXR1cm4gbWF4VmFsdWUgLyBtaW5WYWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGphY29iaShhXzN4Mywgdywgdikge1xuICByZXR1cm4gamFjb2JpTihhXzN4MywgMywgdywgdik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb2x2ZUhvbW9nZW5lb3VzTGVhc3RTcXVhcmVzKG51bWJlck9mU2FtcGxlcywgeHQsIHhPcmRlciwgbXQpIHtcbiAgLy8gY2hlY2sgZGltZW5zaW9uYWwgY29uc2lzdGVuY3lcbiAgaWYgKG51bWJlck9mU2FtcGxlcyA8IHhPcmRlcikge1xuICAgIHZ0a1dhcm5pbmdNYWNybygnSW5zdWZmaWNpZW50IG51bWJlciBvZiBzYW1wbGVzLiBVbmRlcmRldGVybWluZWQuJyk7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBsZXQgaTtcbiAgbGV0IGo7XG4gIGxldCBrO1xuXG4gIC8vIHNldCB1cCBpbnRlcm1lZGlhdGUgdmFyaWFibGVzXG4gIC8vIEFsbG9jYXRlIG1hdHJpeCB0byBob2xkIFggdGltZXMgdHJhbnNwb3NlIG9mIFhcbiAgY29uc3QgWFh0ID0gY3JlYXRlQXJyYXkoeE9yZGVyKTsgLy8gc2l6ZSB4IGJ5IHhcbiAgLy8gQWxsb2NhdGUgdGhlIGFycmF5IG9mIGVpZ2VudmFsdWVzIGFuZCBlaWdlbnZlY3RvcnNcbiAgY29uc3QgZWlnZW52YWxzID0gY3JlYXRlQXJyYXkoeE9yZGVyKTtcbiAgY29uc3QgZWlnZW52ZWNzID0gY3JlYXRlQXJyYXkoeE9yZGVyKTtcblxuICAvLyBDbGVhciB0aGUgdXBwZXIgdHJpYW5ndWxhciByZWdpb24gKGFuZCBidHcsIGFsbG9jYXRlIHRoZSBlaWdlbnZlY3MgYXMgd2VsbClcbiAgZm9yIChpID0gMDsgaSA8IHhPcmRlcjsgaSsrKSB7XG4gICAgZWlnZW52ZWNzW2ldID0gY3JlYXRlQXJyYXkoeE9yZGVyKTtcbiAgICBYWHRbaV0gPSBjcmVhdGVBcnJheSh4T3JkZXIpO1xuICAgIGZvciAoaiA9IDA7IGogPCB4T3JkZXI7IGorKykge1xuICAgICAgWFh0W2ldW2pdID0gMC4wO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBYWHQgdXBwZXIgaGFsZiBvbmx5LCBkdWUgdG8gc3ltbWV0cnlcbiAgZm9yIChrID0gMDsgayA8IG51bWJlck9mU2FtcGxlczsgaysrKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHhPcmRlcjsgaSsrKSB7XG4gICAgICBmb3IgKGogPSBpOyBqIDwgeE9yZGVyOyBqKyspIHtcbiAgICAgICAgWFh0W2ldW2pdICs9IHh0W2tdW2ldICogeHRba11bal07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IGZpbGwgaW4gdGhlIGxvd2VyIGhhbGYgb2YgdGhlIFhYdCBtYXRyaXhcbiAgZm9yIChpID0gMDsgaSA8IHhPcmRlcjsgaSsrKSB7XG4gICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgWFh0W2ldW2pdID0gWFh0W2pdW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGVpZ2VudmVjdG9ycyBhbmQgZWlnZW52YWx1ZXNcbiAgamFjb2JpTihYWHQsIHhPcmRlciwgZWlnZW52YWxzLCBlaWdlbnZlY3MpO1xuXG4gIC8vIFNtYWxsZXN0IGVpZ2VudmFsIGlzIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QgKHhPcmRlci0xKSwgYW5kIHNvbHV0aW9uIGlzXG4gIC8vIGNvcnJlc3BvbmRpbmcgZWlnZW52ZWMuXG4gIGZvciAoaSA9IDA7IGkgPCB4T3JkZXI7IGkrKykge1xuICAgIG10W2ldWzBdID0gZWlnZW52ZWNzW2ldW3hPcmRlciAtIDFdO1xuICB9XG5cbiAgcmV0dXJuIDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb2x2ZUxlYXN0U3F1YXJlcyhcbiAgbnVtYmVyT2ZTYW1wbGVzLFxuICB4dCxcbiAgeE9yZGVyLFxuICB5dCxcbiAgeU9yZGVyLFxuICBtdCxcbiAgY2hlY2tIb21vZ2VuZW91cyA9IHRydWVcbikge1xuICAvLyBjaGVjayBkaW1lbnNpb25hbCBjb25zaXN0ZW5jeVxuICBpZiAobnVtYmVyT2ZTYW1wbGVzIDwgeE9yZGVyIHx8IG51bWJlck9mU2FtcGxlcyA8IHlPcmRlcikge1xuICAgIHZ0a1dhcm5pbmdNYWNybygnSW5zdWZmaWNpZW50IG51bWJlciBvZiBzYW1wbGVzLiBVbmRlcmRldGVybWluZWQuJyk7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBjb25zdCBob21vZ2VuRmxhZ3MgPSBjcmVhdGVBcnJheSh5T3JkZXIpO1xuICBsZXQgYWxsSG9tb2dlbmVvdXMgPSAxO1xuICBsZXQgaG10O1xuICBsZXQgaG9tb2dSQyA9IDA7XG4gIGxldCBpO1xuICBsZXQgajtcbiAgbGV0IGs7XG4gIGxldCBzb21lSG9tb2dlbmVvdXMgPSAwO1xuXG4gIC8vIE9rLCBmaXJzdCBpbml0IHNvbWUgZmxhZ3MgY2hlY2sgYW5kIHNlZSBpZiBhbGwgdGhlIHN5c3RlbXMgYXJlIGhvbW9nZW5lb3VzXG4gIGlmIChjaGVja0hvbW9nZW5lb3VzKSB7XG4gICAgLy8gSWYgWScgaXMgemVybywgaXQncyBhIGhvbW9nZW5lb3VzIHN5c3RlbSBhbmQgY2FuJ3QgYmUgc29sdmVkIHZpYVxuICAgIC8vIHRoZSBwc2V1ZG9pbnZlcnNlIG1ldGhvZC4gRGV0ZWN0IHRoaXMgY2FzZSwgd2FybiB0aGUgdXNlciwgYW5kXG4gICAgLy8gaW52b2tlIFNvbHZlSG9tb2dlbmVvdXNMZWFzdFNxdWFyZXMgaW5zdGVhZC4gTm90ZSB0aGF0IGl0IGRvZXNuJ3RcbiAgICAvLyByZWFsbHkgbWFrZSBtdWNoIHNlbnNlIGZvciB5T3JkZXIgdG8gYmUgZ3JlYXRlciB0aGFuIG9uZSBpbiB0aGlzIGNhc2UsXG4gICAgLy8gc2luY2UgdGhhdCdzIGp1c3QgeU9yZGVyIG9jY3VycmVuY2VzIG9mIGEgMCB2ZWN0b3Igb24gdGhlIFJIUywgYnV0XG4gICAgLy8gd2UgYWxsb3cgaXQgYW55d2F5LiBOXG5cbiAgICAvLyBJbml0aWFsaXplIGhvbW9nZW5lb3VzIGZsYWdzIG9uIGEgcGVyLXJpZ2h0LWhhbmQtc2lkZSBiYXNpc1xuICAgIGZvciAoaiA9IDA7IGogPCB5T3JkZXI7IGorKykge1xuICAgICAgaG9tb2dlbkZsYWdzW2pdID0gMTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG51bWJlck9mU2FtcGxlczsgaSsrKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgeU9yZGVyOyBqKyspIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHl0W2ldW2pdKSA+IFZUS19TTUFMTF9OVU1CRVIpIHtcbiAgICAgICAgICBhbGxIb21vZ2VuZW91cyA9IDA7XG4gICAgICAgICAgaG9tb2dlbkZsYWdzW2pdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3ZlIGdvdCBvbmUgc3lzdGVtLCBhbmQgaXQncyBob21vZ2VuZW91cywgZG8gaXQgYW5kIGJhaWwgb3V0IHF1aWNrbHkuXG4gICAgaWYgKGFsbEhvbW9nZW5lb3VzICYmIHlPcmRlciA9PT0gMSkge1xuICAgICAgdnRrV2FybmluZ01hY3JvKFxuICAgICAgICAnRGV0ZWN0ZWQgaG9tb2dlbmVvdXMgc3lzdGVtIChZPTApLCBjYWxsaW5nIFNvbHZlSG9tb2dlbmVvdXNMZWFzdFNxdWFyZXMoKSdcbiAgICAgICk7XG4gICAgICByZXR1cm4gc29sdmVIb21vZ2VuZW91c0xlYXN0U3F1YXJlcyhudW1iZXJPZlNhbXBsZXMsIHh0LCB4T3JkZXIsIG10KTtcbiAgICB9XG5cbiAgICAvLyBPaywgd2UndmUgZ290IG1vcmUgdGhhbiBvbmUgc3lzdGVtIG9mIGVxdWF0aW9ucy5cbiAgICAvLyBGaWd1cmUgb3V0IGlmIHdlIG5lZWQgdG8gY2FsY3VsYXRlIHRoZSBob21vZ2VuZW91cyBlcXVhdGlvbiBzb2x1dGlvbiBmb3JcbiAgICAvLyBhbnkgb2YgdGhlbS5cbiAgICBpZiAoYWxsSG9tb2dlbmVvdXMpIHtcbiAgICAgIHNvbWVIb21vZ2VuZW91cyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB5T3JkZXI7IGorKykge1xuICAgICAgICBpZiAoaG9tb2dlbkZsYWdzW2pdKSB7XG4gICAgICAgICAgc29tZUhvbW9nZW5lb3VzID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIElmIG5lY2Vzc2FyeSwgc29sdmUgdGhlIGhvbW9nZW5lb3VzIHByb2JsZW1cbiAgaWYgKHNvbWVIb21vZ2VuZW91cykge1xuICAgIC8vIGhtdCBpcyB0aGUgaG9tb2dlbmVvdXMgZXF1YXRpb24gdmVyc2lvbiBvZiBtdCwgdGhlIGdlbmVyYWwgc29sdXRpb24uXG4gICAgaG10ID0gY3JlYXRlQXJyYXkoeE9yZGVyKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgeE9yZGVyOyBqKyspIHtcbiAgICAgIC8vIE9ubHkgYWxsb2NhdGUgMSBoZXJlLCBub3QgeU9yZGVyLCBiZWNhdXNlIGhlcmUgd2UncmUgZ29pbmcgdG8gc29sdmVcbiAgICAgIC8vIGp1c3QgdGhlIG9uZSBob21vZ2VuZW91cyBlcXVhdGlvbiBzdWJzZXQgb2YgdGhlIGVudGlyZSBwcm9ibGVtXG4gICAgICBobXRbal0gPSBbMF07XG4gICAgfVxuXG4gICAgLy8gT2ssIHNvbHZlIHRoZSBob21vZ2VuZW91cyBwcm9ibGVtXG4gICAgaG9tb2dSQyA9IHNvbHZlSG9tb2dlbmVvdXNMZWFzdFNxdWFyZXMobnVtYmVyT2ZTYW1wbGVzLCB4dCwgeE9yZGVyLCBobXQpO1xuICB9XG5cbiAgLy8gc2V0IHVwIGludGVybWVkaWF0ZSB2YXJpYWJsZXNcbiAgY29uc3QgWFh0ID0gY3JlYXRlQXJyYXkoeE9yZGVyKTsgLy8gc2l6ZSB4IGJ5IHhcbiAgY29uc3QgWFh0SSA9IGNyZWF0ZUFycmF5KHhPcmRlcik7IC8vIHNpemUgeCBieSB4XG4gIGNvbnN0IFhZdCA9IGNyZWF0ZUFycmF5KHhPcmRlcik7IC8vIHNpemUgeCBieSB5XG4gIGZvciAoaSA9IDA7IGkgPCB4T3JkZXI7IGkrKykge1xuICAgIFhYdFtpXSA9IGNyZWF0ZUFycmF5KHhPcmRlcik7XG4gICAgWFh0SVtpXSA9IGNyZWF0ZUFycmF5KHhPcmRlcik7XG5cbiAgICBmb3IgKGogPSAwOyBqIDwgeE9yZGVyOyBqKyspIHtcbiAgICAgIFhYdFtpXVtqXSA9IDAuMDtcbiAgICAgIFhYdElbaV1bal0gPSAwLjA7XG4gICAgfVxuXG4gICAgWFl0W2ldID0gY3JlYXRlQXJyYXkoeU9yZGVyKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgeU9yZGVyOyBqKyspIHtcbiAgICAgIFhZdFtpXVtqXSA9IDAuMDtcbiAgICB9XG4gIH1cblxuICAvLyBmaXJzdCBmaW5kIHRoZSBwc2V1ZG9pbnZlcnNlIG1hdHJpeFxuICBmb3IgKGsgPSAwOyBrIDwgbnVtYmVyT2ZTYW1wbGVzOyBrKyspIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgeE9yZGVyOyBpKyspIHtcbiAgICAgIC8vIGZpcnN0IGNhbGN1bGF0ZSB0aGUgWFh0IG1hdHJpeCwgb25seSBkbyB0aGUgdXBwZXIgaGFsZiAoc3ltbWV0cmljYWwpXG4gICAgICBmb3IgKGogPSBpOyBqIDwgeE9yZGVyOyBqKyspIHtcbiAgICAgICAgWFh0W2ldW2pdICs9IHh0W2tdW2ldICogeHRba11bal07XG4gICAgICB9XG5cbiAgICAgIC8vIG5vdyBjYWxjdWxhdGUgdGhlIFhZdCBtYXRyaXhcbiAgICAgIGZvciAoaiA9IDA7IGogPCB5T3JkZXI7IGorKykge1xuICAgICAgICBYWXRbaV1bal0gKz0geHRba11baV0gKiB5dFtrXVtqXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgZmlsbCBpbiB0aGUgbG93ZXIgaGFsZiBvZiB0aGUgWFh0IG1hdHJpeFxuICBmb3IgKGkgPSAwOyBpIDwgeE9yZGVyOyBpKyspIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICBYWHRbaV1bal0gPSBYWHRbal1baV07XG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3VjY2Vzc0ZsYWcgPSBpbnZlcnRNYXRyaXgoWFh0LCBYWHRJLCB4T3JkZXIpO1xuXG4gIC8vIG5leHQgZ2V0IHRoZSBpbnZlcnNlIG9mIFhYdFxuICBpZiAoc3VjY2Vzc0ZsYWcpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgeE9yZGVyOyBpKyspIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB5T3JkZXI7IGorKykge1xuICAgICAgICBtdFtpXVtqXSA9IDAuMDtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IHhPcmRlcjsgaysrKSB7XG4gICAgICAgICAgbXRbaV1bal0gKz0gWFh0SVtpXVtrXSAqIFhZdFtrXVtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEZpeCB1cCBhbnkgb2YgdGhlIHNvbHV0aW9ucyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIGhvbW9nZW5lb3VzIGVxdWF0aW9uXG4gIC8vIHByb2JsZW0uXG4gIGlmIChzb21lSG9tb2dlbmVvdXMpIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgeU9yZGVyOyBqKyspIHtcbiAgICAgIGlmIChob21vZ2VuRmxhZ3Nbal0pIHtcbiAgICAgICAgLy8gRml4IHRoaXMgb25lXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB4T3JkZXI7IGkrKykge1xuICAgICAgICAgIG10W2ldW2pdID0gaG10W2ldWzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHNvbWVIb21vZ2VuZW91cykge1xuICAgIHJldHVybiBob21vZ1JDICYmIHN1Y2Nlc3NGbGFnO1xuICB9XG5cbiAgcmV0dXJuIHN1Y2Nlc3NGbGFnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGV4MmZsb2F0KGhleFN0ciwgb3V0RmxvYXRBcnJheSA9IFswLCAwLjUsIDFdKSB7XG4gIHN3aXRjaCAoaGV4U3RyLmxlbmd0aCkge1xuICAgIGNhc2UgMzogLy8gYWJjID0+ICNhYWJiY2NcbiAgICAgIG91dEZsb2F0QXJyYXlbMF0gPSAocGFyc2VJbnQoaGV4U3RyWzBdLCAxNikgKiAxNykgLyAyNTU7XG4gICAgICBvdXRGbG9hdEFycmF5WzFdID0gKHBhcnNlSW50KGhleFN0clsxXSwgMTYpICogMTcpIC8gMjU1O1xuICAgICAgb3V0RmxvYXRBcnJheVsyXSA9IChwYXJzZUludChoZXhTdHJbMl0sIDE2KSAqIDE3KSAvIDI1NTtcbiAgICAgIHJldHVybiBvdXRGbG9hdEFycmF5O1xuICAgIGNhc2UgNDogLy8gI2FiYyA9PiAjYWFiYmNjXG4gICAgICBvdXRGbG9hdEFycmF5WzBdID0gKHBhcnNlSW50KGhleFN0clsxXSwgMTYpICogMTcpIC8gMjU1O1xuICAgICAgb3V0RmxvYXRBcnJheVsxXSA9IChwYXJzZUludChoZXhTdHJbMl0sIDE2KSAqIDE3KSAvIDI1NTtcbiAgICAgIG91dEZsb2F0QXJyYXlbMl0gPSAocGFyc2VJbnQoaGV4U3RyWzNdLCAxNikgKiAxNykgLyAyNTU7XG4gICAgICByZXR1cm4gb3V0RmxvYXRBcnJheTtcbiAgICBjYXNlIDY6IC8vIGFiMDFkZiA9PiAjYWIwMWRmXG4gICAgICBvdXRGbG9hdEFycmF5WzBdID0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cigwLCAyKSwgMTYpIC8gMjU1O1xuICAgICAgb3V0RmxvYXRBcnJheVsxXSA9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoMiwgMiksIDE2KSAvIDI1NTtcbiAgICAgIG91dEZsb2F0QXJyYXlbMl0gPSBwYXJzZUludChoZXhTdHIuc3Vic3RyKDQsIDIpLCAxNikgLyAyNTU7XG4gICAgICByZXR1cm4gb3V0RmxvYXRBcnJheTtcbiAgICBjYXNlIDc6IC8vICNhYjAxZGZcbiAgICAgIG91dEZsb2F0QXJyYXlbMF0gPSBwYXJzZUludChoZXhTdHIuc3Vic3RyKDEsIDIpLCAxNikgLyAyNTU7XG4gICAgICBvdXRGbG9hdEFycmF5WzFdID0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cigzLCAyKSwgMTYpIC8gMjU1O1xuICAgICAgb3V0RmxvYXRBcnJheVsyXSA9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoNSwgMiksIDE2KSAvIDI1NTtcbiAgICAgIHJldHVybiBvdXRGbG9hdEFycmF5O1xuICAgIGNhc2UgOTogLy8gI2FiMDFkZjAwXG4gICAgICBvdXRGbG9hdEFycmF5WzBdID0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cigxLCAyKSwgMTYpIC8gMjU1O1xuICAgICAgb3V0RmxvYXRBcnJheVsxXSA9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoMywgMiksIDE2KSAvIDI1NTtcbiAgICAgIG91dEZsb2F0QXJyYXlbMl0gPSBwYXJzZUludChoZXhTdHIuc3Vic3RyKDUsIDIpLCAxNikgLyAyNTU7XG4gICAgICBvdXRGbG9hdEFycmF5WzNdID0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cig3LCAyKSwgMTYpIC8gMjU1O1xuICAgICAgcmV0dXJuIG91dEZsb2F0QXJyYXk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBvdXRGbG9hdEFycmF5O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZ2IyaHN2KHJnYiwgaHN2KSB7XG4gIGxldCBoO1xuICBsZXQgcztcbiAgY29uc3QgW3IsIGcsIGJdID0gcmdiO1xuICBjb25zdCBvbmV0aGlyZCA9IDEuMCAvIDMuMDtcbiAgY29uc3Qgb25lc2l4dGggPSAxLjAgLyA2LjA7XG4gIGNvbnN0IHR3b3RoaXJkID0gMi4wIC8gMy4wO1xuXG4gIGxldCBjbWF4ID0gcjtcbiAgbGV0IGNtaW4gPSByO1xuXG4gIGlmIChnID4gY21heCkge1xuICAgIGNtYXggPSBnO1xuICB9IGVsc2UgaWYgKGcgPCBjbWluKSB7XG4gICAgY21pbiA9IGc7XG4gIH1cbiAgaWYgKGIgPiBjbWF4KSB7XG4gICAgY21heCA9IGI7XG4gIH0gZWxzZSBpZiAoYiA8IGNtaW4pIHtcbiAgICBjbWluID0gYjtcbiAgfVxuICBjb25zdCB2ID0gY21heDtcblxuICBpZiAodiA+IDAuMCkge1xuICAgIHMgPSAoY21heCAtIGNtaW4pIC8gY21heDtcbiAgfSBlbHNlIHtcbiAgICBzID0gMC4wO1xuICB9XG4gIGlmIChzID4gMCkge1xuICAgIGlmIChyID09PSBjbWF4KSB7XG4gICAgICBoID0gKG9uZXNpeHRoICogKGcgLSBiKSkgLyAoY21heCAtIGNtaW4pO1xuICAgIH0gZWxzZSBpZiAoZyA9PT0gY21heCkge1xuICAgICAgaCA9IG9uZXRoaXJkICsgKG9uZXNpeHRoICogKGIgLSByKSkgLyAoY21heCAtIGNtaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gdHdvdGhpcmQgKyAob25lc2l4dGggKiAociAtIGcpKSAvIChjbWF4IC0gY21pbik7XG4gICAgfVxuICAgIGlmIChoIDwgMC4wKSB7XG4gICAgICBoICs9IDEuMDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaCA9IDAuMDtcbiAgfVxuXG4gIC8vIFNldCB0aGUgdmFsdWVzIGJhY2sgdG8gdGhlIGFycmF5XG4gIGhzdlswXSA9IGg7XG4gIGhzdlsxXSA9IHM7XG4gIGhzdlsyXSA9IHY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoc3YycmdiKGhzdiwgcmdiKSB7XG4gIGNvbnN0IFtoLCBzLCB2XSA9IGhzdjtcbiAgY29uc3Qgb25ldGhpcmQgPSAxLjAgLyAzLjA7XG4gIGNvbnN0IG9uZXNpeHRoID0gMS4wIC8gNi4wO1xuICBjb25zdCB0d290aGlyZCA9IDIuMCAvIDMuMDtcbiAgY29uc3QgZml2ZXNpeHRoID0gNS4wIC8gNi4wO1xuICBsZXQgcjtcbiAgbGV0IGc7XG4gIGxldCBiO1xuXG4gIC8vIGNvbXB1dGUgUkdCIGZyb20gSFNWXG4gIGlmIChoID4gb25lc2l4dGggJiYgaCA8PSBvbmV0aGlyZCkge1xuICAgIC8vIGdyZWVuL3JlZFxuICAgIGcgPSAxLjA7XG4gICAgciA9IChvbmV0aGlyZCAtIGgpIC8gb25lc2l4dGg7XG4gICAgYiA9IDAuMDtcbiAgfSBlbHNlIGlmIChoID4gb25ldGhpcmQgJiYgaCA8PSAwLjUpIHtcbiAgICAvLyBncmVlbi9ibHVlXG4gICAgZyA9IDEuMDtcbiAgICBiID0gKGggLSBvbmV0aGlyZCkgLyBvbmVzaXh0aDtcbiAgICByID0gMC4wO1xuICB9IGVsc2UgaWYgKGggPiAwLjUgJiYgaCA8PSB0d290aGlyZCkge1xuICAgIC8vIGJsdWUvZ3JlZW5cbiAgICBiID0gMS4wO1xuICAgIGcgPSAodHdvdGhpcmQgLSBoKSAvIG9uZXNpeHRoO1xuICAgIHIgPSAwLjA7XG4gIH0gZWxzZSBpZiAoaCA+IHR3b3RoaXJkICYmIGggPD0gZml2ZXNpeHRoKSB7XG4gICAgLy8gYmx1ZS9yZWRcbiAgICBiID0gMS4wO1xuICAgIHIgPSAoaCAtIHR3b3RoaXJkKSAvIG9uZXNpeHRoO1xuICAgIGcgPSAwLjA7XG4gIH0gZWxzZSBpZiAoaCA+IGZpdmVzaXh0aCAmJiBoIDw9IDEuMCkge1xuICAgIC8vIHJlZC9ibHVlXG4gICAgciA9IDEuMDtcbiAgICBiID0gKDEuMCAtIGgpIC8gb25lc2l4dGg7XG4gICAgZyA9IDAuMDtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWQvZ3JlZW5cbiAgICByID0gMS4wO1xuICAgIGcgPSBoIC8gb25lc2l4dGg7XG4gICAgYiA9IDAuMDtcbiAgfVxuXG4gIC8vIGFkZCBTYXR1cmF0aW9uIHRvIHRoZSBlcXVhdGlvbi5cbiAgciA9IHMgKiByICsgKDEuMCAtIHMpO1xuICBnID0gcyAqIGcgKyAoMS4wIC0gcyk7XG4gIGIgPSBzICogYiArICgxLjAgLSBzKTtcblxuICByICo9IHY7XG4gIGcgKj0gdjtcbiAgYiAqPSB2O1xuXG4gIC8vIEFzc2lnbiBiYWNrIHRvIHRoZSBhcnJheVxuICByZ2JbMF0gPSByO1xuICByZ2JbMV0gPSBnO1xuICByZ2JbMl0gPSBiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGFiMnh5eihsYWIsIHh5eikge1xuICAvLyBMQUIgdG8gWFlaXG4gIGNvbnN0IFtMLCBhLCBiXSA9IGxhYjtcbiAgbGV0IHZhcl9ZID0gKEwgKyAxNikgLyAxMTY7XG4gIGxldCB2YXJfWCA9IGEgLyA1MDAgKyB2YXJfWTtcbiAgbGV0IHZhcl9aID0gdmFyX1kgLSBiIC8gMjAwO1xuXG4gIGlmICh2YXJfWSAqKiAzID4gMC4wMDg4NTYpIHtcbiAgICB2YXJfWSAqKj0gMztcbiAgfSBlbHNlIHtcbiAgICB2YXJfWSA9ICh2YXJfWSAtIDE2LjAgLyAxMTYuMCkgLyA3Ljc4NztcbiAgfVxuXG4gIGlmICh2YXJfWCAqKiAzID4gMC4wMDg4NTYpIHtcbiAgICB2YXJfWCAqKj0gMztcbiAgfSBlbHNlIHtcbiAgICB2YXJfWCA9ICh2YXJfWCAtIDE2LjAgLyAxMTYuMCkgLyA3Ljc4NztcbiAgfVxuXG4gIGlmICh2YXJfWiAqKiAzID4gMC4wMDg4NTYpIHtcbiAgICB2YXJfWiAqKj0gMztcbiAgfSBlbHNlIHtcbiAgICB2YXJfWiA9ICh2YXJfWiAtIDE2LjAgLyAxMTYuMCkgLyA3Ljc4NztcbiAgfVxuICBjb25zdCByZWZfWCA9IDAuOTUwNTtcbiAgY29uc3QgcmVmX1kgPSAxLjA7XG4gIGNvbnN0IHJlZl9aID0gMS4wODk7XG4gIHh5elswXSA9IHJlZl9YICogdmFyX1g7IC8vIHJlZl9YID0gMC45NTA1ICBPYnNlcnZlcj0gMiBkZWcgSWxsdW1pbmFudD0gRDY1XG4gIHh5elsxXSA9IHJlZl9ZICogdmFyX1k7IC8vIHJlZl9ZID0gMS4wMDBcbiAgeHl6WzJdID0gcmVmX1ogKiB2YXJfWjsgLy8gcmVmX1ogPSAxLjA4OVxufVxuXG5leHBvcnQgZnVuY3Rpb24geHl6MmxhYih4eXosIGxhYikge1xuICBjb25zdCBbeCwgeSwgel0gPSB4eXo7XG4gIGNvbnN0IHJlZl9YID0gMC45NTA1O1xuICBjb25zdCByZWZfWSA9IDEuMDtcbiAgY29uc3QgcmVmX1ogPSAxLjA4OTtcbiAgbGV0IHZhcl9YID0geCAvIHJlZl9YOyAvLyByZWZfWCA9IDAuOTUwNSAgT2JzZXJ2ZXI9IDIgZGVnLCBJbGx1bWluYW50PSBENjVcbiAgbGV0IHZhcl9ZID0geSAvIHJlZl9ZOyAvLyByZWZfWSA9IDEuMDAwXG4gIGxldCB2YXJfWiA9IHogLyByZWZfWjsgLy8gcmVmX1ogPSAxLjA4OVxuXG4gIGlmICh2YXJfWCA+IDAuMDA4ODU2KSB2YXJfWCAqKj0gMS4wIC8gMy4wO1xuICBlbHNlIHZhcl9YID0gNy43ODcgKiB2YXJfWCArIDE2LjAgLyAxMTYuMDtcbiAgaWYgKHZhcl9ZID4gMC4wMDg4NTYpIHZhcl9ZICoqPSAxLjAgLyAzLjA7XG4gIGVsc2UgdmFyX1kgPSA3Ljc4NyAqIHZhcl9ZICsgMTYuMCAvIDExNi4wO1xuICBpZiAodmFyX1ogPiAwLjAwODg1NikgdmFyX1ogKio9IDEuMCAvIDMuMDtcbiAgZWxzZSB2YXJfWiA9IDcuNzg3ICogdmFyX1ogKyAxNi4wIC8gMTE2LjA7XG5cbiAgbGFiWzBdID0gMTE2ICogdmFyX1kgLSAxNjtcbiAgbGFiWzFdID0gNTAwICogKHZhcl9YIC0gdmFyX1kpO1xuICBsYWJbMl0gPSAyMDAgKiAodmFyX1kgLSB2YXJfWik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB4eXoycmdiKHh5eiwgcmdiKSB7XG4gIGNvbnN0IFt4LCB5LCB6XSA9IHh5ejtcbiAgbGV0IHIgPSB4ICogMy4yNDA2ICsgeSAqIC0xLjUzNzIgKyB6ICogLTAuNDk4NjtcbiAgbGV0IGcgPSB4ICogLTAuOTY4OSArIHkgKiAxLjg3NTggKyB6ICogMC4wNDE1O1xuICBsZXQgYiA9IHggKiAwLjA1NTcgKyB5ICogLTAuMjA0ICsgeiAqIDEuMDU3O1xuXG4gIC8vIFRoZSBmb2xsb3dpbmcgcGVyZm9ybXMgYSBcImdhbW1hIGNvcnJlY3Rpb25cIiBzcGVjaWZpZWQgYnkgdGhlIHNSR0IgY29sb3JcbiAgLy8gc3BhY2UuICBzUkdCIGlzIGRlZmluZWQgYnkgYSBjYW5vbmljYWwgZGVmaW5pdGlvbiBvZiBhIGRpc3BsYXkgbW9uaXRvciBhbmRcbiAgLy8gaGFzIGJlZW4gc3RhbmRhcmRpemVkIGJ5IHRoZSBJbnRlcm5hdGlvbmFsIEVsZWN0cm90ZWNobmljYWwgQ29tbWlzc2lvbiAoSUVDXG4gIC8vIDYxOTY2LTItMSkuICBUaGUgbm9ubGluZWFyaXR5IG9mIHRoZSBjb3JyZWN0aW9uIGlzIGRlc2lnbmVkIHRvIG1ha2UgdGhlXG4gIC8vIGNvbG9ycyBtb3JlIHBlcmNlcHR1YWxseSB1bmlmb3JtLiAgVGhpcyBjb2xvciBzcGFjZSBoYXMgYmVlbiBhZG9wdGVkIGJ5XG4gIC8vIHNldmVyYWwgYXBwbGljYXRpb25zIGluY2x1ZGluZyBBZG9iZSBQaG90b3Nob3AgYW5kIE1pY3Jvc29mdCBXaW5kb3dzIGNvbG9yXG4gIC8vIG1hbmFnZW1lbnQuICBPcGVuR0wgaXMgYWdub3N0aWMgb24gaXRzIFJHQiBjb2xvciBzcGFjZSwgYnV0IGl0IGlzIHJlYXNvbmFibGVcbiAgLy8gdG8gYXNzdW1lIGl0IGlzIGNsb3NlIHRvIHRoaXMgb25lLlxuICBpZiAociA+IDAuMDAzMTMwOCkgciA9IDEuMDU1ICogciAqKiAoMSAvIDIuNCkgLSAwLjA1NTtcbiAgZWxzZSByICo9IDEyLjkyO1xuICBpZiAoZyA+IDAuMDAzMTMwOCkgZyA9IDEuMDU1ICogZyAqKiAoMSAvIDIuNCkgLSAwLjA1NTtcbiAgZWxzZSBnICo9IDEyLjkyO1xuICBpZiAoYiA+IDAuMDAzMTMwOCkgYiA9IDEuMDU1ICogYiAqKiAoMSAvIDIuNCkgLSAwLjA1NTtcbiAgZWxzZSBiICo9IDEyLjkyO1xuXG4gIC8vIENsaXAgY29sb3JzLiBpZGVhbGx5IHdlIHdvdWxkIGRvIHNvbWV0aGluZyB0aGF0IGlzIHBlcmNlcHR1YWxseSBjbG9zZXN0XG4gIC8vIChzaW5jZSB3ZSBjYW4gc2VlIGNvbG9ycyBvdXRzaWRlIG9mIHRoZSBkaXNwbGF5IGdhbXV0KSwgYnV0IHRoaXMgc2VlbXMgdG9cbiAgLy8gd29yayB3ZWxsIGVub3VnaC5cbiAgbGV0IG1heFZhbCA9IHI7XG4gIGlmIChtYXhWYWwgPCBnKSBtYXhWYWwgPSBnO1xuICBpZiAobWF4VmFsIDwgYikgbWF4VmFsID0gYjtcbiAgaWYgKG1heFZhbCA+IDEuMCkge1xuICAgIHIgLz0gbWF4VmFsO1xuICAgIGcgLz0gbWF4VmFsO1xuICAgIGIgLz0gbWF4VmFsO1xuICB9XG4gIGlmIChyIDwgMCkgciA9IDA7XG4gIGlmIChnIDwgMCkgZyA9IDA7XG4gIGlmIChiIDwgMCkgYiA9IDA7XG5cbiAgLy8gUHVzaCB2YWx1ZXMgYmFjayB0byBhcnJheVxuICByZ2JbMF0gPSByO1xuICByZ2JbMV0gPSBnO1xuICByZ2JbMl0gPSBiO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiMnh5eihyZ2IsIHh5eikge1xuICBsZXQgW3IsIGcsIGJdID0gcmdiO1xuICAvLyBUaGUgZm9sbG93aW5nIHBlcmZvcm1zIGEgXCJnYW1tYSBjb3JyZWN0aW9uXCIgc3BlY2lmaWVkIGJ5IHRoZSBzUkdCIGNvbG9yXG4gIC8vIHNwYWNlLiAgc1JHQiBpcyBkZWZpbmVkIGJ5IGEgY2Fub25pY2FsIGRlZmluaXRpb24gb2YgYSBkaXNwbGF5IG1vbml0b3IgYW5kXG4gIC8vIGhhcyBiZWVuIHN0YW5kYXJkaXplZCBieSB0aGUgSW50ZXJuYXRpb25hbCBFbGVjdHJvdGVjaG5pY2FsIENvbW1pc3Npb24gKElFQ1xuICAvLyA2MTk2Ni0yLTEpLiAgVGhlIG5vbmxpbmVhcml0eSBvZiB0aGUgY29ycmVjdGlvbiBpcyBkZXNpZ25lZCB0byBtYWtlIHRoZVxuICAvLyBjb2xvcnMgbW9yZSBwZXJjZXB0dWFsbHkgdW5pZm9ybS4gIFRoaXMgY29sb3Igc3BhY2UgaGFzIGJlZW4gYWRvcHRlZCBieVxuICAvLyBzZXZlcmFsIGFwcGxpY2F0aW9ucyBpbmNsdWRpbmcgQWRvYmUgUGhvdG9zaG9wIGFuZCBNaWNyb3NvZnQgV2luZG93cyBjb2xvclxuICAvLyBtYW5hZ2VtZW50LiAgT3BlbkdMIGlzIGFnbm9zdGljIG9uIGl0cyBSR0IgY29sb3Igc3BhY2UsIGJ1dCBpdCBpcyByZWFzb25hYmxlXG4gIC8vIHRvIGFzc3VtZSBpdCBpcyBjbG9zZSB0byB0aGlzIG9uZS5cbiAgaWYgKHIgPiAwLjA0MDQ1KSByID0gKChyICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbiAgZWxzZSByIC89IDEyLjkyO1xuICBpZiAoZyA+IDAuMDQwNDUpIGcgPSAoKGcgKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40O1xuICBlbHNlIGcgLz0gMTIuOTI7XG4gIGlmIChiID4gMC4wNDA0NSkgYiA9ICgoYiArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQ7XG4gIGVsc2UgYiAvPSAxMi45MjtcblxuICAvLyBPYnNlcnZlci4gPSAyIGRlZywgSWxsdW1pbmFudCA9IEQ2NVxuICB4eXpbMF0gPSByICogMC40MTI0ICsgZyAqIDAuMzU3NiArIGIgKiAwLjE4MDU7XG4gIHh5elsxXSA9IHIgKiAwLjIxMjYgKyBnICogMC43MTUyICsgYiAqIDAuMDcyMjtcbiAgeHl6WzJdID0gciAqIDAuMDE5MyArIGcgKiAwLjExOTIgKyBiICogMC45NTA1O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmdiMmxhYihyZ2IsIGxhYikge1xuICBjb25zdCB4eXogPSBbMCwgMCwgMF07XG4gIHJnYjJ4eXoocmdiLCB4eXopO1xuICB4eXoybGFiKHh5eiwgbGFiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxhYjJyZ2IobGFiLCByZ2IpIHtcbiAgY29uc3QgeHl6ID0gWzAsIDAsIDBdO1xuICBsYWIyeHl6KGxhYiwgeHl6KTtcbiAgeHl6MnJnYih4eXosIHJnYik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmluaXRpYWxpemVCb3VuZHMoYm91bmRzKSB7XG4gIGJvdW5kc1swXSA9IDEuMDtcbiAgYm91bmRzWzFdID0gLTEuMDtcbiAgYm91bmRzWzJdID0gMS4wO1xuICBib3VuZHNbM10gPSAtMS4wO1xuICBib3VuZHNbNF0gPSAxLjA7XG4gIGJvdW5kc1s1XSA9IC0xLjA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhcmVCb3VuZHNJbml0aWFsaXplZChib3VuZHMpIHtcbiAgcmV0dXJuICEoYm91bmRzWzFdIC0gYm91bmRzWzBdIDwgMC4wKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCb3VuZHNGcm9tUG9pbnRzKHBvaW50MSwgcG9pbnQyLCBib3VuZHMpIHtcbiAgYm91bmRzWzBdID0gTWF0aC5taW4ocG9pbnQxWzBdLCBwb2ludDJbMF0pO1xuICBib3VuZHNbMV0gPSBNYXRoLm1heChwb2ludDFbMF0sIHBvaW50MlswXSk7XG4gIGJvdW5kc1syXSA9IE1hdGgubWluKHBvaW50MVsxXSwgcG9pbnQyWzFdKTtcbiAgYm91bmRzWzNdID0gTWF0aC5tYXgocG9pbnQxWzFdLCBwb2ludDJbMV0pO1xuICBib3VuZHNbNF0gPSBNYXRoLm1pbihwb2ludDFbMl0sIHBvaW50MlsyXSk7XG4gIGJvdW5kc1s1XSA9IE1hdGgubWF4KHBvaW50MVsyXSwgcG9pbnQyWzJdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wVmFsdWUodmFsdWUsIG1pblZhbHVlLCBtYXhWYWx1ZSkge1xuICBpZiAodmFsdWUgPCBtaW5WYWx1ZSkge1xuICAgIHJldHVybiBtaW5WYWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgIHJldHVybiBtYXhWYWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcFZlY3Rvcih2ZWN0b3IsIG1pblZlY3RvciwgbWF4VmVjdG9yLCBvdXQgPSBbXSkge1xuICBvdXRbMF0gPSBjbGFtcFZhbHVlKHZlY3RvclswXSwgbWluVmVjdG9yWzBdLCBtYXhWZWN0b3JbMF0pO1xuICBvdXRbMV0gPSBjbGFtcFZhbHVlKHZlY3RvclsxXSwgbWluVmVjdG9yWzFdLCBtYXhWZWN0b3JbMV0pO1xuICBvdXRbMl0gPSBjbGFtcFZhbHVlKHZlY3RvclsyXSwgbWluVmVjdG9yWzJdLCBtYXhWZWN0b3JbMl0pO1xuXG4gIHJldHVybiBvdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFZlY3Rvcih2ZWN0b3IsIG91dCA9IFtdKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQodmVjdG9yWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5yb3VuZCh2ZWN0b3JbMV0pO1xuICBvdXRbMl0gPSBNYXRoLnJvdW5kKHZlY3RvclsyXSk7XG5cbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYW1wQW5kTm9ybWFsaXplVmFsdWUodmFsdWUsIHJhbmdlKSB7XG4gIGxldCByZXN1bHQgPSAwO1xuICBpZiAocmFuZ2VbMF0gIT09IHJhbmdlWzFdKSB7XG4gICAgLy8gY2xhbXBcbiAgICBpZiAodmFsdWUgPCByYW5nZVswXSkge1xuICAgICAgcmVzdWx0ID0gcmFuZ2VbMF07XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA+IHJhbmdlWzFdKSB7XG4gICAgICByZXN1bHQgPSByYW5nZVsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgfVxuICAgIC8vIG5vcm1hbGl6ZVxuICAgIHJlc3VsdCA9IChyZXN1bHQgLSByYW5nZVswXSkgLyAocmFuZ2VbMV0gLSByYW5nZVswXSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgY29uc3QgZ2V0U2NhbGFyVHlwZUZpdHRpbmdSYW5nZSA9IG5vdEltcGxlbWVudGVkKFxuICAnR2V0U2NhbGFyVHlwZUZpdHRpbmdSYW5nZSdcbik7XG5leHBvcnQgY29uc3QgZ2V0QWRqdXN0ZWRTY2FsYXJSYW5nZSA9IG5vdEltcGxlbWVudGVkKCdHZXRBZGp1c3RlZFNjYWxhclJhbmdlJyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbnRJc1dpdGhpbk90aGVyRXh0ZW50KGV4dGVudDEsIGV4dGVudDIpIHtcbiAgaWYgKCFleHRlbnQxIHx8ICFleHRlbnQyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkgKz0gMikge1xuICAgIGlmIChcbiAgICAgIGV4dGVudDFbaV0gPCBleHRlbnQyW2ldIHx8XG4gICAgICBleHRlbnQxW2ldID4gZXh0ZW50MltpICsgMV0gfHxcbiAgICAgIGV4dGVudDFbaSArIDFdIDwgZXh0ZW50MltpXSB8fFxuICAgICAgZXh0ZW50MVtpICsgMV0gPiBleHRlbnQyW2kgKyAxXVxuICAgICkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib3VuZHNJc1dpdGhpbk90aGVyQm91bmRzKGJvdW5kczFfNiwgYm91bmRzMl82LCBkZWx0YV8zKSB7XG4gIGlmICghYm91bmRzMV82IHx8ICFib3VuZHMyXzYpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkgKz0gMikge1xuICAgIGlmIChcbiAgICAgIGJvdW5kczFfNltpXSArIGRlbHRhXzNbaSAvIDJdIDwgYm91bmRzMl82W2ldIHx8XG4gICAgICBib3VuZHMxXzZbaV0gLSBkZWx0YV8zW2kgLyAyXSA+IGJvdW5kczJfNltpICsgMV0gfHxcbiAgICAgIGJvdW5kczFfNltpICsgMV0gKyBkZWx0YV8zW2kgLyAyXSA8IGJvdW5kczJfNltpXSB8fFxuICAgICAgYm91bmRzMV82W2kgKyAxXSAtIGRlbHRhXzNbaSAvIDJdID4gYm91bmRzMl82W2kgKyAxXVxuICAgICkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG4gIHJldHVybiAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9pbnRJc1dpdGhpbkJvdW5kcyhwb2ludF8zLCBib3VuZHNfNiwgZGVsdGFfMykge1xuICBpZiAoIXBvaW50XzMgfHwgIWJvdW5kc182IHx8ICFkZWx0YV8zKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBwb2ludF8zW2ldICsgZGVsdGFfM1tpXSA8IGJvdW5kc182WzIgKiBpXSB8fFxuICAgICAgcG9pbnRfM1tpXSAtIGRlbHRhXzNbaV0gPiBib3VuZHNfNlsyICogaSArIDFdXG4gICAgKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb2x2ZTNQb2ludENpcmNsZShwMSwgcDIsIHAzLCBjZW50ZXIpIHtcbiAgY29uc3QgdjIxID0gY3JlYXRlQXJyYXkoMyk7XG4gIGNvbnN0IHYzMiA9IGNyZWF0ZUFycmF5KDMpO1xuICBjb25zdCB2MTMgPSBjcmVhdGVBcnJheSgzKTtcbiAgY29uc3QgdjEyID0gY3JlYXRlQXJyYXkoMyk7XG4gIGNvbnN0IHYyMyA9IGNyZWF0ZUFycmF5KDMpO1xuICBjb25zdCB2MzEgPSBjcmVhdGVBcnJheSgzKTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDM7ICsraSkge1xuICAgIHYyMVtpXSA9IHAxW2ldIC0gcDJbaV07XG4gICAgdjMyW2ldID0gcDJbaV0gLSBwM1tpXTtcbiAgICB2MTNbaV0gPSBwM1tpXSAtIHAxW2ldO1xuICAgIHYxMltpXSA9IC12MjFbaV07XG4gICAgdjIzW2ldID0gLXYzMltpXTtcbiAgICB2MzFbaV0gPSAtdjEzW2ldO1xuICB9XG5cbiAgY29uc3Qgbm9ybTEyID0gbm9ybSh2MTIpO1xuICBjb25zdCBub3JtMjMgPSBub3JtKHYyMyk7XG4gIGNvbnN0IG5vcm0xMyA9IG5vcm0odjEzKTtcblxuICBjb25zdCBjcm9zc3YyMXYzMiA9IGNyZWF0ZUFycmF5KDMpO1xuICBjcm9zcyh2MjEsIHYzMiwgY3Jvc3N2MjF2MzIpO1xuICBjb25zdCBub3JtQ3Jvc3MgPSBub3JtKGNyb3NzdjIxdjMyKTtcblxuICBjb25zdCByYWRpdXMgPSAobm9ybTEyICogbm9ybTIzICogbm9ybTEzKSAvICgyICogbm9ybUNyb3NzKTtcblxuICBjb25zdCBub3JtQ3Jvc3MyMiA9IDIgKiBub3JtQ3Jvc3MgKiBub3JtQ3Jvc3M7XG4gIGNvbnN0IGFscGhhID0gKG5vcm0yMyAqIG5vcm0yMyAqIGRvdCh2MjEsIHYzMSkpIC8gbm9ybUNyb3NzMjI7XG4gIGNvbnN0IGJldGEgPSAobm9ybTEzICogbm9ybTEzICogZG90KHYxMiwgdjMyKSkgLyBub3JtQ3Jvc3MyMjtcbiAgY29uc3QgZ2FtbWEgPSAobm9ybTEyICogbm9ybTEyICogZG90KHYxMywgdjIzKSkgLyBub3JtQ3Jvc3MyMjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IDM7ICsraSkge1xuICAgIGNlbnRlcltpXSA9IGFscGhhICogcDFbaV0gKyBiZXRhICogcDJbaV0gKyBnYW1tYSAqIHAzW2ldO1xuICB9XG4gIHJldHVybiByYWRpdXM7XG59XG5cbmV4cG9ydCBjb25zdCBpbmYgPSBJbmZpbml0eTtcbmV4cG9ydCBjb25zdCBuZWdJbmYgPSAtSW5maW5pdHk7XG5cbmV4cG9ydCBjb25zdCBpc0luZiA9ICh2YWx1ZSkgPT4gIU51bWJlci5pc0Zpbml0ZSh2YWx1ZSk7XG5leHBvcnQgY29uc3QgeyBpc0Zpbml0ZSwgaXNOYU4gfSA9IE51bWJlcjtcbmV4cG9ydCBjb25zdCBpc05hbiA9IGlzTmFOO1xuXG4vLyBKYXZhU2NyaXB0IC0gYWRkLW9uIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVVuaW5pdGlhbGl6ZWRCb3VuZHMoKSB7XG4gIHJldHVybiBbXS5jb25jYXQoW1xuICAgIE51bWJlci5NQVhfVkFMVUUsXG4gICAgLU51bWJlci5NQVhfVkFMVUUsIC8vIFhcbiAgICBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgIC1OdW1iZXIuTUFYX1ZBTFVFLCAvLyBZXG4gICAgTnVtYmVyLk1BWF9WQUxVRSxcbiAgICAtTnVtYmVyLk1BWF9WQUxVRSwgLy8gWlxuICBdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1ham9yQXhpc0luZGV4KHZlY3Rvcikge1xuICBsZXQgbWF4VmFsdWUgPSAtMTtcbiAgbGV0IGF4aXNJbmRleCA9IC0xO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZlY3Rvci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gTWF0aC5hYnModmVjdG9yW2ldKTtcbiAgICBpZiAodmFsdWUgPiBtYXhWYWx1ZSkge1xuICAgICAgYXhpc0luZGV4ID0gaTtcbiAgICAgIG1heFZhbHVlID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF4aXNJbmRleDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb2F0VG9IZXgyKHZhbHVlKSB7XG4gIGNvbnN0IGludGVnZXIgPSBNYXRoLmZsb29yKHZhbHVlICogMjU1KTtcbiAgaWYgKGludGVnZXIgPiAxNSkge1xuICAgIHJldHVybiBpbnRlZ2VyLnRvU3RyaW5nKDE2KTtcbiAgfVxuICByZXR1cm4gYDAke2ludGVnZXIudG9TdHJpbmcoMTYpfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmbG9hdFJHQjJIZXhDb2RlKHJnYkFycmF5LCBwcmVmaXggPSAnIycpIHtcbiAgcmV0dXJuIGAke3ByZWZpeH0ke3JnYkFycmF5Lm1hcChmbG9hdFRvSGV4Mikuam9pbignJyl9YDtcbn1cblxuZnVuY3Rpb24gZmxvYXRUb0NoYXIoZikge1xuICByZXR1cm4gTWF0aC5yb3VuZChmICogMjU1KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb2F0MkNzc1JHQkEocmdiQXJyYXkpIHtcbiAgaWYgKHJnYkFycmF5Lmxlbmd0aCA9PT0gMykge1xuICAgIHJldHVybiBgcmdiKCR7cmdiQXJyYXkubWFwKGZsb2F0VG9DaGFyKS5qb2luKCcsICcpfSlgO1xuICB9XG4gIHJldHVybiBgcmdiYSgke2Zsb2F0VG9DaGFyKHJnYkFycmF5WzBdIHx8IDApfSwgJHtmbG9hdFRvQ2hhcihcbiAgICByZ2JBcnJheVsxXSB8fCAwXG4gICl9LCAke2Zsb2F0VG9DaGFyKHJnYkFycmF5WzJdIHx8IDApfSwgJHtyZ2JBcnJheVszXSB8fCAwfSlgO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlVmVjdG9yKHZlY3RvclRvQmVSb3RhdGVkLCBheGlzLCBhbmdsZSkge1xuICBjb25zdCByb3RhdGVkVmVjdG9yID0gWy4uLnZlY3RvclRvQmVSb3RhdGVkXTtcbiAgdnRrTWF0cml4QnVpbGRlclxuICAgIC5idWlsZEZyb21SYWRpYW4oKVxuICAgIC5pZGVudGl0eSgpXG4gICAgLnJvdGF0ZShhbmdsZSwgYXhpcylcbiAgICAuYXBwbHkocm90YXRlZFZlY3Rvcik7XG4gIHJldHVybiByb3RhdGVkVmVjdG9yO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPbmx5IFN0YXRpYyBBUElcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBQaSxcbiAgcmFkaWFuc0Zyb21EZWdyZWVzLFxuICBkZWdyZWVzRnJvbVJhZGlhbnMsXG4gIHJvdW5kLFxuICBmbG9vcixcbiAgY2VpbCxcbiAgY2VpbExvZzIsXG4gIG1pbixcbiAgbWF4LFxuICBhcnJheU1pbixcbiAgYXJyYXlNYXgsXG4gIGFycmF5UmFuZ2UsXG4gIGlzUG93ZXJPZlR3byxcbiAgbmVhcmVzdFBvd2VyT2ZUd28sXG4gIGZhY3RvcmlhbCxcbiAgYmlub21pYWwsXG4gIGJlZ2luQ29tYmluYXRpb24sXG4gIG5leHRDb21iaW5hdGlvbixcbiAgcmFuZG9tU2VlZCxcbiAgZ2V0U2VlZCxcbiAgcmFuZG9tLFxuICBnYXVzc2lhbixcbiAgYWRkLFxuICBzdWJ0cmFjdCxcbiAgbXVsdGlwbHlTY2FsYXIsXG4gIG11bHRpcGx5U2NhbGFyMkQsXG4gIG11bHRpcGx5QWNjdW11bGF0ZSxcbiAgbXVsdGlwbHlBY2N1bXVsYXRlMkQsXG4gIGRvdCxcbiAgb3V0ZXIsXG4gIGNyb3NzLFxuICBub3JtLFxuICBub3JtYWxpemUsXG4gIHBlcnBlbmRpY3VsYXJzLFxuICBwcm9qZWN0VmVjdG9yLFxuICBwcm9qZWN0VmVjdG9yMkQsXG4gIGRpc3RhbmNlMkJldHdlZW5Qb2ludHMsXG4gIGFuZ2xlQmV0d2VlblZlY3RvcnMsXG4gIGdhdXNzaWFuQW1wbGl0dWRlLFxuICBnYXVzc2lhbldlaWdodCxcbiAgZG90MkQsXG4gIG91dGVyMkQsXG4gIG5vcm0yRCxcbiAgbm9ybWFsaXplMkQsXG4gIGRldGVybWluYW50MngyLFxuICBMVUZhY3RvcjN4MyxcbiAgTFVTb2x2ZTN4MyxcbiAgbGluZWFyU29sdmUzeDMsXG4gIG11bHRpcGx5M3gzX3ZlY3QzLFxuICBtdWx0aXBseTN4M19tYXQzLFxuICBtdWx0aXBseU1hdHJpeCxcbiAgdHJhbnNwb3NlM3gzLFxuICBpbnZlcnQzeDMsXG4gIGlkZW50aXR5M3gzLFxuICBkZXRlcm1pbmFudDN4MyxcbiAgcXVhdGVybmlvblRvTWF0cml4M3gzLFxuICBhcmVFcXVhbHMsXG4gIGFyZU1hdHJpY2VzRXF1YWwsXG4gIG1hdHJpeDN4M1RvUXVhdGVybmlvbixcbiAgbXVsdGlwbHlRdWF0ZXJuaW9uLFxuICBvcnRob2dvbmFsaXplM3gzLFxuICBkaWFnb25hbGl6ZTN4MyxcbiAgc2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24zeDMsXG4gIHNvbHZlTGluZWFyU3lzdGVtLFxuICBpbnZlcnRNYXRyaXgsXG4gIGx1RmFjdG9yTGluZWFyU3lzdGVtLFxuICBsdVNvbHZlTGluZWFyU3lzdGVtLFxuICBlc3RpbWF0ZU1hdHJpeENvbmRpdGlvbixcbiAgamFjb2JpLFxuICBqYWNvYmlOLFxuICBzb2x2ZUhvbW9nZW5lb3VzTGVhc3RTcXVhcmVzLFxuICBzb2x2ZUxlYXN0U3F1YXJlcyxcbiAgaGV4MmZsb2F0LFxuICByZ2IyaHN2LFxuICBoc3YycmdiLFxuICBsYWIyeHl6LFxuICB4eXoybGFiLFxuICB4eXoycmdiLFxuICByZ2IyeHl6LFxuICByZ2IybGFiLFxuICBsYWIycmdiLFxuICB1bmluaXRpYWxpemVCb3VuZHMsXG4gIGFyZUJvdW5kc0luaXRpYWxpemVkLFxuICBjb21wdXRlQm91bmRzRnJvbVBvaW50cyxcbiAgY2xhbXBWYWx1ZSxcbiAgY2xhbXBWZWN0b3IsXG4gIGNsYW1wQW5kTm9ybWFsaXplVmFsdWUsXG4gIGdldFNjYWxhclR5cGVGaXR0aW5nUmFuZ2UsXG4gIGdldEFkanVzdGVkU2NhbGFyUmFuZ2UsXG4gIGV4dGVudElzV2l0aGluT3RoZXJFeHRlbnQsXG4gIGJvdW5kc0lzV2l0aGluT3RoZXJCb3VuZHMsXG4gIHBvaW50SXNXaXRoaW5Cb3VuZHMsXG4gIHNvbHZlM1BvaW50Q2lyY2xlLFxuICBpbmYsXG4gIG5lZ0luZixcbiAgaXNJbmYsXG4gIGlzTmFuOiBpc05hTixcbiAgaXNOYU4sXG4gIGlzRmluaXRlLFxuXG4gIC8vIEpTIGFkZC1vblxuICBjcmVhdGVVbmluaXRpYWxpemVkQm91bmRzLFxuICBnZXRNYWpvckF4aXNJbmRleCxcbiAgZmxvYXRUb0hleDIsXG4gIGZsb2F0UkdCMkhleENvZGUsXG4gIGZsb2F0MkNzc1JHQkEsXG4gIHJvdGF0ZVZlY3Rvcixcbn07XG4iLCJpbXBvcnQgeyB2ZWMzLCBtYXQ0LCBnbE1hdHJpeCB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tY3ljbGVcbmltcG9ydCB7IGFyZU1hdHJpY2VzRXF1YWwgfSBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9NYXRoJztcblxuY29uc3QgTm9PcCA9ICh2KSA9PiB2O1xuXG5jb25zdCBJREVOVElUWSA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xubWF0NC5pZGVudGl0eShJREVOVElUWSk7XG5cbmNvbnN0IEVQU0lMT04gPSAxZS02O1xuXG5jbGFzcyBUcmFuc2Zvcm0ge1xuICBjb25zdHJ1Y3Rvcih1c2VEZWdyZWUgPSBmYWxzZSkge1xuICAgIHRoaXMubWF0cml4ID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG4gICAgbWF0NC5pZGVudGl0eSh0aGlzLm1hdHJpeCk7XG4gICAgdGhpcy50bXAgPSBuZXcgRmxvYXQ2NEFycmF5KDMpO1xuICAgIHRoaXMuYW5nbGVDb252ID0gdXNlRGVncmVlID8gZ2xNYXRyaXgudG9SYWRpYW4gOiBOb09wO1xuICB9XG5cbiAgcm90YXRlRnJvbURpcmVjdGlvbnMob3JpZ2luRGlyZWN0aW9uLCB0YXJnZXREaXJlY3Rpb24pIHtcbiAgICBjb25zdCBzcmMgPSBuZXcgRmxvYXQ2NEFycmF5KDMpO1xuICAgIGNvbnN0IGRzdCA9IG5ldyBGbG9hdDY0QXJyYXkoMyk7XG4gICAgY29uc3QgdHJhbnNmID0gbmV3IEZsb2F0NjRBcnJheSgxNik7XG5cbiAgICB2ZWMzLnNldChzcmMsIG9yaWdpbkRpcmVjdGlvblswXSwgb3JpZ2luRGlyZWN0aW9uWzFdLCBvcmlnaW5EaXJlY3Rpb25bMl0pO1xuICAgIHZlYzMuc2V0KGRzdCwgdGFyZ2V0RGlyZWN0aW9uWzBdLCB0YXJnZXREaXJlY3Rpb25bMV0sIHRhcmdldERpcmVjdGlvblsyXSk7XG4gICAgdmVjMy5ub3JtYWxpemUoc3JjLCBzcmMpO1xuICAgIHZlYzMubm9ybWFsaXplKGRzdCwgZHN0KTtcbiAgICBjb25zdCBjb3NBbHBoYSA9IHZlYzMuZG90KHNyYywgZHN0KTtcbiAgICBpZiAoY29zQWxwaGEgPj0gMSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdmVjMy5jcm9zcyh0aGlzLnRtcCwgc3JjLCBkc3QpO1xuICAgIGlmICh2ZWMzLmxlbmd0aCh0aGlzLnRtcCkgPCBFUFNJTE9OKSB7XG4gICAgICAvLyBjcm9zcyBwcm9kdWN0IGlzIDAsIHNvIHBpY2sgYXJiaXRyYXJ5IGF4aXMgcGVycGVuZGljdWxhclxuICAgICAgLy8gdG8gb3JpZ2luRGlyZWN0aW9uLlxuICAgICAgdmVjMy5jcm9zcyh0aGlzLnRtcCwgWzEsIDAsIDBdLCBvcmlnaW5EaXJlY3Rpb24pO1xuICAgICAgaWYgKHZlYzMubGVuZ3RoKHRoaXMudG1wKSA8IEVQU0lMT04pIHtcbiAgICAgICAgdmVjMy5jcm9zcyh0aGlzLnRtcCwgWzAsIDEsIDBdLCBvcmlnaW5EaXJlY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBtYXQ0LmZyb21Sb3RhdGlvbih0cmFuc2YsIE1hdGguYWNvcyhjb3NBbHBoYSksIHRoaXMudG1wKTtcbiAgICBtYXQ0Lm11bHRpcGx5KHRoaXMubWF0cml4LCB0aGlzLm1hdHJpeCwgdHJhbnNmKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcm90YXRlKGFuZ2xlLCBheGlzKSB7XG4gICAgdmVjMy5zZXQodGhpcy50bXAsIC4uLmF4aXMpO1xuICAgIHZlYzMubm9ybWFsaXplKHRoaXMudG1wLCB0aGlzLnRtcCk7XG4gICAgbWF0NC5yb3RhdGUodGhpcy5tYXRyaXgsIHRoaXMubWF0cml4LCB0aGlzLmFuZ2xlQ29udihhbmdsZSksIHRoaXMudG1wKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJvdGF0ZVgoYW5nbGUpIHtcbiAgICBtYXQ0LnJvdGF0ZVgodGhpcy5tYXRyaXgsIHRoaXMubWF0cml4LCB0aGlzLmFuZ2xlQ29udihhbmdsZSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcm90YXRlWShhbmdsZSkge1xuICAgIG1hdDQucm90YXRlWSh0aGlzLm1hdHJpeCwgdGhpcy5tYXRyaXgsIHRoaXMuYW5nbGVDb252KGFuZ2xlKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByb3RhdGVaKGFuZ2xlKSB7XG4gICAgbWF0NC5yb3RhdGVaKHRoaXMubWF0cml4LCB0aGlzLm1hdHJpeCwgdGhpcy5hbmdsZUNvbnYoYW5nbGUpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHRyYW5zbGF0ZSh4LCB5LCB6KSB7XG4gICAgdmVjMy5zZXQodGhpcy50bXAsIHgsIHksIHopO1xuICAgIG1hdDQudHJhbnNsYXRlKHRoaXMubWF0cml4LCB0aGlzLm1hdHJpeCwgdGhpcy50bXApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2NhbGUoc3gsIHN5LCBzeikge1xuICAgIHZlYzMuc2V0KHRoaXMudG1wLCBzeCwgc3ksIHN6KTtcbiAgICBtYXQ0LnNjYWxlKHRoaXMubWF0cml4LCB0aGlzLm1hdHJpeCwgdGhpcy50bXApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWRlbnRpdHkoKSB7XG4gICAgbWF0NC5pZGVudGl0eSh0aGlzLm1hdHJpeCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tXG5cbiAgYXBwbHkodHlwZWRBcnJheSwgb2Zmc2V0ID0gMCwgbmJJdGVyYXRpb25zID0gLTEpIHtcbiAgICBpZiAoYXJlTWF0cmljZXNFcXVhbChJREVOVElUWSwgdGhpcy5tYXRyaXgpKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgd2UgY2FuIGNoYWluIGFwcGx5Li4uXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBjb25zdCBzaXplID1cbiAgICAgIG5iSXRlcmF0aW9ucyA9PT0gLTEgPyB0eXBlZEFycmF5Lmxlbmd0aCA6IG9mZnNldCArIG5iSXRlcmF0aW9ucyAqIDM7XG4gICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IHNpemU7IGkgKz0gMykge1xuICAgICAgdmVjMy5zZXQodGhpcy50bXAsIHR5cGVkQXJyYXlbaV0sIHR5cGVkQXJyYXlbaSArIDFdLCB0eXBlZEFycmF5W2kgKyAyXSk7XG4gICAgICB2ZWMzLnRyYW5zZm9ybU1hdDQodGhpcy50bXAsIHRoaXMudG1wLCB0aGlzLm1hdHJpeCk7XG4gICAgICB0eXBlZEFycmF5W2ldID0gdGhpcy50bXBbMF07XG4gICAgICB0eXBlZEFycmF5W2kgKyAxXSA9IHRoaXMudG1wWzFdO1xuICAgICAgdHlwZWRBcnJheVtpICsgMl0gPSB0aGlzLnRtcFsyXTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgY2FuIGNoYWluIGFwcGx5Li4uXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRNYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0cml4O1xuICB9XG5cbiAgc2V0TWF0cml4KG1hdDR4NCkge1xuICAgIGlmICghIW1hdDR4NCAmJiBtYXQ0eDQubGVuZ3RoID09PSAxNikge1xuICAgICAgbWF0NC5jb3B5KHRoaXMubWF0cml4LCBtYXQ0eDQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZEZyb21EZWdyZWUoKSB7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtKHRydWUpO1xufVxuXG5mdW5jdGlvbiBidWlsZEZyb21SYWRpYW4oKSB7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtKGZhbHNlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBidWlsZEZyb21EZWdyZWUsXG4gIGJ1aWxkRnJvbVJhZGlhbixcbn07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0IHZ0a0RhdGFBcnJheSBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9EYXRhQXJyYXknO1xuaW1wb3J0IHsgVnRrRGF0YVR5cGVzIH0gZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvRGF0YUFycmF5L0NvbnN0YW50cyc7XG5cbmNvbnN0IHsgdnRrRXJyb3JNYWNybyB9ID0gbWFjcm87XG5cbmNvbnN0IElOVkFMSURfQk9VTkRTID0gWzEsIC0xLCAxLCAtMSwgMSwgLTFdO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtQb2ludHMgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtQb2ludHMocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtQb2ludHMnKTtcblxuICAvLyBGb3J3YXJkaW5nIG1ldGhvZHNcbiAgcHVibGljQVBJLmdldE51bWJlck9mUG9pbnRzID0gcHVibGljQVBJLmdldE51bWJlck9mVHVwbGVzO1xuXG4gIHB1YmxpY0FQSS5zZXROdW1iZXJPZlBvaW50cyA9IChuYlBvaW50cywgZGltZW5zaW9uID0gMykgPT4ge1xuICAgIGlmIChwdWJsaWNBUEkuZ2V0TnVtYmVyT2ZQb2ludHMoKSAhPT0gbmJQb2ludHMpIHtcbiAgICAgIG1vZGVsLnNpemUgPSBuYlBvaW50cyAqIGRpbWVuc2lvbjtcbiAgICAgIG1vZGVsLnZhbHVlcyA9IG5ldyB3aW5kb3dbbW9kZWwuZGF0YVR5cGVdKG1vZGVsLnNpemUpO1xuICAgICAgcHVibGljQVBJLnNldE51bWJlck9mQ29tcG9uZW50cyhkaW1lbnNpb24pO1xuICAgICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRQb2ludCA9IChpZHgsIC4uLnh5eikgPT4ge1xuICAgIGNvbnN0IG9mZnNldCA9IGlkeCAqIG1vZGVsLm51bWJlck9mQ29tcG9uZW50cztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsLm51bWJlck9mQ29tcG9uZW50czsgaSsrKSB7XG4gICAgICBtb2RlbC52YWx1ZXNbb2Zmc2V0ICsgaV0gPSB4eXpbaV07XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRQb2ludCA9IHB1YmxpY0FQSS5nZXRUdXBsZTtcblxuICBwdWJsaWNBUEkuZ2V0Qm91bmRzID0gKCkgPT4ge1xuICAgIGlmIChwdWJsaWNBUEkuZ2V0TnVtYmVyT2ZDb21wb25lbnRzKCkgPT09IDMpIHtcbiAgICAgIGNvbnN0IHhSYW5nZSA9IHB1YmxpY0FQSS5nZXRSYW5nZSgwKTtcbiAgICAgIG1vZGVsLmJvdW5kc1swXSA9IHhSYW5nZVswXTtcbiAgICAgIG1vZGVsLmJvdW5kc1sxXSA9IHhSYW5nZVsxXTtcbiAgICAgIGNvbnN0IHlSYW5nZSA9IHB1YmxpY0FQSS5nZXRSYW5nZSgxKTtcbiAgICAgIG1vZGVsLmJvdW5kc1syXSA9IHlSYW5nZVswXTtcbiAgICAgIG1vZGVsLmJvdW5kc1szXSA9IHlSYW5nZVsxXTtcbiAgICAgIGNvbnN0IHpSYW5nZSA9IHB1YmxpY0FQSS5nZXRSYW5nZSgyKTtcbiAgICAgIG1vZGVsLmJvdW5kc1s0XSA9IHpSYW5nZVswXTtcbiAgICAgIG1vZGVsLmJvdW5kc1s1XSA9IHpSYW5nZVsxXTtcbiAgICAgIHJldHVybiBtb2RlbC5ib3VuZHM7XG4gICAgfVxuXG4gICAgaWYgKHB1YmxpY0FQSS5nZXROdW1iZXJPZkNvbXBvbmVudHMoKSAhPT0gMikge1xuICAgICAgdnRrRXJyb3JNYWNybyhgZ2V0Qm91bmRzIGNhbGxlZCBvbiBhbiBhcnJheSB3aXRoIGNvbXBvbmVudHMgb2ZcbiAgICAgICAgJHtwdWJsaWNBUEkuZ2V0TnVtYmVyT2ZDb21wb25lbnRzKCl9YCk7XG4gICAgICByZXR1cm4gSU5WQUxJRF9CT1VORFM7XG4gICAgfVxuXG4gICAgY29uc3QgeFJhbmdlID0gcHVibGljQVBJLmdldFJhbmdlKDApO1xuICAgIG1vZGVsLmJvdW5kc1swXSA9IHhSYW5nZVswXTtcbiAgICBtb2RlbC5ib3VuZHNbMV0gPSB4UmFuZ2VbMV07XG4gICAgY29uc3QgeVJhbmdlID0gcHVibGljQVBJLmdldFJhbmdlKDEpO1xuICAgIG1vZGVsLmJvdW5kc1syXSA9IHlSYW5nZVswXTtcbiAgICBtb2RlbC5ib3VuZHNbM10gPSB5UmFuZ2VbMV07XG4gICAgbW9kZWwuYm91bmRzWzRdID0gMDtcbiAgICBtb2RlbC5ib3VuZHNbNV0gPSAwO1xuXG4gICAgcmV0dXJuIG1vZGVsLmJvdW5kcztcbiAgfTtcblxuICAvLyBUcmlnZ2VyIHRoZSBjb21wdXRhdGlvbiBvZiBib3VuZHNcbiAgcHVibGljQVBJLmNvbXB1dGVCb3VuZHMgPSBwdWJsaWNBUEkuZ2V0Qm91bmRzO1xuXG4gIC8vIEluaXRpYWxpemVcbiAgcHVibGljQVBJLnNldE51bWJlck9mQ29tcG9uZW50cyhcbiAgICBtb2RlbC5udW1iZXJPZkNvbXBvbmVudHMgPCAyID8gMyA6IG1vZGVsLm51bWJlck9mQ29tcG9uZW50c1xuICApO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgZW1wdHk6IHRydWUsXG4gIG51bWJlck9mQ29tcG9uZW50czogMyxcbiAgZGF0YVR5cGU6IFZ0a0RhdGFUeXBlcy5GTE9BVCxcbiAgYm91bmRzOiBbMSwgLTEsIDEsIC0xLCAxLCAtMV0sXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICB2dGtEYXRhQXJyYXkuZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMpO1xuICB2dGtQb2ludHMocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrUG9pbnRzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kIH07XG4iLCJleHBvcnQgY29uc3QgVmVjdG9yTW9kZSA9IHtcbiAgTUFHTklUVURFOiAwLFxuICBDT01QT05FTlQ6IDEsXG4gIFJHQkNPTE9SUzogMixcbn07XG5cbmV4cG9ydCBjb25zdCBTY2FsYXJNYXBwaW5nVGFyZ2V0ID0ge1xuICBMVU1JTkFOQ0U6IDEsXG4gIExVTUlOQU5DRV9BTFBIQTogMixcbiAgUkdCOiAzLFxuICBSR0JBOiA0LFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBWZWN0b3JNb2RlLFxuICBTY2FsYXJNYXBwaW5nVGFyZ2V0LFxufTtcbiIsImltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgdnRrRGF0YUFycmF5IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL0RhdGFBcnJheSc7XG5pbXBvcnQgQ29uc3RhbnRzIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL1NjYWxhcnNUb0NvbG9ycy9Db25zdGFudHMnO1xuaW1wb3J0IHZ0a01hcHBlciBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9NYXBwZXIvQ29uc3RhbnRzJzsgLy8gTmVlZCB0byBnbyBpbnNpZGUgQ29uc3RhbnRzIG90aGVyd2lzZSBkZXBlbmRlbmN5IGxvb3BcblxuY29uc3QgeyBTY2FsYXJNYXBwaW5nVGFyZ2V0LCBWZWN0b3JNb2RlIH0gPSBDb25zdGFudHM7XG5jb25zdCB7IFZ0a0RhdGFUeXBlcyB9ID0gdnRrRGF0YUFycmF5O1xuY29uc3QgeyBDb2xvck1vZGUgfSA9IHZ0a01hcHBlcjtcbmNvbnN0IHsgdnRrRXJyb3JNYWNybyB9ID0gbWFjcm87XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdsb2JhbCBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEFkZCBtb2R1bGUtbGV2ZWwgZnVuY3Rpb25zIG9yIGFwaSB0aGF0IHlvdSB3YW50IHRvIGV4cG9zZSBzdGF0aWNhbGx5IHZpYVxuLy8gdGhlIG5leHQgc2VjdGlvbi4uLlxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTdGF0aWMgQVBJXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGludENvbG9yVG9VQ2hhcihjKSB7XG4gIHJldHVybiBjO1xufVxuZnVuY3Rpb24gZmxvYXRDb2xvclRvVUNoYXIoYykge1xuICByZXR1cm4gTWF0aC5mbG9vcihjICogMjU1LjAgKyAwLjUpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtTY2FsYXJzVG9Db2xvcnMgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtTY2FsYXJzVG9Db2xvcnMocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtTY2FsYXJzVG9Db2xvcnMnKTtcblxuICBwdWJsaWNBUEkuc2V0VmVjdG9yTW9kZVRvTWFnbml0dWRlID0gKCkgPT5cbiAgICBwdWJsaWNBUEkuc2V0VmVjdG9yTW9kZShWZWN0b3JNb2RlLk1BR05JVFVERSk7XG4gIHB1YmxpY0FQSS5zZXRWZWN0b3JNb2RlVG9Db21wb25lbnQgPSAoKSA9PlxuICAgIHB1YmxpY0FQSS5zZXRWZWN0b3JNb2RlKFZlY3Rvck1vZGUuQ09NUE9ORU5UKTtcbiAgcHVibGljQVBJLnNldFZlY3Rvck1vZGVUb1JHQkNvbG9ycyA9ICgpID0+XG4gICAgcHVibGljQVBJLnNldFZlY3Rvck1vZGUoVmVjdG9yTW9kZS5SR0JDT0xPUlMpO1xuXG4gIHB1YmxpY0FQSS5idWlsZCA9ICgpID0+IHt9O1xuXG4gIHB1YmxpY0FQSS5pc09wYXF1ZSA9ICgpID0+IHRydWU7XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5zZXRBbm5vdGF0aW9ucyA9ICh2YWx1ZXMsIGFubm90YXRpb25zKSA9PiB7XG4gICAgaWYgKCh2YWx1ZXMgJiYgIWFubm90YXRpb25zKSB8fCAoIXZhbHVlcyAmJiBhbm5vdGF0aW9ucykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodmFsdWVzICYmIGFubm90YXRpb25zICYmIHZhbHVlcy5sZW5ndGggIT09IGFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgdnRrRXJyb3JNYWNybyhcbiAgICAgICAgJ1ZhbHVlcyBhbmQgYW5ub3RhdGlvbnMgZG8gbm90IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHR1cGxlcyBzbyBpZ25vcmluZydcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbW9kZWwuYW5ub3RhdGlvbkFycmF5ID0gW107XG5cbiAgICBpZiAoYW5ub3RhdGlvbnMgJiYgdmFsdWVzKSB7XG4gICAgICBjb25zdCBudW0gPSBhbm5vdGF0aW9ucy5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgIG1vZGVsLmFubm90YXRpb25BcnJheS5wdXNoKHtcbiAgICAgICAgICB2YWx1ZTogdmFsdWVzW2ldLFxuICAgICAgICAgIGFubm90YXRpb246IFN0cmluZyhhbm5vdGF0aW9uc1tpXSksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpY0FQSS51cGRhdGVBbm5vdGF0ZWRWYWx1ZU1hcCgpO1xuICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuc2V0QW5ub3RhdGlvbiA9ICh2YWx1ZSwgYW5ub3RhdGlvbikgPT4ge1xuICAgIGxldCBpID0gcHVibGljQVBJLmNoZWNrRm9yQW5ub3RhdGVkVmFsdWUodmFsdWUpO1xuICAgIGxldCBtb2RpZmllZCA9IGZhbHNlO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIGlmIChtb2RlbC5hbm5vdGF0aW9uQXJyYXlbaV0uYW5ub3RhdGlvbiAhPT0gYW5ub3RhdGlvbikge1xuICAgICAgICBtb2RlbC5hbm5vdGF0aW9uQXJyYXlbaV0uYW5ub3RhdGlvbiA9IGFubm90YXRpb247XG4gICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWwuYW5ub3RhdGlvbkFycmF5LnB1c2goeyB2YWx1ZSwgYW5ub3RhdGlvbiB9KTtcbiAgICAgIGkgPSBtb2RlbC5hbm5vdGF0aW9uQXJyYXkubGVuZ3RoIC0gMTtcbiAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICBwdWJsaWNBUEkudXBkYXRlQW5ub3RhdGVkVmFsdWVNYXAoKTtcbiAgICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmdldE51bWJlck9mQW5ub3RhdGVkVmFsdWVzID0gKCkgPT4gbW9kZWwuYW5ub3RhdGlvbkFycmF5Lmxlbmd0aDtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmdldEFubm90YXRlZFZhbHVlID0gKGlkeCkgPT4ge1xuICAgIGlmIChpZHggPCAwIHx8IGlkeCA+PSBtb2RlbC5hbm5vdGF0aW9uQXJyYXkubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsLmFubm90YXRpb25BcnJheVtpZHhdLnZhbHVlO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuZ2V0QW5ub3RhdGlvbiA9IChpZHgpID0+IHtcbiAgICBpZiAobW9kZWwuYW5ub3RhdGlvbkFycmF5W2lkeF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbC5hbm5vdGF0aW9uQXJyYXlbaWR4XS5hbm5vdGF0aW9uO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuZ2V0QW5ub3RhdGVkVmFsdWVJbmRleCA9ICh2YWwpID0+XG4gICAgbW9kZWwuYW5ub3RhdGlvbkFycmF5Lmxlbmd0aCA/IHB1YmxpY0FQSS5jaGVja0ZvckFubm90YXRlZFZhbHVlKHZhbCkgOiAtMTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLnJlbW92ZUFubm90YXRpb24gPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCBpID0gcHVibGljQVBJLmNoZWNrRm9yQW5ub3RhdGVkVmFsdWUodmFsdWUpO1xuICAgIGNvbnN0IG5lZWRUb1JlbW92ZSA9IGkgPj0gMDtcbiAgICBpZiAobmVlZFRvUmVtb3ZlKSB7XG4gICAgICBtb2RlbC5hbm5vdGF0aW9uQXJyYXkuc3BsaWNlKGksIDEpO1xuICAgICAgcHVibGljQVBJLnVwZGF0ZUFubm90YXRlZFZhbHVlTWFwKCk7XG4gICAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG5lZWRUb1JlbW92ZTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLnJlc2V0QW5ub3RhdGlvbnMgPSAoKSA9PiB7XG4gICAgbW9kZWwuYW5ub3RhdGlvbkFycmF5ID0gW107XG4gICAgbW9kZWwuYW5ub3RhdGVkVmFsdWVNYXAgPSBbXTtcbiAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmdldEFubm90YXRpb25Db2xvciA9ICh2YWwsIHJnYmEpID0+IHtcbiAgICBpZiAobW9kZWwuaW5kZXhlZExvb2t1cCkge1xuICAgICAgY29uc3QgaSA9IHB1YmxpY0FQSS5nZXRBbm5vdGF0ZWRWYWx1ZUluZGV4KHZhbCk7XG4gICAgICBwdWJsaWNBUEkuZ2V0SW5kZXhlZENvbG9yKGksIHJnYmEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdWJsaWNBUEkuZ2V0Q29sb3IocGFyc2VGbG9hdCh2YWwpLCByZ2JhKTtcbiAgICAgIHJnYmFbM10gPSAxLjA7XG4gICAgfVxuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuY2hlY2tGb3JBbm5vdGF0ZWRWYWx1ZSA9ICh2YWx1ZSkgPT5cbiAgICBwdWJsaWNBUEkuZ2V0QW5ub3RhdGVkVmFsdWVJbmRleEludGVybmFsKHZhbHVlKTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQW4gdW5zYWZlIHZlcnNpb24gb2YgdnRrU2NhbGFyc1RvQ29sb3JzOjpDaGVja0ZvckFubm90YXRlZFZhbHVlIGZvclxuICAvLyBpbnRlcm5hbCB1c2UgKG5vIHBvaW50ZXIgY2hlY2tzIHBlcmZvcm1lZClcbiAgcHVibGljQVBJLmdldEFubm90YXRlZFZhbHVlSW5kZXhJbnRlcm5hbCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmIChtb2RlbC5hbm5vdGF0ZWRWYWx1ZU1hcFt2YWx1ZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbmEgPSBtb2RlbC5hbm5vdGF0aW9uQXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIG1vZGVsLmFubm90YXRlZFZhbHVlTWFwW3ZhbHVlXSAlIG5hO1xuICAgIH1cbiAgICAvLyBUcmVhdCBhcyBhIE5hTlxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmdldEluZGV4ZWRDb2xvciA9ICh2YWwsIHJnYmEpID0+IHtcbiAgICByZ2JhWzBdID0gMC4wO1xuICAgIHJnYmFbMV0gPSAwLjA7XG4gICAgcmdiYVsyXSA9IDAuMDtcbiAgICByZ2JhWzNdID0gMC4wO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkudXBkYXRlQW5ub3RhdGVkVmFsdWVNYXAgPSAoKSA9PiB7XG4gICAgbW9kZWwuYW5ub3RhdGVkVmFsdWVNYXAgPSBbXTtcblxuICAgIGNvbnN0IG5hID0gbW9kZWwuYW5ub3RhdGlvbkFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hOyBpKyspIHtcbiAgICAgIG1vZGVsLmFubm90YXRlZFZhbHVlTWFwW21vZGVsLmFubm90YXRpb25BcnJheVtpXS52YWx1ZV0gPSBpO1xuICAgIH1cbiAgfTtcblxuICAvLyBEZXNjcmlwdGlvbjpcbiAgLy8gSW50ZXJuYWwgbWV0aG9kcyB0aGF0IG1hcCBhIGRhdGEgYXJyYXkgaW50byBhIDQtY29tcG9uZW50LFxuICAvLyB1bnNpZ25lZCBjaGFyIFJHQkEgYXJyYXkuIFRoZSBjb2xvciBtb2RlIGRldGVybWluZXMgdGhlIGJlaGF2aW9yXG4gIC8vIG9mIG1hcHBpbmcuIElmIENvbG9yTW9kZS5ERUZBVUxUIGlzIHNldCwgdGhlbiB1bnNpZ25lZCBjaGFyXG4gIC8vIGRhdGEgYXJyYXlzIGFyZSB0cmVhdGVkIGFzIGNvbG9ycyAoYW5kIGNvbnZlcnRlZCB0byBSR0JBIGlmXG4gIC8vIG5lY2Vzc2FyeSk7IElmIENvbG9yTW9kZS5ESVJFQ1RfU0NBTEFSUyBpcyBzZXQsIHRoZW4gYWxsIGFycmF5c1xuICAvLyBhcmUgdHJlYXRlZCBhcyBjb2xvcnMgKGludGVnZXIgdHlwZXMgYXJlIGNsYW1wZWQgaW4gdGhlIHJhbmdlIDAtMjU1LFxuICAvLyBmbG9hdGluZyBwb2ludCBhcnJheXMgYXJlIGNsYW1wZWQgaW4gdGhlIHJhbmdlIDAuMC0xLjAuIE5vdGUgJ2NoYXInIGRvZXNcbiAgLy8gbm90IGhhdmUgZW5vdWdoIHZhbHVlcyB0byByZXByZXNlbnQgYSBjb2xvciBzbyBtYXBwaW5nIHRoaXMgdHlwZSBpc1xuICAvLyBjb25zaWRlcmVkIGFuIGVycm9yKTtcbiAgLy8gb3RoZXJ3aXNlLCB0aGUgZGF0YSBpcyBtYXBwZWQgdGhyb3VnaCB0aGlzIGluc3RhbmNlXG4gIC8vIG9mIFNjYWxhcnNUb0NvbG9ycy4gVGhlIGNvbXBvbmVudCBhcmd1bWVudCBpcyB1c2VkIGZvciBkYXRhXG4gIC8vIGFycmF5cyB3aXRoIG1vcmUgdGhhbiBvbmUgY29tcG9uZW50OyBpdCBpbmRpY2F0ZXMgd2hpY2ggY29tcG9uZW50XG4gIC8vIHRvIHVzZSB0byBkbyB0aGUgYmxlbmRpbmcuICBXaGVuIHRoZSBjb21wb25lbnQgYXJndW1lbnQgaXMgLTEsXG4gIC8vIHRoZW4gdGhlIHRoaXMgb2JqZWN0IHVzZXMgaXRzIG93biBzZWxlY3RlZCB0ZWNobmlxdWUgdG8gY2hhbmdlIGFcbiAgLy8gdmVjdG9yIGludG8gYSBzY2FsYXIgdG8gbWFwLlxuICBwdWJsaWNBUEkubWFwU2NhbGFycyA9IChzY2FsYXJzLCBjb2xvck1vZGUsIGNvbXBvbmVudEluKSA9PiB7XG4gICAgY29uc3QgbnVtYmVyT2ZDb21wb25lbnRzID0gc2NhbGFycy5nZXROdW1iZXJPZkNvbXBvbmVudHMoKTtcblxuICAgIGxldCBuZXdDb2xvcnMgPSBudWxsO1xuXG4gICAgLy8gbWFwIHNjYWxhcnMgdGhyb3VnaCBsb29rdXAgdGFibGUgb25seSBpZiBuZWVkZWRcbiAgICBpZiAoXG4gICAgICAoY29sb3JNb2RlID09PSBDb2xvck1vZGUuREVGQVVMVCAmJlxuICAgICAgICBzY2FsYXJzLmdldERhdGFUeXBlKCkgPT09IFZ0a0RhdGFUeXBlcy5VTlNJR05FRF9DSEFSKSB8fFxuICAgICAgKGNvbG9yTW9kZSA9PT0gQ29sb3JNb2RlLkRJUkVDVF9TQ0FMQVJTICYmIHNjYWxhcnMpXG4gICAgKSB7XG4gICAgICBuZXdDb2xvcnMgPSBwdWJsaWNBUEkuY29udmVydFRvUkdCQShcbiAgICAgICAgc2NhbGFycyxcbiAgICAgICAgbnVtYmVyT2ZDb21wb25lbnRzLFxuICAgICAgICBzY2FsYXJzLmdldE51bWJlck9mVHVwbGVzKClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5ld3NjYWxhcnMgPSB7XG4gICAgICAgIHR5cGU6ICd2dGtEYXRhQXJyYXknLFxuICAgICAgICBuYW1lOiAndGVtcCcsXG4gICAgICAgIG51bWJlck9mQ29tcG9uZW50czogNCxcbiAgICAgICAgZGF0YVR5cGU6IFZ0a0RhdGFUeXBlcy5VTlNJR05FRF9DSEFSLFxuICAgICAgfTtcblxuICAgICAgY29uc3QgcyA9IG5ldyB3aW5kb3dbbmV3c2NhbGFycy5kYXRhVHlwZV0oXG4gICAgICAgIDQgKiBzY2FsYXJzLmdldE51bWJlck9mVHVwbGVzKClcbiAgICAgICk7XG4gICAgICBuZXdzY2FsYXJzLnZhbHVlcyA9IHM7XG4gICAgICBuZXdzY2FsYXJzLnNpemUgPSBzLmxlbmd0aDtcbiAgICAgIG5ld0NvbG9ycyA9IHZ0a0RhdGFBcnJheS5uZXdJbnN0YW5jZShuZXdzY2FsYXJzKTtcblxuICAgICAgbGV0IGNvbXBvbmVudCA9IGNvbXBvbmVudEluO1xuXG4gICAgICAvLyBJZiBtYXBwZXIgZGlkIG5vdCBzcGVjaWZ5IGEgY29tcG9uZW50LCB1c2UgdGhlIFZlY3Rvck1vZGVcbiAgICAgIGlmIChjb21wb25lbnQgPCAwICYmIG51bWJlck9mQ29tcG9uZW50cyA+IDEpIHtcbiAgICAgICAgcHVibGljQVBJLm1hcFZlY3RvcnNUaHJvdWdoVGFibGUoXG4gICAgICAgICAgc2NhbGFycyxcbiAgICAgICAgICBuZXdDb2xvcnMsXG4gICAgICAgICAgU2NhbGFyTWFwcGluZ1RhcmdldC5SR0JBLFxuICAgICAgICAgIC0xLFxuICAgICAgICAgIC0xXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29tcG9uZW50IDwgMCkge1xuICAgICAgICAgIGNvbXBvbmVudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBvbmVudCA+PSBudW1iZXJPZkNvbXBvbmVudHMpIHtcbiAgICAgICAgICBjb21wb25lbnQgPSBudW1iZXJPZkNvbXBvbmVudHMgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWFwIHRoZSBzY2FsYXJzIHRvIGNvbG9yc1xuICAgICAgICBwdWJsaWNBUEkubWFwU2NhbGFyc1Rocm91Z2hUYWJsZShcbiAgICAgICAgICBzY2FsYXJzLFxuICAgICAgICAgIG5ld0NvbG9ycyxcbiAgICAgICAgICBTY2FsYXJNYXBwaW5nVGFyZ2V0LlJHQkEsXG4gICAgICAgICAgY29tcG9uZW50XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0NvbG9ycztcbiAgfTtcblxuICBwdWJsaWNBUEkubWFwVmVjdG9yc1RvTWFnbml0dWRlID0gKGlucHV0LCBvdXRwdXQsIGNvbXBzVG9Vc2UpID0+IHtcbiAgICBjb25zdCBsZW5ndGggPSBpbnB1dC5nZXROdW1iZXJPZlR1cGxlcygpO1xuICAgIGNvbnN0IGluSW5jciA9IGlucHV0LmdldE51bWJlck9mQ29tcG9uZW50cygpO1xuXG4gICAgY29uc3Qgb3V0cHV0ViA9IG91dHB1dC5nZXREYXRhKCk7XG4gICAgY29uc3QgaW5wdXRWID0gaW5wdXQuZ2V0RGF0YSgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHN1bSA9IDAuMDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29tcHNUb1VzZTsgaisrKSB7XG4gICAgICAgIHN1bSArPSBpbnB1dFZbaSAqIGluSW5jciArIGpdICogaW5wdXRWW2kgKiBpbkluY3IgKyBqXTtcbiAgICAgIH1cbiAgICAgIG91dHB1dFZbaV0gPSBNYXRoLnNxcnQoc3VtKTtcbiAgICB9XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIE1hcCBhIHNldCBvZiB2ZWN0b3IgdmFsdWVzIHRocm91Z2ggdGhlIHRhYmxlXG4gIHB1YmxpY0FQSS5tYXBWZWN0b3JzVGhyb3VnaFRhYmxlID0gKFxuICAgIGlucHV0LFxuICAgIG91dHB1dCxcbiAgICBvdXRwdXRGb3JtYXQsXG4gICAgdmVjdG9yQ29tcG9uZW50SW4sXG4gICAgdmVjdG9yU2l6ZUluXG4gICkgPT4ge1xuICAgIGxldCB2ZWN0b3JNb2RlID0gcHVibGljQVBJLmdldFZlY3Rvck1vZGUoKTtcbiAgICBsZXQgdmVjdG9yU2l6ZSA9IHZlY3RvclNpemVJbjtcbiAgICBsZXQgdmVjdG9yQ29tcG9uZW50ID0gdmVjdG9yQ29tcG9uZW50SW47XG4gICAgY29uc3QgaW5Db21wb25lbnRzID0gaW5wdXQuZ2V0TnVtYmVyT2ZDb21wb25lbnRzKCk7XG5cbiAgICBpZiAodmVjdG9yTW9kZSA9PT0gVmVjdG9yTW9kZS5DT01QT05FTlQpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB2ZWN0b3JDb21wb25lbnQgaXMgd2l0aGluIGFsbG93ZWQgcmFuZ2VcbiAgICAgIGlmICh2ZWN0b3JDb21wb25lbnQgPT09IC0xKSB7XG4gICAgICAgIC8vIGlmIHNldCB0byAtMSwgdXNlIGRlZmF1bHQgdmFsdWUgcHJvdmlkZWQgYnkgdGFibGVcbiAgICAgICAgdmVjdG9yQ29tcG9uZW50ID0gcHVibGljQVBJLmdldFZlY3RvckNvbXBvbmVudCgpO1xuICAgICAgfVxuICAgICAgaWYgKHZlY3RvckNvbXBvbmVudCA8IDApIHtcbiAgICAgICAgdmVjdG9yQ29tcG9uZW50ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICh2ZWN0b3JDb21wb25lbnQgPj0gaW5Db21wb25lbnRzKSB7XG4gICAgICAgIHZlY3RvckNvbXBvbmVudCA9IGluQ29tcG9uZW50cyAtIDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB2ZWN0b3JTaXplIGlzIHdpdGhpbiBhbGxvd2VkIHJhbmdlXG4gICAgICBpZiAodmVjdG9yU2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgLy8gaWYgc2V0IHRvIC0xLCB1c2UgZGVmYXVsdCB2YWx1ZSBwcm92aWRlZCBieSB0YWJsZVxuICAgICAgICB2ZWN0b3JTaXplID0gcHVibGljQVBJLmdldFZlY3RvclNpemUoKTtcbiAgICAgIH1cbiAgICAgIGlmICh2ZWN0b3JTaXplIDw9IDApIHtcbiAgICAgICAgdmVjdG9yQ29tcG9uZW50ID0gMDtcbiAgICAgICAgdmVjdG9yU2l6ZSA9IGluQ29tcG9uZW50cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2ZWN0b3JDb21wb25lbnQgPCAwKSB7XG4gICAgICAgICAgdmVjdG9yQ29tcG9uZW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmVjdG9yQ29tcG9uZW50ID49IGluQ29tcG9uZW50cykge1xuICAgICAgICAgIHZlY3RvckNvbXBvbmVudCA9IGluQ29tcG9uZW50cyAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlY3RvckNvbXBvbmVudCArIHZlY3RvclNpemUgPiBpbkNvbXBvbmVudHMpIHtcbiAgICAgICAgICB2ZWN0b3JTaXplID0gaW5Db21wb25lbnRzIC0gdmVjdG9yQ29tcG9uZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgdmVjdG9yTW9kZSA9PT0gVmVjdG9yTW9kZS5NQUdOSVRVREUgJiZcbiAgICAgICAgKGluQ29tcG9uZW50cyA9PT0gMSB8fCB2ZWN0b3JTaXplID09PSAxKVxuICAgICAgKSB7XG4gICAgICAgIHZlY3Rvck1vZGUgPSBWZWN0b3JNb2RlLkNPTVBPTkVOVDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpbmNyZW1lbnQgaW5wdXQgcG9pbnRlciB0byB0aGUgZmlyc3QgY29tcG9uZW50IHRvIG1hcFxuICAgIGxldCBpbnB1dE9mZnNldCA9IDA7XG4gICAgaWYgKHZlY3RvckNvbXBvbmVudCA+IDApIHtcbiAgICAgIGlucHV0T2Zmc2V0ID0gdmVjdG9yQ29tcG9uZW50O1xuICAgIH1cblxuICAgIC8vIG1hcCBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgdmVjdG9yIG1vZGVcbiAgICBzd2l0Y2ggKHZlY3Rvck1vZGUpIHtcbiAgICAgIGNhc2UgVmVjdG9yTW9kZS5DT01QT05FTlQ6IHtcbiAgICAgICAgcHVibGljQVBJLm1hcFNjYWxhcnNUaHJvdWdoVGFibGUoXG4gICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgb3V0cHV0LFxuICAgICAgICAgIG91dHB1dEZvcm1hdCxcbiAgICAgICAgICBpbnB1dE9mZnNldFxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgIGNhc2UgVmVjdG9yTW9kZS5NQUdOSVRVREU6IHtcbiAgICAgICAgY29uc3QgbWFnVmFsdWVzID0gdnRrRGF0YUFycmF5Lm5ld0luc3RhbmNlKHtcbiAgICAgICAgICBudW1iZXJPZkNvbXBvbmVudHM6IDEsXG4gICAgICAgICAgdmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KGlucHV0LmdldE51bWJlck9mVHVwbGVzKCkpLFxuICAgICAgICB9KTtcblxuICAgICAgICBwdWJsaWNBUEkubWFwVmVjdG9yc1RvTWFnbml0dWRlKGlucHV0LCBtYWdWYWx1ZXMsIHZlY3RvclNpemUpO1xuICAgICAgICBwdWJsaWNBUEkubWFwU2NhbGFyc1Rocm91Z2hUYWJsZShtYWdWYWx1ZXMsIG91dHB1dCwgb3V0cHV0Rm9ybWF0LCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgVmVjdG9yTW9kZS5SR0JDT0xPUlM6IHtcbiAgICAgICAgLy8gcHVibGljQVBJLm1hcENvbG9yc1RvQ29sb3JzKFxuICAgICAgICAvLyAgIGlucHV0LCBvdXRwdXQsIGluQ29tcG9uZW50cywgdmVjdG9yU2l6ZSxcbiAgICAgICAgLy8gICBvdXRwdXRGb3JtYXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmx1bWluYW5jZVRvUkdCQSA9IChuZXdDb2xvcnMsIGNvbG9ycywgYWxwaGEsIGNvbnZ0RnVuKSA9PiB7XG4gICAgY29uc3QgYSA9IGNvbnZ0RnVuKGFscGhhKTtcblxuICAgIGNvbnN0IHZhbHVlcyA9IGNvbG9ycy5nZXREYXRhKCk7XG4gICAgY29uc3QgbmV3VmFsdWVzID0gbmV3Q29sb3JzLmdldERhdGEoKTtcbiAgICBjb25zdCBzaXplID0gdmFsdWVzLmxlbmd0aDtcbiAgICBjb25zdCBjb21wb25lbnQgPSAwO1xuICAgIGNvbnN0IHR1cGxlID0gMTtcblxuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGNvbXBvbmVudDsgaSA8IHNpemU7IGkgKz0gdHVwbGUpIHtcbiAgICAgIGNvbnN0IGwgPSBjb252dEZ1bih2YWx1ZXNbaV0pO1xuICAgICAgbmV3VmFsdWVzW2NvdW50ICogNF0gPSBsO1xuICAgICAgbmV3VmFsdWVzW2NvdW50ICogNCArIDFdID0gbDtcbiAgICAgIG5ld1ZhbHVlc1tjb3VudCAqIDQgKyAyXSA9IGw7XG4gICAgICBuZXdWYWx1ZXNbY291bnQgKiA0ICsgM10gPSBhO1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmx1bWluYW5jZUFscGhhVG9SR0JBID0gKG5ld0NvbG9ycywgY29sb3JzLCBhbHBoYSwgY29udnRGdW4pID0+IHtcbiAgICBjb25zdCB2YWx1ZXMgPSBjb2xvcnMuZ2V0RGF0YSgpO1xuICAgIGNvbnN0IG5ld1ZhbHVlcyA9IG5ld0NvbG9ycy5nZXREYXRhKCk7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlcy5sZW5ndGg7XG4gICAgY29uc3QgY29tcG9uZW50ID0gMDtcbiAgICBjb25zdCB0dXBsZSA9IDI7XG5cbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSBjb21wb25lbnQ7IGkgPCBzaXplOyBpICs9IHR1cGxlKSB7XG4gICAgICBjb25zdCBsID0gY29udnRGdW4odmFsdWVzW2ldKTtcbiAgICAgIG5ld1ZhbHVlc1tjb3VudF0gPSBsO1xuICAgICAgbmV3VmFsdWVzW2NvdW50ICsgMV0gPSBsO1xuICAgICAgbmV3VmFsdWVzW2NvdW50ICsgMl0gPSBsO1xuICAgICAgbmV3VmFsdWVzW2NvdW50ICsgM10gPSBjb252dEZ1bih2YWx1ZXNbaSArIDFdKSAqIGFscGhhO1xuICAgICAgY291bnQgKz0gNDtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLnJHQlRvUkdCQSA9IChuZXdDb2xvcnMsIGNvbG9ycywgYWxwaGEsIGNvbnZ0RnVuKSA9PiB7XG4gICAgY29uc3QgYSA9IGZsb2F0Q29sb3JUb1VDaGFyKGFscGhhKTtcblxuICAgIGNvbnN0IHZhbHVlcyA9IGNvbG9ycy5nZXREYXRhKCk7XG4gICAgY29uc3QgbmV3VmFsdWVzID0gbmV3Q29sb3JzLmdldERhdGEoKTtcbiAgICBjb25zdCBzaXplID0gdmFsdWVzLmxlbmd0aDtcbiAgICBjb25zdCBjb21wb25lbnQgPSAwO1xuICAgIGNvbnN0IHR1cGxlID0gMztcblxuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGNvbXBvbmVudDsgaSA8IHNpemU7IGkgKz0gdHVwbGUpIHtcbiAgICAgIG5ld1ZhbHVlc1tjb3VudCAqIDRdID0gY29udnRGdW4odmFsdWVzW2ldKTtcbiAgICAgIG5ld1ZhbHVlc1tjb3VudCAqIDQgKyAxXSA9IGNvbnZ0RnVuKHZhbHVlc1tpICsgMV0pO1xuICAgICAgbmV3VmFsdWVzW2NvdW50ICogNCArIDJdID0gY29udnRGdW4odmFsdWVzW2kgKyAyXSk7XG4gICAgICBuZXdWYWx1ZXNbY291bnQgKiA0ICsgM10gPSBhO1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLnJHQkFUb1JHQkEgPSAobmV3Q29sb3JzLCBjb2xvcnMsIGFscGhhLCBjb252dEZ1bikgPT4ge1xuICAgIGNvbnN0IHZhbHVlcyA9IGNvbG9ycy5nZXREYXRhKCk7XG4gICAgY29uc3QgbmV3VmFsdWVzID0gbmV3Q29sb3JzLmdldERhdGEoKTtcbiAgICBjb25zdCBzaXplID0gdmFsdWVzLmxlbmd0aDtcbiAgICBjb25zdCBjb21wb25lbnQgPSAwO1xuICAgIGNvbnN0IHR1cGxlID0gNDtcblxuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGNvbXBvbmVudDsgaSA8IHNpemU7IGkgKz0gdHVwbGUpIHtcbiAgICAgIG5ld1ZhbHVlc1tjb3VudCAqIDRdID0gY29udnRGdW4odmFsdWVzW2ldKTtcbiAgICAgIG5ld1ZhbHVlc1tjb3VudCAqIDQgKyAxXSA9IGNvbnZ0RnVuKHZhbHVlc1tpICsgMV0pO1xuICAgICAgbmV3VmFsdWVzW2NvdW50ICogNCArIDJdID0gY29udnRGdW4odmFsdWVzW2kgKyAyXSk7XG4gICAgICBuZXdWYWx1ZXNbY291bnQgKiA0ICsgM10gPSBjb252dEZ1bih2YWx1ZXNbaSArIDNdKSAqIGFscGhhO1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5jb252ZXJ0VG9SR0JBID0gKGNvbG9ycywgbnVtQ29tcCwgbnVtVHVwbGVzKSA9PiB7XG4gICAgbGV0IHsgYWxwaGEgfSA9IG1vZGVsO1xuICAgIGlmIChcbiAgICAgIG51bUNvbXAgPT09IDQgJiZcbiAgICAgIGFscGhhID49IDEuMCAmJlxuICAgICAgY29sb3JzLmdldERhdGFUeXBlKCkgPT09IFZ0a0RhdGFUeXBlcy5VTlNJR05FRF9DSEFSXG4gICAgKSB7XG4gICAgICByZXR1cm4gY29sb3JzO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0NvbG9ycyA9IHZ0a0RhdGFBcnJheS5uZXdJbnN0YW5jZSh7XG4gICAgICBudW1iZXJPZkNvbXBvbmVudHM6IDQsXG4gICAgICBlbXB0eTogdHJ1ZSxcbiAgICAgIHNpemU6IDQgKiBudW1UdXBsZXMsXG4gICAgICBkYXRhVHlwZTogVnRrRGF0YVR5cGVzLlVOU0lHTkVEX0NIQVIsXG4gICAgfSk7XG5cbiAgICBpZiAobnVtVHVwbGVzIDw9IDApIHtcbiAgICAgIHJldHVybiBuZXdDb2xvcnM7XG4gICAgfVxuXG4gICAgYWxwaGEgPSBhbHBoYSA+IDAgPyBhbHBoYSA6IDA7XG4gICAgYWxwaGEgPSBhbHBoYSA8IDEgPyBhbHBoYSA6IDE7XG5cbiAgICBsZXQgY29udnRGdW4gPSBpbnRDb2xvclRvVUNoYXI7XG4gICAgaWYgKFxuICAgICAgY29sb3JzLmdldERhdGFUeXBlKCkgPT09IFZ0a0RhdGFUeXBlcy5GTE9BVCB8fFxuICAgICAgY29sb3JzLmdldERhdGFUeXBlKCkgPT09IFZ0a0RhdGFUeXBlcy5ET1VCTEVcbiAgICApIHtcbiAgICAgIGNvbnZ0RnVuID0gZmxvYXRDb2xvclRvVUNoYXI7XG4gICAgfVxuXG4gICAgc3dpdGNoIChudW1Db21wKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHB1YmxpY0FQSS5sdW1pbmFuY2VUb1JHQkEobmV3Q29sb3JzLCBjb2xvcnMsIGFscGhhLCBjb252dEZ1bik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6XG4gICAgICAgIHB1YmxpY0FQSS5sdW1pbmFuY2VBbHBoYVRvUkdCQShuZXdDb2xvcnMsIGNvbG9ycywgY29udnRGdW4pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzOlxuICAgICAgICBwdWJsaWNBUEkuckdCVG9SR0JBKG5ld0NvbG9ycywgY29sb3JzLCBhbHBoYSwgY29udnRGdW4pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA0OlxuICAgICAgICBwdWJsaWNBUEkuckdCQVRvUkdCQShuZXdDb2xvcnMsIGNvbG9ycywgYWxwaGEsIGNvbnZ0RnVuKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZ0a0Vycm9yTWFjcm8oJ0Nhbm5vdCBjb252ZXJ0IGNvbG9ycycpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3Q29sb3JzO1xuICB9O1xuXG4gIHB1YmxpY0FQSS51c2luZ0xvZ1NjYWxlID0gKCkgPT4gZmFsc2U7XG5cbiAgcHVibGljQVBJLmdldE51bWJlck9mQXZhaWxhYmxlQ29sb3JzID0gKCkgPT4gMjU2ICogMjU2ICogMjU2O1xuXG4gIHB1YmxpY0FQSS5zZXRSYW5nZSA9IChtaW4sIG1heCkgPT4gcHVibGljQVBJLnNldE1hcHBpbmdSYW5nZShtaW4sIG1heCk7XG4gIHB1YmxpY0FQSS5nZXRSYW5nZSA9IChtaW4sIG1heCkgPT4gcHVibGljQVBJLmdldE1hcHBpbmdSYW5nZSgpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgYWxwaGE6IDEuMCxcbiAgdmVjdG9yQ29tcG9uZW50OiAwLFxuICB2ZWN0b3JTaXplOiAtMSxcbiAgdmVjdG9yTW9kZTogVmVjdG9yTW9kZS5DT01QT05FTlQsXG4gIG1hcHBpbmdSYW5nZTogbnVsbCxcbiAgYW5ub3RhdGlvbkFycmF5OiBudWxsLFxuICBhbm5vdGF0ZWRWYWx1ZU1hcDogbnVsbCxcbiAgaW5kZXhlZExvb2t1cDogZmFsc2UsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICBtYWNyby5vYmoocHVibGljQVBJLCBtb2RlbCk7XG5cbiAgbW9kZWwubWFwcGluZ1JhbmdlID0gWzAsIDI1NV07XG4gIG1vZGVsLmFubm90YXRpb25BcnJheSA9IFtdO1xuICBtb2RlbC5hbm5vdGF0ZWRWYWx1ZU1hcCA9IFtdO1xuXG4gIC8vIENyZWF0ZSBnZXQtc2V0IG1hY3Jvc1xuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgW1xuICAgICd2ZWN0b3JTaXplJyxcbiAgICAndmVjdG9yQ29tcG9uZW50JyxcbiAgICAndmVjdG9yTW9kZScsXG4gICAgJ2FscGhhJyxcbiAgICAnaW5kZXhlZExvb2t1cCcsXG4gIF0pO1xuXG4gIC8vIENyZWF0ZSBzZXQgbWFjcm9zIGZvciBhcnJheSAobmVlZHMgdG8ga25vdyBzaXplKVxuICBtYWNyby5zZXRBcnJheShwdWJsaWNBUEksIG1vZGVsLCBbJ21hcHBpbmdSYW5nZSddLCAyKTtcblxuICAvLyBDcmVhdGUgZ2V0IG1hY3JvcyBmb3IgYXJyYXlcbiAgbWFjcm8uZ2V0QXJyYXkocHVibGljQVBJLCBtb2RlbCwgWydtYXBwaW5nUmFuZ2UnXSk7XG5cbiAgLy8gRm9yIG1vcmUgbWFjcm8gbWV0aG9kcywgc2VlIFwiU291cmNlcy9tYWNyby5qc1wiXG5cbiAgLy8gT2JqZWN0IHNwZWNpZmljIG1ldGhvZHNcbiAgdnRrU2NhbGFyc1RvQ29sb3JzKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a1NjYWxhcnNUb0NvbG9ycycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCwgLi4uQ29uc3RhbnRzIH07XG4iLCJpbXBvcnQgKiBhcyB2dGtNYXRoIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL01hdGgnO1xuaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB2dGtQbGFuZSBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL1BsYW5lJztcblxuY29uc3QgSU5JVF9CT1VORFMgPSBbXG4gIE51bWJlci5NQVhfVkFMVUUsXG4gIC1OdW1iZXIuTUFYX1ZBTFVFLCAvLyBYXG4gIE51bWJlci5NQVhfVkFMVUUsXG4gIC1OdW1iZXIuTUFYX1ZBTFVFLCAvLyBZXG4gIE51bWJlci5NQVhfVkFMVUUsXG4gIC1OdW1iZXIuTUFYX1ZBTFVFLCAvLyBaXG5dO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBHbG9iYWwgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBpc1ZhbGlkKGJvdW5kcykge1xuICByZXR1cm4gKFxuICAgIGJvdW5kc1swXSA8PSBib3VuZHNbMV0gJiYgYm91bmRzWzJdIDw9IGJvdW5kc1szXSAmJiBib3VuZHNbNF0gPD0gYm91bmRzWzVdXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdldENlbnRlcihib3VuZHMpIHtcbiAgcmV0dXJuIFtcbiAgICAwLjUgKiAoYm91bmRzWzBdICsgYm91bmRzWzFdKSxcbiAgICAwLjUgKiAoYm91bmRzWzJdICsgYm91bmRzWzNdKSxcbiAgICAwLjUgKiAoYm91bmRzWzRdICsgYm91bmRzWzVdKSxcbiAgXTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoKGJvdW5kcywgaW5kZXgpIHtcbiAgcmV0dXJuIGJvdW5kc1tpbmRleCAqIDIgKyAxXSAtIGJvdW5kc1tpbmRleCAqIDJdO1xufVxuXG5mdW5jdGlvbiBnZXRMZW5ndGhzKGJvdW5kcykge1xuICByZXR1cm4gW2dldExlbmd0aChib3VuZHMsIDApLCBnZXRMZW5ndGgoYm91bmRzLCAxKSwgZ2V0TGVuZ3RoKGJvdW5kcywgMildO1xufVxuXG5mdW5jdGlvbiBnZXRYUmFuZ2UoYm91bmRzKSB7XG4gIHJldHVybiBib3VuZHMuc2xpY2UoMCwgMik7XG59XG5cbmZ1bmN0aW9uIGdldFlSYW5nZShib3VuZHMpIHtcbiAgcmV0dXJuIGJvdW5kcy5zbGljZSgyLCA0KTtcbn1cblxuZnVuY3Rpb24gZ2V0WlJhbmdlKGJvdW5kcykge1xuICByZXR1cm4gYm91bmRzLnNsaWNlKDQsIDYpO1xufVxuXG5mdW5jdGlvbiBnZXRNYXhMZW5ndGgoYm91bmRzKSB7XG4gIGNvbnN0IGwgPSBnZXRMZW5ndGhzKGJvdW5kcyk7XG4gIGlmIChsWzBdID4gbFsxXSkge1xuICAgIGlmIChsWzBdID4gbFsyXSkge1xuICAgICAgcmV0dXJuIGxbMF07XG4gICAgfVxuICAgIHJldHVybiBsWzJdO1xuICB9XG5cbiAgaWYgKGxbMV0gPiBsWzJdKSB7XG4gICAgcmV0dXJuIGxbMV07XG4gIH1cblxuICByZXR1cm4gbFsyXTtcbn1cblxuZnVuY3Rpb24gZ2V0RGlhZ29uYWxMZW5ndGgoYm91bmRzKSB7XG4gIGlmIChpc1ZhbGlkKGJvdW5kcykpIHtcbiAgICBjb25zdCBsID0gZ2V0TGVuZ3Rocyhib3VuZHMpO1xuICAgIHJldHVybiBNYXRoLnNxcnQobFswXSAqIGxbMF0gKyBsWzFdICogbFsxXSArIGxbMl0gKiBsWzJdKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gb3Bwb3NpdGVTaWduKGEsIGIpIHtcbiAgcmV0dXJuIChhIDw9IDAgJiYgYiA+PSAwKSB8fCAoYSA+PSAwICYmIGIgPD0gMCk7XG59XG5cbmZ1bmN0aW9uIGdldENvcm5lcnMoYm91bmRzLCBjb3JuZXJzKSB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAobGV0IGl4ID0gMDsgaXggPCAyOyBpeCsrKSB7XG4gICAgZm9yIChsZXQgaXkgPSAyOyBpeSA8IDQ7IGl5KyspIHtcbiAgICAgIGZvciAobGV0IGl6ID0gNDsgaXogPCA2OyBpeisrKSB7XG4gICAgICAgIGNvcm5lcnNbY291bnRdID0gW2JvdW5kc1tpeF0sIGJvdW5kc1tpeV0sIGJvdW5kc1tpel1dO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBDb21wdXRlcyB0aGUgdHdvIGNvcm5lcnMgd2l0aCBtaW5pbWFsIGFuZCBtaXhpbWFsIGNvb3JkaW5hdGVzXG5mdW5jdGlvbiBjb21wdXRlQ29ybmVyUG9pbnRzKHBvaW50MSwgcG9pbnQyLCBib3VuZHMpIHtcbiAgcG9pbnQxWzBdID0gYm91bmRzWzBdO1xuICBwb2ludDFbMV0gPSBib3VuZHNbMl07XG4gIHBvaW50MVsyXSA9IGJvdW5kc1s0XTtcblxuICBwb2ludDJbMF0gPSBib3VuZHNbMV07XG4gIHBvaW50MlsxXSA9IGJvdW5kc1szXTtcbiAgcG9pbnQyWzJdID0gYm91bmRzWzVdO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU2NhbGUzKGJvdW5kcywgc2NhbGUzID0gW10pIHtcbiAgY29uc3QgY2VudGVyID0gZ2V0Q2VudGVyKGJvdW5kcyk7XG4gIHNjYWxlM1swXSA9IGJvdW5kc1sxXSAtIGNlbnRlclswXTtcbiAgc2NhbGUzWzFdID0gYm91bmRzWzNdIC0gY2VudGVyWzFdO1xuICBzY2FsZTNbMl0gPSBib3VuZHNbNV0gLSBjZW50ZXJbMl07XG5cbiAgcmV0dXJuIHNjYWxlMztcbn1cblxuLyoqXG4gKiBDb21wdXRlIGxvY2FsIGJvdW5kcy5cbiAqIE5vdCBhcyBmYXN0IGFzIHZ0a1BvaW50cy5nZXRCb3VuZHMoKSBpZiB1LCB2LCB3IGZvcm0gYSBuYXR1cmFsIGJhc2lzLlxuICogQHBhcmFtIHt2dGtQb2ludHN9IHBvaW50c1xuICogQHBhcmFtIHthcnJheX0gdSBmaXJzdCB2ZWN0b3JcbiAqIEBwYXJhbSB7YXJyYXl9IHYgc2Vjb25kIHZlY3RvclxuICogQHBhcmFtIHthcnJheX0gdyB0aGlyZCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUxvY2FsQm91bmRzKHBvaW50cywgdSwgdiwgdykge1xuICBjb25zdCBib3VuZHMgPSBbXS5jb25jYXQoSU5JVF9CT1VORFMpO1xuICBjb25zdCBwb2ludHNEYXRhID0gcG9pbnRzLmdldERhdGEoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNEYXRhLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY29uc3QgcG9pbnQgPSBbcG9pbnRzRGF0YVtpXSwgcG9pbnRzRGF0YVtpICsgMV0sIHBvaW50c0RhdGFbaSArIDJdXTtcbiAgICBjb25zdCBkdSA9IHZ0a01hdGguZG90KHBvaW50LCB1KTtcbiAgICBib3VuZHNbMF0gPSBNYXRoLm1pbihkdSwgYm91bmRzWzBdKTtcbiAgICBib3VuZHNbMV0gPSBNYXRoLm1heChkdSwgYm91bmRzWzFdKTtcbiAgICBjb25zdCBkdiA9IHZ0a01hdGguZG90KHBvaW50LCB2KTtcbiAgICBib3VuZHNbMl0gPSBNYXRoLm1pbihkdiwgYm91bmRzWzJdKTtcbiAgICBib3VuZHNbM10gPSBNYXRoLm1heChkdiwgYm91bmRzWzNdKTtcbiAgICBjb25zdCBkdyA9IHZ0a01hdGguZG90KHBvaW50LCB3KTtcbiAgICBib3VuZHNbNF0gPSBNYXRoLm1pbihkdywgYm91bmRzWzRdKTtcbiAgICBib3VuZHNbNV0gPSBNYXRoLm1heChkdywgYm91bmRzWzVdKTtcbiAgfVxuICByZXR1cm4gYm91bmRzO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTdGF0aWMgQVBJXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBTVEFUSUMgPSB7XG4gIGlzVmFsaWQsXG4gIGdldENlbnRlcixcbiAgZ2V0TGVuZ3RoLFxuICBnZXRMZW5ndGhzLFxuICBnZXRNYXhMZW5ndGgsXG4gIGdldERpYWdvbmFsTGVuZ3RoLFxuICBnZXRYUmFuZ2UsXG4gIGdldFlSYW5nZSxcbiAgZ2V0WlJhbmdlLFxuICBnZXRDb3JuZXJzLFxuICBjb21wdXRlQ29ybmVyUG9pbnRzLFxuICBjb21wdXRlTG9jYWxCb3VuZHMsXG4gIGNvbXB1dGVTY2FsZTMsXG4gIElOSVRfQk9VTkRTLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrQm91bmRpbmdCb3ggbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtCb3VuZGluZ0JveChwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a0JvdW5kaW5nQm94Jyk7XG5cbiAgcHVibGljQVBJLmNsb25lID0gKCkgPT4ge1xuICAgIGNvbnN0IGJvdW5kcyA9IFtdLmNvbmNhdChtb2RlbC5ib3VuZHMpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG4gICAgcmV0dXJuIG5ld0luc3RhbmNlKHsgYm91bmRzIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbiAgfTtcblxuICBwdWJsaWNBUEkuZXF1YWxzID0gKG90aGVyKSA9PiB7XG4gICAgY29uc3QgYSA9IG1vZGVsLmJvdW5kcztcbiAgICBjb25zdCBiID0gb3RoZXIuZ2V0Qm91bmRzKCk7XG4gICAgcmV0dXJuIChcbiAgICAgIGFbMF0gPT09IGJbMF0gJiZcbiAgICAgIGFbMV0gPT09IGJbMV0gJiZcbiAgICAgIGFbMl0gPT09IGJbMl0gJiZcbiAgICAgIGFbM10gPT09IGJbM10gJiZcbiAgICAgIGFbNF0gPT09IGJbNF0gJiZcbiAgICAgIGFbNV0gPT09IGJbNV1cbiAgICApO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRNaW5Qb2ludCA9ICh4LCB5LCB6KSA9PiB7XG4gICAgY29uc3QgW3hNaW4sIHhNYXgsIHlNaW4sIHlNYXgsIHpNaW4sIHpNYXhdID0gbW9kZWwuYm91bmRzO1xuICAgIG1vZGVsLmJvdW5kcyA9IFtcbiAgICAgIHgsXG4gICAgICB4ID4geE1heCA/IHggOiB4TWF4LFxuICAgICAgeSxcbiAgICAgIHkgPiB5TWF4ID8geSA6IHlNYXgsXG4gICAgICB6LFxuICAgICAgeiA+IHpNYXggPyB6IDogek1heCxcbiAgICBdO1xuXG4gICAgcmV0dXJuIHhNaW4gIT09IHggfHwgeU1pbiAhPT0geSB8fCB6TWluICE9PSB6O1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRNYXhQb2ludCA9ICh4LCB5LCB6KSA9PiB7XG4gICAgY29uc3QgW3hNaW4sIHhNYXgsIHlNaW4sIHlNYXgsIHpNaW4sIHpNYXhdID0gbW9kZWwuYm91bmRzO1xuICAgIG1vZGVsLmJvdW5kcyA9IFtcbiAgICAgIHggPCB4TWluID8geCA6IHhNaW4sXG4gICAgICB4LFxuICAgICAgeSA8IHlNaW4gPyB5IDogeU1pbixcbiAgICAgIHksXG4gICAgICB6IDwgek1pbiA/IHogOiB6TWluLFxuICAgICAgeixcbiAgICBdO1xuXG4gICAgcmV0dXJuIHhNYXggIT09IHggfHwgeU1heCAhPT0geSB8fCB6TWF4ICE9PSB6O1xuICB9O1xuXG4gIHB1YmxpY0FQSS5hZGRQb2ludCA9ICguLi54eXopID0+IHtcbiAgICBtb2RlbC5ib3VuZHMgPSBtb2RlbC5ib3VuZHMubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgY29uc3QgaWR4ID0gaW5kZXggLyAyO1xuICAgICAgICByZXR1cm4gdmFsdWUgPCB4eXpbaWR4XSA/IHZhbHVlIDogeHl6W2lkeF07XG4gICAgICB9XG4gICAgICBjb25zdCBpZHggPSAoaW5kZXggLSAxKSAvIDI7XG4gICAgICByZXR1cm4gdmFsdWUgPiB4eXpbaWR4XSA/IHZhbHVlIDogeHl6W2lkeF07XG4gICAgfSk7XG4gIH07XG5cbiAgcHVibGljQVBJLmFkZEJvdW5kcyA9ICh4TWluLCB4TWF4LCB5TWluLCB5TWF4LCB6TWluLCB6TWF4KSA9PiB7XG4gICAgY29uc3QgW194TWluLCBfeE1heCwgX3lNaW4sIF95TWF4LCBfek1pbiwgX3pNYXhdID0gbW9kZWwuYm91bmRzO1xuICAgIGlmICh6TWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG1vZGVsLmJvdW5kcyA9IFtcbiAgICAgICAgTWF0aC5taW4oeE1pblswXSwgX3hNaW4pLFxuICAgICAgICBNYXRoLm1heCh4TWluWzFdLCBfeE1heCksXG4gICAgICAgIE1hdGgubWluKHhNaW5bMl0sIF95TWluKSxcbiAgICAgICAgTWF0aC5tYXgoeE1pblszXSwgX3lNYXgpLFxuICAgICAgICBNYXRoLm1pbih4TWluWzRdLCBfek1pbiksXG4gICAgICAgIE1hdGgubWF4KHhNaW5bNV0sIF96TWF4KSxcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsLmJvdW5kcyA9IFtcbiAgICAgICAgTWF0aC5taW4oeE1pbiwgX3hNaW4pLFxuICAgICAgICBNYXRoLm1heCh4TWF4LCBfeE1heCksXG4gICAgICAgIE1hdGgubWluKHlNaW4sIF95TWluKSxcbiAgICAgICAgTWF0aC5tYXgoeU1heCwgX3lNYXgpLFxuICAgICAgICBNYXRoLm1pbih6TWluLCBfek1pbiksXG4gICAgICAgIE1hdGgubWF4KHpNYXgsIF96TWF4KSxcbiAgICAgIF07XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5hZGRCb3ggPSAob3RoZXIpID0+IHtcbiAgICBwdWJsaWNBUEkuYWRkQm91bmRzKG90aGVyLmdldEJvdW5kcygpKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuaXNWYWxpZCA9ICgpID0+IGlzVmFsaWQobW9kZWwuYm91bmRzKTtcblxuICBwdWJsaWNBUEkuaW50ZXJzZWN0ID0gKGJib3gpID0+IHtcbiAgICBpZiAoIShwdWJsaWNBUEkuaXNWYWxpZCgpICYmIGJib3guaXNWYWxpZCgpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IG5ld0JvdW5kcyA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbiAgICBjb25zdCBiQm91bmRzID0gYmJveC5nZXRCb3VuZHMoKTtcbiAgICBsZXQgaW50ZXJzZWN0cztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgaW50ZXJzZWN0cyA9IGZhbHNlO1xuICAgICAgaWYgKFxuICAgICAgICBiQm91bmRzW2kgKiAyXSA+PSBtb2RlbC5ib3VuZHNbaSAqIDJdICYmXG4gICAgICAgIGJCb3VuZHNbaSAqIDJdIDw9IG1vZGVsLmJvdW5kc1tpICogMiArIDFdXG4gICAgICApIHtcbiAgICAgICAgaW50ZXJzZWN0cyA9IHRydWU7XG4gICAgICAgIG5ld0JvdW5kc1tpICogMl0gPSBiQm91bmRzW2kgKiAyXTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIG1vZGVsLmJvdW5kc1tpICogMl0gPj0gYkJvdW5kc1tpICogMl0gJiZcbiAgICAgICAgbW9kZWwuYm91bmRzW2kgKiAyXSA8PSBiQm91bmRzW2kgKiAyICsgMV1cbiAgICAgICkge1xuICAgICAgICBpbnRlcnNlY3RzID0gdHJ1ZTtcbiAgICAgICAgbmV3Qm91bmRzW2kgKiAyXSA9IG1vZGVsLmJvdW5kc1tpICogMl07XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgICAgYkJvdW5kc1tpICogMiArIDFdID49IG1vZGVsLmJvdW5kc1tpICogMl0gJiZcbiAgICAgICAgYkJvdW5kc1tpICogMiArIDFdIDw9IG1vZGVsLmJvdW5kc1tpICogMiArIDFdXG4gICAgICApIHtcbiAgICAgICAgaW50ZXJzZWN0cyA9IHRydWU7XG4gICAgICAgIG5ld0JvdW5kc1tpICogMiArIDFdID0gYmJveC5NYXhQbnRbaV07XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBtb2RlbC5ib3VuZHNbaSAqIDIgKyAxXSA+PSBiYm94Lk1pblBudFtpICogMl0gJiZcbiAgICAgICAgbW9kZWwuYm91bmRzW2kgKiAyICsgMV0gPD0gYmJveC5NYXhQbnRbaSAqIDIgKyAxXVxuICAgICAgKSB7XG4gICAgICAgIGludGVyc2VjdHMgPSB0cnVlO1xuICAgICAgICBuZXdCb3VuZHNbaSAqIDIgKyAxXSA9IG1vZGVsLmJvdW5kc1tpICogMiArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWludGVyc2VjdHMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE9LIHRoZXkgZGlkIGludGVyc2VjdCAtIHNldCB0aGUgYm94IHRvIGJlIHRoZSByZXN1bHRcbiAgICBtb2RlbC5ib3VuZHMgPSBuZXdCb3VuZHM7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLmludGVyc2VjdHMgPSAoYmJveCkgPT4ge1xuICAgIGlmICghKHB1YmxpY0FQSS5pc1ZhbGlkKCkgJiYgYmJveC5pc1ZhbGlkKCkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGJCb3VuZHMgPSBiYm94LmdldEJvdW5kcygpO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnRpbnVlICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgYkJvdW5kc1tpICogMl0gPj0gbW9kZWwuYm91bmRzW2kgKiAyXSAmJlxuICAgICAgICBiQm91bmRzW2kgKiAyXSA8PSBtb2RlbC5ib3VuZHNbaSAqIDIgKyAxXVxuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgbW9kZWwuYm91bmRzW2kgKiAyXSA+PSBiQm91bmRzW2kgKiAyXSAmJlxuICAgICAgICBtb2RlbC5ib3VuZHNbaSAqIDJdIDw9IGJCb3VuZHNbaSAqIDIgKyAxXVxuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIGJCb3VuZHNbaSAqIDIgKyAxXSA+PSBtb2RlbC5ib3VuZHNbaSAqIDJdICYmXG4gICAgICAgIGJCb3VuZHNbaSAqIDIgKyAxXSA8PSBtb2RlbC5ib3VuZHNbaSAqIDIgKyAxXVxuICAgICAgKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgbW9kZWwuYm91bmRzW2kgKiAyICsgMV0gPj0gYmJveC5NaW5QbnRbaSAqIDJdICYmXG4gICAgICAgIG1vZGVsLmJvdW5kc1tpICogMiArIDFdIDw9IGJib3guTWF4UG50W2kgKiAyICsgMV1cbiAgICAgICkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb250aW51ZSAqL1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBwbGFuZSBpbnRlcnNlY3RzIGJvdW5kaW5nIGJveC5cbiAgICogSWYgc28sIHRoZSBib3ggaXMgY3V0IGJ5IHRoZSBwbGFuZVxuICAgKiBAcGFyYW0ge2FycmF5fSBvcmlnaW5cbiAgICogQHBhcmFtIHthcnJheX0gbm9ybWFsXG4gICAqL1xuICBwdWJsaWNBUEkuaW50ZXJzZWN0UGxhbmUgPSAob3JpZ2luLCBub3JtYWwpID0+IHtcbiAgICAvLyBJbmRleFswLi4yXSByZXByZXNlbnRzIHRoZSBvcmRlciBvZiB0cmF2ZXJzaW5nIHRoZSBjb3JuZXJzIG9mIGEgY3ViZVxuICAgIC8vIGluICh4LHkseiksICh5LHgseikgYW5kICh6LHgseSkgb3JkZXJpbmcsIHJlc3BlY3RpdmVseVxuICAgIGNvbnN0IGluZGV4ID0gW1xuICAgICAgWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDddLFxuICAgICAgWzAsIDEsIDQsIDUsIDIsIDMsIDYsIDddLFxuICAgICAgWzAsIDIsIDQsIDYsIDEsIDMsIDUsIDddLFxuICAgIF07XG5cbiAgICAvLyBzdG9yZXMgdGhlIHNpZ25lZCBkaXN0YW5jZSB0byBhIHBsYW5lXG4gICAgY29uc3QgZCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwXTtcbiAgICBsZXQgaWR4ID0gMDtcbiAgICBmb3IgKGxldCBpeCA9IDA7IGl4IDwgMjsgaXgrKykge1xuICAgICAgZm9yIChsZXQgaXkgPSAyOyBpeSA8IDQ7IGl5KyspIHtcbiAgICAgICAgZm9yIChsZXQgaXogPSA0OyBpeiA8IDY7IGl6KyspIHtcbiAgICAgICAgICBjb25zdCB4ID0gW21vZGVsLmJvdW5kc1tpeF0sIG1vZGVsLmJvdW5kc1tpeV0sIG1vZGVsLmJvdW5kc1tpel1dO1xuICAgICAgICAgIGRbaWR4KytdID0gdnRrUGxhbmUuZXZhbHVhdGUobm9ybWFsLCBvcmlnaW4sIHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGRpciA9IDI7XG4gICAgd2hpbGUgKGRpci0tKSB7XG4gICAgICAvLyBpbiBlYWNoIGRpcmVjdGlvbiwgd2UgdGVzdCBpZiB0aGUgdmVydGljZXMgb2YgdHdvIG9ydGhvZ29uYWwgZmFjZXNcbiAgICAgIC8vIGFyZSBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgcGxhbmVcbiAgICAgIGlmIChcbiAgICAgICAgb3Bwb3NpdGVTaWduKGRbaW5kZXhbZGlyXVswXV0sIGRbaW5kZXhbZGlyXVs0XV0pICYmXG4gICAgICAgIG9wcG9zaXRlU2lnbihkW2luZGV4W2Rpcl1bMV1dLCBkW2luZGV4W2Rpcl1bNV1dKSAmJlxuICAgICAgICBvcHBvc2l0ZVNpZ24oZFtpbmRleFtkaXJdWzJdXSwgZFtpbmRleFtkaXJdWzZdXSkgJiZcbiAgICAgICAgb3Bwb3NpdGVTaWduKGRbaW5kZXhbZGlyXVszXV0sIGRbaW5kZXhbZGlyXVs3XV0pXG4gICAgICApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpciA8IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBzaWduID0gTWF0aC5zaWduKG5vcm1hbFtkaXJdKTtcbiAgICBjb25zdCBzaXplID0gTWF0aC5hYnMoXG4gICAgICAobW9kZWwuYm91bmRzW2RpciAqIDIgKyAxXSAtIG1vZGVsLmJvdW5kc1tkaXIgKiAyXSkgKiBub3JtYWxbZGlyXVxuICAgICk7XG4gICAgbGV0IHQgPSBzaWduID4gMCA/IDEgOiAwO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnRpbnVlICovXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIGlmIChzaXplID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBzaG91bGRuJ3QgaGFwcGVuXG4gICAgICB9XG4gICAgICBjb25zdCB0aSA9IE1hdGguYWJzKGRbaW5kZXhbZGlyXVtpXV0pIC8gc2l6ZTtcbiAgICAgIGlmIChzaWduID4gMCAmJiB0aSA8IHQpIHtcbiAgICAgICAgdCA9IHRpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2lnbiA8IDAgJiYgdGkgPiB0KSB7XG4gICAgICAgIHQgPSB0aTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1jb250aW51ZSAqL1xuICAgIGNvbnN0IGJvdW5kID1cbiAgICAgICgxLjAgLSB0KSAqIG1vZGVsLmJvdW5kc1tkaXIgKiAyXSArIHQgKiBtb2RlbC5ib3VuZHNbZGlyICogMiArIDFdO1xuXG4gICAgaWYgKHNpZ24gPiAwKSB7XG4gICAgICBtb2RlbC5ib3VuZHNbZGlyICogMl0gPSBib3VuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWwuYm91bmRzW2RpciAqIDIgKyAxXSA9IGJvdW5kO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5jb250YWluc1BvaW50ID0gKHgsIHksIHopID0+IHtcbiAgICBpZiAoeCA8IG1vZGVsLmJvdW5kc1swXSB8fCB4ID4gbW9kZWwuYm91bmRzWzFdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHkgPCBtb2RlbC5ib3VuZHNbMl0gfHwgeSA+IG1vZGVsLmJvdW5kc1szXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh6IDwgbW9kZWwuYm91bmRzWzRdIHx8IHogPiBtb2RlbC5ib3VuZHNbNV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0TWluUG9pbnQgPSAoKSA9PiBbXG4gICAgbW9kZWwuYm91bmRzWzBdLFxuICAgIG1vZGVsLmJvdW5kc1syXSxcbiAgICBtb2RlbC5ib3VuZHNbNF0sXG4gIF07XG4gIHB1YmxpY0FQSS5nZXRNYXhQb2ludCA9ICgpID0+IFtcbiAgICBtb2RlbC5ib3VuZHNbMV0sXG4gICAgbW9kZWwuYm91bmRzWzNdLFxuICAgIG1vZGVsLmJvdW5kc1s1XSxcbiAgXTtcbiAgcHVibGljQVBJLmdldEJvdW5kID0gKGluZGV4KSA9PiBtb2RlbC5ib3VuZFtpbmRleF07XG5cbiAgcHVibGljQVBJLmNvbnRhaW5zID0gKGJib3gpID0+IHtcbiAgICAvLyBpZiBlaXRoZXIgYm94IGlzIG5vdCB2YWxpZCBvciB0aGV5IGRvbid0IGludGVyc2VjdFxuICAgIGlmICghcHVibGljQVBJLmludGVyc2VjdHMoYmJveCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXB1YmxpY0FQSS5jb250YWluc1BvaW50KC4uLmJib3guZ2V0TWluUG9pbnQoKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXB1YmxpY0FQSS5jb250YWluc1BvaW50KC4uLmJib3guZ2V0TWF4UG9pbnQoKSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRDZW50ZXIgPSAoKSA9PiBnZXRDZW50ZXIobW9kZWwuYm91bmRzKTtcbiAgcHVibGljQVBJLmdldExlbmd0aCA9IChpbmRleCkgPT4gZ2V0TGVuZ3RoKG1vZGVsLmJvdW5kcywgaW5kZXgpO1xuICBwdWJsaWNBUEkuZ2V0TGVuZ3RocyA9ICgpID0+IGdldExlbmd0aHMobW9kZWwuYm91bmRzKTtcbiAgcHVibGljQVBJLmdldE1heExlbmd0aCA9ICgpID0+IGdldE1heExlbmd0aChtb2RlbC5ib3VuZHMpO1xuICBwdWJsaWNBUEkuZ2V0RGlhZ29uYWxMZW5ndGggPSAoKSA9PiBnZXREaWFnb25hbExlbmd0aChtb2RlbC5ib3VuZHMpO1xuXG4gIHB1YmxpY0FQSS5yZXNldCA9ICgpID0+IHB1YmxpY0FQSS5zZXRCb3VuZHMoW10uY29uY2F0KElOSVRfQk9VTkRTKSk7XG5cbiAgcHVibGljQVBJLmluZmxhdGUgPSAoZGVsdGEpID0+IHtcbiAgICBtb2RlbC5ib3VuZHMgPSBtb2RlbC5ib3VuZHMubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpbmRleCAlIDIgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlIC0gZGVsdGE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUgKyBkZWx0YTtcbiAgICB9KTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0Q29ybmVycyA9ICgpID0+IHtcbiAgICBnZXRDb3JuZXJzKG1vZGVsLmJvdW5kcywgbW9kZWwuY29ybmVycyk7XG4gICAgcmV0dXJuIG1vZGVsLmNvcm5lcnM7XG4gIH07XG5cbiAgcHVibGljQVBJLnNjYWxlID0gKHN4LCBzeSwgc3opID0+IHtcbiAgICBpZiAocHVibGljQVBJLmlzVmFsaWQoKSkge1xuICAgICAgY29uc3QgbmV3Qm91bmRzID0gW10uY29uY2F0KG1vZGVsLmJvdW5kcyk7XG4gICAgICBpZiAoc3ggPj0gMC4wKSB7XG4gICAgICAgIG5ld0JvdW5kc1swXSAqPSBzeDtcbiAgICAgICAgbmV3Qm91bmRzWzFdICo9IHN4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3Qm91bmRzWzBdID0gc3ggKiBtb2RlbC5ib3VuZHNbMV07XG4gICAgICAgIG5ld0JvdW5kc1sxXSA9IHN4ICogbW9kZWwuYm91bmRzWzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3kgPj0gMC4wKSB7XG4gICAgICAgIG5ld0JvdW5kc1syXSAqPSBzeTtcbiAgICAgICAgbmV3Qm91bmRzWzNdICo9IHN5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3Qm91bmRzWzJdID0gc3kgKiBtb2RlbC5ib3VuZHNbM107XG4gICAgICAgIG5ld0JvdW5kc1szXSA9IHN5ICogbW9kZWwuYm91bmRzWzJdO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3ogPj0gMC4wKSB7XG4gICAgICAgIG5ld0JvdW5kc1s0XSAqPSBzejtcbiAgICAgICAgbmV3Qm91bmRzWzVdICo9IHN6O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV3Qm91bmRzWzRdID0gc3ogKiBtb2RlbC5ib3VuZHNbNV07XG4gICAgICAgIG5ld0JvdW5kc1s1XSA9IHN6ICogbW9kZWwuYm91bmRzWzRdO1xuICAgICAgfVxuXG4gICAgICBtb2RlbC5ib3VuZHMgPSBuZXdCb3VuZHM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgdHlwZTogJ3Z0a0JvdW5kaW5nQm94JyxcbiAgYm91bmRzOiBbXS5jb25jYXQoSU5JVF9CT1VORFMpLFxuICBjb3JuZXJzOiBbXSxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIG1hY3JvLm9iaihwdWJsaWNBUEksIG1vZGVsKTtcbiAgbWFjcm8uc2V0R2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsnYm91bmRzJ10pO1xuICB2dGtCb3VuZGluZ0JveChwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQsICd2dGtCb3VuZGluZ0JveCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCwgLi4uU1RBVElDIH07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0ICogYXMgdnRrTWF0aCBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9NYXRoJztcbmltcG9ydCB2dGtQb2ludHMgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvUG9pbnRzJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrQ2VsbCBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a0NlbGwocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtDZWxsJyk7XG5cbiAgcHVibGljQVBJLmluaXRpYWxpemUgPSAocG9pbnRzLCBwb2ludElkc0xpc3QgPSBudWxsKSA9PiB7XG4gICAgaWYgKCFwb2ludElkc0xpc3QpIHtcbiAgICAgIG1vZGVsLnBvaW50cyA9IHBvaW50cztcbiAgICAgIG1vZGVsLnBvaW50c0lkcyA9IG5ldyBBcnJheShwb2ludHMuZ2V0TnVtYmVyT2ZQb2ludHMoKSk7XG4gICAgICBmb3IgKGxldCBpID0gcG9pbnRzLmdldE51bWJlck9mUG9pbnRzKCkgLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBtb2RlbC5wb2ludHNJZHNbaV0gPSBpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbC5wb2ludHNJZHMgPSBwb2ludElkc0xpc3Q7XG4gICAgICBsZXQgdHJpYW5nbGVEYXRhID0gbW9kZWwucG9pbnRzLmdldERhdGEoKTtcbiAgICAgIGlmICh0cmlhbmdsZURhdGEubGVuZ3RoICE9PSAzICogbW9kZWwucG9pbnRzSWRzLmxlbmd0aCkge1xuICAgICAgICB0cmlhbmdsZURhdGEgPSBuZXcgd2luZG93W3BvaW50cy5nZXREYXRhVHlwZSgpXShcbiAgICAgICAgICAzICogbW9kZWwucG9pbnRzSWRzLmxlbmd0aFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9pbnRzRGF0YSA9IHBvaW50cy5nZXREYXRhKCk7XG4gICAgICBtb2RlbC5wb2ludHNJZHMuZm9yRWFjaCgocG9pbnRJZCwgaW5kZXgpID0+IHtcbiAgICAgICAgLy8gY29uc3Qgc3RhcnQgPSAzICogcG9pbnRJZDtcbiAgICAgICAgLy8gcG9pbnRzRGF0YS5zZXQocC5zdWJhcnJheShzdGFydCwgc3RhcnQgKyAzKSwgMyAqIGluZGV4KTtcbiAgICAgICAgbGV0IHBvaW50T2Zmc2V0ID0gMyAqIHBvaW50SWQ7XG4gICAgICAgIGxldCB0cmlhbmdsZVBvaW50T2Zmc2V0ID0gMyAqIGluZGV4O1xuICAgICAgICB0cmlhbmdsZURhdGFbdHJpYW5nbGVQb2ludE9mZnNldF0gPSBwb2ludHNEYXRhW3BvaW50T2Zmc2V0XTtcbiAgICAgICAgdHJpYW5nbGVEYXRhWysrdHJpYW5nbGVQb2ludE9mZnNldF0gPSBwb2ludHNEYXRhWysrcG9pbnRPZmZzZXRdO1xuICAgICAgICB0cmlhbmdsZURhdGFbKyt0cmlhbmdsZVBvaW50T2Zmc2V0XSA9IHBvaW50c0RhdGFbKytwb2ludE9mZnNldF07XG4gICAgICB9KTtcbiAgICAgIG1vZGVsLnBvaW50cy5zZXREYXRhKHRyaWFuZ2xlRGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRCb3VuZHMgPSAoKSA9PiB7XG4gICAgY29uc3QgbmJQb2ludHMgPSBtb2RlbC5wb2ludHMuZ2V0TnVtYmVyT2ZQb2ludHMoKTtcbiAgICBjb25zdCB4ID0gW107XG4gICAgaWYgKG5iUG9pbnRzKSB7XG4gICAgICBtb2RlbC5wb2ludHMuZ2V0UG9pbnQoMCwgeCk7XG4gICAgICBtb2RlbC5ib3VuZHNbMF0gPSB4WzBdO1xuICAgICAgbW9kZWwuYm91bmRzWzFdID0geFswXTtcbiAgICAgIG1vZGVsLmJvdW5kc1syXSA9IHhbMV07XG4gICAgICBtb2RlbC5ib3VuZHNbM10gPSB4WzFdO1xuICAgICAgbW9kZWwuYm91bmRzWzRdID0geFsyXTtcbiAgICAgIG1vZGVsLmJvdW5kc1s1XSA9IHhbMl07XG5cbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbmJQb2ludHM7IGkrKykge1xuICAgICAgICBtb2RlbC5wb2ludHMuZ2V0UG9pbnQoaSwgeCk7XG4gICAgICAgIG1vZGVsLmJvdW5kc1swXSA9IHhbMF0gPCBtb2RlbC5ib3VuZHNbMF0gPyB4WzBdIDogbW9kZWwuYm91bmRzWzBdO1xuICAgICAgICBtb2RlbC5ib3VuZHNbMV0gPSB4WzBdID4gbW9kZWwuYm91bmRzWzFdID8geFswXSA6IG1vZGVsLmJvdW5kc1sxXTtcbiAgICAgICAgbW9kZWwuYm91bmRzWzJdID0geFsxXSA8IG1vZGVsLmJvdW5kc1syXSA/IHhbMV0gOiBtb2RlbC5ib3VuZHNbMl07XG4gICAgICAgIG1vZGVsLmJvdW5kc1szXSA9IHhbMV0gPiBtb2RlbC5ib3VuZHNbM10gPyB4WzFdIDogbW9kZWwuYm91bmRzWzNdO1xuICAgICAgICBtb2RlbC5ib3VuZHNbNF0gPSB4WzJdIDwgbW9kZWwuYm91bmRzWzRdID8geFsyXSA6IG1vZGVsLmJvdW5kc1s0XTtcbiAgICAgICAgbW9kZWwuYm91bmRzWzVdID0geFsyXSA+IG1vZGVsLmJvdW5kc1s1XSA/IHhbMl0gOiBtb2RlbC5ib3VuZHNbNV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZ0a01hdGgudW5pbml0aWFsaXplQm91bmRzKG1vZGVsLmJvdW5kcyk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbC5ib3VuZHM7XG4gIH07XG5cbiAgcHVibGljQVBJLmdldExlbmd0aDIgPSAoKSA9PiB7XG4gICAgcHVibGljQVBJLmdldEJvdW5kcygpO1xuICAgIGxldCBsZW5ndGggPSAwLjA7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBkaWZmID0gbW9kZWwuYm91bmRzWzIgKiBpICsgMV0gLSBtb2RlbC5ib3VuZHNbMiAqIGldO1xuICAgICAgbGVuZ3RoICs9IGRpZmYgKiBkaWZmO1xuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRQYXJhbWV0cmljRGlzdGFuY2UgPSAocGNvb3JkcykgPT4ge1xuICAgIGxldCBwRGlzdDtcbiAgICBsZXQgcERpc3RNYXggPSAwLjA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgaWYgKHBjb29yZHNbaV0gPCAwLjApIHtcbiAgICAgICAgcERpc3QgPSAtcGNvb3Jkc1tpXTtcbiAgICAgIH0gZWxzZSBpZiAocGNvb3Jkc1tpXSA+IDEuMCkge1xuICAgICAgICBwRGlzdCA9IHBjb29yZHNbaV0gLSAxLjA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbnNpZGUgdGhlIGNlbGwgaW4gdGhlIHBhcmFtZXRyaWMgZGlyZWN0aW9uXG4gICAgICAgIHBEaXN0ID0gMC4wO1xuICAgICAgfVxuICAgICAgaWYgKHBEaXN0ID4gcERpc3RNYXgpIHtcbiAgICAgICAgcERpc3RNYXggPSBwRGlzdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBEaXN0TWF4O1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXROdW1iZXJPZlBvaW50cyA9ICgpID0+IG1vZGVsLnBvaW50cy5nZXROdW1iZXJPZlBvaW50cygpO1xuXG4gIHB1YmxpY0FQSS5kZWVwQ29weSA9IChjZWxsKSA9PiB7XG4gICAgY2VsbC5pbml0aWFsaXplKG1vZGVsLnBvaW50cywgbW9kZWwucG9pbnRzSWRzKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0Q2VsbERpbWVuc2lvbiA9ICgpID0+IHt9OyAvLyB2aXJ0dWFsXG4gIHB1YmxpY0FQSS5pbnRlcnNlY3RXaXRoTGluZSA9IChwMSwgcDIsIHRvbCwgdCwgeCwgcGNvb3Jkcywgc3ViSWQpID0+IHt9OyAvLyB2aXJ0dWFsXG4gIHB1YmxpY0FQSS5ldmFsdWF0ZVBvc2l0aW9uID0gKFxuICAgIHgsXG4gICAgY2xvc2VzdFBvaW50LFxuICAgIHN1YklkLFxuICAgIHBjb29yZHMsXG4gICAgZGlzdDIsXG4gICAgd2VpZ2h0c1xuICApID0+IHt9OyAvLyB2aXJ0dWFsXG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBib3VuZHM6IFstMSwgLTEsIC0xLCAtMSwgLTEsIC0xXSxcbiAgcG9pbnRzSWRzOiBbXSxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIG1hY3JvLm9iaihwdWJsaWNBUEksIG1vZGVsKTtcblxuICBpZiAoIW1vZGVsLnBvaW50cykge1xuICAgIG1vZGVsLnBvaW50cyA9IHZ0a1BvaW50cy5uZXdJbnN0YW5jZSgpO1xuICB9XG5cbiAgbWFjcm8uZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsncG9pbnRzJywgJ3BvaW50c0lkcyddKTtcblxuICB2dGtDZWxsKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a0NlbGwnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgdnRrQ2VsbCBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0NlbGwnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBHbG9iYWwgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXhwb3J0IGNvbnN0IEluaXRMaW5rID0ge1xuICBuY2VsbHM6IDAsXG4gIGNlbGxzOiBudWxsLFxufTtcblxuZnVuY3Rpb24gcmVzaXplKG1vZGVsLCBzeikge1xuICBsZXQgbmV3U2l6ZSA9IHN6O1xuICBpZiAoc3ogPj0gbW9kZWwuYXJyYXkubGVuZ3RoKSB7XG4gICAgbmV3U2l6ZSArPSBtb2RlbC5hcnJheS5sZW5ndGg7XG4gIH1cblxuICB3aGlsZSAobmV3U2l6ZSA+IG1vZGVsLmFycmF5Lmxlbmd0aClcbiAgICBtb2RlbC5hcnJheS5wdXNoKHtcbiAgICAgIG5jZWxsczogMCxcbiAgICAgIGNlbGxzOiBudWxsLFxuICAgIH0pO1xuICBtb2RlbC5hcnJheS5sZW5ndGggPSBuZXdTaXplO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtDZWxsTGlua3MgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtDZWxsTGlua3MocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtDZWxsTGlua3MnKTtcblxuICAvKipcbiAgICogQnVpbGQgdGhlIGxpbmsgbGlzdCBhcnJheS4gQWxsIHN1YmNsYXNzZXMgb2YgdnRrQWJzdHJhY3RDZWxsTGlua3NcbiAgICogbXVzdCBzdXBwb3J0IHRoaXMgbWV0aG9kLlxuICAgKi9cbiAgcHVibGljQVBJLmJ1aWxkTGlua3MgPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IG51bVB0cyA9IGRhdGEuZ2V0UG9pbnRzKCkuZ2V0TnVtYmVyT2ZQb2ludHMoKTtcbiAgICBjb25zdCBudW1DZWxscyA9IGRhdGEuZ2V0TnVtYmVyT2ZDZWxscygpO1xuXG4gICAgLy8gZmlsbCBvdXQgbGlzdHMgd2l0aCBudW1iZXIgb2YgcmVmZXJlbmNlcyB0byBjZWxsc1xuICAgIGNvbnN0IGxpbmtMb2MgPSBuZXcgVWludDMyQXJyYXkobnVtUHRzKTtcblxuICAgIC8vIFVzZSBmYXN0IHBhdGggaWYgcG9seWRhdGFcbiAgICBpZiAoZGF0YS5pc0EoJ3Z0a1BvbHlEYXRhJykpIHtcbiAgICAgIC8vIHRyYXZlcnNlIGRhdGEgdG8gZGV0ZXJtaW5lIG51bWJlciBvZiB1c2VzIG9mIGVhY2ggcG9pbnRcbiAgICAgIGZvciAobGV0IGNlbGxJZCA9IDA7IGNlbGxJZCA8IG51bUNlbGxzOyArK2NlbGxJZCkge1xuICAgICAgICBjb25zdCB7IGNlbGxQb2ludElkcyB9ID0gZGF0YS5nZXRDZWxsUG9pbnRzKGNlbGxJZCk7XG4gICAgICAgIGNlbGxQb2ludElkcy5mb3JFYWNoKChjZWxsUG9pbnRJZCkgPT4ge1xuICAgICAgICAgIHB1YmxpY0FQSS5pbmNyZW1lbnRMaW5rQ291bnQoY2VsbFBvaW50SWQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gbm93IGFsbG9jYXRlIHN0b3JhZ2UgZm9yIHRoZSBsaW5rc1xuICAgICAgcHVibGljQVBJLmFsbG9jYXRlTGlua3MobnVtUHRzKTtcbiAgICAgIG1vZGVsLm1heElkID0gbnVtUHRzIC0gMTtcblxuICAgICAgZm9yIChsZXQgY2VsbElkID0gMDsgY2VsbElkIDwgbnVtQ2VsbHM7ICsrY2VsbElkKSB7XG4gICAgICAgIGNvbnN0IHsgY2VsbFBvaW50SWRzIH0gPSBkYXRhLmdldENlbGxQb2ludHMoY2VsbElkKTtcbiAgICAgICAgY2VsbFBvaW50SWRzLmZvckVhY2goKGNlbGxQb2ludElkKSA9PiB7XG4gICAgICAgICAgcHVibGljQVBJLmluc2VydENlbGxSZWZlcmVuY2UoXG4gICAgICAgICAgICBjZWxsUG9pbnRJZCxcbiAgICAgICAgICAgIGxpbmtMb2NbY2VsbFBvaW50SWRdKyssXG4gICAgICAgICAgICBjZWxsSWRcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IC8vIGFueSBvdGhlciB0eXBlIG9mIGRhdGFzZXRcbiAgICBlbHNlIHtcbiAgICAgIC8vIHRyYXZlcnNlIGRhdGEgdG8gZGV0ZXJtaW5lIG51bWJlciBvZiB1c2VzIG9mIGVhY2ggcG9pbnRcbiAgICAgIGZvciAobGV0IGNlbGxJZCA9IDA7IGNlbGxJZCA8IG51bUNlbGxzOyBjZWxsSWQrKykge1xuICAgICAgICAvLyBUT0RPOiBDdXJyZW50bHkgbm90IHN1cHBvcnRlZDogY29uc3QgY2VsbCA9IGRhdGEuZ2V0Q2VsbChjZWxsSWQpO1xuICAgICAgICBjb25zdCBjZWxsID0gdnRrQ2VsbC5uZXdJbnN0YW5jZSgpO1xuICAgICAgICBjZWxsLmdldFBvaW50c0lkcygpLmZvckVhY2goKGNlbGxQb2ludElkKSA9PiB7XG4gICAgICAgICAgcHVibGljQVBJLmluY3JlbWVudExpbmtDb3VudChjZWxsUG9pbnRJZCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBub3cgYWxsb2NhdGUgc3RvcmFnZSBmb3IgdGhlIGxpbmtzXG4gICAgICBwdWJsaWNBUEkuYWxsb2NhdGVMaW5rcyhudW1QdHMpO1xuICAgICAgbW9kZWwubWF4SWQgPSBudW1QdHMgLSAxO1xuXG4gICAgICBmb3IgKGxldCBjZWxsSWQgPSAwOyBjZWxsSWQgPCBudW1DZWxsczsgKytjZWxsSWQpIHtcbiAgICAgICAgLy8gVE9ETzogQ3VycmVudGx5IG5vdCBzdXBwb3J0ZWQ6IGNvbnN0IGNlbGwgPSBkYXRhLmdldENlbGwoY2VsbElkKTtcbiAgICAgICAgY29uc3QgY2VsbCA9IHZ0a0NlbGwubmV3SW5zdGFuY2UoKTtcbiAgICAgICAgY2VsbC5nZXRQb2ludHNJZHMoKS5mb3JFYWNoKChjZWxsUG9pbnRJZCkgPT4ge1xuICAgICAgICAgIHB1YmxpY0FQSS5pbnNlcnRDZWxsUmVmZXJlbmNlKFxuICAgICAgICAgICAgY2VsbFBvaW50SWQsXG4gICAgICAgICAgICBsaW5rTG9jW2NlbGxQb2ludElkXSsrLFxuICAgICAgICAgICAgY2VsbElkXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSAvLyBlbmQgZWxzZVxuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZCB0aGUgbGluayBsaXN0IGFycmF5IHdpdGggYSBwcm92aWRlZCBjb25uZWN0aXZpdHkgYXJyYXkuXG4gICAqL1xuICAvLyBwdWJsaWNBUEkuYnVpbGRMaW5rcyA9IChkYXRhLCBjb25uZWN0aXZpdHkpID0+IHt9O1xuXG4gIC8qKlxuICAgKiBBbGxvY2F0ZSB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBsaW5rcyAoaS5lLiwgbnVtYmVyIG9mIHBvaW50cykgdGhhdFxuICAgKiB3aWxsIGJlIGJ1aWx0LlxuICAgKi9cbiAgcHVibGljQVBJLmFsbG9jYXRlID0gKG51bUxpbmtzLCBleHQgPSAxMDAwKSA9PiB7XG4gICAgbW9kZWwuYXJyYXkgPSBBcnJheShudW1MaW5rcylcbiAgICAgIC5maWxsKClcbiAgICAgIC5tYXAoKCkgPT4gKHtcbiAgICAgICAgbmNlbGxzOiAwLFxuICAgICAgICBjZWxsczogbnVsbCxcbiAgICAgIH0pKTtcbiAgICBtb2RlbC5leHRlbmQgPSBleHQ7XG4gICAgbW9kZWwubWF4SWQgPSAtMTtcbiAgfTtcblxuICBwdWJsaWNBUEkuaW5pdGlhbGl6ZSA9ICgpID0+IHtcbiAgICBtb2RlbC5hcnJheSA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpbmsgc3RydWN0dXJlIGdpdmVuIGEgcG9pbnQgaWQuXG4gICAqL1xuICBwdWJsaWNBUEkuZ2V0TGluayA9IChwdElkKSA9PiBtb2RlbC5hcnJheVtwdElkXTtcblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgY2VsbHMgdXNpbmcgdGhlIHBvaW50IHNwZWNpZmllZCBieSBwdElkLlxuICAgKi9cbiAgcHVibGljQVBJLmdldE5jZWxscyA9IChwdElkKSA9PiBtb2RlbC5hcnJheVtwdElkXS5uY2VsbHM7XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGxpc3Qgb2YgY2VsbCBpZHMgdXNpbmcgdGhlIHBvaW50LlxuICAgKi9cbiAgcHVibGljQVBJLmdldENlbGxzID0gKHB0SWQpID0+IG1vZGVsLmFycmF5W3B0SWRdLmNlbGxzO1xuXG4gIC8qKlxuICAgKiBJbnNlcnQgYSBuZXcgcG9pbnQgaW50byB0aGUgY2VsbC1saW5rcyBkYXRhIHN0cnVjdHVyZS4gVGhlIHNpemUgcGFyYW1ldGVyXG4gICAqIGlzIHRoZSBpbml0aWFsIHNpemUgb2YgdGhlIGxpc3QuXG4gICAqL1xuICBwdWJsaWNBUEkuaW5zZXJ0TmV4dFBvaW50ID0gKG51bUxpbmtzKSA9PiB7XG4gICAgbW9kZWwuYXJyYXkucHVzaCh7IG5jZWxsczogbnVtTGlua3MsIGNlbGxzOiBBcnJheShudW1MaW5rcykgfSk7XG4gICAgKyttb2RlbC5tYXhJZDtcbiAgfTtcblxuICAvKipcbiAgICogSW5zZXJ0IGEgY2VsbCBpZCBpbnRvIHRoZSBsaXN0IG9mIGNlbGxzIChhdCB0aGUgZW5kKSB1c2luZyB0aGUgY2VsbCBpZFxuICAgKiBwcm92aWRlZC4gKE1ha2Ugc3VyZSB0byBleHRlbmQgdGhlIGxpbmsgbGlzdCAoaWYgbmVjZXNzYXJ5KSB1c2luZyB0aGVcbiAgICogbWV0aG9kIHJlc2l6ZUNlbGxMaXN0KCkuKVxuICAgKi9cbiAgcHVibGljQVBJLmluc2VydE5leHRDZWxsUmVmZXJlbmNlID0gKHB0SWQsIGNlbGxJZCkgPT4ge1xuICAgIG1vZGVsLmFycmF5W3B0SWRdLmNlbGxzW21vZGVsLmFycmF5W3B0SWRdLm5jZWxscysrXSA9IGNlbGxJZDtcbiAgfTtcblxuICAvKipcbiAgICogRGVsZXRlIHBvaW50IChhbmQgc3RvcmFnZSkgYnkgZGVzdHJveWluZyBsaW5rcyB0byB1c2luZyBjZWxscy5cbiAgICovXG4gIHB1YmxpY0FQSS5kZWxldGVQb2ludCA9IChwdElkKSA9PiB7XG4gICAgbW9kZWwuYXJyYXlbcHRJZF0ubmNlbGxzID0gMDtcbiAgICBtb2RlbC5hcnJheVtwdElkXS5jZWxscyA9IG51bGw7XG4gIH07XG5cbiAgLyoqXG4gICAqIERlbGV0ZSB0aGUgcmVmZXJlbmNlIHRvIHRoZSBjZWxsIChjZWxsSWQpIGZyb20gdGhlIHBvaW50IChwdElkKS4gVGhpc1xuICAgKiByZW1vdmVzIHRoZSByZWZlcmVuY2UgdG8gdGhlIGNlbGxJZCBmcm9tIHRoZSBjZWxsIGxpc3QsIGJ1dCBkb2VzIG5vdFxuICAgKiByZXNpemUgdGhlIGxpc3QgKHJlY292ZXIgbWVtb3J5IHdpdGggcmVzaXplQ2VsbExpc3QoKSwgaWYgbmVjZXNzYXJ5KS5cbiAgICovXG4gIHB1YmxpY0FQSS5yZW1vdmVDZWxsUmVmZXJlbmNlID0gKGNlbGxJZCwgcHRJZCkgPT4ge1xuICAgIG1vZGVsLmFycmF5W3B0SWRdLmNlbGxzID0gbW9kZWwuYXJyYXlbcHRJZF0uY2VsbHMuZmlsdGVyKFxuICAgICAgKGNlbGwpID0+IGNlbGwgIT09IGNlbGxJZFxuICAgICk7XG4gICAgbW9kZWwuYXJyYXlbcHRJZF0ubmNlbGxzID0gbW9kZWwuYXJyYXlbcHRJZF0uY2VsbHMubGVuZ3RoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBZGQgdGhlIHJlZmVyZW5jZSB0byB0aGUgY2VsbCAoY2VsbElkKSBmcm9tIHRoZSBwb2ludCAocHRJZCkuIFRoaXNcbiAgICogYWRkcyBhIHJlZmVyZW5jZSB0byB0aGUgY2VsbElkIGZyb20gdGhlIGNlbGwgbGlzdCwgYnV0IGRvZXMgbm90IHJlc2l6ZVxuICAgKiB0aGUgbGlzdCAoZXh0ZW5kIG1lbW9yeSB3aXRoIHJlc2l6ZUNlbGxMaXN0KCksIGlmIG5lY2Vzc2FyeSkuXG4gICAqL1xuICBwdWJsaWNBUEkuYWRkQ2VsbFJlZmVyZW5jZSA9IChjZWxsSWQsIHB0SWQpID0+IHtcbiAgICBtb2RlbC5hcnJheVtwdElkXS5jZWxsc1ttb2RlbC5hcnJheVtwdElkXS5uY2VsbHMrK10gPSBjZWxsSWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoYW5nZSB0aGUgbGVuZ3RoIG9mIGEgcG9pbnQncyBsaW5rIGxpc3QgKGkuZS4sIGxpc3Qgb2YgY2VsbHMgdXNpbmcgYVxuICAgKiBwb2ludCkgYnkgdGhlIHNpemUgc3BlY2lmaWVkLlxuICAgKi9cbiAgcHVibGljQVBJLnJlc2l6ZUNlbGxMaXN0ID0gKHB0SWQsIHNpemUpID0+IHtcbiAgICBtb2RlbC5hcnJheVtwdElkXS5jZWxscy5sZW5ndGggPSBzaXplO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWNsYWltIGFueSB1bnVzZWQgbWVtb3J5LlxuICAgKi9cbiAgcHVibGljQVBJLnNxdWVlemUgPSAoKSA9PiB7XG4gICAgcmVzaXplKG1vZGVsLCBtb2RlbC5tYXhJZCArIDEpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldCB0byBhIHN0YXRlIG9mIG5vIGVudHJpZXMgd2l0aG91dCBmcmVlaW5nIHRoZSBtZW1vcnkuXG4gICAqL1xuICBwdWJsaWNBUEkucmVzZXQgPSAoKSA9PiB7XG4gICAgbW9kZWwubWF4SWQgPSAtMTtcbiAgfTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgRGVlcENvcHkgbWV0aG9kLiAgU2luY2UgdGhpcyBvYmplY3QgY29udGFpbnMgbm8gcmVmZXJlbmNlXG4gICAqIHRvIG90aGVyIG9iamVjdHMsIHRoZXJlIGlzIG5vIFNoYWxsb3dDb3B5LlxuICAgKi9cbiAgcHVibGljQVBJLmRlZXBDb3B5ID0gKHNyYykgPT4ge1xuICAgIG1vZGVsLmFycmF5ID0gWy4uLnNyYy5hcnJheV07XG4gICAgbW9kZWwuZXh0ZW5kID0gc3JjLmV4dGVuZDtcbiAgICBtb2RlbC5tYXhJZCA9IHNyYy5tYXhJZDtcbiAgfTtcblxuICAvKipcbiAgICogSW5jcmVtZW50IHRoZSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIGNlbGxzIHVzaW5nIHRoZSBwb2ludC5cbiAgICovXG4gIHB1YmxpY0FQSS5pbmNyZW1lbnRMaW5rQ291bnQgPSAocHRJZCkgPT4ge1xuICAgICsrbW9kZWwuYXJyYXlbcHRJZF0ubmNlbGxzO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5hbGxvY2F0ZUxpbmtzID0gKG4pID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgbW9kZWwuYXJyYXlbaV0uY2VsbHMgPSBuZXcgQXJyYXkobW9kZWwuYXJyYXlbaV0ubmNlbGxzKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEluc2VydCBhIGNlbGwgaWQgaW50byB0aGUgbGlzdCBvZiBjZWxscyB1c2luZyB0aGUgcG9pbnQuXG4gICAqL1xuICBwdWJsaWNBUEkuaW5zZXJ0Q2VsbFJlZmVyZW5jZSA9IChwdElkLCBwb3MsIGNlbGxJZCkgPT4ge1xuICAgIG1vZGVsLmFycmF5W3B0SWRdLmNlbGxzW3Bvc10gPSBjZWxsSWQ7XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBhcnJheTogbnVsbCwgLy8gcG9pbnRlciB0byBkYXRhXG4gIG1heElkOiAwLCAvLyBtYXhpbXVtIGluZGV4IGluc2VydGVkIHRodXMgZmFyXG4gIGV4dGVuZDogMCwgLy8gZ3JvdyBhcnJheSBieSB0aGlzIHBvaW50XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICBtYWNyby5vYmoocHVibGljQVBJLCBtb2RlbCk7XG5cbiAgdnRrQ2VsbExpbmtzKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a0NlbGxMaW5rcycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCB9O1xuIiwiZXhwb3J0IGNvbnN0IENlbGxUeXBlID0ge1xuICAvLyBMaW5lYXIgY2VsbHNcbiAgVlRLX0VNUFRZX0NFTEw6IDAsXG4gIFZUS19WRVJURVg6IDEsXG4gIFZUS19QT0xZX1ZFUlRFWDogMixcbiAgVlRLX0xJTkU6IDMsXG4gIFZUS19QT0xZX0xJTkU6IDQsXG4gIFZUS19UUklBTkdMRTogNSxcbiAgVlRLX1RSSUFOR0xFX1NUUklQOiA2LFxuICBWVEtfUE9MWUdPTjogNyxcbiAgVlRLX1BJWEVMOiA4LFxuICBWVEtfUVVBRDogOSxcbiAgVlRLX1RFVFJBOiAxMCxcbiAgVlRLX1ZPWEVMOiAxMSxcbiAgVlRLX0hFWEFIRURST046IDEyLFxuICBWVEtfV0VER0U6IDEzLFxuICBWVEtfUFlSQU1JRDogMTQsXG4gIFZUS19QRU5UQUdPTkFMX1BSSVNNOiAxNSxcbiAgVlRLX0hFWEFHT05BTF9QUklTTTogMTYsXG5cbiAgLy8gUXVhZHJhdGljLCBpc29wYXJhbWV0cmljIGNlbGxzXG4gIFZUS19RVUFEUkFUSUNfRURHRTogMjEsXG4gIFZUS19RVUFEUkFUSUNfVFJJQU5HTEU6IDIyLFxuICBWVEtfUVVBRFJBVElDX1FVQUQ6IDIzLFxuICBWVEtfUVVBRFJBVElDX1BPTFlHT046IDM2LFxuICBWVEtfUVVBRFJBVElDX1RFVFJBOiAyNCxcbiAgVlRLX1FVQURSQVRJQ19IRVhBSEVEUk9OOiAyNSxcbiAgVlRLX1FVQURSQVRJQ19XRURHRTogMjYsXG4gIFZUS19RVUFEUkFUSUNfUFlSQU1JRDogMjcsXG4gIFZUS19CSVFVQURSQVRJQ19RVUFEOiAyOCxcbiAgVlRLX1RSSVFVQURSQVRJQ19IRVhBSEVEUk9OOiAyOSxcbiAgVlRLX1FVQURSQVRJQ19MSU5FQVJfUVVBRDogMzAsXG4gIFZUS19RVUFEUkFUSUNfTElORUFSX1dFREdFOiAzMSxcbiAgVlRLX0JJUVVBRFJBVElDX1FVQURSQVRJQ19XRURHRTogMzIsXG4gIFZUS19CSVFVQURSQVRJQ19RVUFEUkFUSUNfSEVYQUhFRFJPTjogMzMsXG4gIFZUS19CSVFVQURSQVRJQ19UUklBTkdMRTogMzQsXG5cbiAgLy8gQ3ViaWMsIGlzb3BhcmFtZXRyaWMgY2VsbFxuICBWVEtfQ1VCSUNfTElORTogMzUsXG5cbiAgLy8gU3BlY2lhbCBjbGFzcyBvZiBjZWxscyBmb3JtZWQgYnkgY29udmV4IGdyb3VwIG9mIHBvaW50c1xuICBWVEtfQ09OVkVYX1BPSU5UX1NFVDogNDEsXG5cbiAgLy8gUG9seWhlZHJvbiBjZWxsIChjb25zaXN0aW5nIG9mIHBvbHlnb25hbCBmYWNlcylcbiAgVlRLX1BPTFlIRURST046IDQyLFxuXG4gIC8vIEhpZ2hlciBvcmRlciBjZWxscyBpbiBwYXJhbWV0cmljIGZvcm1cbiAgVlRLX1BBUkFNRVRSSUNfQ1VSVkU6IDUxLFxuICBWVEtfUEFSQU1FVFJJQ19TVVJGQUNFOiA1MixcbiAgVlRLX1BBUkFNRVRSSUNfVFJJX1NVUkZBQ0U6IDUzLFxuICBWVEtfUEFSQU1FVFJJQ19RVUFEX1NVUkZBQ0U6IDU0LFxuICBWVEtfUEFSQU1FVFJJQ19URVRSQV9SRUdJT046IDU1LFxuICBWVEtfUEFSQU1FVFJJQ19IRVhfUkVHSU9OOiA1NixcblxuICAvLyBIaWdoZXIgb3JkZXIgY2VsbHNcbiAgVlRLX0hJR0hFUl9PUkRFUl9FREdFOiA2MCxcbiAgVlRLX0hJR0hFUl9PUkRFUl9UUklBTkdMRTogNjEsXG4gIFZUS19ISUdIRVJfT1JERVJfUVVBRDogNjIsXG4gIFZUS19ISUdIRVJfT1JERVJfUE9MWUdPTjogNjMsXG4gIFZUS19ISUdIRVJfT1JERVJfVEVUUkFIRURST046IDY0LFxuICBWVEtfSElHSEVSX09SREVSX1dFREdFOiA2NSxcbiAgVlRLX0hJR0hFUl9PUkRFUl9QWVJBTUlEOiA2NixcbiAgVlRLX0hJR0hFUl9PUkRFUl9IRVhBSEVEUk9OOiA2NyxcblxuICAvLyBBcmJpdHJhcnkgb3JkZXIgTGFncmFuZ2UgZWxlbWVudHMgKGZvcm11bGF0ZWQgc2VwYXJhdGVkIGZyb20gZ2VuZXJpYyBoaWdoZXIgb3JkZXIgY2VsbHMpXG4gIFZUS19MQUdSQU5HRV9DVVJWRTogNjgsXG4gIFZUS19MQUdSQU5HRV9UUklBTkdMRTogNjksXG4gIFZUS19MQUdSQU5HRV9RVUFEUklMQVRFUkFMOiA3MCxcbiAgVlRLX0xBR1JBTkdFX1RFVFJBSEVEUk9OOiA3MSxcbiAgVlRLX0xBR1JBTkdFX0hFWEFIRURST046IDcyLFxuICBWVEtfTEFHUkFOR0VfV0VER0U6IDczLFxuICBWVEtfTEFHUkFOR0VfUFlSQU1JRDogNzQsXG5cbiAgVlRLX05VTUJFUl9PRl9DRUxMX1RZUEVTOiA3NSxcbn07XG5cbi8vIFRoaXMgbGlzdCBzaG91bGQgY29udGFpbiB0aGUgY2VsbCBjbGFzcyBuYW1lcyBpblxuLy8gdGhlIHNhbWUgb3JkZXIgYXMgaW4gQ2VsbFR5cGUuXG5leHBvcnQgY29uc3QgQ2VsbFR5cGVzU3RyaW5ncyA9IFtcbiAgJ3Z0a0VtcHR5Q2VsbCcsXG4gICd2dGtWZXJ0ZXgnLFxuICAndnRrUG9seVZlcnRleCcsXG4gICd2dGtMaW5lJyxcbiAgJ3Z0a1BvbHlMaW5lJyxcbiAgJ3Z0a1RyaWFuZ2xlJyxcbiAgJ3Z0a1RyaWFuZ2xlU3RyaXAnLFxuICAndnRrUG9seWdvbicsXG4gICd2dGtQaXhlbCcsXG4gICd2dGtRdWFkJyxcbiAgJ3Z0a1RldHJhJyxcbiAgJ3Z0a1ZveGVsJyxcbiAgJ3Z0a0hleGFoZWRyb24nLFxuICAndnRrV2VkZ2UnLFxuICAndnRrUHlyYW1pZCcsXG4gICd2dGtQZW50YWdvbmFsUHJpc20nLFxuICAndnRrSGV4YWdvbmFsUHJpc20nLFxuICAnVW5rbm93bkNsYXNzJyxcbiAgJ1Vua25vd25DbGFzcycsXG4gICdVbmtub3duQ2xhc3MnLFxuICAnVW5rbm93bkNsYXNzJyxcbiAgJ3Z0a1F1YWRyYXRpY0VkZ2UnLFxuICAndnRrUXVhZHJhdGljVHJpYW5nbGUnLFxuICAndnRrUXVhZHJhdGljUXVhZCcsXG4gICd2dGtRdWFkcmF0aWNUZXRyYScsXG4gICd2dGtRdWFkcmF0aWNIZXhhaGVkcm9uJyxcbiAgJ3Z0a1F1YWRyYXRpY1dlZGdlJyxcbiAgJ3Z0a1F1YWRyYXRpY1B5cmFtaWQnLFxuICAndnRrQmlRdWFkcmF0aWNRdWFkJyxcbiAgJ3Z0a1RyaVF1YWRyYXRpY0hleGFoZWRyb24nLFxuICAndnRrUXVhZHJhdGljTGluZWFyUXVhZCcsXG4gICd2dGtRdWFkcmF0aWNMaW5lYXJXZWRnZScsXG4gICd2dGtCaVF1YWRyYXRpY1F1YWRyYXRpY1dlZGdlJyxcbiAgJ3Z0a0JpUXVhZHJhdGljUXVhZHJhdGljSGV4YWhlZHJvbicsXG4gICd2dGtCaVF1YWRyYXRpY1RyaWFuZ2xlJyxcbiAgJ3Z0a0N1YmljTGluZScsXG4gICd2dGtRdWFkcmF0aWNQb2x5Z29uJyxcbiAgJ1Vua25vd25DbGFzcycsXG4gICdVbmtub3duQ2xhc3MnLFxuICAnVW5rbm93bkNsYXNzJyxcbiAgJ1Vua25vd25DbGFzcycsXG4gICd2dGtDb252ZXhQb2ludFNldCcsXG4gICdVbmtub3duQ2xhc3MnLFxuICAnVW5rbm93bkNsYXNzJyxcbiAgJ1Vua25vd25DbGFzcycsXG4gICdVbmtub3duQ2xhc3MnLFxuICAnVW5rbm93bkNsYXNzJyxcbiAgJ1Vua25vd25DbGFzcycsXG4gICdVbmtub3duQ2xhc3MnLFxuICAnVW5rbm93bkNsYXNzJyxcbiAgJ1Vua25vd25DbGFzcycsXG4gICd2dGtQYXJhbWV0cmljQ3VydmUnLFxuICAndnRrUGFyYW1ldHJpY1N1cmZhY2UnLFxuICAndnRrUGFyYW1ldHJpY1RyaVN1cmZhY2UnLFxuICAndnRrUGFyYW1ldHJpY1F1YWRTdXJmYWNlJyxcbiAgJ3Z0a1BhcmFtZXRyaWNUZXRyYVJlZ2lvbicsXG4gICd2dGtQYXJhbWV0cmljSGV4UmVnaW9uJyxcbiAgJ1Vua25vd25DbGFzcycsXG4gICdVbmtub3duQ2xhc3MnLFxuICAnVW5rbm93bkNsYXNzJyxcbiAgJ3Z0a0hpZ2hlck9yZGVyRWRnZScsXG4gICd2dGtIaWdoZXJPcmRlclRyaWFuZ2xlJyxcbiAgJ3Z0a0hpZ2hlck9yZGVyUXVhZCcsXG4gICd2dGtIaWdoZXJPcmRlclBvbHlnb24nLFxuICAndnRrSGlnaGVyT3JkZXJUZXRyYWhlZHJvbicsXG4gICd2dGtIaWdoZXJPcmRlcldlZGdlJyxcbiAgJ3Z0a0hpZ2hlck9yZGVyUHlyYW1pZCcsXG4gICd2dGtIaWdoZXJPcmRlckhleGFoZWRyb24nLFxuXTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBDZWxsVHlwZSxcbiAgQ2VsbFR5cGVzU3RyaW5ncyxcbn07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0IHtcbiAgQ2VsbFR5cGUsXG4gIENlbGxUeXBlc1N0cmluZ3MsXG59IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvQ2VsbFR5cGVzL0NvbnN0YW50cyc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdsb2JhbCBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogR2l2ZW4gYW4gaW50IChhcyBkZWZpbmVkIGluIHZ0a0NlbGxUeXBlLmgpIGlkZW50aWZpZXIgZm9yIGEgY2xhc3NcbiAqIHJldHVybiBpdCdzIGNsYXNzbmFtZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lRnJvbVR5cGVJZCh0eXBlSWQpIHtcbiAgcmV0dXJuIHR5cGVJZCA8IENlbGxUeXBlc1N0cmluZ3MubGVuZ3RoXG4gICAgPyBDZWxsVHlwZXNTdHJpbmdzW3R5cGVJZF1cbiAgICA6ICdVbmtub3duQ2xhc3MnO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgZGF0YSBvYmplY3QgY2xhc3NuYW1lLCByZXR1cm4gaXQncyBpbnQgaWRlbnRpZmllZCAoYXNcbiAqIGRlZmluZWQgaW4gdnRrQ2VsbFR5cGUuaClcbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZUlkRnJvbUNsYXNzTmFtZShjZWxsVHlwZVN0cmluZykge1xuICByZXR1cm4gQ2VsbFR5cGVzU3RyaW5ncy5maW5kSW5kZXgoY2VsbFR5cGVTdHJpbmcpO1xufVxuXG4vKipcbiAqIFRoaXMgY29udmVuaWVuY2UgbWV0aG9kIGlzIGEgZmFzdCBjaGVjayB0byBkZXRlcm1pbmUgaWYgYSBjZWxsIHR5cGVcbiAqIHJlcHJlc2VudHMgYSBsaW5lYXIgb3Igbm9ubGluZWFyIGNlbGwuICBUaGlzIGlzIGdlbmVyYWxseSBtdWNoIG1vcmVcbiAqIGVmZmljaWVudCB0aGFuIGdldHRpbmcgdGhlIGFwcHJvcHJpYXRlIHZ0a0NlbGwgYW5kIGNoZWNraW5nIGl0cyBJc0xpbmVhclxuICogbWV0aG9kLlxuICovXG5mdW5jdGlvbiBpc0xpbmVhcih0eXBlKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZSA8IENlbGxUeXBlLlZUS19RVUFEUkFUSUNfRURHRSB8fFxuICAgIHR5cGUgPT09IENlbGxUeXBlLlZUS19DT05WRVhfUE9JTlRfU0VUIHx8XG4gICAgdHlwZSA9PT0gQ2VsbFR5cGUuVlRLX1BPTFlIRURST05cbiAgKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU3RhdGljIEFQSVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgU1RBVElDID0ge1xuICBnZXRDbGFzc05hbWVGcm9tVHlwZUlkLFxuICBnZXRUeXBlSWRGcm9tQ2xhc3NOYW1lLFxuICBpc0xpbmVhcixcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a0NlbGxUeXBlcyBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a0NlbGxUeXBlcyhwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a0NlbGxUeXBlcycpO1xuXG4gIC8qKlxuICAgKiBBbGxvY2F0ZSBtZW1vcnkgZm9yIHRoaXMgYXJyYXkuIERlbGV0ZSBvbGQgc3RvcmFnZSBvbmx5IGlmIG5lY2Vzc2FyeS5cbiAgICovXG4gIHB1YmxpY0FQSS5hbGxvY2F0ZSA9IChzeiA9IDUxMiwgZXh0ID0gMTAwMCkgPT4ge1xuICAgIG1vZGVsLnNpemUgPSBzeiA+IDAgPyBzeiA6IDE7XG4gICAgbW9kZWwuZXh0ZW5kID0gZXh0ID4gMCA/IGV4dCA6IDE7XG4gICAgbW9kZWwubWF4SWQgPSAtMTtcbiAgICBtb2RlbC50eXBlQXJyYXkgPSBuZXcgVWludDhBcnJheShzeik7XG4gICAgbW9kZWwubG9jYXRpb25BcnJheSA9IG5ldyBVaW50MzJBcnJheShzeik7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNlbGwgYXQgc3BlY2lmaWVkIGlkLlxuICAgKi9cbiAgcHVibGljQVBJLmluc2VydENlbGwgPSAoY2VsbElkLCB0eXBlLCBsb2MpID0+IHtcbiAgICBtb2RlbC50eXBlQXJyYXlbY2VsbElkXSA9IHR5cGU7XG4gICAgbW9kZWwubG9jYXRpb25BcnJheVtjZWxsSWRdID0gbG9jO1xuXG4gICAgaWYgKGNlbGxJZCA+IG1vZGVsLm1heElkKSB7XG4gICAgICBtb2RlbC5tYXhJZCA9IGNlbGxJZDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNlbGwgdG8gdGhlIG9iamVjdCBpbiB0aGUgbmV4dCBhdmFpbGFibGUgc2xvdC5cbiAgICovXG4gIHB1YmxpY0FQSS5pbnNlcnROZXh0Q2VsbCA9ICh0eXBlLCBsb2MpID0+IHtcbiAgICBwdWJsaWNBUEkuaW5zZXJ0Q2VsbCgrK21vZGVsLm1heElkLCB0eXBlLCBsb2MpO1xuICAgIHJldHVybiBtb2RlbC5tYXhJZDtcbiAgfTtcblxuICAvKipcbiAgICogU3BlY2lmeSBhIGdyb3VwIG9mIGNlbGwgdHlwZXMuIFRoaXMgdmVyc2lvbiBpcyBwcm92aWRlZCB0byBtYWludGFpblxuICAgKiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBhbmQgZG9lcyBhIGNvcHkgb2YgdGhlIGNlbGxMb2NhdGlvbnNcbiAgICovXG4gIHB1YmxpY0FQSS5zZXRDZWxsVHlwZXMgPSAobmNlbGxzLCBjZWxsVHlwZXMsIGNlbGxMb2NhdGlvbnMpID0+IHtcbiAgICBtb2RlbC5zaXplID0gbmNlbGxzO1xuXG4gICAgbW9kZWwudHlwZUFycmF5ID0gY2VsbFR5cGVzO1xuICAgIG1vZGVsLmxvY2F0aW9uQXJyYXkgPSBjZWxsTG9jYXRpb25zO1xuXG4gICAgbW9kZWwubWF4SWQgPSBuY2VsbHMgLSAxO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxvY2F0aW9uIG9mIHRoZSBjZWxsIGluIHRoZSBhc3NvY2lhdGVkIHZ0a0NlbGxBcnJheS5cbiAgICovXG4gIHB1YmxpY0FQSS5nZXRDZWxsTG9jYXRpb24gPSAoY2VsbElkKSA9PiBtb2RlbC5sb2NhdGlvbkFycmF5W2NlbGxJZF07XG5cbiAgLyoqXG4gICAqIERlbGV0ZSBjZWxsIGJ5IHNldHRpbmcgdG8gbnVsbHB0ciBjZWxsIHR5cGUuXG4gICAqL1xuICBwdWJsaWNBUEkuZGVsZXRlQ2VsbCA9IChjZWxsSWQpID0+IHtcbiAgICBtb2RlbC50eXBlQXJyYXlbY2VsbElkXSA9IENlbGxUeXBlLlZUS19FTVBUWV9DRUxMO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiB0eXBlcyBpbiB0aGUgbGlzdC5cbiAgICovXG4gIHB1YmxpY0FQSS5nZXROdW1iZXJPZlR5cGVzID0gKCkgPT4gbW9kZWwubWF4SWQgKyAxO1xuXG4gIC8qKlxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0eXBlIHNwZWNpZmllZCBpcyBjb250YWluZWQgaW4gbGlzdDsgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgcHVibGljQVBJLmlzVHlwZSA9ICh0eXBlKSA9PiB7XG4gICAgY29uc3QgbnVtVHlwZXMgPSBwdWJsaWNBUEkuZ2V0TnVtYmVyT2ZUeXBlcygpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1UeXBlczsgKytpKSB7XG4gICAgICBpZiAodHlwZSA9PT0gcHVibGljQVBJLmdldENlbGxUeXBlKGkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0aGUgdHlwZSBzcGVjaWZpZWQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC4gUmFuZ2UgY2hlY2tpbmcgaXMgcGVyZm9ybWVkLlxuICAgKi9cbiAgcHVibGljQVBJLmluc2VydE5leHRUeXBlID0gKHR5cGUpID0+IHB1YmxpY0FQSS5pbnNlcnROZXh0Q2VsbCh0eXBlLCAtMSk7XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgdHlwZSBvZiBjZWxsLlxuICAgKi9cbiAgcHVibGljQVBJLmdldENlbGxUeXBlID0gKGNlbGxJZCkgPT4gbW9kZWwudHlwZUFycmF5W2NlbGxJZF07XG5cbiAgLyoqXG4gICAqIFJlY2xhaW0gYW55IGV4dHJhIG1lbW9yeS5cbiAgICovXG4gIC8vIFRPRE86IHB1YmxpY0FQSS5zcXVlZXplID0gKCkgPT4gIHt9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIG9iamVjdCB3aXRob3V0IHJlbGVhc2luZyBtZW1vcnkuXG4gICAqL1xuICBwdWJsaWNBUEkucmVzZXQgPSAoKSA9PiB7XG4gICAgbW9kZWwubWF4SWQgPSAtMTtcbiAgfTtcblxuICAvKipcbiAgICogU3RhbmRhcmQgRGVlcENvcHkgbWV0aG9kLiAgU2luY2UgdGhpcyBvYmplY3QgY29udGFpbnMgbm8gcmVmZXJlbmNlXG4gICAqIHRvIG90aGVyIG9iamVjdHMsIHRoZXJlIGlzIG5vIFNoYWxsb3dDb3B5LlxuICAgKi9cbiAgcHVibGljQVBJLmRlZXBDb3B5ID0gKHNyYykgPT4ge1xuICAgIHB1YmxpY0FQSS5hbGxvY2F0ZShzcmMuZ2V0U2l6ZSgpLCBzcmMuZ2V0RXh0ZW5kKCkpO1xuICAgIG1vZGVsLnR5cGVBcnJheS5zZXQoc3JjLmdldFR5cGVBcnJheSgpKTtcbiAgICBtb2RlbC5sb2NhdGlvbkFycmF5LnNldChzcmMuZ2V0TG9jYXRpb25BcnJheSgpKTtcbiAgICBtb2RlbC5tYXhJZCA9IHNyYy5nZXRNYXhJZCgpO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgLy8gdHlwZUFycmF5OiBudWxsLCAvLyBwb2ludGVyIHRvIHR5cGVzIGFycmF5XG4gIC8vIGxvY2F0aW9uQXJyYXk6IG51bGw7ICAgLy8gcG9pbnRlciB0byBhcnJheSBvZiBvZmZzZXRzXG4gIHNpemU6IDAsIC8vIGFsbG9jYXRlZCBzaXplIG9mIGRhdGFcbiAgbWF4SWQ6IC0xLCAvLyBtYXhpbXVtIGluZGV4IGluc2VydGVkIHRodXMgZmFyXG4gIGV4dGVuZDogMTAwMCwgLy8gZ3JvdyBhcnJheSBieSB0aGlzIHBvaW50XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICBtYWNyby5vYmoocHVibGljQVBJLCBtb2RlbCk7XG5cbiAgbWFjcm8uZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsnc2l6ZScsICdtYXhJZCcsICdleHRlbmQnXSk7XG4gIG1hY3JvLmdldEFycmF5KHB1YmxpY0FQSSwgbW9kZWwsIFsndHlwZUFycmF5JywgJ2xvY2F0aW9uQXJyYXknXSk7XG5cbiAgdnRrQ2VsbFR5cGVzKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a0NlbGxUeXBlcycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCwgLi4uU1RBVElDIH07XG4iLCIvLyBTcGVjaWZ5IGhvdyBkYXRhIGFycmF5cyBjYW4gYmUgdXNlZCBieSBkYXRhIG9iamVjdHNcbmV4cG9ydCBjb25zdCBGaWVsZERhdGFUeXBlcyA9IHtcbiAgVU5JRk9STTogMCwgLy8gZGF0YSB0aGF0IGRvZXMgbm90IHZhcnkgb3ZlciBwb2ludHMvY2VsbHMvZXRjLlxuICBEQVRBX09CSkVDVF9GSUVMRDogMCwgLy8gdG8gbWF0Y2ggVlRLXG5cbiAgQ09PUkRJTkFURTogMSwgLy8gZGF0YSB0aGF0IHNwZWNpZmllcyB0aGUgbG9jYXRpb24gb2YgZWFjaCBwb2ludFxuICBQT0lOVF9EQVRBOiAxLCAvLyB0byBtYXRjaCBWVEtcblxuICBQT0lOVDogMiwgLy8gZGF0YSBkZWZpbmVkIGF0IGVhY2ggcG9pbnQsIGJ1dCB0aGF0IGRvZXMgbm90IHNwZWNpZnkgdGhlIHBvaW50IGxvY2F0aW9uXG4gIFBPSU5UX0ZJRUxEX0RBVEE6IDIsIC8vIHRvIG1hdGNoIFZUS1xuXG4gIENFTEw6IDMsIC8vIGRhdGEgZGVmaW5lZCBhdCBlYWNoIGNlbGwsIGJ1dCB0aGF0IGRvZXMgbm90IHNwZWNpZnkgdGhlIGNlbGxcbiAgQ0VMTF9GSUVMRF9EQVRBOiAzLCAvLyB0byBtYXRjaCBWVEtcblxuICBWRVJURVg6IDQsIC8vIGRhdGEgZGVmaW5lZCBhdCBlYWNoIGdyYXBoIHZlcnRleCwgYnV0IHRoYXQgZG9lcyBub3Qgc3BlY2lmeSB0aGUgZ3JhcGggdmVydGV4XG4gIFZFUlRFWF9GSUVMRF9EQVRBOiA0LCAvLyB0byBtYXRjaCBWVEtcblxuICBFREdFOiA1LCAvLyBkYXRhIGRlZmluZWQgYXQgZWFjaCBncmFwaCBlZGdlLCBidXQgdGhhdCBkb2VzIG5vdCBzcGVjaWZ5IHRoZSBncmFwaCBlZGdlXG4gIEVER0VfRklFTERfREFUQTogNSwgLy8gdG8gbWF0Y2ggVlRLXG5cbiAgUk9XOiA2LCAvLyBkYXRhIHNwZWNpZnlpbmcgYSB0YWJsZSByb3dcbiAgUk9XX0RBVEE6IDYsIC8vIHRvIG1hdGNoIFZUS1xufTtcblxuZXhwb3J0IGNvbnN0IEZpZWxkQXNzb2NpYXRpb25zID0ge1xuICBGSUVMRF9BU1NPQ0lBVElPTl9QT0lOVFM6IDAsXG4gIEZJRUxEX0FTU09DSUFUSU9OX0NFTExTOiAxLFxuICBGSUVMRF9BU1NPQ0lBVElPTl9OT05FOiAyLFxuICBGSUVMRF9BU1NPQ0lBVElPTl9QT0lOVFNfVEhFTl9DRUxMUzogMyxcbiAgRklFTERfQVNTT0NJQVRJT05fVkVSVElDRVM6IDQsXG4gIEZJRUxEX0FTU09DSUFUSU9OX0VER0VTOiA1LFxuICBGSUVMRF9BU1NPQ0lBVElPTl9ST1dTOiA2LFxuICBOVU1CRVJfT0ZfQVNTT0NJQVRJT05TOiA3LFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBGaWVsZERhdGFUeXBlcyxcbiAgRmllbGRBc3NvY2lhdGlvbnMsXG59O1xuIiwiaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB2dGsgZnJvbSAndnRrLmpzL1NvdXJjZXMvdnRrJztcbmltcG9ydCB2dGtEYXRhU2V0QXR0cmlidXRlcyBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0RhdGFTZXRBdHRyaWJ1dGVzJztcbmltcG9ydCBDb25zdGFudHMgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9EYXRhU2V0L0NvbnN0YW50cyc7XG5cbi8vIGltcG9ydCB2dGtCb3VuZGluZ0JveCBmcm9tICcuLi9Cb3VuZGluZ0JveCc7XG4vLyBpbXBvcnQgKiBhcyB2dGtNYXRoIGZyb20gJy4uLy4uL0NvcmUvTWF0aCc7XG4vL1xuLy8gZnVuY3Rpb24gZ2V0Qm91bmRzKGRhdGFzZXQpIHtcbi8vICAgaWYgKGRhdGFzZXQuYm91bmRzKSB7XG4vLyAgICAgcmV0dXJuIGRhdGFzZXQuYm91bmRzO1xuLy8gICB9XG4vLyAgIGlmIChkYXRhc2V0LnR5cGUgJiYgZGF0YXNldFtkYXRhc2V0LnR5cGVdKSB7XG4vLyAgICAgY29uc3QgZHMgPSBkYXRhc2V0W2RhdGFzZXQudHlwZV07XG4vLyAgICAgaWYgKGRzLmJvdW5kcykge1xuLy8gICAgICAgcmV0dXJuIGRzLmJvdW5kcztcbi8vICAgICB9XG4vLyAgICAgaWYgKGRzLlBvaW50cyAmJiBkcy5Qb2ludHMuYm91bmRzKSB7XG4vLyAgICAgICByZXR1cm4gZHMuUG9pbnRzLmJvdW5kcztcbi8vICAgICB9XG5cbi8vICAgICBpZiAoZHMuUG9pbnRzICYmIGRzLlBvaW50cy52YWx1ZXMpIHtcbi8vICAgICAgIGNvbnN0IGFycmF5ID0gZHMuUG9pbnRzLnZhbHVlcztcbi8vICAgICAgIGNvbnN0IGJib3ggPSB2dGtCb3VuZGluZ0JveC5uZXdJbnN0YW5jZSgpO1xuLy8gICAgICAgY29uc3Qgc2l6ZSA9IGFycmF5Lmxlbmd0aDtcbi8vICAgICAgIGNvbnN0IGRlbHRhID0gZHMuUG9pbnRzLm51bWJlck9mQ29tcG9uZW50cyA/IGRzLlBvaW50cy5udW1iZXJPZkNvbXBvbmVudHMgOiAzO1xuLy8gICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc2l6ZTsgaWR4ICs9IGRlbHRhKSB7XG4vLyAgICAgICAgIGJib3guYWRkUG9pbnQoYXJyYXlbaWR4ICogZGVsdGFdLCBhcnJheVsoaWR4ICogZGVsdGEpICsgMV0sIGFycmF5WyhpZHggKiBkZWx0YSkgKyAyXSk7XG4vLyAgICAgICB9XG4vLyAgICAgICBkcy5Qb2ludHMuYm91bmRzID0gYmJveC5nZXRCb3VuZHMoKTtcbi8vICAgICAgIHJldHVybiBkcy5Qb2ludHMuYm91bmRzO1xuLy8gICAgIH1cbi8vICAgfVxuLy8gICByZXR1cm4gdnRrTWF0aC5jcmVhdGVVbmluaXRpYWxpemVkQm91bmRzKCk7XG4vLyB9XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdsb2JhbCBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERBVEFTRVRfRklFTERTID0gWydwb2ludERhdGEnLCAnY2VsbERhdGEnLCAnZmllbGREYXRhJ107XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a0RhdGFTZXQgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtEYXRhU2V0KHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrRGF0YVNldCcpO1xuXG4gIC8vIEFkZCBkYXRhc2V0IGF0dHJpYnV0ZXNcbiAgREFUQVNFVF9GSUVMRFMuZm9yRWFjaCgoZmllbGROYW1lKSA9PiB7XG4gICAgaWYgKCFtb2RlbFtmaWVsZE5hbWVdKSB7XG4gICAgICBtb2RlbFtmaWVsZE5hbWVdID0gdnRrRGF0YVNldEF0dHJpYnV0ZXMubmV3SW5zdGFuY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWxbZmllbGROYW1lXSA9IHZ0ayhtb2RlbFtmaWVsZE5hbWVdKTtcbiAgICB9XG4gIH0pO1xuXG4gIGNvbnN0IHN1cGVyU2hhbGxvd0NvcHkgPSBwdWJsaWNBUEkuc2hhbGxvd0NvcHk7XG4gIHB1YmxpY0FQSS5zaGFsbG93Q29weSA9IChvdGhlciwgZGVidWcgPSBmYWxzZSkgPT4ge1xuICAgIHN1cGVyU2hhbGxvd0NvcHkob3RoZXIsIGRlYnVnKTtcbiAgICBEQVRBU0VUX0ZJRUxEUy5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcbiAgICAgIG1vZGVsW2ZpZWxkTmFtZV0gPSB2dGtEYXRhU2V0QXR0cmlidXRlcy5uZXdJbnN0YW5jZSgpO1xuICAgICAgbW9kZWxbZmllbGROYW1lXS5zaGFsbG93Q29weShvdGhlci5nZXRSZWZlcmVuY2VCeU5hbWUoZmllbGROYW1lKSk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICAvLyBwb2ludERhdGE6IG51bGwsXG4gIC8vIGNlbGxEYXRhOiBudWxsLFxuICAvLyBmaWVsZERhdGE6IG51bGwsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICBtYWNyby5vYmoocHVibGljQVBJLCBtb2RlbCk7XG4gIG1hY3JvLnNldEdldChwdWJsaWNBUEksIG1vZGVsLCBEQVRBU0VUX0ZJRUxEUyk7XG5cbiAgLy8gT2JqZWN0IHNwZWNpZmljIG1ldGhvZHNcbiAgdnRrRGF0YVNldChwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQsICd2dGtEYXRhU2V0Jyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kLCAuLi5Db25zdGFudHMgfTtcbiIsImV4cG9ydCBjb25zdCBBdHRyaWJ1dGVUeXBlcyA9IHtcbiAgU0NBTEFSUzogMCxcbiAgVkVDVE9SUzogMSxcbiAgTk9STUFMUzogMixcbiAgVENPT1JEUzogMyxcbiAgVEVOU09SUzogNCxcbiAgR0xPQkFMSURTOiA1LFxuICBQRURJR1JFRUlEUzogNixcbiAgRURHRUZMQUc6IDcsXG4gIE5VTV9BVFRSSUJVVEVTOiA4LFxufTtcblxuZXhwb3J0IGNvbnN0IEF0dHJpYnV0ZUxpbWl0VHlwZXMgPSB7XG4gIE1BWDogMCxcbiAgRVhBQ1Q6IDEsXG4gIE5PTElNSVQ6IDIsXG59O1xuXG5leHBvcnQgY29uc3QgQ2VsbEdob3N0VHlwZXMgPSB7XG4gIERVUExJQ0FURUNFTEw6IDEsIC8vIHRoZSBjZWxsIGlzIHByZXNlbnQgb24gbXVsdGlwbGUgcHJvY2Vzc29yc1xuICBISUdIQ09OTkVDVElWSVRZQ0VMTDogMiwgLy8gdGhlIGNlbGwgaGFzIG1vcmUgbmVpZ2hib3JzIHRoYW4gaW4gYSByZWd1bGFyIG1lc2hcbiAgTE9XQ09OTkVDVElWSVRZQ0VMTDogNCwgLy8gdGhlIGNlbGwgaGFzIGxlc3MgbmVpZ2hib3JzIHRoYW4gaW4gYSByZWd1bGFyIG1lc2hcbiAgUkVGSU5FRENFTEw6IDgsIC8vIG90aGVyIGNlbGxzIGFyZSBwcmVzZW50IHRoYXQgcmVmaW5lcyBpdC5cbiAgRVhURVJJT1JDRUxMOiAxNiwgLy8gdGhlIGNlbGwgaXMgb24gdGhlIGV4dGVyaW9yIG9mIHRoZSBkYXRhIHNldFxuICBISURERU5DRUxMOiAzMiwgLy8gdGhlIGNlbGwgaXMgbmVlZGVkIHRvIG1haW50YWluIGNvbm5lY3Rpdml0eSwgYnV0IHRoZSBkYXRhIHZhbHVlcyBzaG91bGQgYmUgaWdub3JlZC5cbn07XG5cbmV4cG9ydCBjb25zdCBQb2ludEdob3N0VHlwZXMgPSB7XG4gIERVUExJQ0FURVBPSU5UOiAxLCAvLyB0aGUgY2VsbCBpcyBwcmVzZW50IG9uIG11bHRpcGxlIHByb2Nlc3NvcnNcbiAgSElEREVOUE9JTlQ6IDIsIC8vIHRoZSBwb2ludCBpcyBuZWVkZWQgdG8gbWFpbnRhaW4gY29ubmVjdGl2aXR5LCBidXQgdGhlIGRhdGEgdmFsdWVzIHNob3VsZCBiZSBpZ25vcmVkLlxufTtcblxuZXhwb3J0IGNvbnN0IEF0dHJpYnV0ZUNvcHlPcGVyYXRpb25zID0ge1xuICBDT1BZVFVQTEU6IDAsXG4gIElOVEVSUE9MQVRFOiAxLFxuICBQQVNTREFUQTogMixcbiAgQUxMQ09QWTogMywgLy8gYWxsIG9mIHRoZSBhYm92ZVxufTtcblxuZXhwb3J0IGNvbnN0IGdob3N0QXJyYXlOYW1lID0gJ3Z0a0dob3N0VHlwZSc7XG5cbmV4cG9ydCBjb25zdCBEZXNpcmVkT3V0cHV0UHJlY2lzaW9uID0ge1xuICBERUZBVUxUOiAwLCAvLyB1c2UgdGhlIHBvaW50IHR5cGUgdGhhdCBkb2VzIG5vdCB0cnVuY2F0ZSBhbnkgZGF0YVxuICBTSU5HTEU6IDEsIC8vIHVzZSBGbG9hdDMyQXJyYXlcbiAgRE9VQkxFOiAyLCAvLyB1c2UgRmxvYXQ2NEFycmF5XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIEF0dHJpYnV0ZUNvcHlPcGVyYXRpb25zLFxuICBBdHRyaWJ1dGVMaW1pdFR5cGVzLFxuICBBdHRyaWJ1dGVUeXBlcyxcbiAgQ2VsbEdob3N0VHlwZXMsXG4gIERlc2lyZWRPdXRwdXRQcmVjaXNpb24sXG4gIFBvaW50R2hvc3RUeXBlcyxcbiAgZ2hvc3RBcnJheU5hbWUsXG59O1xuIiwiaW1wb3J0IHZ0ayBmcm9tICd2dGsuanMvU291cmNlcy92dGsnO1xuaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB2dGtEYXRhQXJyYXkgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvRGF0YUFycmF5JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrRmllbGREYXRhIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrRmllbGREYXRhKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrRmllbGREYXRhJyk7XG4gIGNvbnN0IHN1cGVyR2V0U3RhdGUgPSBwdWJsaWNBUEkuZ2V0U3RhdGU7XG5cbiAgLy8gRGVjb2RlIHNlcmlhbGl6ZWQgZGF0YSBpZiBhbnlcbiAgaWYgKG1vZGVsLmFycmF5cykge1xuICAgIG1vZGVsLmFycmF5cyA9IG1vZGVsLmFycmF5cy5tYXAoKGl0ZW0pID0+ICh7IGRhdGE6IHZ0ayhpdGVtLmRhdGEpIH0pKTtcbiAgfVxuXG4gIHB1YmxpY0FQSS5pbml0aWFsaXplID0gKCkgPT4ge1xuICAgIHB1YmxpY0FQSS5pbml0aWFsaXplRmllbGRzKCk7XG4gICAgcHVibGljQVBJLmNvcHlBbGxPbigpO1xuICAgIHB1YmxpY0FQSS5jbGVhckZpZWxkRmxhZ3MoKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuaW5pdGlhbGl6ZUZpZWxkcyA9ICgpID0+IHtcbiAgICBtb2RlbC5hcnJheXMgPSBbXTtcbiAgICBtb2RlbC5jb3B5RmllbGRGbGFncyA9IHt9O1xuICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5jb3B5U3RydWN0dXJlID0gKG90aGVyKSA9PiB7XG4gICAgcHVibGljQVBJLmluaXRpYWxpemVGaWVsZHMoKTtcbiAgICBtb2RlbC5jb3B5RmllbGRGbGFncyA9IG90aGVyLmdldENvcHlGaWVsZEZsYWdzKCkubWFwKCh4KSA9PiB4KTsgLy8gRGVlcC1jb3B5XG4gICAgbW9kZWwuYXJyYXlzID0gb3RoZXIuYXJyYXlzKCkubWFwKCh4KSA9PiAoeyBhcnJheTogeCB9KSk7IC8vIERlZXAtY29weVxuICAgIC8vIFRPRE86IENvcHkgYXJyYXkgaW5mb3JtYXRpb24gb2JqZWN0cyAob25jZSB3ZSBzdXBwb3J0IGluZm9ybWF0aW9uIG9iamVjdHMpXG4gIH07XG5cbiAgcHVibGljQVBJLmdldE51bWJlck9mQXJyYXlzID0gKCkgPT4gbW9kZWwuYXJyYXlzLmxlbmd0aDtcbiAgcHVibGljQVBJLmdldE51bWJlck9mQWN0aXZlQXJyYXlzID0gKCkgPT4gbW9kZWwuYXJyYXlzLmxlbmd0aDtcbiAgcHVibGljQVBJLmFkZEFycmF5ID0gKGFycikgPT4ge1xuICAgIG1vZGVsLmFycmF5cyA9IFtdLmNvbmNhdChtb2RlbC5hcnJheXMsIHsgZGF0YTogYXJyIH0pO1xuICAgIHJldHVybiBtb2RlbC5hcnJheXMubGVuZ3RoIC0gMTtcbiAgfTtcbiAgcHVibGljQVBJLnJlbW92ZUFsbEFycmF5cyA9ICgpID0+IHtcbiAgICBtb2RlbC5hcnJheXMgPSBbXTtcbiAgfTtcbiAgcHVibGljQVBJLnJlbW92ZUFycmF5ID0gKGFycmF5TmFtZSkgPT4ge1xuICAgIG1vZGVsLmFycmF5cyA9IG1vZGVsLmFycmF5cy5maWx0ZXIoXG4gICAgICAoZW50cnkpID0+IGFycmF5TmFtZSAhPT0gZW50cnkuZGF0YS5nZXROYW1lKClcbiAgICApO1xuICB9O1xuICBwdWJsaWNBUEkucmVtb3ZlQXJyYXlCeUluZGV4ID0gKGFycmF5SWR4KSA9PiB7XG4gICAgbW9kZWwuYXJyYXlzID0gbW9kZWwuYXJyYXlzLmZpbHRlcigoZW50cnksIGlkeCkgPT4gaWR4ICE9PSBhcnJheUlkeCk7XG4gIH07XG4gIHB1YmxpY0FQSS5nZXRBcnJheXMgPSAoKSA9PiBtb2RlbC5hcnJheXMubWFwKChlbnRyeSkgPT4gZW50cnkuZGF0YSk7XG4gIHB1YmxpY0FQSS5nZXRBcnJheSA9IChhcnJheVNwZWMpID0+XG4gICAgdHlwZW9mIGFycmF5U3BlYyA9PT0gJ251bWJlcidcbiAgICAgID8gcHVibGljQVBJLmdldEFycmF5QnlJbmRleChhcnJheVNwZWMpXG4gICAgICA6IHB1YmxpY0FQSS5nZXRBcnJheUJ5TmFtZShhcnJheVNwZWMpO1xuICBwdWJsaWNBUEkuZ2V0QXJyYXlCeU5hbWUgPSAoYXJyYXlOYW1lKSA9PlxuICAgIG1vZGVsLmFycmF5cy5yZWR1Y2UoXG4gICAgICAoYSwgYiwgaSkgPT4gKGIuZGF0YS5nZXROYW1lKCkgPT09IGFycmF5TmFtZSA/IGIuZGF0YSA6IGEpLFxuICAgICAgbnVsbFxuICAgICk7XG4gIHB1YmxpY0FQSS5nZXRBcnJheVdpdGhJbmRleCA9IChhcnJheU5hbWUpID0+XG4gICAgbW9kZWwuYXJyYXlzLnJlZHVjZShcbiAgICAgIChhLCBiLCBpKSA9PlxuICAgICAgICBiLmRhdGEgJiYgYi5kYXRhLmdldE5hbWUoKSA9PT0gYXJyYXlOYW1lXG4gICAgICAgICAgPyB7IGFycmF5OiBiLmRhdGEsIGluZGV4OiBpIH1cbiAgICAgICAgICA6IGEsXG4gICAgICB7IGFycmF5OiBudWxsLCBpbmRleDogLTEgfVxuICAgICk7XG4gIHB1YmxpY0FQSS5nZXRBcnJheUJ5SW5kZXggPSAoaWR4KSA9PlxuICAgIGlkeCA+PSAwICYmIGlkeCA8IG1vZGVsLmFycmF5cy5sZW5ndGggPyBtb2RlbC5hcnJheXNbaWR4XS5kYXRhIDogbnVsbDtcbiAgcHVibGljQVBJLmhhc0FycmF5ID0gKGFycmF5TmFtZSkgPT5cbiAgICBwdWJsaWNBUEkuZ2V0QXJyYXlXaXRoSW5kZXgoYXJyYXlOYW1lKS5pbmRleCA+PSAwO1xuICBwdWJsaWNBUEkuZ2V0QXJyYXlOYW1lID0gKGlkeCkgPT4ge1xuICAgIGNvbnN0IGFyciA9IG1vZGVsLmFycmF5c1tpZHhdO1xuICAgIHJldHVybiBhcnIgPyBhcnIuZGF0YS5nZXROYW1lKCkgOiAnJztcbiAgfTtcbiAgcHVibGljQVBJLmdldENvcHlGaWVsZEZsYWdzID0gKCkgPT4gbW9kZWwuY29weUZpZWxkRmxhZ3M7XG4gIHB1YmxpY0FQSS5nZXRGbGFnID0gKGFycmF5TmFtZSkgPT4gbW9kZWwuY29weUZpZWxkRmxhZ3NbYXJyYXlOYW1lXTtcbiAgcHVibGljQVBJLnBhc3NEYXRhID0gKG90aGVyLCBmcm9tSWQgPSAtMSwgdG9JZCA9IC0xKSA9PiB7XG4gICAgb3RoZXIuZ2V0QXJyYXlzKCkuZm9yRWFjaCgoYXJyKSA9PiB7XG4gICAgICBjb25zdCBjb3B5RmxhZyA9IHB1YmxpY0FQSS5nZXRGbGFnKGFyci5nZXROYW1lKCkpO1xuICAgICAgaWYgKFxuICAgICAgICBjb3B5RmxhZyAhPT0gZmFsc2UgJiZcbiAgICAgICAgIShtb2RlbC5kb0NvcHlBbGxPZmYgJiYgY29weUZsYWcgIT09IHRydWUpICYmXG4gICAgICAgIGFyclxuICAgICAgKSB7XG4gICAgICAgIGxldCBkZXN0QXJyID0gcHVibGljQVBJLmdldEFycmF5QnlOYW1lKGFyci5nZXROYW1lKCkpO1xuICAgICAgICBpZiAoIWRlc3RBcnIpIHtcbiAgICAgICAgICBpZiAoZnJvbUlkIDwgMCB8fCBmcm9tSWQgPiBhcnIuZ2V0TnVtYmVyT2ZUdXBsZXMoKSkge1xuICAgICAgICAgICAgcHVibGljQVBJLmFkZEFycmF5KGFycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5jb21wcyA9IGFyci5nZXROdW1iZXJPZkNvbXBvbmVudHMoKTtcbiAgICAgICAgICAgIGxldCBuZXdTaXplID0gYXJyLmdldE51bWJlck9mVmFsdWVzKCk7XG4gICAgICAgICAgICBjb25zdCB0SWQgPSB0b0lkID4gLTEgPyB0b0lkIDogZnJvbUlkO1xuICAgICAgICAgICAgaWYgKG5ld1NpemUgPCB0SWQgKiBuY29tcHMpIHtcbiAgICAgICAgICAgICAgbmV3U2l6ZSA9ICh0SWQgKyAxKSAqIG5jb21wcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3RBcnIgPSB2dGtEYXRhQXJyYXkubmV3SW5zdGFuY2Uoe1xuICAgICAgICAgICAgICBuYW1lOiBhcnIuZ2V0TmFtZSgpLFxuICAgICAgICAgICAgICBkYXRhVHlwZTogYXJyLmdldERhdGFUeXBlKCksXG4gICAgICAgICAgICAgIG51bWJlck9mQ29tcG9uZW50czogYXJyLmdldE51bWJlck9mQ29tcG9uZW50cygpLFxuICAgICAgICAgICAgICBzaXplOiBuZXdTaXplLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZXN0QXJyLnNldFR1cGxlKHRJZCwgYXJyLmdldFR1cGxlKGZyb21JZCkpO1xuICAgICAgICAgICAgcHVibGljQVBJLmFkZEFycmF5KGRlc3RBcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBhcnIuZ2V0TnVtYmVyT2ZDb21wb25lbnRzKCkgPT09IGRlc3RBcnIuZ2V0TnVtYmVyT2ZDb21wb25lbnRzKClcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGZyb21JZCA+IC0xICYmIGZyb21JZCA8IGFyci5nZXROdW1iZXJPZlR1cGxlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB0SWQgPSB0b0lkID4gLTEgPyB0b0lkIDogZnJvbUlkO1xuICAgICAgICAgICAgZGVzdEFyci5zZXRUdXBsZSh0SWQsIGFyci5nZXRUdXBsZShmcm9tSWQpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgZnJvbUlkIGFuZCBub3QgcHJvdmlkZWQsIGp1c3QgY29weSBhbGwgKG9yIGFzIG11Y2ggcG9zc2libGUpXG4gICAgICAgICAgICAvLyBvZiBhcnIgdG8gZGVzdEFyci5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmdldE51bWJlck9mVHVwbGVzKCk7ICsraSkge1xuICAgICAgICAgICAgICBkZXN0QXJyLnNldFR1cGxlKGksIGFyci5nZXRUdXBsZShpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHB1YmxpY0FQSS5jb3B5RmllbGRPbiA9IChhcnJheU5hbWUpID0+IHtcbiAgICBtb2RlbC5jb3B5RmllbGRGbGFnc1thcnJheU5hbWVdID0gdHJ1ZTtcbiAgfTtcbiAgcHVibGljQVBJLmNvcHlGaWVsZE9mZiA9IChhcnJheU5hbWUpID0+IHtcbiAgICBtb2RlbC5jb3B5RmllbGRGbGFnc1thcnJheU5hbWVdID0gZmFsc2U7XG4gIH07XG4gIHB1YmxpY0FQSS5jb3B5QWxsT24gPSAoKSA9PiB7XG4gICAgaWYgKCFtb2RlbC5kb0NvcHlBbGxPbiB8fCBtb2RlbC5kb0NvcHlBbGxPZmYpIHtcbiAgICAgIG1vZGVsLmRvQ29weUFsbE9uID0gdHJ1ZTtcbiAgICAgIG1vZGVsLmRvQ29weUFsbE9mZiA9IGZhbHNlO1xuICAgICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gICAgfVxuICB9O1xuICBwdWJsaWNBUEkuY29weUFsbE9mZiA9ICgpID0+IHtcbiAgICBpZiAobW9kZWwuZG9Db3B5QWxsT24gfHwgIW1vZGVsLmRvQ29weUFsbE9mZikge1xuICAgICAgbW9kZWwuZG9Db3B5QWxsT24gPSBmYWxzZTtcbiAgICAgIG1vZGVsLmRvQ29weUFsbE9mZiA9IHRydWU7XG4gICAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgICB9XG4gIH07XG4gIHB1YmxpY0FQSS5jbGVhckZpZWxkRmxhZ3MgPSAoKSA9PiB7XG4gICAgbW9kZWwuY29weUZpZWxkRmxhZ3MgPSB7fTtcbiAgfTtcbiAgcHVibGljQVBJLmRlZXBDb3B5ID0gKG90aGVyKSA9PiB7XG4gICAgbW9kZWwuYXJyYXlzID0gb3RoZXIuZ2V0QXJyYXlzKCkubWFwKChhcnIpID0+IHtcbiAgICAgIGNvbnN0IGFyck5ldyA9IGFyci5uZXdDbG9uZSgpO1xuICAgICAgYXJyTmV3LmRlZXBDb3B5KGFycik7XG4gICAgICByZXR1cm4geyBkYXRhOiBhcnJOZXcgfTtcbiAgICB9KTtcbiAgfTtcbiAgcHVibGljQVBJLmNvcHlGbGFncyA9IChvdGhlcikgPT4gb3RoZXIuZ2V0Q29weUZpZWxkRmxhZ3MoKS5tYXAoKHgpID0+IHgpO1xuICAvLyBUT0RPOiBwdWJsaWNBUEkuc3F1ZWV6ZSA9ICgpID0+IG1vZGVsLmFycmF5cy5mb3JFYWNoKGVudHJ5ID0+IGVudHJ5LmRhdGEuc3F1ZWV6ZSgpKTtcbiAgcHVibGljQVBJLnJlc2V0ID0gKCkgPT4gbW9kZWwuYXJyYXlzLmZvckVhY2goKGVudHJ5KSA9PiBlbnRyeS5kYXRhLnJlc2V0KCkpO1xuICAvLyBUT0RPOiBnZXRBY3R1YWxNZW1vcnlTaXplXG4gIHB1YmxpY0FQSS5nZXRNVGltZSA9ICgpID0+XG4gICAgbW9kZWwuYXJyYXlzLnJlZHVjZShcbiAgICAgIChhLCBiKSA9PiAoYi5kYXRhLmdldE1UaW1lKCkgPiBhID8gYi5kYXRhLmdldE1UaW1lKCkgOiBhKSxcbiAgICAgIG1vZGVsLm10aW1lXG4gICAgKTtcbiAgLy8gVE9ETzogcHVibGljQVBJLmdldEZpZWxkID0gKGlkcywgb3RoZXIpID0+IHsgY29weSBpZHMgZnJvbSBvdGhlciBpbnRvIHRoaXMgbW9kZWwncyBhcnJheXMgfVxuICAvLyBUT0RPOiBwdWJsaWNBUEkuZ2V0QXJyYXlDb250YWluaW5nQ29tcG9uZW50ID0gKGNvbXBvbmVudCkgPT4gLi4uXG4gIHB1YmxpY0FQSS5nZXROdW1iZXJPZkNvbXBvbmVudHMgPSAoKSA9PlxuICAgIG1vZGVsLmFycmF5cy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLmRhdGEuZ2V0TnVtYmVyT2ZDb21wb25lbnRzKCksIDApO1xuICBwdWJsaWNBUEkuZ2V0TnVtYmVyT2ZUdXBsZXMgPSAoKSA9PlxuICAgIG1vZGVsLmFycmF5cy5sZW5ndGggPiAwID8gbW9kZWwuYXJyYXlzWzBdLmdldE51bWJlck9mVHVwbGVzKCkgOiAwO1xuXG4gIHB1YmxpY0FQSS5nZXRTdGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlckdldFN0YXRlKCk7XG4gICAgcmVzdWx0LmFycmF5cyA9IG1vZGVsLmFycmF5cy5tYXAoKGl0ZW0pID0+ICh7XG4gICAgICBkYXRhOiBpdGVtLmRhdGEuZ2V0U3RhdGUoKSxcbiAgICB9KSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIGFycmF5czogW10sXG4gIGNvcHlGaWVsZEZsYWdzOiBbXSwgLy8gZmllbGRzIG5vdCB0byBjb3B5XG4gIGRvQ29weUFsbE9uOiB0cnVlLFxuICBkb0NvcHlBbGxPZmY6IGZhbHNlLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIG1hY3JvLm9iaihwdWJsaWNBUEksIG1vZGVsKTtcblxuICB2dGtGaWVsZERhdGEocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrRmllbGREYXRhJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kIH07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0IHZ0a0ZpZWxkRGF0YSBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0RhdGFTZXRBdHRyaWJ1dGVzL0ZpZWxkRGF0YSc7XG5pbXBvcnQgQ29uc3RhbnRzIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvRGF0YVNldEF0dHJpYnV0ZXMvQ29uc3RhbnRzJztcbmltcG9ydCB2dGtEYXRhQXJyYXkgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvRGF0YUFycmF5JztcblxuY29uc3QgeyBBdHRyaWJ1dGVUeXBlcywgQXR0cmlidXRlQ29weU9wZXJhdGlvbnMgfSA9IENvbnN0YW50cztcbmNvbnN0IHsgdnRrV2FybmluZ01hY3JvIH0gPSBtYWNybztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrRGF0YVNldEF0dHJpYnV0ZXMgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtEYXRhU2V0QXR0cmlidXRlcyhwdWJsaWNBUEksIG1vZGVsKSB7XG4gIGNvbnN0IGF0dHJUeXBlcyA9IFtcbiAgICAnU2NhbGFycycsXG4gICAgJ1ZlY3RvcnMnLFxuICAgICdOb3JtYWxzJyxcbiAgICAnVENvb3JkcycsXG4gICAgJ1RlbnNvcnMnLFxuICAgICdHbG9iYWxJZHMnLFxuICAgICdQZWRpZ3JlZUlkcycsXG4gIF07XG5cbiAgZnVuY3Rpb24gY2xlYW5BdHRyaWJ1dGVUeXBlKGF0dFR5cGUpIHtcbiAgICAvLyBHaXZlbiBhbiBpbnRlZ2VyIG9yIHN0cmluZywgY29udmVydCB0aGUgcmVzdWx0IHRvIG9uZSBvZiB0aGVcbiAgICAvLyBzdHJpbmdzIGluIHRoZSBcImF0dHJUeXBlc1wiIGFycmF5IGFib3ZlIG9yIG51bGwgKGlmXG4gICAgLy8gbm8gbWF0Y2ggaXMgZm91bmQpXG4gICAgbGV0IGNsZWFuQXR0VHlwZSA9IGF0dHJUeXBlcy5maW5kKFxuICAgICAgKGVlKSA9PlxuICAgICAgICBBdHRyaWJ1dGVUeXBlc1tlZS50b1VwcGVyQ2FzZSgpXSA9PT0gYXR0VHlwZSB8fFxuICAgICAgICAodHlwZW9mIGF0dFR5cGUgIT09ICdudW1iZXInICYmXG4gICAgICAgICAgZWUudG9Mb3dlckNhc2UoKSA9PT0gYXR0VHlwZS50b0xvd2VyQ2FzZSgpKVxuICAgICk7XG4gICAgaWYgKHR5cGVvZiBjbGVhbkF0dFR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjbGVhbkF0dFR5cGUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY2xlYW5BdHRUeXBlO1xuICB9XG5cbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrRGF0YVNldEF0dHJpYnV0ZXMnKTtcblxuICBwdWJsaWNBUEkuY2hlY2tOdW1iZXJPZkNvbXBvbmVudHMgPSAoeCkgPT4gdHJ1ZTsgLy8gVE9ET1xuXG4gIHB1YmxpY0FQSS5zZXRBdHRyaWJ1dGUgPSAoYXJyLCB1bmNsZWFuQXR0VHlwZSkgPT4ge1xuICAgIGNvbnN0IGF0dFR5cGUgPSBjbGVhbkF0dHJpYnV0ZVR5cGUodW5jbGVhbkF0dFR5cGUpO1xuICAgIGlmIChcbiAgICAgIGFyciAmJlxuICAgICAgYXR0VHlwZS50b1VwcGVyQ2FzZSgpID09PSAnUEVESUdSRUVJRFMnICYmXG4gICAgICAhYXJyLmlzQSgndnRrRGF0YUFycmF5JylcbiAgICApIHtcbiAgICAgIHZ0a1dhcm5pbmdNYWNybyhcbiAgICAgICAgYENhbm5vdCBzZXQgYXR0cmlidXRlICR7YXR0VHlwZX0uIFRoZSBhdHRyaWJ1dGUgbXVzdCBiZSBhIHZ0a0RhdGFBcnJheS5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYXJyICYmICFwdWJsaWNBUEkuY2hlY2tOdW1iZXJPZkNvbXBvbmVudHMoYXJyLCBhdHRUeXBlKSkge1xuICAgICAgdnRrV2FybmluZ01hY3JvKFxuICAgICAgICBgQ2Fubm90IHNldCBhdHRyaWJ1dGUgJHthdHRUeXBlfS4gSW5jb3JyZWN0IG51bWJlciBvZiBjb21wb25lbnRzLmBcbiAgICAgICk7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGxldCBjdXJyZW50QXR0cmlidXRlID0gbW9kZWxbYGFjdGl2ZSR7YXR0VHlwZX1gXTtcbiAgICBpZiAoY3VycmVudEF0dHJpYnV0ZSA+PSAwICYmIGN1cnJlbnRBdHRyaWJ1dGUgPCBtb2RlbC5hcnJheXMubGVuZ3RoKSB7XG4gICAgICBpZiAobW9kZWwuYXJyYXlzW2N1cnJlbnRBdHRyaWJ1dGVdID09PSBhcnIpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRBdHRyaWJ1dGU7XG4gICAgICB9XG4gICAgICBwdWJsaWNBUEkucmVtb3ZlQXJyYXlCeUluZGV4KGN1cnJlbnRBdHRyaWJ1dGUpO1xuICAgIH1cblxuICAgIGlmIChhcnIpIHtcbiAgICAgIGN1cnJlbnRBdHRyaWJ1dGUgPSBwdWJsaWNBUEkuYWRkQXJyYXkoYXJyKTtcbiAgICAgIG1vZGVsW2BhY3RpdmUke2F0dFR5cGV9YF0gPSBjdXJyZW50QXR0cmlidXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbFtgYWN0aXZlJHthdHRUeXBlfWBdID0gLTE7XG4gICAgfVxuICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICAgIHJldHVybiBtb2RlbFtgYWN0aXZlJHthdHRUeXBlfWBdO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRBY3RpdmVBdHRyaWJ1dGVCeU5hbWUgPSAoYXJyYXlOYW1lLCBhdHRUeXBlKSA9PlxuICAgIHB1YmxpY0FQSS5zZXRBY3RpdmVBdHRyaWJ1dGVCeUluZGV4KFxuICAgICAgcHVibGljQVBJLmdldEFycmF5V2l0aEluZGV4KGFycmF5TmFtZSkuaW5kZXgsXG4gICAgICBhdHRUeXBlXG4gICAgKTtcblxuICBwdWJsaWNBUEkuc2V0QWN0aXZlQXR0cmlidXRlQnlJbmRleCA9IChhcnJheUlkeCwgdW5jbGVhbkF0dFR5cGUpID0+IHtcbiAgICBjb25zdCBhdHRUeXBlID0gY2xlYW5BdHRyaWJ1dGVUeXBlKHVuY2xlYW5BdHRUeXBlKTtcbiAgICBpZiAoYXJyYXlJZHggPj0gMCAmJiBhcnJheUlkeCA8IG1vZGVsLmFycmF5cy5sZW5ndGgpIHtcbiAgICAgIGlmIChhdHRUeXBlLnRvVXBwZXJDYXNlKCkgIT09ICdQRURJR1JFRUlEUycpIHtcbiAgICAgICAgY29uc3QgYXJyID0gcHVibGljQVBJLmdldEFycmF5QnlJbmRleChhcnJheUlkeCk7XG4gICAgICAgIGlmICghYXJyLmlzQSgndnRrRGF0YUFycmF5JykpIHtcbiAgICAgICAgICB2dGtXYXJuaW5nTWFjcm8oXG4gICAgICAgICAgICBgQ2Fubm90IHNldCBhdHRyaWJ1dGUgJHthdHRUeXBlfS4gT25seSB2dGtEYXRhQXJyYXkgc3ViY2xhc3NlcyBjYW4gYmUgc2V0IGFzIGFjdGl2ZSBhdHRyaWJ1dGVzLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXB1YmxpY0FQSS5jaGVja051bWJlck9mQ29tcG9uZW50cyhhcnIsIGF0dFR5cGUpKSB7XG4gICAgICAgICAgdnRrV2FybmluZ01hY3JvKFxuICAgICAgICAgICAgYENhbm5vdCBzZXQgYXR0cmlidXRlICR7YXR0VHlwZX0uIEluY29ycmVjdCBudW1iZXIgb2YgY29tcG9uZW50cy5gXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1vZGVsW2BhY3RpdmUke2F0dFR5cGV9YF0gPSBhcnJheUlkeDtcbiAgICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICAgICAgcmV0dXJuIGFycmF5SWR4O1xuICAgIH1cblxuICAgIGlmIChhcnJheUlkeCA9PT0gLTEpIHtcbiAgICAgIG1vZGVsW2BhY3RpdmUke2F0dFR5cGV9YF0gPSBhcnJheUlkeDtcbiAgICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0QWN0aXZlQXR0cmlidXRlID0gKGF0dFR5cGUpID0+IHtcbiAgICAvLyBHaXZlbiBhbiBpbnRlZ2VyIGVudW0gdmFsdWUgb3IgYSBzdHJpbmcgKHdpdGggcmFuZG9tIGNhcGl0YWxpemF0aW9uKSxcbiAgICAvLyBmaW5kIHRoZSBtYXRjaGluZyBzdHJpbmcgaW4gYXR0clR5cGVzLlxuICAgIGNvbnN0IGNsZWFuQXR0VHlwZSA9IGNsZWFuQXR0cmlidXRlVHlwZShhdHRUeXBlKTtcbiAgICByZXR1cm4gcHVibGljQVBJW2BnZXQke2NsZWFuQXR0VHlwZX1gXSgpO1xuICB9O1xuXG4gIC8vIE92ZXJyaWRlIHRvIGFsbG93IHByb3BlciBoYW5kbGluZyBvZiBhY3RpdmUgYXR0cmlidXRlc1xuICBwdWJsaWNBUEkucmVtb3ZlQWxsQXJyYXlzID0gKCkgPT4ge1xuICAgIG1vZGVsLmFycmF5cyA9IFtdO1xuICAgIGF0dHJUeXBlcy5mb3JFYWNoKChhdHRUeXBlKSA9PiB7XG4gICAgICBtb2RlbFtgYWN0aXZlJHthdHRUeXBlfWBdID0gLTE7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gT3ZlcnJpZGUgdG8gYWxsb3cgcHJvcGVyIGhhbmRsaW5nIG9mIGFjdGl2ZSBhdHRyaWJ1dGVzXG4gIHB1YmxpY0FQSS5yZW1vdmVBcnJheSA9IChhcnJheU5hbWUpID0+IHtcbiAgICBtb2RlbC5hcnJheXMgPSBtb2RlbC5hcnJheXMuZmlsdGVyKChlbnRyeSwgaWR4KSA9PiB7XG4gICAgICBpZiAoYXJyYXlOYW1lID09PSBlbnRyeS5kYXRhLmdldE5hbWUoKSkge1xuICAgICAgICAvLyBGb3VuZCB0aGUgYXJyYXkgdG8gcmVtb3ZlLCBidXQgaXMgaXQgYW4gYWN0aXZlIGF0dHJpYnV0ZT9cbiAgICAgICAgYXR0clR5cGVzLmZvckVhY2goKGF0dFR5cGUpID0+IHtcbiAgICAgICAgICBpZiAoaWR4ID09PSBtb2RlbFtgYWN0aXZlJHthdHRUeXBlfWBdKSB7XG4gICAgICAgICAgICBtb2RlbFtgYWN0aXZlJHthdHRUeXBlfWBdID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gT3ZlcnJpZGUgdG8gYWxsb3cgcHJvcGVyIGhhbmRsaW5nIG9mIGFjdGl2ZSBhdHRyaWJ1dGVzXG4gIHB1YmxpY0FQSS5yZW1vdmVBcnJheUJ5SW5kZXggPSAoYXJyYXlJZHgpID0+IHtcbiAgICBtb2RlbC5hcnJheXMgPSBtb2RlbC5hcnJheXMuZmlsdGVyKChlbnRyeSwgaWR4KSA9PiBpZHggIT09IGFycmF5SWR4KTtcbiAgICBhdHRyVHlwZXMuZm9yRWFjaCgoYXR0VHlwZSkgPT4ge1xuICAgICAgaWYgKGFycmF5SWR4ID09PSBtb2RlbFtgYWN0aXZlJHthdHRUeXBlfWBdKSB7XG4gICAgICAgIG1vZGVsW2BhY3RpdmUke2F0dFR5cGV9YF0gPSAtMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBhdHRyVHlwZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICBjb25zdCBhY3RpdmVWYWwgPSBgYWN0aXZlJHt2YWx1ZX1gO1xuICAgIHB1YmxpY0FQSVtgZ2V0JHt2YWx1ZX1gXSA9ICgpID0+XG4gICAgICBwdWJsaWNBUEkuZ2V0QXJyYXlCeUluZGV4KG1vZGVsW2FjdGl2ZVZhbF0pO1xuICAgIHB1YmxpY0FQSVtgc2V0JHt2YWx1ZX1gXSA9IChkYSkgPT4gcHVibGljQVBJLnNldEF0dHJpYnV0ZShkYSwgdmFsdWUpO1xuICAgIHB1YmxpY0FQSVtgc2V0QWN0aXZlJHt2YWx1ZX1gXSA9IChhcnJheU5hbWUpID0+XG4gICAgICBwdWJsaWNBUEkuc2V0QWN0aXZlQXR0cmlidXRlQnlJbmRleChcbiAgICAgICAgcHVibGljQVBJLmdldEFycmF5V2l0aEluZGV4KGFycmF5TmFtZSkuaW5kZXgsXG4gICAgICAgIHZhbHVlXG4gICAgICApO1xuICAgIHB1YmxpY0FQSVtgY29weSR7dmFsdWV9T2ZmYF0gPSAoKSA9PiB7XG4gICAgICBjb25zdCBhdHRUeXBlID0gdmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICAgIG1vZGVsLmNvcHlBdHRyaWJ1dGVGbGFnc1tBdHRyaWJ1dGVDb3B5T3BlcmF0aW9ucy5QQVNTREFUQV1bXG4gICAgICAgIEF0dHJpYnV0ZVR5cGVzW2F0dFR5cGVdXG4gICAgICBdID0gZmFsc2U7XG4gICAgfTtcbiAgfSk7XG5cbiAgcHVibGljQVBJLmluaXRpYWxpemVBdHRyaWJ1dGVDb3B5RmxhZ3MgPSAoKSA9PiB7XG4gICAgLy8gRGVmYXVsdCB0byBjb3B5aW5nIGFsbCBhdHRyaWJ1dGVzIGluIGV2ZXJ5IGNpcmN1bXN0YW5jZTpcbiAgICBtb2RlbC5jb3B5QXR0cmlidXRlRmxhZ3MgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhBdHRyaWJ1dGVDb3B5T3BlcmF0aW9ucylcbiAgICAgIC5maWx0ZXIoKG9wKSA9PiBvcCAhPT0gJ0FMTENPUFknKVxuICAgICAgLmZvckVhY2goKGF0dENvcHlPcCkgPT4ge1xuICAgICAgICBtb2RlbC5jb3B5QXR0cmlidXRlRmxhZ3NbXG4gICAgICAgICAgQXR0cmlidXRlQ29weU9wZXJhdGlvbnNbYXR0Q29weU9wXVxuICAgICAgICBdID0gT2JqZWN0LmtleXMoQXR0cmlidXRlVHlwZXMpXG4gICAgICAgICAgLmZpbHRlcigodHkpID0+IHR5ICE9PSAnTlVNX0FUVFJJQlVURVMnKVxuICAgICAgICAgIC5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGFbQXR0cmlidXRlVHlwZXNbYl1dID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgIH0sIFtdKTtcbiAgICAgIH0pO1xuICAgIC8vIE92ZXJyaWRlIHNvbWUgb3BlcmF0aW9ucyB3aGVyZSB3ZSBkb24ndCB3YW50IHRvIGNvcHk6XG4gICAgbW9kZWwuY29weUF0dHJpYnV0ZUZsYWdzW0F0dHJpYnV0ZUNvcHlPcGVyYXRpb25zLkNPUFlUVVBMRV1bXG4gICAgICBBdHRyaWJ1dGVUeXBlcy5HTE9CQUxJRFNcbiAgICBdID0gZmFsc2U7XG4gICAgbW9kZWwuY29weUF0dHJpYnV0ZUZsYWdzW0F0dHJpYnV0ZUNvcHlPcGVyYXRpb25zLklOVEVSUE9MQVRFXVtcbiAgICAgIEF0dHJpYnV0ZVR5cGVzLkdMT0JBTElEU1xuICAgIF0gPSBmYWxzZTtcbiAgICBtb2RlbC5jb3B5QXR0cmlidXRlRmxhZ3NbQXR0cmlidXRlQ29weU9wZXJhdGlvbnMuQ09QWVRVUExFXVtcbiAgICAgIEF0dHJpYnV0ZVR5cGVzLlBFRElHUkVFSURTXG4gICAgXSA9IGZhbHNlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5pbml0aWFsaXplID0gbWFjcm8uY2hhaW4oXG4gICAgcHVibGljQVBJLmluaXRpYWxpemUsXG4gICAgcHVibGljQVBJLmluaXRpYWxpemVBdHRyaWJ1dGVDb3B5RmxhZ3NcbiAgKTtcblxuICAvLyBQcm9jZXNzIGRhdGFBcnJheXMgaWYgYW55XG4gIGlmIChtb2RlbC5kYXRhQXJyYXlzICYmIE9iamVjdC5rZXlzKG1vZGVsLmRhdGFBcnJheXMpLmxlbmd0aCkge1xuICAgIE9iamVjdC5rZXlzKG1vZGVsLmRhdGFBcnJheXMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgIW1vZGVsLmRhdGFBcnJheXNbbmFtZV0ucmVmICYmXG4gICAgICAgIG1vZGVsLmRhdGFBcnJheXNbbmFtZV0udHlwZSA9PT0gJ3Z0a0RhdGFBcnJheSdcbiAgICAgICkge1xuICAgICAgICBwdWJsaWNBUEkuYWRkQXJyYXkodnRrRGF0YUFycmF5Lm5ld0luc3RhbmNlKG1vZGVsLmRhdGFBcnJheXNbbmFtZV0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHN1cGVyU2hhbGxvd0NvcHkgPSBwdWJsaWNBUEkuc2hhbGxvd0NvcHk7XG4gIHB1YmxpY0FQSS5zaGFsbG93Q29weSA9IChvdGhlciwgZGVidWcpID0+IHtcbiAgICBzdXBlclNoYWxsb3dDb3B5KG90aGVyLCBkZWJ1Zyk7XG4gICAgbW9kZWwuYXJyYXlzID0gb3RoZXIuZ2V0QXJyYXlzKCkubWFwKChhcnIpID0+IHtcbiAgICAgIGNvbnN0IGFyck5ldyA9IGFyci5uZXdDbG9uZSgpO1xuICAgICAgYXJyTmV3LnNoYWxsb3dDb3B5KGFyciwgZGVidWcpO1xuICAgICAgcmV0dXJuIHsgZGF0YTogYXJyTmV3IH07XG4gICAgfSk7XG4gIH07XG5cbiAgcHVibGljQVBJLmluaXRpYWxpemVBdHRyaWJ1dGVDb3B5RmxhZ3MoKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIGFjdGl2ZVNjYWxhcnM6IC0xLFxuICBhY3RpdmVWZWN0b3JzOiAtMSxcbiAgYWN0aXZlVGVuc29yczogLTEsXG4gIGFjdGl2ZU5vcm1hbHM6IC0xLFxuICBhY3RpdmVUQ29vcmRzOiAtMSxcbiAgYWN0aXZlR2xvYmFsSWRzOiAtMSxcbiAgYWN0aXZlUGVkaWdyZWVJZHM6IC0xLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gT2JqZWN0IG1ldGhvZHNcbiAgdnRrRmllbGREYXRhLmV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzKTtcbiAgbWFjcm8uc2V0R2V0KHB1YmxpY0FQSSwgbW9kZWwsIFtcbiAgICAnYWN0aXZlU2NhbGFycycsXG4gICAgJ2FjdGl2ZU5vcm1hbHMnLFxuICAgICdhY3RpdmVUQ29vcmRzJyxcbiAgICAnYWN0aXZlVmVjdG9ycycsXG4gICAgJ2FjdGl2ZVRlbnNvcnMnLFxuICAgICdhY3RpdmVHbG9iYWxJZHMnLFxuICAgICdhY3RpdmVQZWRpZ3JlZUlkcycsXG4gIF0pO1xuXG4gIGlmICghbW9kZWwuYXJyYXlzKSB7XG4gICAgbW9kZWwuYXJyYXlzID0ge307XG4gIH1cblxuICAvLyBPYmplY3Qgc3BlY2lmaWMgbWV0aG9kc1xuICB2dGtEYXRhU2V0QXR0cmlidXRlcyhwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQsICd2dGtEYXRhU2V0QXR0cmlidXRlcycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCwgLi4uQ29uc3RhbnRzIH07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0ICogYXMgdnRrTWF0aCBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9NYXRoJztcbmltcG9ydCB2dGtCb3VuZGluZ0JveCBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0JvdW5kaW5nQm94JztcbmltcG9ydCB2dGtEYXRhU2V0IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvRGF0YVNldCc7XG5pbXBvcnQgdnRrU3RydWN0dXJlZERhdGEgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9TdHJ1Y3R1cmVkRGF0YSc7XG5pbXBvcnQgeyBTdHJ1Y3R1cmVkVHlwZSB9IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvU3RydWN0dXJlZERhdGEvQ29uc3RhbnRzJztcbmltcG9ydCB7IHZlYzMsIG1hdDMsIG1hdDQgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5jb25zdCB7IHZ0a0Vycm9yTWFjcm8gfSA9IG1hY3JvO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtJbWFnZURhdGEgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtJbWFnZURhdGEocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtJbWFnZURhdGEnKTtcblxuICBwdWJsaWNBUEkuc2V0RXh0ZW50ID0gKC4uLmluRXh0ZW50KSA9PiB7XG4gICAgaWYgKG1vZGVsLmRlbGV0ZWQpIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oJ2luc3RhbmNlIGRlbGV0ZWQgLSBjYW5ub3QgY2FsbCBhbnkgbWV0aG9kJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ZW50QXJyYXkgPSBpbkV4dGVudC5sZW5ndGggPT09IDEgPyBpbkV4dGVudFswXSA6IGluRXh0ZW50O1xuXG4gICAgaWYgKGV4dGVudEFycmF5Lmxlbmd0aCAhPT0gNikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCBjaGFuZ2VEZXRlY3RlZCA9IGZhbHNlO1xuICAgIG1vZGVsLmV4dGVudC5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGl0ZW0gIT09IGV4dGVudEFycmF5W2luZGV4XSkge1xuICAgICAgICBpZiAoY2hhbmdlRGV0ZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGNoYW5nZURldGVjdGVkKSB7XG4gICAgICBtb2RlbC5leHRlbnQgPSBleHRlbnRBcnJheS5zbGljZSgpO1xuICAgICAgbW9kZWwuZGF0YURlc2NyaXB0aW9uID0gdnRrU3RydWN0dXJlZERhdGEuZ2V0RGF0YURlc2NyaXB0aW9uRnJvbUV4dGVudChcbiAgICAgICAgbW9kZWwuZXh0ZW50XG4gICAgICApO1xuICAgICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VEZXRlY3RlZDtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0RGltZW5zaW9ucyA9ICguLi5kaW1zKSA9PiB7XG4gICAgbGV0IGk7XG4gICAgbGV0IGo7XG4gICAgbGV0IGs7XG5cbiAgICBpZiAobW9kZWwuZGVsZXRlZCkge1xuICAgICAgdnRrRXJyb3JNYWNybygnaW5zdGFuY2UgZGVsZXRlZCAtIGNhbm5vdCBjYWxsIGFueSBtZXRob2QnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGltcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGFycmF5ID0gZGltc1swXTtcbiAgICAgIGkgPSBhcnJheVswXTtcbiAgICAgIGogPSBhcnJheVsxXTtcbiAgICAgIGsgPSBhcnJheVsyXTtcbiAgICB9IGVsc2UgaWYgKGRpbXMubGVuZ3RoID09PSAzKSB7XG4gICAgICBpID0gZGltc1swXTtcbiAgICAgIGogPSBkaW1zWzFdO1xuICAgICAgayA9IGRpbXNbMl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oJ0JhZCBkaW1lbnNpb24gc3BlY2lmaWNhdGlvbicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHB1YmxpY0FQSS5zZXRFeHRlbnQoMCwgaSAtIDEsIDAsIGogLSAxLCAwLCBrIC0gMSk7XG4gIH07XG5cbiAgcHVibGljQVBJLmdldERpbWVuc2lvbnMgPSAoKSA9PiBbXG4gICAgbW9kZWwuZXh0ZW50WzFdIC0gbW9kZWwuZXh0ZW50WzBdICsgMSxcbiAgICBtb2RlbC5leHRlbnRbM10gLSBtb2RlbC5leHRlbnRbMl0gKyAxLFxuICAgIG1vZGVsLmV4dGVudFs1XSAtIG1vZGVsLmV4dGVudFs0XSArIDEsXG4gIF07XG5cbiAgcHVibGljQVBJLmdldE51bWJlck9mQ2VsbHMgPSAoKSA9PiB7XG4gICAgY29uc3QgZGltcyA9IHB1YmxpY0FQSS5nZXREaW1lbnNpb25zKCk7XG4gICAgbGV0IG5DZWxscyA9IDE7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgaWYgKGRpbXNbaV0gPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoZGltc1tpXSA+IDEpIHtcbiAgICAgICAgbkNlbGxzICo9IGRpbXNbaV0gLSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuQ2VsbHM7XG4gIH07XG5cbiAgcHVibGljQVBJLmdldE51bWJlck9mUG9pbnRzID0gKCkgPT4ge1xuICAgIGNvbnN0IGRpbXMgPSBwdWJsaWNBUEkuZ2V0RGltZW5zaW9ucygpO1xuICAgIHJldHVybiBkaW1zWzBdICogZGltc1sxXSAqIGRpbXNbMl07XG4gIH07XG5cbiAgcHVibGljQVBJLmdldFBvaW50ID0gKGluZGV4KSA9PiB7XG4gICAgY29uc3QgZGltcyA9IHB1YmxpY0FQSS5nZXREaW1lbnNpb25zKCk7XG4gICAgY29uc3QgaWprID0gdmVjMy5mcm9tVmFsdWVzKDAsIDAsIDApO1xuICAgIGNvbnN0IGNvb3JkcyA9IFswLCAwLCAwXTtcblxuICAgIGlmIChkaW1zWzBdID09PSAwIHx8IGRpbXNbMV0gPT09IDAgfHwgZGltc1syXSA9PT0gMCkge1xuICAgICAgdnRrRXJyb3JNYWNybygnUmVxdWVzdGluZyBhIHBvaW50IGZyb20gYW4gZW1wdHkgaW1hZ2UuJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG1vZGVsLmRhdGFEZXNjcmlwdGlvbikge1xuICAgICAgY2FzZSBTdHJ1Y3R1cmVkVHlwZS5FTVBUWTpcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNhc2UgU3RydWN0dXJlZFR5cGUuU0lOR0xFX1BPSU5UOlxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdHJ1Y3R1cmVkVHlwZS5YX0xJTkU6XG4gICAgICAgIGlqa1swXSA9IGluZGV4O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdHJ1Y3R1cmVkVHlwZS5ZX0xJTkU6XG4gICAgICAgIGlqa1sxXSA9IGluZGV4O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdHJ1Y3R1cmVkVHlwZS5aX0xJTkU6XG4gICAgICAgIGlqa1syXSA9IGluZGV4O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdHJ1Y3R1cmVkVHlwZS5YWV9QTEFORTpcbiAgICAgICAgaWprWzBdID0gaW5kZXggJSBkaW1zWzBdO1xuICAgICAgICBpamtbMV0gPSBpbmRleCAvIGRpbXNbMF07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFN0cnVjdHVyZWRUeXBlLllaX1BMQU5FOlxuICAgICAgICBpamtbMV0gPSBpbmRleCAlIGRpbXNbMV07XG4gICAgICAgIGlqa1syXSA9IGluZGV4IC8gZGltc1sxXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU3RydWN0dXJlZFR5cGUuWFpfUExBTkU6XG4gICAgICAgIGlqa1swXSA9IGluZGV4ICUgZGltc1swXTtcbiAgICAgICAgaWprWzJdID0gaW5kZXggLyBkaW1zWzBdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdHJ1Y3R1cmVkVHlwZS5YWVpfR1JJRDpcbiAgICAgICAgaWprWzBdID0gaW5kZXggJSBkaW1zWzBdO1xuICAgICAgICBpamtbMV0gPSAoaW5kZXggLyBkaW1zWzBdKSAlIGRpbXNbMV07XG4gICAgICAgIGlqa1syXSA9IGluZGV4IC8gKGRpbXNbMF0gKiBkaW1zWzFdKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZ0a0Vycm9yTWFjcm8oJ0ludmFsaWQgZGF0YURlc2NyaXB0aW9uJyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNvbnN0IHZvdXQgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIHB1YmxpY0FQSS5pbmRleFRvV29ybGRWZWMzKGlqaywgdm91dCk7XG4gICAgdmVjMy5jb3B5KGNvb3Jkcywgdm91dCk7XG4gICAgcmV0dXJuIGNvb3JkcztcbiAgfTtcblxuICAvLyB2dGtDZWxsICpHZXRDZWxsKHZ0a0lkVHlwZSBjZWxsSWQpIFZUS19PVkVSUklERTtcbiAgLy8gdm9pZCBHZXRDZWxsKHZ0a0lkVHlwZSBjZWxsSWQsIHZ0a0dlbmVyaWNDZWxsICpjZWxsKSBWVEtfT1ZFUlJJREU7XG4gIC8vIHZvaWQgR2V0Q2VsbEJvdW5kcyh2dGtJZFR5cGUgY2VsbElkLCBkb3VibGUgYm91bmRzWzZdKSBWVEtfT1ZFUlJJREU7XG4gIC8vIHZpcnR1YWwgdnRrSWRUeXBlIEZpbmRQb2ludChkb3VibGUgeCwgZG91YmxlIHksIGRvdWJsZSB6KVxuICAvLyB7XG4gIC8vICAgcmV0dXJuIHRoaXMtPnZ0a0RhdGFTZXQ6OkZpbmRQb2ludCh4LCB5LCB6KTtcbiAgLy8gfVxuICAvLyB2dGtJZFR5cGUgRmluZFBvaW50KGRvdWJsZSB4WzNdKSBWVEtfT1ZFUlJJREU7XG4gIC8vIHZ0a0lkVHlwZSBGaW5kQ2VsbChcbiAgLy8gICBkb3VibGUgeFszXSwgdnRrQ2VsbCAqY2VsbCwgdnRrSWRUeXBlIGNlbGxJZCwgZG91YmxlIHRvbDIsXG4gIC8vICAgaW50JiBzdWJJZCwgZG91YmxlIHBjb29yZHNbM10sIGRvdWJsZSAqd2VpZ2h0cykgVlRLX09WRVJSSURFO1xuICAvLyB2dGtJZFR5cGUgRmluZENlbGwoXG4gIC8vICAgZG91YmxlIHhbM10sIHZ0a0NlbGwgKmNlbGwsIHZ0a0dlbmVyaWNDZWxsICpnZW5jZWxsLFxuICAvLyAgIHZ0a0lkVHlwZSBjZWxsSWQsIGRvdWJsZSB0b2wyLCBpbnQmIHN1YklkLFxuICAvLyAgIGRvdWJsZSBwY29vcmRzWzNdLCBkb3VibGUgKndlaWdodHMpIFZUS19PVkVSUklERTtcbiAgLy8gdnRrQ2VsbCAqRmluZEFuZEdldENlbGwoZG91YmxlIHhbM10sIHZ0a0NlbGwgKmNlbGwsIHZ0a0lkVHlwZSBjZWxsSWQsXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG91YmxlIHRvbDIsIGludCYgc3ViSWQsIGRvdWJsZSBwY29vcmRzWzNdLFxuICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdWJsZSAqd2VpZ2h0cykgVlRLX09WRVJSSURFO1xuICAvLyBpbnQgR2V0Q2VsbFR5cGUodnRrSWRUeXBlIGNlbGxJZCkgVlRLX09WRVJSSURFO1xuICAvLyB2b2lkIEdldENlbGxQb2ludHModnRrSWRUeXBlIGNlbGxJZCwgdnRrSWRMaXN0ICpwdElkcykgVlRLX09WRVJSSURFXG4gIC8vICAge3Z0a1N0cnVjdHVyZWREYXRhOjpHZXRDZWxsUG9pbnRzKGNlbGxJZCxwdElkcyx0aGlzLT5EYXRhRGVzY3JpcHRpb24sXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMtPkdldERpbWVuc2lvbnMoKSk7fVxuICAvLyB2b2lkIEdldFBvaW50Q2VsbHModnRrSWRUeXBlIHB0SWQsIHZ0a0lkTGlzdCAqY2VsbElkcykgVlRLX09WRVJSSURFXG4gIC8vICAge3Z0a1N0cnVjdHVyZWREYXRhOjpHZXRQb2ludENlbGxzKHB0SWQsY2VsbElkcyx0aGlzLT5HZXREaW1lbnNpb25zKCkpO31cbiAgLy8gdm9pZCBDb21wdXRlQm91bmRzKCkgVlRLX09WRVJSSURFO1xuICAvLyBpbnQgR2V0TWF4Q2VsbFNpemUoKSBWVEtfT1ZFUlJJREUge3JldHVybiA4O307IC8vdm94ZWwgaXMgdGhlIGxhcmdlc3RcblxuICBwdWJsaWNBUEkuZ2V0Qm91bmRzID0gKCkgPT4gcHVibGljQVBJLmV4dGVudFRvQm91bmRzKG1vZGVsLmV4dGVudCk7XG5cbiAgcHVibGljQVBJLmV4dGVudFRvQm91bmRzID0gKGV4KSA9PiB7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgY29ybmVycyA9IFtcbiAgICAgIGV4WzBdLCBleFsyXSwgZXhbNF0sXG4gICAgICBleFsxXSwgZXhbMl0sIGV4WzRdLFxuICAgICAgZXhbMF0sIGV4WzNdLCBleFs0XSxcbiAgICAgIGV4WzFdLCBleFszXSwgZXhbNF0sXG4gICAgICBleFswXSwgZXhbMl0sIGV4WzVdLFxuICAgICAgZXhbMV0sIGV4WzJdLCBleFs1XSxcbiAgICAgIGV4WzBdLCBleFszXSwgZXhbNV0sXG4gICAgICBleFsxXSwgZXhbM10sIGV4WzVdXTtcblxuICAgIGNvbnN0IGlkeCA9IHZlYzMuZnJvbVZhbHVlcyhjb3JuZXJzWzBdLCBjb3JuZXJzWzFdLCBjb3JuZXJzWzJdKTtcbiAgICBjb25zdCB2b3V0ID0gdmVjMy5jcmVhdGUoKTtcbiAgICBwdWJsaWNBUEkuaW5kZXhUb1dvcmxkVmVjMyhpZHgsIHZvdXQpO1xuICAgIGNvbnN0IGJvdW5kcyA9IFt2b3V0WzBdLCB2b3V0WzBdLCB2b3V0WzFdLCB2b3V0WzFdLCB2b3V0WzJdLCB2b3V0WzJdXTtcbiAgICBmb3IgKGxldCBpID0gMzsgaSA8IDI0OyBpICs9IDMpIHtcbiAgICAgIHZlYzMuc2V0KGlkeCwgY29ybmVyc1tpXSwgY29ybmVyc1tpICsgMV0sIGNvcm5lcnNbaSArIDJdKTtcbiAgICAgIHB1YmxpY0FQSS5pbmRleFRvV29ybGRWZWMzKGlkeCwgdm91dCk7XG4gICAgICBpZiAodm91dFswXSA8IGJvdW5kc1swXSkge1xuICAgICAgICBib3VuZHNbMF0gPSB2b3V0WzBdO1xuICAgICAgfVxuICAgICAgaWYgKHZvdXRbMV0gPCBib3VuZHNbMl0pIHtcbiAgICAgICAgYm91bmRzWzJdID0gdm91dFsxXTtcbiAgICAgIH1cbiAgICAgIGlmICh2b3V0WzJdIDwgYm91bmRzWzRdKSB7XG4gICAgICAgIGJvdW5kc1s0XSA9IHZvdXRbMl07XG4gICAgICB9XG4gICAgICBpZiAodm91dFswXSA+IGJvdW5kc1sxXSkge1xuICAgICAgICBib3VuZHNbMV0gPSB2b3V0WzBdO1xuICAgICAgfVxuICAgICAgaWYgKHZvdXRbMV0gPiBib3VuZHNbM10pIHtcbiAgICAgICAgYm91bmRzWzNdID0gdm91dFsxXTtcbiAgICAgIH1cbiAgICAgIGlmICh2b3V0WzJdID4gYm91bmRzWzVdKSB7XG4gICAgICAgIGJvdW5kc1s1XSA9IHZvdXRbMl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kcztcbiAgfTtcblxuICAvLyBJbnRlcm5hbCwgc2hvdWxkbid0IG5lZWQgdG8gY2FsbCB0aGlzIG1hbnVhbGx5LlxuICBwdWJsaWNBUEkuY29tcHV0ZVRyYW5zZm9ybXMgPSAoKSA9PiB7XG4gICAgY29uc3QgdHJhbnMgPSB2ZWMzLmZyb21WYWx1ZXMoXG4gICAgICBtb2RlbC5vcmlnaW5bMF0sXG4gICAgICBtb2RlbC5vcmlnaW5bMV0sXG4gICAgICBtb2RlbC5vcmlnaW5bMl1cbiAgICApO1xuICAgIG1hdDQuZnJvbVRyYW5zbGF0aW9uKG1vZGVsLmluZGV4VG9Xb3JsZCwgdHJhbnMpO1xuXG4gICAgbW9kZWwuaW5kZXhUb1dvcmxkWzBdID0gbW9kZWwuZGlyZWN0aW9uWzBdO1xuICAgIG1vZGVsLmluZGV4VG9Xb3JsZFsxXSA9IG1vZGVsLmRpcmVjdGlvblsxXTtcbiAgICBtb2RlbC5pbmRleFRvV29ybGRbMl0gPSBtb2RlbC5kaXJlY3Rpb25bMl07XG5cbiAgICBtb2RlbC5pbmRleFRvV29ybGRbNF0gPSBtb2RlbC5kaXJlY3Rpb25bM107XG4gICAgbW9kZWwuaW5kZXhUb1dvcmxkWzVdID0gbW9kZWwuZGlyZWN0aW9uWzRdO1xuICAgIG1vZGVsLmluZGV4VG9Xb3JsZFs2XSA9IG1vZGVsLmRpcmVjdGlvbls1XTtcblxuICAgIG1vZGVsLmluZGV4VG9Xb3JsZFs4XSA9IG1vZGVsLmRpcmVjdGlvbls2XTtcbiAgICBtb2RlbC5pbmRleFRvV29ybGRbOV0gPSBtb2RlbC5kaXJlY3Rpb25bN107XG4gICAgbW9kZWwuaW5kZXhUb1dvcmxkWzEwXSA9IG1vZGVsLmRpcmVjdGlvbls4XTtcblxuICAgIGNvbnN0IHNjYWxlID0gdmVjMy5mcm9tVmFsdWVzKFxuICAgICAgbW9kZWwuc3BhY2luZ1swXSxcbiAgICAgIG1vZGVsLnNwYWNpbmdbMV0sXG4gICAgICBtb2RlbC5zcGFjaW5nWzJdXG4gICAgKTtcbiAgICBtYXQ0LnNjYWxlKG1vZGVsLmluZGV4VG9Xb3JsZCwgbW9kZWwuaW5kZXhUb1dvcmxkLCBzY2FsZSk7XG5cbiAgICBtYXQ0LmludmVydChtb2RlbC53b3JsZFRvSW5kZXgsIG1vZGVsLmluZGV4VG9Xb3JsZCk7XG4gIH07XG5cbiAgLy9cbiAgLy8gVGhlIGRpcmVjdGlvbiBtYXRyaXggaXMgYSAzeDMgYmFzaXMgZm9yIHRoZSBJLCBKLCBLIGF4ZXNcbiAgLy8gb2YgdGhlIGltYWdlLiBUaGUgcm93cyBvZiB0aGUgbWF0cml4IGNvcnJlc3BvbmQgdG8gdGhlXG4gIC8vIGF4ZXMgZGlyZWN0aW9ucyBpbiB3b3JsZCBjb29yZGluYXRlcy4gRGlyZWN0aW9uIG11c3RcbiAgLy8gZm9ybSBhbiBvcnRob25vcm1hbCBiYXNpcywgcmVzdWx0cyBhcmUgdW5kZWZpbmVkIGlmXG4gIC8vIGl0IGlzIG5vdC5cbiAgLy9cbiAgcHVibGljQVBJLnNldERpcmVjdGlvbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKG1vZGVsLmRlbGV0ZWQpIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oJ2luc3RhbmNlIGRlbGV0ZWQgLSBjYW5ub3QgY2FsbCBhbnkgbWV0aG9kJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IGFycmF5ID0gYXJncztcbiAgICAvLyBhbGxvdyBhbiBhcnJheSBwYXNzZWQgYXMgYSBzaW5nbGUgYXJnLlxuICAgIGlmIChcbiAgICAgIGFycmF5Lmxlbmd0aCA9PT0gMSAmJlxuICAgICAgKEFycmF5LmlzQXJyYXkoYXJyYXlbMF0pIHx8XG4gICAgICAgIGFycmF5WzBdLmNvbnN0cnVjdG9yID09PSBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgYXJyYXlbMF0uY29uc3RydWN0b3IgPT09IEZsb2F0NjRBcnJheSlcbiAgICApIHtcbiAgICAgIGFycmF5ID0gYXJyYXlbMF07XG4gICAgfVxuXG4gICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gOSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIHZhbHVlcyBmb3IgYXJyYXkgc2V0dGVyJyk7XG4gICAgfVxuICAgIGxldCBjaGFuZ2VEZXRlY3RlZCA9IGZhbHNlO1xuICAgIG1vZGVsLmRpcmVjdGlvbi5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGl0ZW0gIT09IGFycmF5W2luZGV4XSkge1xuICAgICAgICBpZiAoY2hhbmdlRGV0ZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2hhbmdlRGV0ZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKGNoYW5nZURldGVjdGVkKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDk7ICsraSkge1xuICAgICAgICBtb2RlbC5kaXJlY3Rpb25baV0gPSBhcnJheVtpXTtcbiAgICAgIH1cbiAgICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyB0aGlzIGlzIHRoZSBmYXN0IHZlcnNpb24sIHJlcXVpcmVzIHZlYzMgYXJndW1lbnRzXG4gIHB1YmxpY0FQSS5pbmRleFRvV29ybGRWZWMzID0gKHZpbiwgdm91dCkgPT4ge1xuICAgIHZlYzMudHJhbnNmb3JtTWF0NCh2b3V0LCB2aW4sIG1vZGVsLmluZGV4VG9Xb3JsZCk7XG4gICAgcmV0dXJuIHZvdXQ7XG4gIH07XG5cbiAgLy8gc2xvdyB2ZXJzaW9uIGZvciBnZW5lcmljIGFycmF5c1xuICBwdWJsaWNBUEkuaW5kZXhUb1dvcmxkID0gKGFpbiwgYW91dCA9IFtdKSA9PiB7XG4gICAgY29uc3QgdmluID0gdmVjMy5mcm9tVmFsdWVzKGFpblswXSwgYWluWzFdLCBhaW5bMl0pO1xuICAgIGNvbnN0IHZvdXQgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIHZlYzMudHJhbnNmb3JtTWF0NCh2b3V0LCB2aW4sIG1vZGVsLmluZGV4VG9Xb3JsZCk7XG4gICAgdmVjMy5jb3B5KGFvdXQsIHZvdXQpO1xuICAgIHJldHVybiBhb3V0O1xuICB9O1xuXG4gIC8vIHRoaXMgaXMgdGhlIGZhc3QgdmVyc2lvbiwgcmVxdWlyZXMgdmVjMyBhcmd1bWVudHNcbiAgcHVibGljQVBJLndvcmxkVG9JbmRleFZlYzMgPSAodmluLCB2b3V0KSA9PiB7XG4gICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHZvdXQsIHZpbiwgbW9kZWwud29ybGRUb0luZGV4KTtcbiAgICByZXR1cm4gdm91dDtcbiAgfTtcblxuICAvLyBzbG93IHZlcnNpb24gZm9yIGdlbmVyaWMgYXJyYXlzXG4gIHB1YmxpY0FQSS53b3JsZFRvSW5kZXggPSAoYWluLCBhb3V0ID0gW10pID0+IHtcbiAgICBjb25zdCB2aW4gPSB2ZWMzLmZyb21WYWx1ZXMoYWluWzBdLCBhaW5bMV0sIGFpblsyXSk7XG4gICAgY29uc3Qgdm91dCA9IHZlYzMuY3JlYXRlKCk7XG4gICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHZvdXQsIHZpbiwgbW9kZWwud29ybGRUb0luZGV4KTtcbiAgICB2ZWMzLmNvcHkoYW91dCwgdm91dCk7XG4gICAgcmV0dXJuIGFvdXQ7XG4gIH07XG5cbiAgcHVibGljQVBJLmluZGV4VG9Xb3JsZEJvdW5kcyA9IChiaW4sIGJvdXQgPSBbXSkgPT4ge1xuICAgIGNvbnN0IGluMSA9IFswLCAwLCAwXTtcbiAgICBjb25zdCBpbjIgPSBbMCwgMCwgMF07XG4gICAgdnRrQm91bmRpbmdCb3guY29tcHV0ZUNvcm5lclBvaW50cyhpbjEsIGluMiwgYmluKTtcblxuICAgIGNvbnN0IG91dDEgPSBbMCwgMCwgMF07XG4gICAgY29uc3Qgb3V0MiA9IFswLCAwLCAwXTtcbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDQob3V0MSwgaW4xLCBtb2RlbC5pbmRleFRvV29ybGQpO1xuICAgIHZlYzMudHJhbnNmb3JtTWF0NChvdXQyLCBpbjIsIG1vZGVsLmluZGV4VG9Xb3JsZCk7XG5cbiAgICB2dGtNYXRoLmNvbXB1dGVCb3VuZHNGcm9tUG9pbnRzKG91dDEsIG91dDIsIGJvdXQpO1xuXG4gICAgcmV0dXJuIGJvdXQ7XG4gIH07XG5cbiAgcHVibGljQVBJLndvcmxkVG9JbmRleEJvdW5kcyA9IChiaW4sIGJvdXQgPSBbXSkgPT4ge1xuICAgIGNvbnN0IGluMSA9IFswLCAwLCAwXTtcbiAgICBjb25zdCBpbjIgPSBbMCwgMCwgMF07XG4gICAgdnRrQm91bmRpbmdCb3guY29tcHV0ZUNvcm5lclBvaW50cyhpbjEsIGluMiwgYmluKTtcblxuICAgIGNvbnN0IG91dDEgPSBbMCwgMCwgMF07XG4gICAgY29uc3Qgb3V0MiA9IFswLCAwLCAwXTtcbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDQob3V0MSwgaW4xLCBtb2RlbC53b3JsZFRvSW5kZXgpO1xuICAgIHZlYzMudHJhbnNmb3JtTWF0NChvdXQyLCBpbjIsIG1vZGVsLndvcmxkVG9JbmRleCk7XG5cbiAgICB2dGtNYXRoLmNvbXB1dGVCb3VuZHNGcm9tUG9pbnRzKG91dDEsIG91dDIsIGJvdXQpO1xuXG4gICAgcmV0dXJuIGJvdXQ7XG4gIH07XG5cbiAgLy8gTWFrZSBzdXJlIHRoZSB0cmFuc2Zvcm0gaXMgY29ycmVjdFxuICBwdWJsaWNBUEkub25Nb2RpZmllZChwdWJsaWNBUEkuY29tcHV0ZVRyYW5zZm9ybXMpO1xuICBwdWJsaWNBUEkuY29tcHV0ZVRyYW5zZm9ybXMoKTtcblxuICBwdWJsaWNBUEkuZ2V0Q2VudGVyID0gKCkgPT4ge1xuICAgIGNvbnN0IGJvdW5kcyA9IHB1YmxpY0FQSS5nZXRCb3VuZHMoKTtcbiAgICBjb25zdCBjZW50ZXIgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBjZW50ZXJbaV0gPSAoYm91bmRzWzIgKiBpICsgMV0gKyBib3VuZHNbMiAqIGldKSAvIDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbnRlcjtcbiAgfTtcblxuICBwdWJsaWNBUEkuY29tcHV0ZUhpc3RvZ3JhbSA9ICh3b3JsZEJvdW5kcywgdm94ZWxGdW5jID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IGJvdW5kcyA9IFswLCAwLCAwLCAwLCAwLCAwXTtcbiAgICBwdWJsaWNBUEkud29ybGRUb0luZGV4Qm91bmRzKHdvcmxkQm91bmRzLCBib3VuZHMpO1xuXG4gICAgY29uc3QgcG9pbnQxID0gWzAsIDAsIDBdO1xuICAgIGNvbnN0IHBvaW50MiA9IFswLCAwLCAwXTtcbiAgICB2dGtCb3VuZGluZ0JveC5jb21wdXRlQ29ybmVyUG9pbnRzKHBvaW50MSwgcG9pbnQyLCBib3VuZHMpO1xuXG4gICAgdnRrTWF0aC5yb3VuZFZlY3Rvcihwb2ludDEsIHBvaW50MSk7XG4gICAgdnRrTWF0aC5yb3VuZFZlY3Rvcihwb2ludDIsIHBvaW50Mik7XG5cbiAgICBjb25zdCBkaW1lbnNpb25zID0gcHVibGljQVBJLmdldERpbWVuc2lvbnMoKTtcblxuICAgIHZ0a01hdGguY2xhbXBWZWN0b3IoXG4gICAgICBwb2ludDEsXG4gICAgICBbMCwgMCwgMF0sXG4gICAgICBbZGltZW5zaW9uc1swXSAtIDEsIGRpbWVuc2lvbnNbMV0gLSAxLCBkaW1lbnNpb25zWzJdIC0gMV0sXG4gICAgICBwb2ludDFcbiAgICApO1xuICAgIHZ0a01hdGguY2xhbXBWZWN0b3IoXG4gICAgICBwb2ludDIsXG4gICAgICBbMCwgMCwgMF0sXG4gICAgICBbZGltZW5zaW9uc1swXSAtIDEsIGRpbWVuc2lvbnNbMV0gLSAxLCBkaW1lbnNpb25zWzJdIC0gMV0sXG4gICAgICBwb2ludDJcbiAgICApO1xuXG4gICAgY29uc3QgeVN0cmlkZSA9IGRpbWVuc2lvbnNbMF07XG4gICAgY29uc3QgelN0cmlkZSA9IGRpbWVuc2lvbnNbMF0gKiBkaW1lbnNpb25zWzFdO1xuXG4gICAgY29uc3QgcGl4ZWxzID0gcHVibGljQVBJLmdldFBvaW50RGF0YSgpLmdldFNjYWxhcnMoKS5nZXREYXRhKCk7XG5cbiAgICBsZXQgbWF4aW11bSA9IC1JbmZpbml0eTtcbiAgICBsZXQgbWluaW11bSA9IEluZmluaXR5O1xuICAgIGxldCBzdW1PZlNxdWFyZXMgPSAwO1xuICAgIGxldCBpc3VtID0gMDtcbiAgICBsZXQgaW51bSA9IDA7XG5cbiAgICBmb3IgKGxldCB6ID0gcG9pbnQxWzJdOyB6IDw9IHBvaW50MlsyXTsgeisrKSB7XG4gICAgICBmb3IgKGxldCB5ID0gcG9pbnQxWzFdOyB5IDw9IHBvaW50MlsxXTsgeSsrKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHBvaW50MVswXSArIHkgKiB5U3RyaWRlICsgeiAqIHpTdHJpZGU7XG4gICAgICAgIGZvciAobGV0IHggPSBwb2ludDFbMF07IHggPD0gcG9pbnQyWzBdOyB4KyspIHtcbiAgICAgICAgICBpZiAoIXZveGVsRnVuYyB8fCB2b3hlbEZ1bmMoW3gsIHksIHpdLCBib3VuZHMpKSB7XG4gICAgICAgICAgICBjb25zdCBwaXhlbCA9IHBpeGVsc1tpbmRleF07XG5cbiAgICAgICAgICAgIGlmIChwaXhlbCA+IG1heGltdW0pIG1heGltdW0gPSBwaXhlbDtcbiAgICAgICAgICAgIGlmIChwaXhlbCA8IG1pbmltdW0pIG1pbmltdW0gPSBwaXhlbDtcbiAgICAgICAgICAgIHN1bU9mU3F1YXJlcyArPSBwaXhlbCAqIHBpeGVsO1xuICAgICAgICAgICAgaXN1bSArPSBwaXhlbDtcbiAgICAgICAgICAgIGludW0gKz0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICArK2luZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYXZlcmFnZSA9IGludW0gPiAwID8gaXN1bSAvIGludW0gOiAwO1xuICAgIGNvbnN0IHZhcmlhbmNlID0gc3VtT2ZTcXVhcmVzIC0gYXZlcmFnZSAqIGF2ZXJhZ2U7XG4gICAgY29uc3Qgc2lnbWEgPSBNYXRoLnNxcnQodmFyaWFuY2UpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbmltdW0sXG4gICAgICBtYXhpbXVtLFxuICAgICAgYXZlcmFnZSxcbiAgICAgIHZhcmlhbmNlLFxuICAgICAgc2lnbWEsXG4gICAgfTtcbiAgfTtcblxuICAvLyBUT0RPOiB1c2UgdGhlIHVuaW1wbGVtZW50ZWQgYHZ0a0RhdGFTZXRBdHRyaWJ1dGVzYCBmb3Igc2NhbGFyIGxlbmd0aCwgdGhhdCBpcyBjdXJyZW50bHkgYWxzbyBhIFRPRE8gKEdldE51bWJlck9mQ29tcG9uZW50cykuXG4gIC8vIFNjYWxhciBkYXRhIGNvdWxkIGJlIHR1cGxlcyBmb3IgY29sb3IgaW5mb3JtYXRpb24/XG4gIHB1YmxpY0FQSS5jb21wdXRlSW5jcmVtZW50cyA9IChleHRlbnQsIG51bWJlck9mQ29tcG9uZW50cyA9IDEpID0+IHtcbiAgICBjb25zdCBpbmNyZW1lbnRzID0gW107XG4gICAgbGV0IGluY3IgPSBudW1iZXJPZkNvbXBvbmVudHM7XG5cbiAgICAvLyBDYWxjdWxhdGUgYXJyYXkgaW5jcmVtZW50IG9mZnNldHNcbiAgICAvLyBzaW1pbGFyIHRvIGMrKyB2dGtJbWFnZURhdGE6OkNvbXB1dGVJbmNyZW1lbnRzXG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgMzsgKytpZHgpIHtcbiAgICAgIGluY3JlbWVudHNbaWR4XSA9IGluY3I7XG4gICAgICBpbmNyICo9IGV4dGVudFtpZHggKiAyICsgMV0gLSBleHRlbnRbaWR4ICogMl0gKyAxO1xuICAgIH1cbiAgICByZXR1cm4gaW5jcmVtZW50cztcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJbXX0gaW5kZXggdGhlIGxvY2FsaXplZCBgW2ksaixrXWAgcGl4ZWwgYXJyYXkgcG9zaXRpb24uIEZsb2F0IHZhbHVlcyB3aWxsIGJlIHJvdW5kZWQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gdGhlIGNvcnJlc3BvbmRpbmcgZmxhdHRlbmVkIGluZGV4IGluIHRoZSBzY2FsYXIgYXJyYXlcbiAgICovXG4gIHB1YmxpY0FQSS5jb21wdXRlT2Zmc2V0SW5kZXggPSAoW2ksIGosIGtdKSA9PiB7XG4gICAgY29uc3QgZXh0ZW50ID0gcHVibGljQVBJLmdldEV4dGVudCgpO1xuICAgIGNvbnN0IG51bWJlck9mQ29tcG9uZW50cyA9IHB1YmxpY0FQSVxuICAgICAgLmdldFBvaW50RGF0YSgpXG4gICAgICAuZ2V0U2NhbGFycygpXG4gICAgICAuZ2V0TnVtYmVyT2ZDb21wb25lbnRzKCk7XG4gICAgY29uc3QgaW5jcmVtZW50cyA9IHB1YmxpY0FQSS5jb21wdXRlSW5jcmVtZW50cyhleHRlbnQsIG51bWJlck9mQ29tcG9uZW50cyk7XG4gICAgLy8gVXNlIHRoZSBhcnJheSBpbmNyZW1lbnRzIHRvIGZpbmQgdGhlIHBpeGVsIGluZGV4XG4gICAgLy8gc2ltaWxhciB0byBjKysgdnRrSW1hZ2VEYXRhOjpHZXRBcnJheVBvaW50ZXJcbiAgICAvLyBNYXRoLmZsb29yIHRvIGNhdGNoIFwicHJhY3RpY2FsbHkgMFwiIGVeLTE1IHNjZW5hcmlvcy5cbiAgICByZXR1cm4gTWF0aC5mbG9vcihcbiAgICAgIChNYXRoLnJvdW5kKGkpIC0gZXh0ZW50WzBdKSAqIGluY3JlbWVudHNbMF0gK1xuICAgICAgICAoTWF0aC5yb3VuZChqKSAtIGV4dGVudFsyXSkgKiBpbmNyZW1lbnRzWzFdICtcbiAgICAgICAgKE1hdGgucm91bmQoaykgLSBleHRlbnRbNF0pICogaW5jcmVtZW50c1syXVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TnVtYmVyW119IHh5eiB0aGUgW3gseSx6XSBBcnJheSBpbiB3b3JsZCBjb29yZGluYXRlc1xuICAgKiBAcmV0dXJuIHtOdW1iZXJ8TmFOfSB0aGUgY29ycmVzcG9uZGluZyBwaXhlbCdzIGluZGV4IGluIHRoZSBzY2FsYXIgYXJyYXlcbiAgICovXG4gIHB1YmxpY0FQSS5nZXRPZmZzZXRJbmRleEZyb21Xb3JsZCA9ICh4eXopID0+IHtcbiAgICBjb25zdCBleHRlbnQgPSBwdWJsaWNBUEkuZ2V0RXh0ZW50KCk7XG4gICAgY29uc3QgaW5kZXggPSBwdWJsaWNBUEkud29ybGRUb0luZGV4KHh5eik7XG5cbiAgICAvLyBDb25maXJtIGluZGV4ZWQgaSxqLGsgY29vcmRzIGFyZSB3aXRoaW4gdGhlIGJvdW5kcyBvZiB0aGUgdm9sdW1lXG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgMzsgKytpZHgpIHtcbiAgICAgIGlmIChpbmRleFtpZHhdIDwgZXh0ZW50W2lkeCAqIDJdIHx8IGluZGV4W2lkeF0gPiBleHRlbnRbaWR4ICogMiArIDFdKSB7XG4gICAgICAgIHZ0a0Vycm9yTWFjcm8oXG4gICAgICAgICAgYEdldFNjYWxhclBvaW50ZXI6IFBpeGVsICR7aW5kZXh9IGlzIG5vdCBpbiBtZW1vcnkuIEN1cnJlbnQgZXh0ZW50ID0gJHtleHRlbnR9YFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFzc3VtZWQgdGhlIGluZGV4IGhlcmUgaXMgd2l0aGluIDAgPC0+IHNjYWxhckRhdGEubGVuZ3RoLCBidXQgZG9lc24ndCBodXJ0IHRvIGNoZWNrIHVwc3RyZWFtXG4gICAgcmV0dXJuIHB1YmxpY0FQSS5jb21wdXRlT2Zmc2V0SW5kZXgoaW5kZXgpO1xuICB9O1xuICAvKipcbiAgICogQHBhcmFtIHtOdW1iZXJbXX0geHl6IHRoZSBbeCx5LHpdIEFycmF5IGluIHdvcmxkIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSB7TnVtYmVyP30gY29tcCB0aGUgc2NhbGFyIGNvbXBvbmVudCBpbmRleCBmb3IgbXVsdGktY29tcG9uZW50IHNjYWxhcnNcbiAgICogQHJldHVybiB7TnVtYmVyfE5hTn0gdGhlIGNvcnJlc3BvbmRpbmcgcGl4ZWwncyBzY2FsYXIgdmFsdWVcbiAgICovXG4gIHB1YmxpY0FQSS5nZXRTY2FsYXJWYWx1ZUZyb21Xb3JsZCA9ICh4eXosIGNvbXAgPSAwKSA9PiB7XG4gICAgY29uc3QgbnVtYmVyT2ZDb21wb25lbnRzID0gcHVibGljQVBJXG4gICAgICAuZ2V0UG9pbnREYXRhKClcbiAgICAgIC5nZXRTY2FsYXJzKClcbiAgICAgIC5nZXROdW1iZXJPZkNvbXBvbmVudHMoKTtcbiAgICBpZiAoY29tcCA8IDAgfHwgY29tcCA+PSBudW1iZXJPZkNvbXBvbmVudHMpIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oXG4gICAgICAgIGBHZXRTY2FsYXJQb2ludGVyOiBTY2FsYXIgQ29tcG9uZW50ICR7Y29tcH0gaXMgbm90IHdpdGhpbiBib3VuZHMuIEN1cnJlbnQgU2NhbGFyIG51bWJlck9mQ29tcG9uZW50czogJHtudW1iZXJPZkNvbXBvbmVudHN9YFxuICAgICAgKTtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldEluZGV4ID0gcHVibGljQVBJLmdldE9mZnNldEluZGV4RnJvbVdvcmxkKHh5eik7XG4gICAgaWYgKE51bWJlci5pc05hTihvZmZzZXRJbmRleCkpIHtcbiAgICAgIC8vIFZUSyBFcnJvciBNYWNybyB3aWxsIGhhdmUgYmVlbiB0cmlwcGVkIGFscmVhZHksIG5vIG5lZWQgdG8gZG8gaXQgYWdhaW4sXG4gICAgICByZXR1cm4gb2Zmc2V0SW5kZXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHB1YmxpY0FQSVxuICAgICAgLmdldFBvaW50RGF0YSgpXG4gICAgICAuZ2V0U2NhbGFycygpXG4gICAgICAuZ2V0Q29tcG9uZW50KG9mZnNldEluZGV4LCBjb21wKTtcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIGRpcmVjdGlvbjogbnVsbCwgLy8gYSBtYXQzXG4gIGluZGV4VG9Xb3JsZDogbnVsbCwgLy8gYSBtYXQ0XG4gIHdvcmxkVG9JbmRleDogbnVsbCwgLy8gYSBtYXQ0XG4gIHNwYWNpbmc6IFsxLjAsIDEuMCwgMS4wXSxcbiAgb3JpZ2luOiBbMC4wLCAwLjAsIDAuMF0sXG4gIGV4dGVudDogWzAsIC0xLCAwLCAtMSwgMCwgLTFdLFxuICBkYXRhRGVzY3JpcHRpb246IFN0cnVjdHVyZWRUeXBlLkVNUFRZLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gSW5oZXJpdGFuY2VcbiAgdnRrRGF0YVNldC5leHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyk7XG5cbiAgaWYgKCFtb2RlbC5kaXJlY3Rpb24pIHtcbiAgICBtb2RlbC5kaXJlY3Rpb24gPSBtYXQzLmNyZWF0ZSgpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobW9kZWwuZGlyZWN0aW9uKSkge1xuICAgIGNvbnN0IGR2YWxzID0gbW9kZWwuZGlyZWN0aW9uLnNsaWNlKDApO1xuICAgIG1vZGVsLmRpcmVjdGlvbiA9IG1hdDMuY3JlYXRlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA5OyArK2kpIHtcbiAgICAgIG1vZGVsLmRpcmVjdGlvbltpXSA9IGR2YWxzW2ldO1xuICAgIH1cbiAgfVxuXG4gIG1vZGVsLmluZGV4VG9Xb3JsZCA9IG5ldyBGbG9hdDY0QXJyYXkoMTYpO1xuICBtb2RlbC53b3JsZFRvSW5kZXggPSBuZXcgRmxvYXQ2NEFycmF5KDE2KTtcblxuICAvLyBTZXQvR2V0IG1ldGhvZHNcbiAgbWFjcm8uZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsnZGlyZWN0aW9uJywgJ2luZGV4VG9Xb3JsZCcsICd3b3JsZFRvSW5kZXgnXSk7XG4gIG1hY3JvLnNldEdldEFycmF5KHB1YmxpY0FQSSwgbW9kZWwsIFsnb3JpZ2luJywgJ3NwYWNpbmcnXSwgMyk7XG4gIG1hY3JvLmdldEFycmF5KHB1YmxpY0FQSSwgbW9kZWwsIFsnZXh0ZW50J10sIDYpO1xuXG4gIC8vIE9iamVjdCBzcGVjaWZpYyBtZXRob2RzXG4gIHZ0a0ltYWdlRGF0YShwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQsICd2dGtJbWFnZURhdGEnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImV4cG9ydCBjb25zdCBJbnRlcnNlY3Rpb25TdGF0ZSA9IHtcbiAgTk9fSU5URVJTRUNUSU9OOiAwLFxuICBZRVNfSU5URVJTRUNUSU9OOiAxLFxuICBPTl9MSU5FOiAyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBJbnRlcnNlY3Rpb25TdGF0ZSxcbn07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0IENvbnN0YW50cyBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0xpbmUvQ29uc3RhbnRzJztcbmltcG9ydCB2dGtDZWxsIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvQ2VsbCc7XG5pbXBvcnQgKiBhcyB2dGtNYXRoIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL01hdGgnO1xuXG5jb25zdCB7IEludGVyc2VjdGlvblN0YXRlIH0gPSBDb25zdGFudHM7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdsb2JhbCBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBkaXN0YW5jZVRvTGluZSh4LCBwMSwgcDIsIGNsb3Nlc3RQb2ludCA9IG51bGwpIHtcbiAgY29uc3Qgb3V0T2JqID0geyB0OiBOdW1iZXIuTUlOX1ZBTFVFLCBkaXN0YW5jZTogMCB9O1xuICBjb25zdCBwMjEgPSBbXTtcbiAgbGV0IGNsb3Nlc3Q7XG4gIC8vIERldGVybWluZSBhcHByb3ByaWF0ZSB2ZWN0b3JcbiAgcDIxWzBdID0gcDJbMF0gLSBwMVswXTtcbiAgcDIxWzFdID0gcDJbMV0gLSBwMVsxXTtcbiAgcDIxWzJdID0gcDJbMl0gLSBwMVsyXTtcblxuICAvLyBHZXQgcGFyYW1ldHJpYyBsb2NhdGlvblxuICBjb25zdCBudW0gPVxuICAgIHAyMVswXSAqICh4WzBdIC0gcDFbMF0pICsgcDIxWzFdICogKHhbMV0gLSBwMVsxXSkgKyBwMjFbMl0gKiAoeFsyXSAtIHAxWzJdKTtcbiAgY29uc3QgZGVub20gPSB2dGtNYXRoLmRvdChwMjEsIHAyMSk7XG5cbiAgLy8gdHJ5aW5nIHRvIGF2b2lkIGFuIGV4cGVuc2l2ZSBmYWJzXG4gIGxldCB0b2xlcmFuY2UgPSAxZS01ICogbnVtO1xuICBpZiAoZGVub20gIT09IDAuMCkge1xuICAgIG91dE9iai50ID0gbnVtIC8gZGVub207XG4gIH1cbiAgaWYgKHRvbGVyYW5jZSA8IDAuMCkge1xuICAgIHRvbGVyYW5jZSA9IC10b2xlcmFuY2U7XG4gIH1cbiAgaWYgKC10b2xlcmFuY2UgPCBkZW5vbSAmJiBkZW5vbSA8IHRvbGVyYW5jZSkge1xuICAgIGNsb3Nlc3QgPSBwMTtcbiAgfSBlbHNlIGlmIChkZW5vbSA8PSAwLjAgfHwgb3V0T2JqLnQgPCAwLjApIHtcbiAgICAvLyBJZiBwYXJhbWV0cmljIGNvb3JkaW5hdGUgaXMgd2l0aGluIDA8PXA8PTEsIHRoZW4gdGhlIHBvaW50IGlzIGNsb3Nlc3QgdG9cbiAgICAvLyB0aGUgbGluZS4gIE90aGVyd2lzZSwgaXQncyBjbG9zZXN0IHRvIGEgcG9pbnQgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICBjbG9zZXN0ID0gcDE7XG4gIH0gZWxzZSBpZiAob3V0T2JqLnQgPiAxLjApIHtcbiAgICBjbG9zZXN0ID0gcDI7XG4gIH0gZWxzZSB7XG4gICAgY2xvc2VzdCA9IHAyMTtcbiAgICBwMjFbMF0gPSBwMVswXSArIG91dE9iai50ICogcDIxWzBdO1xuICAgIHAyMVsxXSA9IHAxWzFdICsgb3V0T2JqLnQgKiBwMjFbMV07XG4gICAgcDIxWzJdID0gcDFbMl0gKyBvdXRPYmoudCAqIHAyMVsyXTtcbiAgfVxuXG4gIGlmIChjbG9zZXN0UG9pbnQpIHtcbiAgICBjbG9zZXN0UG9pbnRbMF0gPSBjbG9zZXN0WzBdO1xuICAgIGNsb3Nlc3RQb2ludFsxXSA9IGNsb3Nlc3RbMV07XG4gICAgY2xvc2VzdFBvaW50WzJdID0gY2xvc2VzdFsyXTtcbiAgfVxuICBvdXRPYmouZGlzdGFuY2UgPSB2dGtNYXRoLmRpc3RhbmNlMkJldHdlZW5Qb2ludHMoY2xvc2VzdCwgeCk7XG4gIHJldHVybiBvdXRPYmo7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbihhMSwgYTIsIGIxLCBiMiwgdSwgdikge1xuICBjb25zdCBhMjEgPSBbXTtcbiAgY29uc3QgYjIxID0gW107XG4gIGNvbnN0IGIxYTEgPSBbXTtcblxuICB1WzBdID0gMC4wO1xuICB2WzBdID0gMC4wO1xuXG4gIC8vIERldGVybWluZSBsaW5lIHZlY3RvcnMuXG4gIGEyMVswXSA9IGEyWzBdIC0gYTFbMF07XG4gIGEyMVsxXSA9IGEyWzFdIC0gYTFbMV07XG4gIGEyMVsyXSA9IGEyWzJdIC0gYTFbMl07XG4gIGIyMVswXSA9IGIyWzBdIC0gYjFbMF07XG4gIGIyMVsxXSA9IGIyWzFdIC0gYjFbMV07XG4gIGIyMVsyXSA9IGIyWzJdIC0gYjFbMl07XG4gIGIxYTFbMF0gPSBiMVswXSAtIGExWzBdO1xuICBiMWExWzFdID0gYjFbMV0gLSBhMVsxXTtcbiAgYjFhMVsyXSA9IGIxWzJdIC0gYTFbMl07XG5cbiAgLy8gQ29tcHV0ZSB0aGUgc3lzdGVtIChsZWFzdCBzcXVhcmVzKSBtYXRyaXguXG4gIGNvbnN0IEEgPSBbXTtcbiAgQVswXSA9IFt2dGtNYXRoLmRvdChhMjEsIGEyMSksIC12dGtNYXRoLmRvdChhMjEsIGIyMSldO1xuICBBWzFdID0gW0FbMF1bMV0sIHZ0a01hdGguZG90KGIyMSwgYjIxKV07XG5cbiAgLy8gQ29tcHV0ZSB0aGUgbGVhc3Qgc3F1YXJlcyBzeXN0ZW0gY29uc3RhbnQgdGVybS5cbiAgY29uc3QgYyA9IFtdO1xuICBjWzBdID0gdnRrTWF0aC5kb3QoYTIxLCBiMWExKTtcbiAgY1sxXSA9IC12dGtNYXRoLmRvdChiMjEsIGIxYTEpO1xuXG4gIC8vIFNvbHZlIHRoZSBzeXN0ZW0gb2YgZXF1YXRpb25zXG4gIGlmICh2dGtNYXRoLnNvbHZlTGluZWFyU3lzdGVtKEEsIGMsIDIpID09PSAwKSB7XG4gICAgLy8gVGhlIGxpbmVzIGFyZSBjb2xpbmVhci4gVGhlcmVmb3JlLCBvbmUgb2YgdGhlIGZvdXIgZW5kcG9pbnRzIGlzIHRoZVxuICAgIC8vIHBvaW50IG9mIGNsb3Nlc3QgYXBwcm9hY2hcbiAgICBsZXQgbWluRGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgY29uc3QgcCA9IFthMSwgYTIsIGIxLCBiMl07XG4gICAgY29uc3QgbDEgPSBbYjEsIGIxLCBhMSwgYTFdO1xuICAgIGNvbnN0IGwyID0gW2IyLCBiMiwgYTIsIGEyXTtcbiAgICBjb25zdCB1djEgPSBbdlswXSwgdlswXSwgdVswXSwgdVswXV07XG4gICAgY29uc3QgdXYyID0gW3VbMF0sIHVbMF0sIHZbMF0sIHZbMF1dO1xuICAgIGxldCBvYmo7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgIG9iaiA9IGRpc3RhbmNlVG9MaW5lKHBbaV0sIGwxW2ldLCBsMltpXSk7XG4gICAgICBpZiAob2JqLmRpc3RhbmNlIDwgbWluRGlzdCkge1xuICAgICAgICBtaW5EaXN0ID0gb2JqLmRpc3RhbmNlO1xuICAgICAgICB1djFbaV0gPSBvYmoudDtcbiAgICAgICAgdXYyW2ldID0gaSAlIDI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJbnRlcnNlY3Rpb25TdGF0ZS5PTl9MSU5FO1xuICB9XG4gIHVbMF0gPSBjWzBdO1xuICB2WzBdID0gY1sxXTtcblxuICAvLyBDaGVjayBwYXJhbWV0cmljIGNvb3JkaW5hdGVzIGZvciBpbnRlcnNlY3Rpb24uXG4gIGlmICh1WzBdID49IDAuMCAmJiB1WzBdIDw9IDEuMCAmJiB2WzBdID49IDAuMCAmJiB2WzBdIDw9IDEuMCkge1xuICAgIHJldHVybiBJbnRlcnNlY3Rpb25TdGF0ZS5ZRVNfSU5URVJTRUNUSU9OO1xuICB9XG5cbiAgcmV0dXJuIEludGVyc2VjdGlvblN0YXRlLk5PX0lOVEVSU0VDVElPTjtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU3RhdGljIEFQSVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgU1RBVElDID0ge1xuICBkaXN0YW5jZVRvTGluZSxcbiAgaW50ZXJzZWN0aW9uLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrTGluZSBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a0xpbmUocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtMaW5lJyk7XG5cbiAgcHVibGljQVBJLmdldENlbGxEaW1lbnNpb24gPSAoKSA9PiAxO1xuICBwdWJsaWNBUEkuaW50ZXJzZWN0V2l0aExpbmUgPSAocDEsIHAyLCB0b2wsIHgsIHBjb29yZHMpID0+IHtcbiAgICBjb25zdCBvdXRPYmogPSB7IGludGVyc2VjdDogMCwgdDogTnVtYmVyLk1JTl9WQUxVRSwgc3ViSWQ6IDAgfTtcbiAgICBwY29vcmRzWzFdID0gMC4wO1xuICAgIHBjb29yZHNbMl0gPSAwLjA7XG4gICAgY29uc3QgcHJvalhZWiA9IFtdO1xuXG4gICAgY29uc3QgYTEgPSBbXTtcbiAgICBjb25zdCBhMiA9IFtdO1xuICAgIG1vZGVsLnBvaW50cy5nZXRQb2ludCgwLCBhMSk7XG4gICAgbW9kZWwucG9pbnRzLmdldFBvaW50KDEsIGEyKTtcblxuICAgIGNvbnN0IHUgPSBbXTtcbiAgICBjb25zdCB2ID0gW107XG4gICAgY29uc3QgaW50ZXJzZWN0ID0gaW50ZXJzZWN0aW9uKHAxLCBwMiwgYTEsIGEyLCB1LCB2KTtcbiAgICBvdXRPYmoudCA9IHVbMF07XG4gICAgcGNvb3Jkc1swXSA9IHZbMF07XG5cbiAgICBpZiAoaW50ZXJzZWN0ID09PSBJbnRlcnNlY3Rpb25TdGF0ZS5ZRVNfSU5URVJTRUNUSU9OKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgd2UgYXJlIHdpdGhpbiB0b2xlcmFuY2VcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIHhbaV0gPSBhMVtpXSArIHBjb29yZHNbMF0gKiAoYTJbaV0gLSBhMVtpXSk7XG4gICAgICAgIHByb2pYWVpbaV0gPSBwMVtpXSArIG91dE9iai50ICogKHAyW2ldIC0gcDFbaV0pO1xuICAgICAgfVxuICAgICAgaWYgKHZ0a01hdGguZGlzdGFuY2UyQmV0d2VlblBvaW50cyh4LCBwcm9qWFlaKSA8PSB0b2wgKiB0b2wpIHtcbiAgICAgICAgb3V0T2JqLmludGVyc2VjdCA9IDE7XG4gICAgICAgIHJldHVybiBvdXRPYmo7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBvdXREaXN0YW5jZTtcbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiBpdCBsaWVzIHdpdGhpbiB0b2xlcmFuY2VcbiAgICAgIC8vIG9uZSBvZiB0aGUgcGFyYW1ldHJpYyBjb29yZHMgbXVzdCBiZSBvdXRzaWRlIDAtMVxuICAgICAgaWYgKG91dE9iai50IDwgMC4wKSB7XG4gICAgICAgIG91dE9iai50ID0gMC4wO1xuICAgICAgICBvdXREaXN0YW5jZSA9IGRpc3RhbmNlVG9MaW5lKHAxLCBhMSwgYTIsIHgpO1xuICAgICAgICBwY29vcmRzWzBdID0gb3V0RGlzdGFuY2UudDtcbiAgICAgICAgaWYgKG91dERpc3RhbmNlLmRpc3RhbmNlIDw9IHRvbCAqIHRvbCkge1xuICAgICAgICAgIG91dE9iai5pbnRlcnNlY3QgPSAxO1xuICAgICAgICAgIHJldHVybiBvdXRPYmo7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dE9iajtcbiAgICAgIH1cbiAgICAgIGlmIChvdXRPYmoudCA+IDEuMCkge1xuICAgICAgICBvdXRPYmoudCA9IDEuMDtcbiAgICAgICAgb3V0RGlzdGFuY2UgPSBkaXN0YW5jZVRvTGluZShwMiwgYTEsIGEyLCB4KTtcbiAgICAgICAgcGNvb3Jkc1swXSA9IG91dERpc3RhbmNlLnQ7XG4gICAgICAgIGlmIChvdXREaXN0YW5jZS5kaXN0YW5jZSA8PSB0b2wgKiB0b2wpIHtcbiAgICAgICAgICBvdXRPYmouaW50ZXJzZWN0ID0gMTtcbiAgICAgICAgICByZXR1cm4gb3V0T2JqO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRPYmo7XG4gICAgICB9XG4gICAgICBpZiAocGNvb3Jkc1swXSA8IDAuMCkge1xuICAgICAgICBwY29vcmRzWzBdID0gMC4wO1xuICAgICAgICBvdXREaXN0YW5jZSA9IGRpc3RhbmNlVG9MaW5lKGExLCBwMSwgcDIsIHgpO1xuICAgICAgICBvdXRPYmoudCA9IG91dERpc3RhbmNlLnQ7XG4gICAgICAgIGlmIChvdXREaXN0YW5jZS5kaXN0YW5jZSA8PSB0b2wgKiB0b2wpIHtcbiAgICAgICAgICBvdXRPYmouaW50ZXJzZWN0ID0gMTtcbiAgICAgICAgICByZXR1cm4gb3V0T2JqO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRPYmo7XG4gICAgICB9XG4gICAgICBpZiAocGNvb3Jkc1sxXSA+IDEuMCkge1xuICAgICAgICBwY29vcmRzWzFdID0gMS4wO1xuICAgICAgICBvdXREaXN0YW5jZSA9IGRpc3RhbmNlVG9MaW5lKGEyLCBwMSwgcDIsIHgpO1xuICAgICAgICBvdXRPYmoudCA9IG91dERpc3RhbmNlLnQ7XG4gICAgICAgIGlmIChvdXREaXN0YW5jZS5kaXN0YW5jZSA8PSB0b2wgKiB0b2wpIHtcbiAgICAgICAgICBvdXRPYmouaW50ZXJzZWN0ID0gMTtcbiAgICAgICAgICByZXR1cm4gb3V0T2JqO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRPYmo7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRPYmo7XG4gIH07XG4gIHB1YmxpY0FQSS5ldmFsdWF0ZVBvc2l0aW9uID0gKFxuICAgIHgsXG4gICAgY2xvc2VzdFBvaW50LFxuICAgIHN1YklkLFxuICAgIHBjb29yZHMsXG4gICAgZGlzdDIsXG4gICAgd2VpZ2h0c1xuICApID0+IHt9OyAvLyB2aXJ0dWFsXG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge307XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIHZ0a0NlbGwuZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIHZ0a0xpbmUocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrTGluZScpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCwgLi4uU1RBVElDLCAuLi5Db25zdGFudHMgfTtcbiIsImltcG9ydCAqIGFzIHZ0a01hdGggZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvTWF0aCc7XG5pbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuXG5jb25zdCBQTEFORV9UT0xFUkFOQ0UgPSAxLjBlLTY7XG5jb25zdCBDT0lOQ0lERSA9ICdjb2luY2lkZSc7XG5jb25zdCBESVNKT0lOVCA9ICdkaXNqb2ludCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdsb2JhbCBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGV2YWx1YXRlKG5vcm1hbCwgb3JpZ2luLCB4KSB7XG4gIHJldHVybiAoXG4gICAgbm9ybWFsWzBdICogKHhbMF0gLSBvcmlnaW5bMF0pICtcbiAgICBub3JtYWxbMV0gKiAoeFsxXSAtIG9yaWdpblsxXSkgK1xuICAgIG5vcm1hbFsyXSAqICh4WzJdIC0gb3JpZ2luWzJdKVxuICApO1xufVxuXG5mdW5jdGlvbiBkaXN0YW5jZVRvUGxhbmUoeCwgb3JpZ2luLCBub3JtYWwpIHtcbiAgY29uc3QgZGlzdGFuY2UgPVxuICAgIG5vcm1hbFswXSAqICh4WzBdIC0gb3JpZ2luWzBdKSArXG4gICAgbm9ybWFsWzFdICogKHhbMV0gLSBvcmlnaW5bMV0pICtcbiAgICBub3JtYWxbMl0gKiAoeFsyXSAtIG9yaWdpblsyXSk7XG5cbiAgcmV0dXJuIE1hdGguYWJzKGRpc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gcHJvamVjdFBvaW50KHgsIG9yaWdpbiwgbm9ybWFsLCB4cHJvaikge1xuICBjb25zdCB4byA9IFtdO1xuICB2dGtNYXRoLnN1YnRyYWN0KHgsIG9yaWdpbiwgeG8pO1xuXG4gIGNvbnN0IHQgPSB2dGtNYXRoLmRvdChub3JtYWwsIHhvKTtcblxuICB4cHJvalswXSA9IHhbMF0gLSB0ICogbm9ybWFsWzBdO1xuICB4cHJvalsxXSA9IHhbMV0gLSB0ICogbm9ybWFsWzFdO1xuICB4cHJvalsyXSA9IHhbMl0gLSB0ICogbm9ybWFsWzJdO1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0VmVjdG9yKHYsIG5vcm1hbCwgdnByb2opIHtcbiAgY29uc3QgdCA9IHZ0a01hdGguZG90KHYsIG5vcm1hbCk7XG5cbiAgbGV0IG4yID0gdnRrTWF0aC5kb3Qobm9ybWFsLCBub3JtYWwpO1xuICBpZiAobjIgPT09IDApIHtcbiAgICBuMiA9IDEuMDtcbiAgfVxuXG4gIHZwcm9qWzBdID0gdlswXSAtICh0ICogbm9ybWFsWzBdKSAvIG4yO1xuICB2cHJvalsxXSA9IHZbMV0gLSAodCAqIG5vcm1hbFsxXSkgLyBuMjtcbiAgdnByb2pbMl0gPSB2WzJdIC0gKHQgKiBub3JtYWxbMl0pIC8gbjI7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYWxpemVkUHJvamVjdFBvaW50KHgsIG9yaWdpbiwgbm9ybWFsLCB4cHJvaikge1xuICBjb25zdCB4byA9IFtdO1xuICB2dGtNYXRoLnN1YnRyYWN0KHgsIG9yaWdpbiwgeG8pO1xuXG4gIGNvbnN0IHQgPSB2dGtNYXRoLmRvdChub3JtYWwsIHhvKTtcbiAgY29uc3QgbjIgPSB2dGtNYXRoLmRvdChub3JtYWwsIG5vcm1hbCk7XG5cbiAgaWYgKG4yICE9PSAwKSB7XG4gICAgeHByb2pbMF0gPSB4WzBdIC0gKHQgKiBub3JtYWxbMF0pIC8gbjI7XG4gICAgeHByb2pbMV0gPSB4WzFdIC0gKHQgKiBub3JtYWxbMV0pIC8gbjI7XG4gICAgeHByb2pbMl0gPSB4WzJdIC0gKHQgKiBub3JtYWxbMl0pIC8gbjI7XG4gIH0gZWxzZSB7XG4gICAgeHByb2pbMF0gPSB4WzBdO1xuICAgIHhwcm9qWzFdID0geFsxXTtcbiAgICB4cHJvalsyXSA9IHhbMl07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0V2l0aExpbmUocDEsIHAyLCBvcmlnaW4sIG5vcm1hbCkge1xuICBjb25zdCBvdXRPYmogPSB7XG4gICAgaW50ZXJzZWN0aW9uOiBmYWxzZSxcbiAgICBiZXR3ZWVuUG9pbnRzOiBmYWxzZSxcbiAgICB0OiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgIHg6IFtdLFxuICB9O1xuXG4gIGNvbnN0IHAyMSA9IFtdO1xuICBjb25zdCBwMU9yaWdpbiA9IFtdO1xuICAvLyBDb21wdXRlIGxpbmUgdmVjdG9yXG4gIHZ0a01hdGguc3VidHJhY3QocDIsIHAxLCBwMjEpO1xuICB2dGtNYXRoLnN1YnRyYWN0KG9yaWdpbiwgcDEsIHAxT3JpZ2luKTtcblxuICAvLyBDb21wdXRlIGRlbm9taW5hdG9yLiAgSWYgfjAsIGxpbmUgYW5kIHBsYW5lIGFyZSBwYXJhbGxlbC5cbiAgLy8gY29uc3QgbnVtID0gdnRrTWF0aC5kb3Qobm9ybWFsLCBvcmlnaW4pIC0gdnRrTWF0aC5kb3Qobm9ybWFsLCBwMSk7XG4gIGNvbnN0IG51bSA9IHZ0a01hdGguZG90KG5vcm1hbCwgcDFPcmlnaW4pO1xuICBjb25zdCBkZW4gPSB2dGtNYXRoLmRvdChub3JtYWwsIHAyMSk7XG5cbiAgLy8gSWYgZGVub21pbmF0b3Igd2l0aCByZXNwZWN0IHRvIG51bWVyYXRvciBpcyBcInplcm9cIiwgdGhlbiB0aGUgbGluZSBhbmRcbiAgLy8gcGxhbmUgYXJlIGNvbnNpZGVyZWQgcGFyYWxsZWwuXG4gIGxldCBmYWJzZGVuO1xuICBsZXQgZmFic3RvbGVyYW5jZTtcblxuICAvLyBUcnlpbmcgdG8gYXZvaWQgYW4gZXhwZW5zaXZlIGNhbGwgdG8gZmFicygpXG4gIGlmIChkZW4gPCAwLjApIHtcbiAgICBmYWJzZGVuID0gLWRlbjtcbiAgfSBlbHNlIHtcbiAgICBmYWJzZGVuID0gZGVuO1xuICB9XG4gIGlmIChudW0gPCAwLjApIHtcbiAgICBmYWJzdG9sZXJhbmNlID0gLW51bSAqIFBMQU5FX1RPTEVSQU5DRTtcbiAgfSBlbHNlIHtcbiAgICBmYWJzdG9sZXJhbmNlID0gbnVtICogUExBTkVfVE9MRVJBTkNFO1xuICB9XG4gIGlmIChmYWJzZGVuIDw9IGZhYnN0b2xlcmFuY2UpIHtcbiAgICByZXR1cm4gb3V0T2JqO1xuICB9XG5cbiAgLy8gV2hlcmUgb24gdGhlIGxpbmUgYmV0d2VlbiBwMSBhbmQgcDIgaXMgdGhlIGludGVyc2VjdGlvblxuICAvLyBJZiBiZXR3ZWVuIDAgYW5kIDEsIGl0IGlzIGJldHdlZW4gdGhlIHR3byBwb2ludHMuIElmIDwgMCBpdCdzIGJlZm9yZSBwMSwgaWYgPiAxIGl0J3MgYWZ0ZXIgcDJcbiAgb3V0T2JqLnQgPSBudW0gLyBkZW47XG5cbiAgb3V0T2JqLnhbMF0gPSBwMVswXSArIG91dE9iai50ICogcDIxWzBdO1xuICBvdXRPYmoueFsxXSA9IHAxWzFdICsgb3V0T2JqLnQgKiBwMjFbMV07XG4gIG91dE9iai54WzJdID0gcDFbMl0gKyBvdXRPYmoudCAqIHAyMVsyXTtcblxuICBvdXRPYmouaW50ZXJzZWN0aW9uID0gdHJ1ZTtcbiAgb3V0T2JqLmJldHdlZW5Qb2ludHMgPSBvdXRPYmoudCA+PSAwLjAgJiYgb3V0T2JqLnQgPD0gMS4wO1xuICByZXR1cm4gb3V0T2JqO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RXaXRoUGxhbmUoXG4gIHBsYW5lMU9yaWdpbixcbiAgcGxhbmUxTm9ybWFsLFxuICBwbGFuZTJPcmlnaW4sXG4gIHBsYW5lMk5vcm1hbFxuKSB7XG4gIGNvbnN0IG91dE9iaiA9IHtcbiAgICBpbnRlcnNlY3Rpb246IGZhbHNlLFxuICAgIGwwOiBbXSxcbiAgICBsMTogW10sXG4gICAgZXJyb3I6IG51bGwsXG4gIH07XG5cbiAgY29uc3QgY3Jvc3MgPSBbXTtcbiAgdnRrTWF0aC5jcm9zcyhwbGFuZTFOb3JtYWwsIHBsYW5lMk5vcm1hbCwgY3Jvc3MpO1xuICBjb25zdCBhYnNDcm9zcyA9IGNyb3NzLm1hcCgobikgPT4gTWF0aC5hYnMobikpO1xuXG4gIC8vIHRlc3QgaWYgdGhlIHR3byBwbGFuZXMgYXJlIHBhcmFsbGVsXG4gIGlmIChhYnNDcm9zc1swXSArIGFic0Nyb3NzWzFdICsgYWJzQ3Jvc3NbMl0gPCBQTEFORV9UT0xFUkFOQ0UpIHtcbiAgICAvLyB0ZXN0IGlmIGRpc2pvaW50IG9yIGNvaW5jaWRlXG4gICAgY29uc3QgdiA9IFtdO1xuICAgIHZ0a01hdGguc3VidHJhY3QocGxhbmUxT3JpZ2luLCBwbGFuZTJPcmlnaW4sIHYpO1xuICAgIGlmICh2dGtNYXRoLmRvdChwbGFuZTFOb3JtYWwsIHYpID09PSAwKSB7XG4gICAgICBvdXRPYmouZXJyb3IgPSBDT0lOQ0lERTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0T2JqLmVycm9yID0gRElTSk9JTlQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRPYmo7XG4gIH1cblxuICAvLyBQbGFuZTEgYW5kIFBsYW5lMiBpbnRlcnNlY3QgaW4gYSBsaW5lXG4gIC8vIGZpcnN0IGRldGVybWluZSBtYXggYWJzIGNvb3JkaW5hdGUgb2YgdGhlIGNyb3NzIHByb2R1Y3RcbiAgbGV0IG1heGM7XG4gIGlmIChhYnNDcm9zc1swXSA+IGFic0Nyb3NzWzFdICYmIGFic0Nyb3NzWzBdID4gYWJzQ3Jvc3NbMl0pIHtcbiAgICBtYXhjID0gJ3gnO1xuICB9IGVsc2UgaWYgKGFic0Nyb3NzWzFdID4gYWJzQ3Jvc3NbMl0pIHtcbiAgICBtYXhjID0gJ3knO1xuICB9IGVsc2Uge1xuICAgIG1heGMgPSAneic7XG4gIH1cblxuICAvLyBUbyBnZXQgYSBwb2ludCBvbiB0aGUgaW50ZXJzZWN0IGxpbmUsIHplcm8gdGhlIG1heCBjb29yZCwgYW5kIHNvbHZlIGZvciB0aGUgb3RoZXIgdHdvXG4gIGNvbnN0IGlQID0gW107IC8vIGludGVyc2VjdGlvblBvaW50XG4gIC8vIHRoZSBjb25zdGFudHMgaW4gdGhlIDIgcGxhbmUgZXF1YXRpb25zXG4gIGNvbnN0IGQxID0gLXZ0a01hdGguZG90KHBsYW5lMU5vcm1hbCwgcGxhbmUxT3JpZ2luKTtcbiAgY29uc3QgZDIgPSAtdnRrTWF0aC5kb3QocGxhbmUyTm9ybWFsLCBwbGFuZTJPcmlnaW4pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcbiAgc3dpdGNoIChtYXhjKSB7XG4gICAgY2FzZSAneCc6IC8vIGludGVyc2VjdCB3aXRoIHg9MFxuICAgICAgaVBbMF0gPSAwO1xuICAgICAgaVBbMV0gPSAoZDIgKiBwbGFuZTFOb3JtYWxbMl0gLSBkMSAqIHBsYW5lMk5vcm1hbFsyXSkgLyBjcm9zc1swXTtcbiAgICAgIGlQWzJdID0gKGQxICogcGxhbmUyTm9ybWFsWzFdIC0gZDIgKiBwbGFuZTFOb3JtYWxbMV0pIC8gY3Jvc3NbMF07XG4gICAgICBicmVhaztcbiAgICBjYXNlICd5JzogLy8gaW50ZXJzZWN0IHdpdGggeT0wXG4gICAgICBpUFswXSA9IChkMSAqIHBsYW5lMk5vcm1hbFsyXSAtIGQyICogcGxhbmUxTm9ybWFsWzJdKSAvIGNyb3NzWzFdO1xuICAgICAgaVBbMV0gPSAwO1xuICAgICAgaVBbMl0gPSAoZDIgKiBwbGFuZTFOb3JtYWxbMF0gLSBkMSAqIHBsYW5lMk5vcm1hbFswXSkgLyBjcm9zc1sxXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3onOiAvLyBpbnRlcnNlY3Qgd2l0aCB6PTBcbiAgICAgIGlQWzBdID0gKGQyICogcGxhbmUxTm9ybWFsWzFdIC0gZDEgKiBwbGFuZTJOb3JtYWxbMV0pIC8gY3Jvc3NbMl07XG4gICAgICBpUFsxXSA9IChkMSAqIHBsYW5lMk5vcm1hbFswXSAtIGQyICogcGxhbmUxTm9ybWFsWzBdKSAvIGNyb3NzWzJdO1xuICAgICAgaVBbMl0gPSAwO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBvdXRPYmoubDAgPSBpUDtcbiAgdnRrTWF0aC5hZGQoaVAsIGNyb3NzLCBvdXRPYmoubDEpO1xuICBvdXRPYmouaW50ZXJzZWN0aW9uID0gdHJ1ZTtcblxuICByZXR1cm4gb3V0T2JqO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTdGF0aWMgQVBJXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBTVEFUSUMgPSB7XG4gIGV2YWx1YXRlLFxuICBkaXN0YW5jZVRvUGxhbmUsXG4gIHByb2plY3RQb2ludCxcbiAgcHJvamVjdFZlY3RvcixcbiAgZ2VuZXJhbGl6ZWRQcm9qZWN0UG9pbnQsXG4gIGludGVyc2VjdFdpdGhMaW5lLFxuICBpbnRlcnNlY3RXaXRoUGxhbmUsXG4gIERJU0pPSU5ULFxuICBDT0lOQ0lERSxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a1BsYW5lIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIHZ0a1BsYW5lKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrUGxhbmUnKTtcblxuICBwdWJsaWNBUEkuZGlzdGFuY2VUb1BsYW5lID0gKHgpID0+XG4gICAgZGlzdGFuY2VUb1BsYW5lKHgsIG1vZGVsLm9yaWdpbiwgbW9kZWwubm9ybWFsKTtcblxuICBwdWJsaWNBUEkucHJvamVjdFBvaW50ID0gKHgsIHhwcm9qKSA9PiB7XG4gICAgcHJvamVjdFBvaW50KHgsIG1vZGVsLm9yaWdpbiwgbW9kZWwubm9ybWFsLCB4cHJvaik7XG4gIH07XG5cbiAgcHVibGljQVBJLnByb2plY3RWZWN0b3IgPSAodiwgdnByb2opID0+IHtcbiAgICBwcm9qZWN0VmVjdG9yKHYsIG1vZGVsLm5vcm1hbCwgdnByb2opO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5wdXNoID0gKGRpc3RhbmNlKSA9PiB7XG4gICAgaWYgKGRpc3RhbmNlID09PSAwLjApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIG1vZGVsLm9yaWdpbltpXSArPSBkaXN0YW5jZSAqIG1vZGVsLm5vcm1hbFtpXTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmdlbmVyYWxpemVkUHJvamVjdFBvaW50ID0gKHgsIHhwcm9qKSA9PiB7XG4gICAgZ2VuZXJhbGl6ZWRQcm9qZWN0UG9pbnQoeCwgbW9kZWwub3JpZ2luLCBtb2RlbC5ub3JtYWwsIHhwcm9qKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZXZhbHVhdGVGdW5jdGlvbiA9ICh4LCB5LCB6KSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBtb2RlbC5ub3JtYWxbMF0gKiAoeCAtIG1vZGVsLm9yaWdpblswXSkgK1xuICAgICAgICBtb2RlbC5ub3JtYWxbMV0gKiAoeSAtIG1vZGVsLm9yaWdpblsxXSkgK1xuICAgICAgICBtb2RlbC5ub3JtYWxbMl0gKiAoeiAtIG1vZGVsLm9yaWdpblsyXSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiAoXG4gICAgICBtb2RlbC5ub3JtYWxbMF0gKiAoeFswXSAtIG1vZGVsLm9yaWdpblswXSkgK1xuICAgICAgbW9kZWwubm9ybWFsWzFdICogKHhbMV0gLSBtb2RlbC5vcmlnaW5bMV0pICtcbiAgICAgIG1vZGVsLm5vcm1hbFsyXSAqICh4WzJdIC0gbW9kZWwub3JpZ2luWzJdKVxuICAgICk7XG4gIH07XG5cbiAgcHVibGljQVBJLmV2YWx1YXRlR3JhZGllbnQgPSAoeHl6KSA9PiB7XG4gICAgY29uc3QgcmV0VmFsID0gW21vZGVsLm5vcm1hbFswXSwgbW9kZWwubm9ybWFsWzFdLCBtb2RlbC5ub3JtYWxbMl1dO1xuICAgIHJldHVybiByZXRWYWw7XG4gIH07XG5cbiAgcHVibGljQVBJLmludGVyc2VjdFdpdGhMaW5lID0gKHAxLCBwMikgPT5cbiAgICBpbnRlcnNlY3RXaXRoTGluZShwMSwgcDIsIG1vZGVsLm9yaWdpbiwgbW9kZWwubm9ybWFsKTtcblxuICBwdWJsaWNBUEkuaW50ZXJzZWN0V2l0aFBsYW5lID0gKHBsYW5lT3JpZ2luLCBwbGFuZU5vcm1hbCkgPT5cbiAgICBpbnRlcnNlY3RXaXRoUGxhbmUocGxhbmVPcmlnaW4sIHBsYW5lTm9ybWFsLCBtb2RlbC5vcmlnaW4sIG1vZGVsLm5vcm1hbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBub3JtYWw6IFswLjAsIDAuMCwgMS4wXSxcbiAgb3JpZ2luOiBbMC4wLCAwLjAsIDAuMF0sXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICBtYWNyby5vYmoocHVibGljQVBJLCBtb2RlbCk7XG5cbiAgbWFjcm8uc2V0R2V0QXJyYXkocHVibGljQVBJLCBtb2RlbCwgWydub3JtYWwnLCAnb3JpZ2luJ10sIDMpO1xuXG4gIHZ0a1BsYW5lKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a1BsYW5lJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kLCAuLi5TVEFUSUMgfTtcbiIsImltcG9ydCB2dGsgZnJvbSAndnRrLmpzL1NvdXJjZXMvdnRrJztcbmltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgdnRrRGF0YVNldCBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0RhdGFTZXQnO1xuaW1wb3J0IHZ0a1BvaW50cyBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9Qb2ludHMnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBHbG9iYWwgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtQb2ludFNldCBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a1BvaW50U2V0KHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrUG9pbnRTZXQnKTtcblxuICAvLyBDcmVhdGUgZW1wdHkgcG9pbnRzXG4gIGlmICghbW9kZWwucG9pbnRzKSB7XG4gICAgbW9kZWwucG9pbnRzID0gdnRrUG9pbnRzLm5ld0luc3RhbmNlKCk7XG4gIH0gZWxzZSB7XG4gICAgbW9kZWwucG9pbnRzID0gdnRrKG1vZGVsLnBvaW50cyk7XG4gIH1cblxuICBwdWJsaWNBUEkuZ2V0TnVtYmVyT2ZQb2ludHMgPSAoKSA9PiBtb2RlbC5wb2ludHMuZ2V0TnVtYmVyT2ZQb2ludHMoKTtcblxuICBwdWJsaWNBUEkuZ2V0Qm91bmRzID0gKCkgPT4gbW9kZWwucG9pbnRzLmdldEJvdW5kcygpO1xuXG4gIHB1YmxpY0FQSS5jb21wdXRlQm91bmRzID0gKCkgPT4ge1xuICAgIHB1YmxpY0FQSS5nZXRCb3VuZHMoKTtcbiAgfTtcblxuICBjb25zdCBzdXBlclNoYWxsb3dDb3B5ID0gcHVibGljQVBJLnNoYWxsb3dDb3B5O1xuICBwdWJsaWNBUEkuc2hhbGxvd0NvcHkgPSAob3RoZXIsIGRlYnVnID0gZmFsc2UpID0+IHtcbiAgICBzdXBlclNoYWxsb3dDb3B5KG90aGVyLCBkZWJ1Zyk7XG4gICAgbW9kZWwucG9pbnRzID0gdnRrUG9pbnRzLm5ld0luc3RhbmNlKCk7XG4gICAgbW9kZWwucG9pbnRzLnNoYWxsb3dDb3B5KG90aGVyLmdldFBvaW50cygpKTtcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIC8vIHBvaW50czogbnVsbCxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEluaGVyaXRhbmNlXG4gIHZ0a0RhdGFTZXQuZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMpO1xuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgWydwb2ludHMnXSk7XG5cbiAgLy8gT2JqZWN0IHNwZWNpZmljIG1ldGhvZHNcbiAgdnRrUG9pbnRTZXQocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrUG9pbnRTZXQnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImV4cG9ydCBjb25zdCBQT0xZREFUQV9GSUVMRFMgPSBbJ3ZlcnRzJywgJ2xpbmVzJywgJ3BvbHlzJywgJ3N0cmlwcyddO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFBPTFlEQVRBX0ZJRUxEUyxcbn07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0IHZ0ayBmcm9tICd2dGsuanMvU291cmNlcy92dGsnO1xuaW1wb3J0IHZ0a0NlbGxBcnJheSBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9DZWxsQXJyYXknO1xuaW1wb3J0IHZ0a0NlbGxMaW5rcyBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0NlbGxMaW5rcyc7XG5pbXBvcnQgdnRrQ2VsbFR5cGVzIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvQ2VsbFR5cGVzJztcbmltcG9ydCB2dGtMaW5lIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvTGluZSc7XG5pbXBvcnQgdnRrUG9pbnRTZXQgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9Qb2ludFNldCc7XG5pbXBvcnQgdnRrVHJpYW5nbGUgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9UcmlhbmdsZSc7XG5cbmltcG9ydCB7IENlbGxUeXBlIH0gZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9DZWxsVHlwZXMvQ29uc3RhbnRzJztcbmltcG9ydCB7IFBPTFlEQVRBX0ZJRUxEUyB9IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvUG9seURhdGEvQ29uc3RhbnRzJztcblxuY29uc3QgeyB2dGtXYXJuaW5nTWFjcm8gfSA9IG1hY3JvO1xuXG5leHBvcnQgY29uc3QgQ0VMTF9GQUNUT1JZID0ge1xuICBbQ2VsbFR5cGUuVlRLX0xJTkVdOiB2dGtMaW5lLFxuICBbQ2VsbFR5cGUuVlRLX1BPTFlfTElORV06IHZ0a0xpbmUsXG4gIFtDZWxsVHlwZS5WVEtfVFJJQU5HTEVdOiB2dGtUcmlhbmdsZSxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a1BvbHlEYXRhIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrUG9seURhdGEocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtQb2x5RGF0YScpO1xuXG4gIGZ1bmN0aW9uIGNhbWVsaXplKHN0cikge1xuICAgIHJldHVybiBzdHJcbiAgICAgIC5yZXBsYWNlKC8oPzpeXFx3fFtBLVpdfFxcYlxcdykvZywgKGxldHRlcikgPT4gbGV0dGVyLnRvVXBwZXJDYXNlKCkpXG4gICAgICAucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gIH1cblxuICAvLyBidWlsZCBlbXB0eSBjZWxsIGFycmF5cyBhbmQgc2V0IG1ldGhvZHNcbiAgUE9MWURBVEFfRklFTERTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICBwdWJsaWNBUElbYGdldE51bWJlck9mJHtjYW1lbGl6ZSh0eXBlKX1gXSA9ICgpID0+XG4gICAgICBtb2RlbFt0eXBlXS5nZXROdW1iZXJPZkNlbGxzKCk7XG4gICAgaWYgKCFtb2RlbFt0eXBlXSkge1xuICAgICAgbW9kZWxbdHlwZV0gPSB2dGtDZWxsQXJyYXkubmV3SW5zdGFuY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWxbdHlwZV0gPSB2dGsobW9kZWxbdHlwZV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcHVibGljQVBJLmdldE51bWJlck9mQ2VsbHMgPSAoKSA9PlxuICAgIFBPTFlEQVRBX0ZJRUxEUy5yZWR1Y2UoXG4gICAgICAobnVtLCBjZWxsVHlwZSkgPT4gbnVtICsgbW9kZWxbY2VsbFR5cGVdLmdldE51bWJlck9mQ2VsbHMoKSxcbiAgICAgIDBcbiAgICApO1xuXG4gIGNvbnN0IHN1cGVyU2hhbGxvd0NvcHkgPSBwdWJsaWNBUEkuc2hhbGxvd0NvcHk7XG4gIHB1YmxpY0FQSS5zaGFsbG93Q29weSA9IChvdGhlciwgZGVidWcgPSBmYWxzZSkgPT4ge1xuICAgIHN1cGVyU2hhbGxvd0NvcHkob3RoZXIsIGRlYnVnKTtcbiAgICBQT0xZREFUQV9GSUVMRFMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgbW9kZWxbdHlwZV0gPSB2dGtDZWxsQXJyYXkubmV3SW5zdGFuY2UoKTtcbiAgICAgIG1vZGVsW3R5cGVdLnNoYWxsb3dDb3B5KG90aGVyLmdldFJlZmVyZW5jZUJ5TmFtZSh0eXBlKSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcHVibGljQVBJLmJ1aWxkQ2VsbHMgPSAoKSA9PiB7XG4gICAgLy8gaGVyZSBhcmUgdGhlIG51bWJlciBvZiBjZWxscyB3ZSBoYXZlXG4gICAgY29uc3QgblZlcnRzID0gcHVibGljQVBJLmdldE51bWJlck9mVmVydHMoKTtcbiAgICBjb25zdCBuTGluZXMgPSBwdWJsaWNBUEkuZ2V0TnVtYmVyT2ZMaW5lcygpO1xuICAgIGNvbnN0IG5Qb2x5cyA9IHB1YmxpY0FQSS5nZXROdW1iZXJPZlBvbHlzKCk7XG4gICAgY29uc3QgblN0cmlwcyA9IHB1YmxpY0FQSS5nZXROdW1iZXJPZlN0cmlwcygpO1xuXG4gICAgLy8gcHJlLWFsbG9jYXRlIHRoZSBzcGFjZSB3ZSBuZWVkXG4gICAgY29uc3QgbkNlbGxzID0gblZlcnRzICsgbkxpbmVzICsgblBvbHlzICsgblN0cmlwcztcblxuICAgIGNvbnN0IHR5cGVzID0gbmV3IFVpbnQ4QXJyYXkobkNlbGxzKTtcbiAgICBsZXQgcFR5cGVzID0gdHlwZXM7XG4gICAgY29uc3QgbG9jcyA9IG5ldyBVaW50MzJBcnJheShuQ2VsbHMpO1xuICAgIGxldCBwTG9jcyA9IGxvY3M7XG5cbiAgICAvLyByZWNvcmQgbG9jYXRpb25zIGFuZCB0eXBlIG9mIGVhY2ggY2VsbC5cbiAgICAvLyB2ZXJ0c1xuICAgIGlmIChuVmVydHMpIHtcbiAgICAgIGxldCBuZXh0Q2VsbFB0cyA9IDA7XG4gICAgICBtb2RlbC52ZXJ0cy5nZXRDZWxsU2l6ZXMoKS5mb3JFYWNoKChudW1DZWxsUHRzLCBpbmRleCkgPT4ge1xuICAgICAgICBwTG9jc1tpbmRleF0gPSBuZXh0Q2VsbFB0cztcbiAgICAgICAgcFR5cGVzW2luZGV4XSA9XG4gICAgICAgICAgbnVtQ2VsbFB0cyA+IDEgPyBDZWxsVHlwZS5WVEtfUE9MWV9WRVJURVggOiBDZWxsVHlwZS5WVEtfVkVSVEVYO1xuICAgICAgICBuZXh0Q2VsbFB0cyArPSBudW1DZWxsUHRzICsgMTtcbiAgICAgIH0pO1xuXG4gICAgICBwTG9jcyA9IHBMb2NzLnN1YmFycmF5KG5WZXJ0cyk7XG4gICAgICBwVHlwZXMgPSBwVHlwZXMuc3ViYXJyYXkoblZlcnRzKTtcbiAgICB9XG5cbiAgICAvLyBsaW5lc1xuICAgIGlmIChuTGluZXMpIHtcbiAgICAgIGxldCBuZXh0Q2VsbFB0cyA9IDA7XG4gICAgICBtb2RlbC5saW5lcy5nZXRDZWxsU2l6ZXMoKS5mb3JFYWNoKChudW1DZWxsUHRzLCBpbmRleCkgPT4ge1xuICAgICAgICBwTG9jc1tpbmRleF0gPSBuZXh0Q2VsbFB0cztcbiAgICAgICAgcFR5cGVzW2luZGV4XSA9XG4gICAgICAgICAgbnVtQ2VsbFB0cyA+IDIgPyBDZWxsVHlwZS5WVEtfUE9MWV9MSU5FIDogQ2VsbFR5cGUuVlRLX0xJTkU7XG4gICAgICAgIGlmIChudW1DZWxsUHRzID09PSAxKSB7XG4gICAgICAgICAgdnRrV2FybmluZ01hY3JvKFxuICAgICAgICAgICAgJ0J1aWxkaW5nIFZUS19MSU5FICcsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICcgd2l0aCBvbmx5IG9uZSBwb2ludCwgYnV0IFZUS19MSU5FIG5lZWRzIGF0IGxlYXN0IHR3byBwb2ludHMuIENoZWNrIHRoZSBpbnB1dC4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0Q2VsbFB0cyArPSBudW1DZWxsUHRzICsgMTtcbiAgICAgIH0pO1xuXG4gICAgICBwTG9jcyA9IHBMb2NzLnN1YmFycmF5KG5MaW5lcyk7XG4gICAgICBwVHlwZXMgPSBwVHlwZXMuc3ViYXJyYXkobkxpbmVzKTtcbiAgICB9XG5cbiAgICAvLyBwb2x5c1xuICAgIGlmIChuUG9seXMpIHtcbiAgICAgIGxldCBuZXh0Q2VsbFB0cyA9IDA7XG4gICAgICBtb2RlbC5wb2x5cy5nZXRDZWxsU2l6ZXMoKS5mb3JFYWNoKChudW1DZWxsUHRzLCBpbmRleCkgPT4ge1xuICAgICAgICBwTG9jc1tpbmRleF0gPSBuZXh0Q2VsbFB0cztcbiAgICAgICAgc3dpdGNoIChudW1DZWxsUHRzKSB7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcFR5cGVzW2luZGV4XSA9IENlbGxUeXBlLlZUS19UUklBTkdMRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHBUeXBlc1tpbmRleF0gPSBDZWxsVHlwZS5WVEtfUVVBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBwVHlwZXNbaW5kZXhdID0gQ2VsbFR5cGUuVlRLX1BPTFlHT047XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtQ2VsbFB0cyA8IDMpIHtcbiAgICAgICAgICB2dGtXYXJuaW5nTWFjcm8oXG4gICAgICAgICAgICAnQnVpbGRpbmcgVlRLX1RSSUFOR0xFICcsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICcgd2l0aCBsZXNzIHRoYW4gdGhyZWUgcG9pbnRzLCBidXQgVlRLX1RSSUFOR0xFIG5lZWRzIGF0IGxlYXN0IHRocmVlIHBvaW50cy4gQ2hlY2sgdGhlIGlucHV0LidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG5leHRDZWxsUHRzICs9IG51bUNlbGxQdHMgKyAxO1xuICAgICAgfSk7XG5cbiAgICAgIHBMb2NzICs9IHBMb2NzLnN1YmFycmF5KG5Qb2x5cyk7XG4gICAgICBwVHlwZXMgKz0gcFR5cGVzLnN1YmFycmF5KG5Qb2x5cyk7XG4gICAgfVxuXG4gICAgLy8gc3RyaXBzXG4gICAgaWYgKG5TdHJpcHMpIHtcbiAgICAgIGxldCBuZXh0Q2VsbFB0cyA9IDA7XG4gICAgICBwVHlwZXMuZmlsbChDZWxsVHlwZS5WVEtfVFJJQU5HTEVfU1RSSVAsIDAsIG5TdHJpcHMpO1xuXG4gICAgICBtb2RlbC5zdHJpcHMuZ2V0Q2VsbFNpemVzKCkuZm9yRWFjaCgobnVtQ2VsbFB0cywgaW5kZXgpID0+IHtcbiAgICAgICAgcExvY3NbaW5kZXhdID0gbmV4dENlbGxQdHM7XG4gICAgICAgIG5leHRDZWxsUHRzICs9IG51bUNlbGxQdHMgKyAxO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IHVwIHRoZSBjZWxsIHR5cGVzIGRhdGEgc3RydWN0dXJlXG4gICAgbW9kZWwuY2VsbHMgPSB2dGtDZWxsVHlwZXMubmV3SW5zdGFuY2UoKTtcbiAgICBtb2RlbC5jZWxscy5zZXRDZWxsVHlwZXMobkNlbGxzLCB0eXBlcywgbG9jcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB1cHdhcmQgbGlua3MgZnJvbSBwb2ludHMgdG8gY2VsbHMgdGhhdCB1c2UgZWFjaCBwb2ludC4gRW5hYmxlc1xuICAgKiB0b3BvbG9naWNhbGx5IGNvbXBsZXggcXVlcmllcy5cbiAgICovXG4gIHB1YmxpY0FQSS5idWlsZExpbmtzID0gKGluaXRpYWxTaXplID0gMCkgPT4ge1xuICAgIGlmIChtb2RlbC5jZWxscyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdWJsaWNBUEkuYnVpbGRDZWxscygpO1xuICAgIH1cblxuICAgIG1vZGVsLmxpbmtzID0gdnRrQ2VsbExpbmtzLm5ld0luc3RhbmNlKCk7XG4gICAgaWYgKGluaXRpYWxTaXplID4gMCkge1xuICAgICAgbW9kZWwubGlua3MuYWxsb2NhdGUoaW5pdGlhbFNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbC5saW5rcy5hbGxvY2F0ZShwdWJsaWNBUEkuZ2V0UG9pbnRzKCkuZ2V0TnVtYmVyT2ZQb2ludHMoKSk7XG4gICAgfVxuXG4gICAgbW9kZWwubGlua3MuYnVpbGRMaW5rcyhwdWJsaWNBUEkpO1xuICB9O1xuXG4gIC8vIFJldHVybnMgYW4gb2JqZWN0IG1hZGUgb2YgdGhlIGNlbGxUeXBlIGFuZCBhIHN1YmFycmF5IGBjZWxsUG9pbnRJZHNgIG9mXG4gIC8vIHRoZSBjZWxsIHBvaW50cy5cbiAgcHVibGljQVBJLmdldENlbGxQb2ludHMgPSAoY2VsbElkKSA9PiB7XG4gICAgY29uc3QgY2VsbFR5cGUgPSBtb2RlbC5jZWxscy5nZXRDZWxsVHlwZShjZWxsSWQpO1xuICAgIGxldCBjZWxscyA9IG51bGw7XG4gICAgc3dpdGNoIChjZWxsVHlwZSkge1xuICAgICAgY2FzZSBDZWxsVHlwZS5WVEtfVkVSVEVYOlxuICAgICAgY2FzZSBDZWxsVHlwZS5WVEtfUE9MWV9WRVJURVg6XG4gICAgICAgIGNlbGxzID0gbW9kZWwudmVydHM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENlbGxUeXBlLlZUS19MSU5FOlxuICAgICAgY2FzZSBDZWxsVHlwZS5WVEtfUE9MWV9MSU5FOlxuICAgICAgICBjZWxscyA9IG1vZGVsLmxpbmVzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDZWxsVHlwZS5WVEtfVFJJQU5HTEU6XG4gICAgICBjYXNlIENlbGxUeXBlLlZUS19RVUFEOlxuICAgICAgY2FzZSBDZWxsVHlwZS5WVEtfUE9MWUdPTjpcbiAgICAgICAgY2VsbHMgPSBtb2RlbC5wb2x5cztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ2VsbFR5cGUuVlRLX1RSSUFOR0xFX1NUUklQOlxuICAgICAgICBjZWxscyA9IG1vZGVsLnN0cmlwcztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNlbGxzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogMCwgY2VsbFBvaW50SWRzOiBudWxsIH07XG4gICAgfVxuICAgIGNvbnN0IGxvYyA9IG1vZGVsLmNlbGxzLmdldENlbGxMb2NhdGlvbihjZWxsSWQpO1xuICAgIGNvbnN0IGNlbGxQb2ludElkcyA9IGNlbGxzLmdldENlbGwobG9jKTtcbiAgICByZXR1cm4geyBjZWxsVHlwZSwgY2VsbFBvaW50SWRzIH07XG4gIH07XG5cbiAgcHVibGljQVBJLmdldFBvaW50Q2VsbHMgPSAocHRJZCkgPT4gbW9kZWwubGlua3MuZ2V0Q2VsbHMocHRJZCk7XG5cbiAgcHVibGljQVBJLmdldENlbGxFZGdlTmVpZ2hib3JzID0gKGNlbGxJZCwgcG9pbnQxLCBwb2ludDIpID0+IHtcbiAgICBjb25zdCBsaW5rMSA9IG1vZGVsLmxpbmtzLmdldExpbmsocG9pbnQxKTtcbiAgICBjb25zdCBsaW5rMiA9IG1vZGVsLmxpbmtzLmdldExpbmsocG9pbnQyKTtcblxuICAgIHJldHVybiBsaW5rMS5jZWxscy5maWx0ZXIoXG4gICAgICAoY2VsbCkgPT4gY2VsbCAhPT0gY2VsbElkICYmIGxpbmsyLmNlbGxzLmluZGV4T2YoY2VsbCkgIT09IC0xXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogSWYgeW91IGtub3cgdGhlIHR5cGUgb2YgY2VsbCwgeW91IG1heSBwcm92aWRlIGl0IHRvIGltcHJvdmUgcGVyZm9ybWFuY2VzLlxuICAgKi9cbiAgcHVibGljQVBJLmdldENlbGwgPSAoY2VsbElkLCBjZWxsSGludCA9IG51bGwpID0+IHtcbiAgICBjb25zdCBjZWxsSW5mbyA9IHB1YmxpY0FQSS5nZXRDZWxsUG9pbnRzKGNlbGxJZCk7XG4gICAgY29uc3QgY2VsbCA9IGNlbGxIaW50IHx8IENFTExfRkFDVE9SWVtjZWxsSW5mby5jZWxsVHlwZV0ubmV3SW5zdGFuY2UoKTtcbiAgICBjZWxsLmluaXRpYWxpemUocHVibGljQVBJLmdldFBvaW50cygpLCBjZWxsSW5mby5jZWxsUG9pbnRJZHMpO1xuICAgIHJldHVybiBjZWxsO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgLy8gdmVydHM6IG51bGwsXG4gIC8vIGxpbmVzOiBudWxsLFxuICAvLyBwb2x5czogbnVsbCxcbiAgLy8gc3RyaXBzOiBudWxsLFxuICAvLyBjZWxsczogbnVsbCxcbiAgLy8gbGlua3M6IG51bGwsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBJbmhlcml0YW5jZVxuICB2dGtQb2ludFNldC5leHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyk7XG4gIG1hY3JvLmdldChwdWJsaWNBUEksIG1vZGVsLCBbJ2NlbGxzJywgJ2xpbmtzJ10pO1xuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgWyd2ZXJ0cycsICdsaW5lcycsICdwb2x5cycsICdzdHJpcHMnXSk7XG5cbiAgLy8gT2JqZWN0IHNwZWNpZmljIG1ldGhvZHNcbiAgdnRrUG9seURhdGEocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrUG9seURhdGEnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsIi8qKlxuICogVGhlIChwcmltYXJ5KSBwcm9wZXJ0eSB0aGF0IGRlc2NyaWJlcyB0aGUgY29udGVudCBvZiBhIHNlbGVjdGlvblxuICogbm9kZSdzIGRhdGEuIE90aGVyIGF1eGlsaWFyeSBkZXNjcmlwdGlvbiBwcm9wZXJ0aWVzIGZvbGxvdy5cbiAqIEdMT0JBTElEUyBtZWFucyB0aGF0IHRoZSBzZWxlY3Rpb24gbGlzdCBjb250YWlucyB2YWx1ZXMgZnJvbSB0aGVcbiAqIHZ0a0RhdGFTZXRBdHRyaWJ1dGUgYXJyYXkgb2YgdGhlIHNhbWUgbmFtZS5cbiAqIFBFRElHUkVFSURTIG1lYW5zIHRoYXQgdGhlIHNlbGVjdGlvbiBsaXN0IGNvbnRhaW5zIHZhbHVlcyBmcm9tIHRoZVxuICogdnRrRGF0YVNldEF0dHJpYnV0ZSBhcnJheSBvZiB0aGUgc2FtZSBuYW1lLlxuICogVkFMVUVTIG1lYW5zIHRoZSB0aGUgc2VsZWN0aW9uIGxpc3QgY29udGFpbnMgdmFsdWVzIGZyb20gYW5cbiAqIGFyYml0cmFyeSBhdHRyaWJ1dGUgYXJyYXkgKGlnbm9yZXMgYW55IGdsb2JhbGlkcyBhdHRyaWJ1dGUpXG4gKiBJTkRJQ0VTIG1lYW5zIHRoYXQgdGhlIHNlbGVjdGlvbiBsaXN0IGNvbnRhaW5zIGluZGV4ZXMgaW50byB0aGVcbiAqIGNlbGwgb3IgcG9pbnQgYXJyYXlzLlxuICogRlJVU1RVTSBtZWFucyB0aGUgc2V0IG9mIHBvaW50cyBhbmQgY2VsbHMgaW5zaWRlIGEgZnJ1c3R1bVxuICogTE9DQVRJT05TIG1lYW5zIHRoZSBzZXQgb2YgcG9pbnRzIGFuZCBjZWxscyBuZWFyIGEgc2V0IG9mIHBvc2l0aW9uc1xuICogVEhSRVNIT0xEUyBtZWFucyB0aGUgcG9pbnRzIGFuZCBjZWxscyB3aXRoIHZhbHVlcyB3aXRoaW4gYSBzZXQgb2YgcmFuZ2VzXG4gKiBnZXRDb250ZW50VHlwZSgpIHJldHVybnMgLTEgaWYgdGhlIGNvbnRlbnQgdHlwZSBpcyBub3Qgc2V0LlxuICovXG5cbi8vIFNwZWNpZnkgaG93IGRhdGEgYXJyYXlzIGNhbiBiZSB1c2VkIGJ5IGRhdGEgb2JqZWN0c1xuZXhwb3J0IGNvbnN0IFNlbGVjdGlvbkNvbnRlbnQgPSB7XG4gIEdMT0JBTElEUzogMCxcbiAgUEVESUdSRUVJRFM6IDEsXG4gIFZBTFVFUzogMixcbiAgSU5ESUNFUzogMyxcbiAgRlJVU1RVTTogNCxcbiAgTE9DQVRJT05TOiA1LFxuICBUSFJFU0hPTERTOiA2LFxuICBCTE9DS1M6IDcsXG4gIFFVRVJZOiA4LFxufTtcblxuZXhwb3J0IGNvbnN0IFNlbGVjdGlvbkZpZWxkID0ge1xuICBDRUxMOiAwLFxuICBQT0lOVDogMSxcbiAgRklFTEQ6IDIsXG4gIFZFUlRFWDogMyxcbiAgRURHRTogNCxcbiAgUk9XOiA1LFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBTZWxlY3Rpb25Db250ZW50LFxuICBTZWxlY3Rpb25GaWVsZCxcbn07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0IENvbnN0YW50cyBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL1NlbGVjdGlvbk5vZGUvQ29uc3RhbnRzJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrU2VsZWN0aW9uTm9kZSBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a1NlbGVjdGlvbk5vZGUocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtTZWxlY3Rpb25Ob2RlJyk7XG5cbiAgcHVibGljQVBJLmdldEJvdW5kcyA9ICgpID0+IG1vZGVsLnBvaW50cy5nZXRCb3VuZHMoKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIGNvbnRlbnRUeXBlOiAtMSxcbiAgZmllbGRUeXBlOiAtMSxcbiAgcHJvcGVydGllczogbnVsbCxcbiAgc2VsZWN0aW9uTGlzdDogW10sXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBJbmhlcml0YW5jZVxuICBtYWNyby5vYmoocHVibGljQVBJLCBtb2RlbCk7XG4gIG1vZGVsLnByb3BlcnRpZXMgPSB7fTtcbiAgbWFjcm8uc2V0R2V0KHB1YmxpY0FQSSwgbW9kZWwsIFtcbiAgICAnY29udGVudFR5cGUnLFxuICAgICdmaWVsZFR5cGUnLFxuICAgICdwcm9wZXJ0aWVzJyxcbiAgICAnc2VsZWN0aW9uTGlzdCcsXG4gIF0pO1xuXG4gIC8vIE9iamVjdCBzcGVjaWZpYyBtZXRob2RzXG4gIHZ0a1NlbGVjdGlvbk5vZGUocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrU2VsZWN0aW9uTm9kZScpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCwgLi4uQ29uc3RhbnRzIH07XG4iLCJleHBvcnQgY29uc3QgU3RydWN0dXJlZFR5cGUgPSB7XG4gIFVOQ0hBTkdFRDogMCxcbiAgU0lOR0xFX1BPSU5UOiAxLFxuICBYX0xJTkU6IDIsXG4gIFlfTElORTogMyxcbiAgWl9MSU5FOiA0LFxuICBYWV9QTEFORTogNSxcbiAgWVpfUExBTkU6IDYsXG4gIFhaX1BMQU5FOiA3LFxuICBYWVpfR1JJRDogOCxcbiAgRU1QVFk6IDksXG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFN0cnVjdHVyZWRUeXBlLFxufTtcbiIsImltcG9ydCBDb25zdGFudHMgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9TdHJ1Y3R1cmVkRGF0YS9Db25zdGFudHMnO1xuXG5jb25zdCB7IFN0cnVjdHVyZWRUeXBlIH0gPSBDb25zdGFudHM7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhRGVzY3JpcHRpb25Gcm9tRXh0ZW50KGluRXh0KSB7XG4gIGxldCBkYXRhRGltID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyArK2kpIHtcbiAgICBpZiAoaW5FeHRbaSAqIDJdIDwgaW5FeHRbaSAqIDIgKyAxXSkge1xuICAgICAgZGF0YURpbSsrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbkV4dFswXSA+IGluRXh0WzFdIHx8IGluRXh0WzJdID4gaW5FeHRbM10gfHwgaW5FeHRbNF0gPiBpbkV4dFs1XSkge1xuICAgIHJldHVybiBTdHJ1Y3R1cmVkVHlwZS5FTVBUWTtcbiAgfVxuXG4gIGlmIChkYXRhRGltID09PSAzKSB7XG4gICAgcmV0dXJuIFN0cnVjdHVyZWRUeXBlLlhZWl9HUklEO1xuICB9XG5cbiAgaWYgKGRhdGFEaW0gPT09IDIpIHtcbiAgICBpZiAoaW5FeHRbMF0gPT09IGluRXh0WzFdKSB7XG4gICAgICByZXR1cm4gU3RydWN0dXJlZFR5cGUuWVpfUExBTkU7XG4gICAgfVxuXG4gICAgaWYgKGluRXh0WzJdID09PSBpbkV4dFszXSkge1xuICAgICAgcmV0dXJuIFN0cnVjdHVyZWRUeXBlLlhaX1BMQU5FO1xuICAgIH1cbiAgICByZXR1cm4gU3RydWN0dXJlZFR5cGUuWFlfUExBTkU7XG4gIH1cblxuICBpZiAoZGF0YURpbSA9PT0gMSkge1xuICAgIGlmIChpbkV4dFswXSA8IGluRXh0WzFdKSB7XG4gICAgICByZXR1cm4gU3RydWN0dXJlZFR5cGUuWF9MSU5FO1xuICAgIH1cblxuICAgIGlmIChpbkV4dFsyXSA8IGluRXh0WzNdKSB7XG4gICAgICByZXR1cm4gU3RydWN0dXJlZFR5cGUuWV9MSU5FO1xuICAgIH1cblxuICAgIHJldHVybiBTdHJ1Y3R1cmVkVHlwZS5aX0xJTkU7XG4gIH1cblxuICByZXR1cm4gU3RydWN0dXJlZFR5cGUuU0lOR0xFX1BPSU5UO1xufVxuXG5leHBvcnQgZGVmYXVsdCB7IGdldERhdGFEZXNjcmlwdGlvbkZyb21FeHRlbnQsIC4uLkNvbnN0YW50cyB9O1xuIiwiaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB2dGtDZWxsIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvQ2VsbCc7XG5pbXBvcnQgKiBhcyB2dGtNYXRoIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL01hdGgnO1xuaW1wb3J0IHZ0a0xpbmUgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9MaW5lJztcbmltcG9ydCB2dGtQbGFuZSBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL1BsYW5lJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gR2xvYmFsIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gY29tcHV0ZU5vcm1hbERpcmVjdGlvbih2MSwgdjIsIHYzLCBuKSB7XG4gIC8vIG9yZGVyIGlzIGltcG9ydGFudCEhISBtYWludGFpbiBjb25zaXN0ZW5jeSB3aXRoIHRyaWFuZ2xlIHZlcnRleCBvcmRlclxuICBjb25zdCBheCA9IHYzWzBdIC0gdjJbMF07XG4gIGNvbnN0IGF5ID0gdjNbMV0gLSB2MlsxXTtcbiAgY29uc3QgYXogPSB2M1syXSAtIHYyWzJdO1xuICBjb25zdCBieCA9IHYxWzBdIC0gdjJbMF07XG4gIGNvbnN0IGJ5ID0gdjFbMV0gLSB2MlsxXTtcbiAgY29uc3QgYnogPSB2MVsyXSAtIHYyWzJdO1xuXG4gIG5bMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgblsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICBuWzJdID0gYXggKiBieSAtIGF5ICogYng7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVOb3JtYWwodjEsIHYyLCB2Mywgbikge1xuICBjb21wdXRlTm9ybWFsRGlyZWN0aW9uKHYxLCB2MiwgdjMsIG4pO1xuICBjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoblswXSAqIG5bMF0gKyBuWzFdICogblsxXSArIG5bMl0gKiBuWzJdKTtcbiAgaWYgKGxlbmd0aCAhPT0gMC4wKSB7XG4gICAgblswXSAvPSBsZW5ndGg7XG4gICAgblsxXSAvPSBsZW5ndGg7XG4gICAgblsyXSAvPSBsZW5ndGg7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU3RhdGljIEFQSVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgU1RBVElDID0ge1xuICBjb21wdXRlTm9ybWFsRGlyZWN0aW9uLFxuICBjb21wdXRlTm9ybWFsLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrVHJpYW5nbGUgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtUcmlhbmdsZShwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a1RyaWFuZ2xlJyk7XG5cbiAgcHVibGljQVBJLmdldENlbGxEaW1lbnNpb24gPSAoKSA9PiAyO1xuICBwdWJsaWNBUEkuaW50ZXJzZWN0V2l0aExpbmUgPSAocDEsIHAyLCB0b2wsIHgsIHBjb29yZHMpID0+IHtcbiAgICBjb25zdCBvdXRPYmogPSB7IHN1YklkOiAwLCB0OiAwLCBpbnRlcnNlY3Q6IC0xIH07XG4gICAgcGNvb3Jkc1syXSA9IDAuMDtcbiAgICBjb25zdCBjbG9zZXN0UG9pbnQgPSBbXTtcbiAgICBjb25zdCB0b2wyID0gdG9sICogdG9sO1xuXG4gICAgLy8gR2V0IG5vcm1hbCBmb3IgdHJpYW5nbGVcbiAgICBjb25zdCBwdDEgPSBbXTtcbiAgICBjb25zdCBwdDIgPSBbXTtcbiAgICBjb25zdCBwdDMgPSBbXTtcbiAgICBtb2RlbC5wb2ludHMuZ2V0UG9pbnQoMCwgcHQxKTtcbiAgICBtb2RlbC5wb2ludHMuZ2V0UG9pbnQoMSwgcHQyKTtcbiAgICBtb2RlbC5wb2ludHMuZ2V0UG9pbnQoMiwgcHQzKTtcbiAgICBjb25zdCBuID0gW107XG4gICAgY29uc3Qgd2VpZ2h0cyA9IFtdO1xuICAgIGNvbXB1dGVOb3JtYWwocHQxLCBwdDIsIHB0Mywgbik7XG4gICAgaWYgKG5bMF0gIT09IDAgfHwgblsxXSAhPT0gMCB8fCBuWzJdICE9PSAwKSB7XG4gICAgICAvLyBJbnRlcnNlY3QgcGxhbmUgb2YgdHJpYW5nbGUgd2l0aCBsaW5lXG4gICAgICBjb25zdCBwbGFuZSA9IHZ0a1BsYW5lLmludGVyc2VjdFdpdGhMaW5lKHAxLCBwMiwgcHQxLCBuKTtcbiAgICAgIG91dE9iai50ID0gcGxhbmUudDtcbiAgICAgIHhbMF0gPSBwbGFuZS54WzBdO1xuICAgICAgeFsxXSA9IHBsYW5lLnhbMV07XG4gICAgICB4WzJdID0gcGxhbmUueFsyXTtcbiAgICAgIGlmICghcGxhbmUuaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIHBjb29yZHNbMF0gPSAwLjA7XG4gICAgICAgIHBjb29yZHNbMV0gPSAwLjA7XG4gICAgICAgIG91dE9iai5pbnRlcnNlY3QgPSAwO1xuICAgICAgICByZXR1cm4gb3V0T2JqO1xuICAgICAgfVxuXG4gICAgICAvLyBFdmFsdWF0ZSBwb3NpdGlvblxuICAgICAgY29uc3QgaW5zaWRlID0gcHVibGljQVBJLmV2YWx1YXRlUG9zaXRpb24oXG4gICAgICAgIHgsXG4gICAgICAgIGNsb3Nlc3RQb2ludCxcbiAgICAgICAgcGNvb3JkcyxcbiAgICAgICAgd2VpZ2h0c1xuICAgICAgKTtcbiAgICAgIGlmIChpbnNpZGUuZXZhbHVhdGlvbiA+PSAwKSB7XG4gICAgICAgIGlmIChpbnNpZGUuZGlzdDIgPD0gdG9sMikge1xuICAgICAgICAgIG91dE9iai5pbnRlcnNlY3QgPSAxO1xuICAgICAgICAgIHJldHVybiBvdXRPYmo7XG4gICAgICAgIH1cbiAgICAgICAgb3V0T2JqLmludGVyc2VjdCA9IGluc2lkZS5ldmFsdWF0aW9uO1xuICAgICAgICByZXR1cm4gb3V0T2JqO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5vcm1hbHMgYXJlIG51bGwsIHNvIHRoZSB0cmlhbmdsZSBpcyBkZWdlbmVyYXRlZCBhbmRcbiAgICAvLyB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrIGludGVyc2VjdGlvbiBiZXR3ZWVuIGxpbmUgYW5kXG4gICAgLy8gdGhlIGxvbmdlc3QgZWRnZS5cbiAgICBjb25zdCBkaXN0MlB0MVB0MiA9IHZ0a01hdGguZGlzdGFuY2UyQmV0d2VlblBvaW50cyhwdDEsIHB0Mik7XG4gICAgY29uc3QgZGlzdDJQdDJQdDMgPSB2dGtNYXRoLmRpc3RhbmNlMkJldHdlZW5Qb2ludHMocHQyLCBwdDMpO1xuICAgIGNvbnN0IGRpc3QyUHQzUHQxID0gdnRrTWF0aC5kaXN0YW5jZTJCZXR3ZWVuUG9pbnRzKHB0MywgcHQxKTtcbiAgICBpZiAoIW1vZGVsLmxpbmUpIHtcbiAgICAgIG1vZGVsLmxpbmUgPSB2dGtMaW5lLm5ld0luc3RhbmNlKCk7XG4gICAgfVxuICAgIGlmIChkaXN0MlB0MVB0MiA+IGRpc3QyUHQyUHQzICYmIGRpc3QyUHQxUHQyID4gZGlzdDJQdDNQdDEpIHtcbiAgICAgIG1vZGVsLmxpbmUuZ2V0UG9pbnRzKCkuc2V0UG9pbnQoMCwgcHQxKTtcbiAgICAgIG1vZGVsLmxpbmUuZ2V0UG9pbnRzKCkuc2V0UG9pbnQoMSwgcHQyKTtcbiAgICB9IGVsc2UgaWYgKGRpc3QyUHQyUHQzID4gZGlzdDJQdDNQdDEgJiYgZGlzdDJQdDJQdDMgPiBkaXN0MlB0MVB0Mikge1xuICAgICAgbW9kZWwubGluZS5nZXRQb2ludHMoKS5zZXRQb2ludCgwLCBwdDIpO1xuICAgICAgbW9kZWwubGluZS5nZXRQb2ludHMoKS5zZXRQb2ludCgxLCBwdDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbC5saW5lLmdldFBvaW50cygpLnNldFBvaW50KDAsIHB0Myk7XG4gICAgICBtb2RlbC5saW5lLmdldFBvaW50cygpLnNldFBvaW50KDEsIHB0MSk7XG4gICAgfVxuXG4gICAgY29uc3QgaW50ZXJzZWN0TGluZSA9IG1vZGVsLmxpbmUuaW50ZXJzZWN0V2l0aExpbmUocDEsIHAyLCB0b2wsIHgsIHBjb29yZHMpO1xuICAgIGlmIChpbnRlcnNlY3RMaW5lLmludGVyc2VjdCkge1xuICAgICAgY29uc3QgcHQzUHQxID0gW107XG4gICAgICBjb25zdCBwdDNQdDIgPSBbXTtcbiAgICAgIGNvbnN0IHB0M1ggPSBbXTtcbiAgICAgIC8vIENvbXB1dGUgciBhbmQgcyBtYW51YWxseSwgdXNpbmcgZG90IGFuZCBub3JtLlxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgcHQzUHQxW2ldID0gcHQxW2ldIC0gcHQzW2ldO1xuICAgICAgICBwdDNQdDJbaV0gPSBwdDJbaV0gLSBwdDNbaV07XG4gICAgICAgIHB0M1hbaV0gPSB4W2ldIC0gcHQzW2ldO1xuICAgICAgfVxuICAgICAgcGNvb3Jkc1swXSA9IHZ0a01hdGguZG90KHB0M1gsIHB0M1B0MSkgLyBkaXN0MlB0M1B0MTtcbiAgICAgIHBjb29yZHNbMV0gPSB2dGtNYXRoLmRvdChwdDNYLCBwdDNQdDIpIC8gZGlzdDJQdDJQdDM7XG4gICAgICBvdXRPYmouZXZhbHVhdGlvbiA9IDE7XG4gICAgICByZXR1cm4gb3V0T2JqO1xuICAgIH1cblxuICAgIHBjb29yZHNbMF0gPSAwLjA7XG4gICAgcGNvb3Jkc1sxXSA9IDAuMDtcbiAgICBvdXRPYmouZXZhbHVhdGlvbiA9IDA7XG4gICAgcmV0dXJuIG91dE9iajtcbiAgfTtcblxuICBwdWJsaWNBUEkuZXZhbHVhdGVQb3NpdGlvbiA9ICh4LCBjbG9zZXN0UG9pbnQsIHBjb29yZHMsIHdlaWdodHMpID0+IHtcbiAgICAvLyB3aWxsIHJldHVybiBvYmpcbiAgICBjb25zdCBvdXRPYmogPSB7IHN1YklkOiAwLCBkaXN0MjogMCwgZXZhbHVhdGlvbjogLTEgfTtcbiAgICBsZXQgaTtcbiAgICBsZXQgajtcbiAgICBjb25zdCBwdDEgPSBbXTtcbiAgICBjb25zdCBwdDIgPSBbXTtcbiAgICBjb25zdCBwdDMgPSBbXTtcbiAgICBjb25zdCBuID0gW107XG4gICAgbGV0IGZhYnNuO1xuICAgIGNvbnN0IHJocyA9IFtdO1xuICAgIGNvbnN0IGMxID0gW107XG4gICAgY29uc3QgYzIgPSBbXTtcbiAgICBsZXQgZGV0ID0gMDtcbiAgICBsZXQgaWR4ID0gMDtcbiAgICBjb25zdCBpbmRpY2VzID0gW107XG4gICAgbGV0IGRpc3QyUG9pbnQ7XG4gICAgbGV0IGRpc3QyTGluZTE7XG4gICAgbGV0IGRpc3QyTGluZTI7XG4gICAgbGV0IGNsb3Nlc3QgPSBbXTtcbiAgICBjb25zdCBjbG9zZXN0UG9pbnQxID0gW107XG4gICAgY29uc3QgY2xvc2VzdFBvaW50MiA9IFtdO1xuICAgIGNvbnN0IGNwID0gW107XG5cbiAgICBvdXRPYmouc3ViSWQgPSAwO1xuICAgIHBjb29yZHNbMl0gPSAwLjA7XG5cbiAgICAvLyBHZXQgbm9ybWFsIGZvciB0cmlhbmdsZSwgb25seSB0aGUgbm9ybWFsIGRpcmVjdGlvbiBpcyBuZWVkZWQsIGkuZS4gdGhlXG4gICAgLy8gbm9ybWFsIG5lZWQgbm90IGJlIG5vcm1hbGl6ZWQgKHVuaXQgbGVuZ3RoKVxuICAgIC8vXG4gICAgbW9kZWwucG9pbnRzLmdldFBvaW50KDEsIHB0MSk7XG4gICAgbW9kZWwucG9pbnRzLmdldFBvaW50KDIsIHB0Mik7XG4gICAgbW9kZWwucG9pbnRzLmdldFBvaW50KDAsIHB0Myk7XG5cbiAgICBjb21wdXRlTm9ybWFsRGlyZWN0aW9uKHB0MSwgcHQyLCBwdDMsIG4pO1xuXG4gICAgLy8gUHJvamVjdCBwb2ludCB0byBwbGFuZVxuICAgIHZ0a1BsYW5lLmdlbmVyYWxpemVkUHJvamVjdFBvaW50KHgsIHB0MSwgbiwgY3ApO1xuXG4gICAgLy8gQ29uc3RydWN0IG1hdHJpY2VzLiAgU2luY2Ugd2UgaGF2ZSBvdmVyIGRldGVybWluZWQgc3lzdGVtLCBuZWVkIHRvIGZpbmRcbiAgICAvLyB3aGljaCAyIG91dCBvZiAzIGVxdWF0aW9ucyB0byB1c2UgdG8gZGV2ZWxvcCBlcXVhdGlvbnMuIChBbnkgMiBzaG91bGRcbiAgICAvLyB3b3JrIHNpbmNlIHdlJ3ZlIHByb2plY3RlZCBwb2ludCB0byBwbGFuZS4pXG4gICAgbGV0IG1heENvbXBvbmVudCA9IDAuMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAvLyB0cnlpbmcgdG8gYXZvaWQgYW4gZXhwZW5zaXZlIGNhbGwgdG8gZmFicygpXG4gICAgICBpZiAobltpXSA8IDApIHtcbiAgICAgICAgZmFic24gPSAtbltpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZhYnNuID0gbltpXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWJzbiA+IG1heENvbXBvbmVudCkge1xuICAgICAgICBtYXhDb21wb25lbnQgPSBmYWJzbjtcbiAgICAgICAgaWR4ID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGogPSAwLCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgaWYgKGkgIT09IGlkeCkge1xuICAgICAgICBpbmRpY2VzW2orK10gPSBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgIHJoc1tpXSA9IGNwW2luZGljZXNbaV1dIC0gcHQzW2luZGljZXNbaV1dO1xuICAgICAgYzFbaV0gPSBwdDFbaW5kaWNlc1tpXV0gLSBwdDNbaW5kaWNlc1tpXV07XG4gICAgICBjMltpXSA9IHB0MltpbmRpY2VzW2ldXSAtIHB0M1tpbmRpY2VzW2ldXTtcbiAgICB9XG4gICAgZGV0ID0gdnRrTWF0aC5kZXRlcm1pbmFudDJ4MihjMSwgYzIpO1xuICAgIGlmIChkZXQgPT09IDAuMCkge1xuICAgICAgcGNvb3Jkc1swXSA9IDAuMDtcbiAgICAgIHBjb29yZHNbMV0gPSAwLjA7XG4gICAgICBvdXRPYmouZXZhbHVhdGlvbiA9IC0xO1xuICAgICAgcmV0dXJuIG91dE9iajtcbiAgICB9XG5cbiAgICBwY29vcmRzWzBdID0gdnRrTWF0aC5kZXRlcm1pbmFudDJ4MihyaHMsIGMyKSAvIGRldDtcbiAgICBwY29vcmRzWzFdID0gdnRrTWF0aC5kZXRlcm1pbmFudDJ4MihjMSwgcmhzKSAvIGRldDtcblxuICAgIC8vIE9rYXksIG5vdyBmaW5kIGNsb3Nlc3QgcG9pbnQgdG8gZWxlbWVudFxuICAgIHdlaWdodHNbMF0gPSAxIC0gKHBjb29yZHNbMF0gKyBwY29vcmRzWzFdKTtcbiAgICB3ZWlnaHRzWzFdID0gcGNvb3Jkc1swXTtcbiAgICB3ZWlnaHRzWzJdID0gcGNvb3Jkc1sxXTtcblxuICAgIGlmIChcbiAgICAgIHdlaWdodHNbMF0gPj0gMC4wICYmXG4gICAgICB3ZWlnaHRzWzBdIDw9IDEuMCAmJlxuICAgICAgd2VpZ2h0c1sxXSA+PSAwLjAgJiZcbiAgICAgIHdlaWdodHNbMV0gPD0gMS4wICYmXG4gICAgICB3ZWlnaHRzWzJdID49IDAuMCAmJlxuICAgICAgd2VpZ2h0c1syXSA8PSAxLjBcbiAgICApIHtcbiAgICAgIC8vIHByb2plY3Rpb24gZGlzdGFuY2VcbiAgICAgIGlmIChjbG9zZXN0UG9pbnQpIHtcbiAgICAgICAgb3V0T2JqLmRpc3QyID0gdnRrTWF0aC5kaXN0YW5jZTJCZXR3ZWVuUG9pbnRzKGNwLCB4KTtcbiAgICAgICAgY2xvc2VzdFBvaW50WzBdID0gY3BbMF07XG4gICAgICAgIGNsb3Nlc3RQb2ludFsxXSA9IGNwWzFdO1xuICAgICAgICBjbG9zZXN0UG9pbnRbMl0gPSBjcFsyXTtcbiAgICAgIH1cbiAgICAgIG91dE9iai5ldmFsdWF0aW9uID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHQ7XG4gICAgICBpZiAoY2xvc2VzdFBvaW50KSB7XG4gICAgICAgIGlmICh3ZWlnaHRzWzFdIDwgMC4wICYmIHdlaWdodHNbMl0gPCAwLjApIHtcbiAgICAgICAgICBkaXN0MlBvaW50ID0gdnRrTWF0aC5kaXN0YW5jZTJCZXR3ZWVuUG9pbnRzKHgsIHB0Myk7XG4gICAgICAgICAgZGlzdDJMaW5lMSA9IHZ0a0xpbmUuZGlzdGFuY2VUb0xpbmUoeCwgcHQxLCBwdDMsIHQsIGNsb3Nlc3RQb2ludDEpO1xuICAgICAgICAgIGRpc3QyTGluZTIgPSB2dGtMaW5lLmRpc3RhbmNlVG9MaW5lKHgsIHB0MywgcHQyLCB0LCBjbG9zZXN0UG9pbnQyKTtcbiAgICAgICAgICBpZiAoZGlzdDJQb2ludCA8IGRpc3QyTGluZTEpIHtcbiAgICAgICAgICAgIG91dE9iai5kaXN0MiA9IGRpc3QyUG9pbnQ7XG4gICAgICAgICAgICBjbG9zZXN0ID0gcHQzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRPYmouZGlzdDIgPSBkaXN0MkxpbmUxO1xuICAgICAgICAgICAgY2xvc2VzdCA9IGNsb3Nlc3RQb2ludDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkaXN0MkxpbmUyIDwgb3V0T2JqLmRpc3QyKSB7XG4gICAgICAgICAgICBvdXRPYmouZGlzdDIgPSBkaXN0MkxpbmUyO1xuICAgICAgICAgICAgY2xvc2VzdCA9IGNsb3Nlc3RQb2ludDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIGNsb3Nlc3RQb2ludFtpXSA9IGNsb3Nlc3RbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHdlaWdodHNbMl0gPCAwLjAgJiYgd2VpZ2h0c1swXSA8IDAuMCkge1xuICAgICAgICAgIGRpc3QyUG9pbnQgPSB2dGtNYXRoLmRpc3RhbmNlMkJldHdlZW5Qb2ludHMoeCwgcHQxKTtcbiAgICAgICAgICBkaXN0MkxpbmUxID0gdnRrTGluZS5kaXN0YW5jZVRvTGluZSh4LCBwdDEsIHB0MywgdCwgY2xvc2VzdFBvaW50MSk7XG4gICAgICAgICAgZGlzdDJMaW5lMiA9IHZ0a0xpbmUuZGlzdGFuY2VUb0xpbmUoeCwgcHQxLCBwdDIsIHQsIGNsb3Nlc3RQb2ludDIpO1xuICAgICAgICAgIGlmIChkaXN0MlBvaW50IDwgZGlzdDJMaW5lMSkge1xuICAgICAgICAgICAgb3V0T2JqLmRpc3QyID0gZGlzdDJQb2ludDtcbiAgICAgICAgICAgIGNsb3Nlc3QgPSBwdDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG91dE9iai5kaXN0MiA9IGRpc3QyTGluZTE7XG4gICAgICAgICAgICBjbG9zZXN0ID0gY2xvc2VzdFBvaW50MTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRpc3QyTGluZTIgPCBvdXRPYmouZGlzdDIpIHtcbiAgICAgICAgICAgIG91dE9iai5kaXN0MiA9IGRpc3QyTGluZTI7XG4gICAgICAgICAgICBjbG9zZXN0ID0gY2xvc2VzdFBvaW50MjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgY2xvc2VzdFBvaW50W2ldID0gY2xvc2VzdFtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAod2VpZ2h0c1sxXSA8IDAuMCAmJiB3ZWlnaHRzWzBdIDwgMC4wKSB7XG4gICAgICAgICAgZGlzdDJQb2ludCA9IHZ0a01hdGguZGlzdGFuY2UyQmV0d2VlblBvaW50cyh4LCBwdDIpO1xuICAgICAgICAgIGRpc3QyTGluZTEgPSB2dGtMaW5lLmRpc3RhbmNlVG9MaW5lKHgsIHB0MiwgcHQzLCB0LCBjbG9zZXN0UG9pbnQxKTtcbiAgICAgICAgICBkaXN0MkxpbmUyID0gdnRrTGluZS5kaXN0YW5jZVRvTGluZSh4LCBwdDEsIHB0MiwgdCwgY2xvc2VzdFBvaW50Mik7XG4gICAgICAgICAgaWYgKGRpc3QyUG9pbnQgPCBkaXN0MkxpbmUxKSB7XG4gICAgICAgICAgICBvdXRPYmouZGlzdDIgPSBkaXN0MlBvaW50O1xuICAgICAgICAgICAgY2xvc2VzdCA9IHB0MjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3V0T2JqLmRpc3QyID0gZGlzdDJMaW5lMTtcbiAgICAgICAgICAgIGNsb3Nlc3QgPSBjbG9zZXN0UG9pbnQxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGlzdDJMaW5lMiA8IG91dE9iai5kaXN0Mikge1xuICAgICAgICAgICAgb3V0T2JqLmRpc3QyID0gZGlzdDJMaW5lMjtcbiAgICAgICAgICAgIGNsb3Nlc3QgPSBjbG9zZXN0UG9pbnQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICBjbG9zZXN0UG9pbnRbaV0gPSBjbG9zZXN0W2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh3ZWlnaHRzWzBdIDwgMC4wKSB7XG4gICAgICAgICAgY29uc3QgbGluZURpc3RhbmNlID0gdnRrTGluZS5kaXN0YW5jZVRvTGluZShcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICBwdDEsXG4gICAgICAgICAgICBwdDIsXG4gICAgICAgICAgICBjbG9zZXN0UG9pbnRcbiAgICAgICAgICApO1xuICAgICAgICAgIG91dE9iai5kaXN0MiA9IGxpbmVEaXN0YW5jZS5kaXN0YW5jZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWlnaHRzWzFdIDwgMC4wKSB7XG4gICAgICAgICAgY29uc3QgbGluZURpc3RhbmNlID0gdnRrTGluZS5kaXN0YW5jZVRvTGluZShcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICBwdDIsXG4gICAgICAgICAgICBwdDMsXG4gICAgICAgICAgICBjbG9zZXN0UG9pbnRcbiAgICAgICAgICApO1xuICAgICAgICAgIG91dE9iai5kaXN0MiA9IGxpbmVEaXN0YW5jZS5kaXN0YW5jZTtcbiAgICAgICAgfSBlbHNlIGlmICh3ZWlnaHRzWzJdIDwgMC4wKSB7XG4gICAgICAgICAgY29uc3QgbGluZURpc3RhbmNlID0gdnRrTGluZS5kaXN0YW5jZVRvTGluZShcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICBwdDEsXG4gICAgICAgICAgICBwdDMsXG4gICAgICAgICAgICBjbG9zZXN0UG9pbnRcbiAgICAgICAgICApO1xuICAgICAgICAgIG91dE9iai5kaXN0MiA9IGxpbmVEaXN0YW5jZS5kaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgb3V0T2JqLmV2YWx1YXRpb24gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiBvdXRPYmo7XG4gIH07XG5cbiAgcHVibGljQVBJLmV2YWx1YXRlTG9jYXRpb24gPSAocGNvb3JkcywgeCwgd2VpZ2h0cykgPT4ge1xuICAgIGNvbnN0IHAwID0gW107XG4gICAgY29uc3QgcDEgPSBbXTtcbiAgICBjb25zdCBwMiA9IFtdO1xuICAgIG1vZGVsLnBvaW50cy5nZXRQb2ludCgwLCBwMCk7XG4gICAgbW9kZWwucG9pbnRzLmdldFBvaW50KDEsIHAxKTtcbiAgICBtb2RlbC5wb2ludHMuZ2V0UG9pbnQoMiwgcDIpO1xuICAgIGNvbnN0IHUzID0gMS4wIC0gcGNvb3Jkc1swXSAtIHBjb29yZHNbMV07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgeFtpXSA9IHAwW2ldICogdTMgKyBwMVtpXSAqIHBjb29yZHNbMF0gKyBwMltpXSAqIHBjb29yZHNbMV07XG4gICAgfVxuXG4gICAgd2VpZ2h0c1swXSA9IHUzO1xuICAgIHdlaWdodHNbMV0gPSBwY29vcmRzWzBdO1xuICAgIHdlaWdodHNbMl0gPSBwY29vcmRzWzFdO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRQYXJhbWV0cmljRGlzdGFuY2UgPSAocGNvb3JkcykgPT4ge1xuICAgIGxldCBwRGlzdDtcbiAgICBsZXQgcERpc3RNYXggPSAwLjA7XG4gICAgY29uc3QgcGMgPSBbXTtcbiAgICBwY1swXSA9IHBjb29yZHNbMF07XG4gICAgcGNbMV0gPSBwY29vcmRzWzFdO1xuICAgIHBjWzJdID0gMS4wIC0gcGNvb3Jkc1swXSAtIHBjb29yZHNbMV07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgaWYgKHBjW2ldIDwgMC4wKSB7XG4gICAgICAgIHBEaXN0ID0gLXBjW2ldO1xuICAgICAgfSBlbHNlIGlmIChwY1tpXSA+IDEuMCkge1xuICAgICAgICBwRGlzdCA9IHBjW2ldIC0gMS4wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW5zaWRlIHRoZSBjZWxsIGluIHRoZSBwYXJhbWV0cmljIGRpcmVjdGlvblxuICAgICAgICBwRGlzdCA9IDAuMDtcbiAgICAgIH1cbiAgICAgIGlmIChwRGlzdCA+IHBEaXN0TWF4KSB7XG4gICAgICAgIHBEaXN0TWF4ID0gcERpc3Q7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwRGlzdE1heDtcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7fTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgdnRrQ2VsbC5leHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyk7XG5cbiAgdnRrVHJpYW5nbGUocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrVHJpYW5nbGUnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQsIC4uLlNUQVRJQyB9O1xuIiwiaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB2dGtJbnRlcmFjdG9yU3R5bGUgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvSW50ZXJhY3RvclN0eWxlJztcbmltcG9ydCB2dGtJbnRlcmFjdG9yU3R5bGVDb25zdGFudHMgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvSW50ZXJhY3RvclN0eWxlL0NvbnN0YW50cyc7XG5pbXBvcnQgKiBhcyB2dGtNYXRoIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL01hdGgnO1xuaW1wb3J0IHtcbiAgRGV2aWNlLFxuICBJbnB1dCxcbn0gZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvUmVuZGVyV2luZG93SW50ZXJhY3Rvci9Db25zdGFudHMnO1xuXG5jb25zdCB7IFN0YXRlcyB9ID0gdnRrSW50ZXJhY3RvclN0eWxlQ29uc3RhbnRzO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1sb25lbHktaWYgKi9cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrSW50ZXJhY3RvclN0eWxlVHJhY2tiYWxsQ2FtZXJhIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrSW50ZXJhY3RvclN0eWxlVHJhY2tiYWxsQ2FtZXJhKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrSW50ZXJhY3RvclN0eWxlVHJhY2tiYWxsQ2FtZXJhJyk7XG5cbiAgLy8gUHVibGljIEFQSSBtZXRob2RzXG4gIHB1YmxpY0FQSS5oYW5kbGVNb3VzZU1vdmUgPSAoY2FsbERhdGEpID0+IHtcbiAgICBjb25zdCBwb3MgPSBjYWxsRGF0YS5wb3NpdGlvbjtcbiAgICBjb25zdCByZW5kZXJlciA9IGNhbGxEYXRhLnBva2VkUmVuZGVyZXI7XG5cbiAgICBzd2l0Y2ggKG1vZGVsLnN0YXRlKSB7XG4gICAgICBjYXNlIFN0YXRlcy5JU19ST1RBVEU6XG4gICAgICAgIHB1YmxpY0FQSS5oYW5kbGVNb3VzZVJvdGF0ZShyZW5kZXJlciwgcG9zKTtcbiAgICAgICAgcHVibGljQVBJLmludm9rZUludGVyYWN0aW9uRXZlbnQoeyB0eXBlOiAnSW50ZXJhY3Rpb25FdmVudCcgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFN0YXRlcy5JU19QQU46XG4gICAgICAgIHB1YmxpY0FQSS5oYW5kbGVNb3VzZVBhbihyZW5kZXJlciwgcG9zKTtcbiAgICAgICAgcHVibGljQVBJLmludm9rZUludGVyYWN0aW9uRXZlbnQoeyB0eXBlOiAnSW50ZXJhY3Rpb25FdmVudCcgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFN0YXRlcy5JU19ET0xMWTpcbiAgICAgICAgcHVibGljQVBJLmhhbmRsZU1vdXNlRG9sbHkocmVuZGVyZXIsIHBvcyk7XG4gICAgICAgIHB1YmxpY0FQSS5pbnZva2VJbnRlcmFjdGlvbkV2ZW50KHsgdHlwZTogJ0ludGVyYWN0aW9uRXZlbnQnIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBTdGF0ZXMuSVNfU1BJTjpcbiAgICAgICAgcHVibGljQVBJLmhhbmRsZU1vdXNlU3BpbihyZW5kZXJlciwgcG9zKTtcbiAgICAgICAgcHVibGljQVBJLmludm9rZUludGVyYWN0aW9uRXZlbnQoeyB0eXBlOiAnSW50ZXJhY3Rpb25FdmVudCcgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBtb2RlbC5wcmV2aW91c1Bvc2l0aW9uID0gcG9zO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuaGFuZGxlQnV0dG9uM0QgPSAoZWQpID0+IHtcbiAgICBpZiAoXG4gICAgICBlZCAmJlxuICAgICAgZWQucHJlc3NlZCAmJlxuICAgICAgZWQuZGV2aWNlID09PSBEZXZpY2UuUmlnaHRDb250cm9sbGVyICYmXG4gICAgICBlZC5pbnB1dCA9PT0gSW5wdXQuVHJhY2tQYWRcbiAgICApIHtcbiAgICAgIHB1YmxpY0FQSS5zdGFydENhbWVyYVBvc2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgZWQgJiZcbiAgICAgICFlZC5wcmVzc2VkICYmXG4gICAgICBlZC5kZXZpY2UgPT09IERldmljZS5SaWdodENvbnRyb2xsZXIgJiZcbiAgICAgIGVkLmlucHV0ID09PSBJbnB1dC5UcmFja1BhZCAmJlxuICAgICAgbW9kZWwuc3RhdGUgPT09IFN0YXRlcy5JU19DQU1FUkFfUE9TRVxuICAgICkge1xuICAgICAgcHVibGljQVBJLmVuZENhbWVyYVBvc2UoKTtcbiAgICAgIC8vIHJldHVybjtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmhhbmRsZU1vdmUzRCA9IChlZCkgPT4ge1xuICAgIHN3aXRjaCAobW9kZWwuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGVzLklTX0NBTUVSQV9QT1NFOlxuICAgICAgICBwdWJsaWNBUEkudXBkYXRlQ2FtZXJhUG9zZShlZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLnVwZGF0ZUNhbWVyYVBvc2UgPSAoZWQpID0+IHtcbiAgICAvLyBtb3ZlIHRoZSB3b3JsZCBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZVxuICAgIC8vIGNvbnRyb2xsZXJcbiAgICBjb25zdCBjYW1lcmEgPSBlZC5wb2tlZFJlbmRlcmVyLmdldEFjdGl2ZUNhbWVyYSgpO1xuICAgIGNvbnN0IG9sZFRyYW5zID0gY2FtZXJhLmdldFBoeXNpY2FsVHJhbnNsYXRpb24oKTtcblxuICAgIC8vIGxvb2sgYXQgdGhlIHkgYXhpcyB0byBkZXRlcm1pbmUgaG93IGZhc3QgLyB3aGF0IGRpcmVjdGlvbiB0byBtb3ZlXG4gICAgY29uc3Qgc3BlZWQgPSBlZC5nYW1lcGFkLmF4ZXNbMV07XG5cbiAgICAvLyAwLjA1IG1ldGVycyAvIGZyYW1lIG1vdmVtZW50XG4gICAgY29uc3QgcHNjYWxlID0gKHNwZWVkICogMC4wNSkgLyBjYW1lcmEuZ2V0UGh5c2ljYWxTY2FsZSgpO1xuXG4gICAgLy8gY29udmVydCBvcmllbnRhdGlvbiB0byB3b3JsZCBjb29yZGluYXRlIGRpcmVjdGlvblxuICAgIGNvbnN0IGRpciA9IGNhbWVyYS5waHlzaWNhbE9yaWVudGF0aW9uVG9Xb3JsZERpcmVjdGlvbihlZC5vcmllbnRhdGlvbik7XG5cbiAgICBjYW1lcmEuc2V0UGh5c2ljYWxUcmFuc2xhdGlvbihcbiAgICAgIG9sZFRyYW5zWzBdICsgZGlyWzBdICogcHNjYWxlLFxuICAgICAgb2xkVHJhbnNbMV0gKyBkaXJbMV0gKiBwc2NhbGUsXG4gICAgICBvbGRUcmFuc1syXSArIGRpclsyXSAqIHBzY2FsZVxuICAgICk7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5oYW5kbGVMZWZ0QnV0dG9uUHJlc3MgPSAoY2FsbERhdGEpID0+IHtcbiAgICBjb25zdCBwb3MgPSBjYWxsRGF0YS5wb3NpdGlvbjtcbiAgICBtb2RlbC5wcmV2aW91c1Bvc2l0aW9uID0gcG9zO1xuXG4gICAgaWYgKGNhbGxEYXRhLnNoaWZ0S2V5KSB7XG4gICAgICBpZiAoY2FsbERhdGEuY29udHJvbEtleSB8fCBjYWxsRGF0YS5hbHRLZXkpIHtcbiAgICAgICAgcHVibGljQVBJLnN0YXJ0RG9sbHkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1YmxpY0FQSS5zdGFydFBhbigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY2FsbERhdGEuY29udHJvbEtleSB8fCBjYWxsRGF0YS5hbHRLZXkpIHtcbiAgICAgICAgcHVibGljQVBJLnN0YXJ0U3BpbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVibGljQVBJLnN0YXJ0Um90YXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmhhbmRsZUxlZnRCdXR0b25SZWxlYXNlID0gKCkgPT4ge1xuICAgIHN3aXRjaCAobW9kZWwuc3RhdGUpIHtcbiAgICAgIGNhc2UgU3RhdGVzLklTX0RPTExZOlxuICAgICAgICBwdWJsaWNBUEkuZW5kRG9sbHkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlcy5JU19QQU46XG4gICAgICAgIHB1YmxpY0FQSS5lbmRQYW4oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0YXRlcy5JU19TUElOOlxuICAgICAgICBwdWJsaWNBUEkuZW5kU3BpbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RhdGVzLklTX1JPVEFURTpcbiAgICAgICAgcHVibGljQVBJLmVuZFJvdGF0ZSgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuaGFuZGxlU3RhcnRNb3VzZVdoZWVsID0gKGNhbGxEYXRhKSA9PiB7XG4gICAgcHVibGljQVBJLnN0YXJ0RG9sbHkoKTtcbiAgICBwdWJsaWNBUEkuaGFuZGxlTW91c2VXaGVlbChjYWxsRGF0YSk7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuaGFuZGxlRW5kTW91c2VXaGVlbCA9ICgpID0+IHtcbiAgICBwdWJsaWNBUEkuZW5kRG9sbHkoKTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmhhbmRsZVN0YXJ0UGluY2ggPSAoY2FsbERhdGEpID0+IHtcbiAgICBtb2RlbC5wcmV2aW91c1NjYWxlID0gY2FsbERhdGEuc2NhbGU7XG4gICAgcHVibGljQVBJLnN0YXJ0RG9sbHkoKTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5oYW5kbGVFbmRQaW5jaCA9ICgpID0+IHtcbiAgICBwdWJsaWNBUEkuZW5kRG9sbHkoKTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmhhbmRsZVN0YXJ0Um90YXRlID0gKGNhbGxEYXRhKSA9PiB7XG4gICAgbW9kZWwucHJldmlvdXNSb3RhdGlvbiA9IGNhbGxEYXRhLnJvdGF0aW9uO1xuICAgIHB1YmxpY0FQSS5zdGFydFJvdGF0ZSgpO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmhhbmRsZUVuZFJvdGF0ZSA9ICgpID0+IHtcbiAgICBwdWJsaWNBUEkuZW5kUm90YXRlKCk7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5oYW5kbGVTdGFydFBhbiA9IChjYWxsRGF0YSkgPT4ge1xuICAgIG1vZGVsLnByZXZpb3VzVHJhbnNsYXRpb24gPSBjYWxsRGF0YS50cmFuc2xhdGlvbjtcbiAgICBwdWJsaWNBUEkuc3RhcnRQYW4oKTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5oYW5kbGVFbmRQYW4gPSAoKSA9PiB7XG4gICAgcHVibGljQVBJLmVuZFBhbigpO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuaGFuZGxlUGluY2ggPSAoY2FsbERhdGEpID0+IHtcbiAgICBwdWJsaWNBUEkuZG9sbHlCeUZhY3RvcihcbiAgICAgIGNhbGxEYXRhLnBva2VkUmVuZGVyZXIsXG4gICAgICBjYWxsRGF0YS5zY2FsZSAvIG1vZGVsLnByZXZpb3VzU2NhbGVcbiAgICApO1xuICAgIG1vZGVsLnByZXZpb3VzU2NhbGUgPSBjYWxsRGF0YS5zY2FsZTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmhhbmRsZVBhbiA9IChjYWxsRGF0YSkgPT4ge1xuICAgIGNvbnN0IGNhbWVyYSA9IGNhbGxEYXRhLnBva2VkUmVuZGVyZXIuZ2V0QWN0aXZlQ2FtZXJhKCk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGZvY2FsIGRlcHRoIHNpbmNlIHdlJ2xsIGJlIHVzaW5nIGl0IGEgbG90XG4gICAgbGV0IHZpZXdGb2N1cyA9IGNhbWVyYS5nZXRGb2NhbFBvaW50KCk7XG5cbiAgICB2aWV3Rm9jdXMgPSBwdWJsaWNBUEkuY29tcHV0ZVdvcmxkVG9EaXNwbGF5KFxuICAgICAgY2FsbERhdGEucG9rZWRSZW5kZXJlcixcbiAgICAgIHZpZXdGb2N1c1swXSxcbiAgICAgIHZpZXdGb2N1c1sxXSxcbiAgICAgIHZpZXdGb2N1c1syXVxuICAgICk7XG4gICAgY29uc3QgZm9jYWxEZXB0aCA9IHZpZXdGb2N1c1syXTtcblxuICAgIGNvbnN0IHRyYW5zID0gY2FsbERhdGEudHJhbnNsYXRpb247XG4gICAgY29uc3QgbGFzdFRyYW5zID0gbW9kZWwucHJldmlvdXNUcmFuc2xhdGlvbjtcbiAgICBjb25zdCBuZXdQaWNrUG9pbnQgPSBwdWJsaWNBUEkuY29tcHV0ZURpc3BsYXlUb1dvcmxkKFxuICAgICAgY2FsbERhdGEucG9rZWRSZW5kZXJlcixcbiAgICAgIHZpZXdGb2N1c1swXSArIHRyYW5zWzBdIC0gbGFzdFRyYW5zWzBdLFxuICAgICAgdmlld0ZvY3VzWzFdICsgdHJhbnNbMV0gLSBsYXN0VHJhbnNbMV0sXG4gICAgICBmb2NhbERlcHRoXG4gICAgKTtcblxuICAgIC8vIEhhcyB0byByZWNhbGMgb2xkIG1vdXNlIHBvaW50IHNpbmNlIHRoZSB2aWV3cG9ydCBoYXMgbW92ZWQsXG4gICAgLy8gc28gY2FuJ3QgbW92ZSBpdCBvdXRzaWRlIHRoZSBsb29wXG4gICAgY29uc3Qgb2xkUGlja1BvaW50ID0gcHVibGljQVBJLmNvbXB1dGVEaXNwbGF5VG9Xb3JsZChcbiAgICAgIGNhbGxEYXRhLnBva2VkUmVuZGVyZXIsXG4gICAgICB2aWV3Rm9jdXNbMF0sXG4gICAgICB2aWV3Rm9jdXNbMV0sXG4gICAgICBmb2NhbERlcHRoXG4gICAgKTtcblxuICAgIC8vIENhbWVyYSBtb3Rpb24gaXMgcmV2ZXJzZWRcbiAgICBjb25zdCBtb3Rpb25WZWN0b3IgPSBbXTtcbiAgICBtb3Rpb25WZWN0b3JbMF0gPSBvbGRQaWNrUG9pbnRbMF0gLSBuZXdQaWNrUG9pbnRbMF07XG4gICAgbW90aW9uVmVjdG9yWzFdID0gb2xkUGlja1BvaW50WzFdIC0gbmV3UGlja1BvaW50WzFdO1xuICAgIG1vdGlvblZlY3RvclsyXSA9IG9sZFBpY2tQb2ludFsyXSAtIG5ld1BpY2tQb2ludFsyXTtcblxuICAgIHZpZXdGb2N1cyA9IGNhbWVyYS5nZXRGb2NhbFBvaW50KCk7XG4gICAgY29uc3Qgdmlld1BvaW50ID0gY2FtZXJhLmdldFBvc2l0aW9uKCk7XG4gICAgY2FtZXJhLnNldEZvY2FsUG9pbnQoXG4gICAgICBtb3Rpb25WZWN0b3JbMF0gKyB2aWV3Rm9jdXNbMF0sXG4gICAgICBtb3Rpb25WZWN0b3JbMV0gKyB2aWV3Rm9jdXNbMV0sXG4gICAgICBtb3Rpb25WZWN0b3JbMl0gKyB2aWV3Rm9jdXNbMl1cbiAgICApO1xuXG4gICAgY2FtZXJhLnNldFBvc2l0aW9uKFxuICAgICAgbW90aW9uVmVjdG9yWzBdICsgdmlld1BvaW50WzBdLFxuICAgICAgbW90aW9uVmVjdG9yWzFdICsgdmlld1BvaW50WzFdLFxuICAgICAgbW90aW9uVmVjdG9yWzJdICsgdmlld1BvaW50WzJdXG4gICAgKTtcblxuICAgIGlmIChtb2RlbC5pbnRlcmFjdG9yLmdldExpZ2h0Rm9sbG93Q2FtZXJhKCkpIHtcbiAgICAgIGNhbGxEYXRhLnBva2VkUmVuZGVyZXIudXBkYXRlTGlnaHRzR2VvbWV0cnlUb0ZvbGxvd0NhbWVyYSgpO1xuICAgIH1cblxuICAgIGNhbWVyYS5vcnRob2dvbmFsaXplVmlld1VwKCk7XG5cbiAgICBtb2RlbC5wcmV2aW91c1RyYW5zbGF0aW9uID0gY2FsbERhdGEudHJhbnNsYXRpb247XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5oYW5kbGVSb3RhdGUgPSAoY2FsbERhdGEpID0+IHtcbiAgICBjb25zdCBjYW1lcmEgPSBjYWxsRGF0YS5wb2tlZFJlbmRlcmVyLmdldEFjdGl2ZUNhbWVyYSgpO1xuICAgIGNhbWVyYS5yb2xsKGNhbGxEYXRhLnJvdGF0aW9uIC0gbW9kZWwucHJldmlvdXNSb3RhdGlvbik7XG4gICAgY2FtZXJhLm9ydGhvZ29uYWxpemVWaWV3VXAoKTtcbiAgICBtb2RlbC5wcmV2aW91c1JvdGF0aW9uID0gY2FsbERhdGEucm90YXRpb247XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuaGFuZGxlTW91c2VSb3RhdGUgPSAocmVuZGVyZXIsIHBvc2l0aW9uKSA9PiB7XG4gICAgY29uc3QgcndpID0gbW9kZWwuaW50ZXJhY3RvcjtcblxuICAgIGNvbnN0IGR4ID0gcG9zaXRpb24ueCAtIG1vZGVsLnByZXZpb3VzUG9zaXRpb24ueDtcbiAgICBjb25zdCBkeSA9IHBvc2l0aW9uLnkgLSBtb2RlbC5wcmV2aW91c1Bvc2l0aW9uLnk7XG5cbiAgICBjb25zdCBzaXplID0gcndpLmdldFZpZXcoKS5nZXRWaWV3cG9ydFNpemUocmVuZGVyZXIpO1xuXG4gICAgbGV0IGRlbHRhRWxldmF0aW9uID0gLTAuMTtcbiAgICBsZXQgZGVsdGFBemltdXRoID0gLTAuMTtcbiAgICBpZiAoc2l6ZVswXSAmJiBzaXplWzFdKSB7XG4gICAgICBkZWx0YUVsZXZhdGlvbiA9IC0yMC4wIC8gc2l6ZVsxXTtcbiAgICAgIGRlbHRhQXppbXV0aCA9IC0yMC4wIC8gc2l6ZVswXTtcbiAgICB9XG5cbiAgICBjb25zdCByeGYgPSBkeCAqIGRlbHRhQXppbXV0aCAqIG1vZGVsLm1vdGlvbkZhY3RvcjtcbiAgICBjb25zdCByeWYgPSBkeSAqIGRlbHRhRWxldmF0aW9uICogbW9kZWwubW90aW9uRmFjdG9yO1xuXG4gICAgY29uc3QgY2FtZXJhID0gcmVuZGVyZXIuZ2V0QWN0aXZlQ2FtZXJhKCk7XG4gICAgaWYgKCFOdW1iZXIuaXNOYU4ocnhmKSAmJiAhTnVtYmVyLmlzTmFOKHJ5ZikpIHtcbiAgICAgIGNhbWVyYS5hemltdXRoKHJ4Zik7XG4gICAgICBjYW1lcmEuZWxldmF0aW9uKHJ5Zik7XG4gICAgICBjYW1lcmEub3J0aG9nb25hbGl6ZVZpZXdVcCgpO1xuICAgIH1cblxuICAgIGlmIChtb2RlbC5hdXRvQWRqdXN0Q2FtZXJhQ2xpcHBpbmdSYW5nZSkge1xuICAgICAgcmVuZGVyZXIucmVzZXRDYW1lcmFDbGlwcGluZ1JhbmdlKCk7XG4gICAgfVxuXG4gICAgaWYgKHJ3aS5nZXRMaWdodEZvbGxvd0NhbWVyYSgpKSB7XG4gICAgICByZW5kZXJlci51cGRhdGVMaWdodHNHZW9tZXRyeVRvRm9sbG93Q2FtZXJhKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmhhbmRsZU1vdXNlU3BpbiA9IChyZW5kZXJlciwgcG9zaXRpb24pID0+IHtcbiAgICBjb25zdCByd2kgPSBtb2RlbC5pbnRlcmFjdG9yO1xuICAgIGNvbnN0IGNhbWVyYSA9IHJlbmRlcmVyLmdldEFjdGl2ZUNhbWVyYSgpO1xuICAgIGNvbnN0IGNlbnRlciA9IHJ3aS5nZXRWaWV3KCkuZ2V0Vmlld3BvcnRDZW50ZXIocmVuZGVyZXIpO1xuXG4gICAgY29uc3Qgb2xkQW5nbGUgPSB2dGtNYXRoLmRlZ3JlZXNGcm9tUmFkaWFucyhcbiAgICAgIE1hdGguYXRhbjIoXG4gICAgICAgIG1vZGVsLnByZXZpb3VzUG9zaXRpb24ueSAtIGNlbnRlclsxXSxcbiAgICAgICAgbW9kZWwucHJldmlvdXNQb3NpdGlvbi54IC0gY2VudGVyWzBdXG4gICAgICApXG4gICAgKTtcbiAgICBjb25zdCBuZXdBbmdsZSA9XG4gICAgICB2dGtNYXRoLmRlZ3JlZXNGcm9tUmFkaWFucyhcbiAgICAgICAgTWF0aC5hdGFuMihwb3NpdGlvbi55IC0gY2VudGVyWzFdLCBwb3NpdGlvbi54IC0gY2VudGVyWzBdKVxuICAgICAgKSAtIG9sZEFuZ2xlO1xuXG4gICAgaWYgKCFOdW1iZXIuaXNOYU4obmV3QW5nbGUpKSB7XG4gICAgICBjYW1lcmEucm9sbChuZXdBbmdsZSk7XG4gICAgICBjYW1lcmEub3J0aG9nb25hbGl6ZVZpZXdVcCgpO1xuICAgIH1cbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5oYW5kbGVNb3VzZVBhbiA9IChyZW5kZXJlciwgcG9zaXRpb24pID0+IHtcbiAgICBjb25zdCBjYW1lcmEgPSByZW5kZXJlci5nZXRBY3RpdmVDYW1lcmEoKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZm9jYWwgZGVwdGggc2luY2Ugd2UnbGwgYmUgdXNpbmcgaXQgYSBsb3RcbiAgICBsZXQgdmlld0ZvY3VzID0gY2FtZXJhLmdldEZvY2FsUG9pbnQoKTtcbiAgICB2aWV3Rm9jdXMgPSBwdWJsaWNBUEkuY29tcHV0ZVdvcmxkVG9EaXNwbGF5KFxuICAgICAgcmVuZGVyZXIsXG4gICAgICB2aWV3Rm9jdXNbMF0sXG4gICAgICB2aWV3Rm9jdXNbMV0sXG4gICAgICB2aWV3Rm9jdXNbMl1cbiAgICApO1xuICAgIGNvbnN0IGZvY2FsRGVwdGggPSB2aWV3Rm9jdXNbMl07XG5cbiAgICBjb25zdCBuZXdQaWNrUG9pbnQgPSBwdWJsaWNBUEkuY29tcHV0ZURpc3BsYXlUb1dvcmxkKFxuICAgICAgcmVuZGVyZXIsXG4gICAgICBwb3NpdGlvbi54LFxuICAgICAgcG9zaXRpb24ueSxcbiAgICAgIGZvY2FsRGVwdGhcbiAgICApO1xuXG4gICAgLy8gSGFzIHRvIHJlY2FsYyBvbGQgbW91c2UgcG9pbnQgc2luY2UgdGhlIHZpZXdwb3J0IGhhcyBtb3ZlZCxcbiAgICAvLyBzbyBjYW4ndCBtb3ZlIGl0IG91dHNpZGUgdGhlIGxvb3BcbiAgICBjb25zdCBvbGRQaWNrUG9pbnQgPSBwdWJsaWNBUEkuY29tcHV0ZURpc3BsYXlUb1dvcmxkKFxuICAgICAgcmVuZGVyZXIsXG4gICAgICBtb2RlbC5wcmV2aW91c1Bvc2l0aW9uLngsXG4gICAgICBtb2RlbC5wcmV2aW91c1Bvc2l0aW9uLnksXG4gICAgICBmb2NhbERlcHRoXG4gICAgKTtcblxuICAgIC8vIENhbWVyYSBtb3Rpb24gaXMgcmV2ZXJzZWRcbiAgICBjb25zdCBtb3Rpb25WZWN0b3IgPSBbXTtcbiAgICBtb3Rpb25WZWN0b3JbMF0gPSBvbGRQaWNrUG9pbnRbMF0gLSBuZXdQaWNrUG9pbnRbMF07XG4gICAgbW90aW9uVmVjdG9yWzFdID0gb2xkUGlja1BvaW50WzFdIC0gbmV3UGlja1BvaW50WzFdO1xuICAgIG1vdGlvblZlY3RvclsyXSA9IG9sZFBpY2tQb2ludFsyXSAtIG5ld1BpY2tQb2ludFsyXTtcblxuICAgIHZpZXdGb2N1cyA9IGNhbWVyYS5nZXRGb2NhbFBvaW50KCk7XG4gICAgY29uc3Qgdmlld1BvaW50ID0gY2FtZXJhLmdldFBvc2l0aW9uKCk7XG4gICAgY2FtZXJhLnNldEZvY2FsUG9pbnQoXG4gICAgICBtb3Rpb25WZWN0b3JbMF0gKyB2aWV3Rm9jdXNbMF0sXG4gICAgICBtb3Rpb25WZWN0b3JbMV0gKyB2aWV3Rm9jdXNbMV0sXG4gICAgICBtb3Rpb25WZWN0b3JbMl0gKyB2aWV3Rm9jdXNbMl1cbiAgICApO1xuXG4gICAgY2FtZXJhLnNldFBvc2l0aW9uKFxuICAgICAgbW90aW9uVmVjdG9yWzBdICsgdmlld1BvaW50WzBdLFxuICAgICAgbW90aW9uVmVjdG9yWzFdICsgdmlld1BvaW50WzFdLFxuICAgICAgbW90aW9uVmVjdG9yWzJdICsgdmlld1BvaW50WzJdXG4gICAgKTtcblxuICAgIGlmIChtb2RlbC5pbnRlcmFjdG9yLmdldExpZ2h0Rm9sbG93Q2FtZXJhKCkpIHtcbiAgICAgIHJlbmRlcmVyLnVwZGF0ZUxpZ2h0c0dlb21ldHJ5VG9Gb2xsb3dDYW1lcmEoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5oYW5kbGVNb3VzZURvbGx5ID0gKHJlbmRlcmVyLCBwb3NpdGlvbikgPT4ge1xuICAgIGNvbnN0IGR5ID0gcG9zaXRpb24ueSAtIG1vZGVsLnByZXZpb3VzUG9zaXRpb24ueTtcbiAgICBjb25zdCByd2kgPSBtb2RlbC5pbnRlcmFjdG9yO1xuICAgIGNvbnN0IGNlbnRlciA9IHJ3aS5nZXRWaWV3KCkuZ2V0Vmlld3BvcnRDZW50ZXIocmVuZGVyZXIpO1xuICAgIGNvbnN0IGR5ZiA9IChtb2RlbC5tb3Rpb25GYWN0b3IgKiBkeSkgLyBjZW50ZXJbMV07XG5cbiAgICBwdWJsaWNBUEkuZG9sbHlCeUZhY3RvcihyZW5kZXJlciwgMS4xICoqIGR5Zik7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5oYW5kbGVNb3VzZVdoZWVsID0gKGNhbGxEYXRhKSA9PiB7XG4gICAgY29uc3QgZHlmID0gMSAtIGNhbGxEYXRhLnNwaW5ZIC8gMTA7IC8vIGRpdmlkZSBieSAxMCB0byBsb3dlciB0aGUgem9vbSBmYWN0b3JcbiAgICBwdWJsaWNBUEkuZG9sbHlCeUZhY3RvcihjYWxsRGF0YS5wb2tlZFJlbmRlcmVyLCBkeWYpO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuZG9sbHlCeUZhY3RvciA9IChyZW5kZXJlciwgZmFjdG9yKSA9PiB7XG4gICAgaWYgKE51bWJlci5pc05hTihmYWN0b3IpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY2FtZXJhID0gcmVuZGVyZXIuZ2V0QWN0aXZlQ2FtZXJhKCk7XG4gICAgaWYgKGNhbWVyYS5nZXRQYXJhbGxlbFByb2plY3Rpb24oKSkge1xuICAgICAgY2FtZXJhLnNldFBhcmFsbGVsU2NhbGUoY2FtZXJhLmdldFBhcmFsbGVsU2NhbGUoKSAvIGZhY3Rvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbWVyYS5kb2xseShmYWN0b3IpO1xuICAgICAgaWYgKG1vZGVsLmF1dG9BZGp1c3RDYW1lcmFDbGlwcGluZ1JhbmdlKSB7XG4gICAgICAgIHJlbmRlcmVyLnJlc2V0Q2FtZXJhQ2xpcHBpbmdSYW5nZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2RlbC5pbnRlcmFjdG9yLmdldExpZ2h0Rm9sbG93Q2FtZXJhKCkpIHtcbiAgICAgIHJlbmRlcmVyLnVwZGF0ZUxpZ2h0c0dlb21ldHJ5VG9Gb2xsb3dDYW1lcmEoKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBtb3Rpb25GYWN0b3I6IDEwLjAsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBJbmhlcml0YW5jZVxuICB2dGtJbnRlcmFjdG9yU3R5bGUuZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIENyZWF0ZSBnZXQtc2V0IG1hY3Jvc1xuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgWydtb3Rpb25GYWN0b3InXSk7XG5cbiAgLy8gRm9yIG1vcmUgbWFjcm8gbWV0aG9kcywgc2VlIFwiU291cmNlcy9tYWNyby5qc1wiXG5cbiAgLy8gT2JqZWN0IHNwZWNpZmljIG1ldGhvZHNcbiAgdnRrSW50ZXJhY3RvclN0eWxlVHJhY2tiYWxsQ2FtZXJhKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKFxuICBleHRlbmQsXG4gICd2dGtJbnRlcmFjdG9yU3R5bGVUcmFja2JhbGxDYW1lcmEnXG4pO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCB9O1xuIiwiaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrQWJzdHJhY3RNYXBwZXIgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtBYnN0cmFjdE1hcHBlcihwdWJsaWNBUEksIG1vZGVsKSB7XG4gIHB1YmxpY0FQSS51cGRhdGUgPSAoKSA9PiB7XG4gICAgcHVibGljQVBJLmdldElucHV0RGF0YSgpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5hZGRDbGlwcGluZ1BsYW5lID0gKHBsYW5lKSA9PiB7XG4gICAgaWYgKHBsYW5lLmdldENsYXNzTmFtZSgpICE9PSAndnRrUGxhbmUnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1vZGVsLmNsaXBwaW5nUGxhbmVzLnB1c2gocGxhbmUpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXROdW1iZXJPZkNsaXBwaW5nUGxhbmVzID0gKCkgPT4gbW9kZWwuY2xpcHBpbmdQbGFuZXMubGVuZ3RoO1xuXG4gIHB1YmxpY0FQSS5yZW1vdmVBbGxDbGlwcGluZ1BsYW5lcyA9ICgpID0+IHtcbiAgICBtb2RlbC5jbGlwcGluZ1BsYW5lcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZW1vdmVDbGlwcGluZ1BsYW5lID0gKGkpID0+IHtcbiAgICBpZiAoaSA8IDAgfHwgaSA+PSA2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1vZGVsLmNsaXBwaW5nUGxhbmVzLnNwbGljZShpLCAxKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0Q2xpcHBpbmdQbGFuZXMgPSAoKSA9PiBtb2RlbC5jbGlwcGluZ1BsYW5lcztcblxuICBwdWJsaWNBUEkuc2V0Q2xpcHBpbmdQbGFuZXMgPSAocGxhbmVzKSA9PiB7XG4gICAgaWYgKCFwbGFuZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBsYW5lcykpIHtcbiAgICAgIHB1YmxpY0FQSS5hZGRDbGlwcGluZ1BsYW5lKHBsYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5iUGxhbmVzID0gcGxhbmVzLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJQbGFuZXMgJiYgaSA8IDY7IGkrKykge1xuICAgICAgICBwdWJsaWNBUEkuYWRkQ2xpcHBpbmdQbGFuZShwbGFuZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIGNsaXBwaW5nUGxhbmVzOiBbXSxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIG1hY3JvLm9iaihwdWJsaWNBUEksIG1vZGVsKTtcbiAgbWFjcm8uYWxnbyhwdWJsaWNBUEksIG1vZGVsLCAxLCAwKTtcblxuICBpZiAoIW1vZGVsLmNsaXBwaW5nUGxhbmVzKSB7XG4gICAgbW9kZWwuY2xpcHBpbmdQbGFuZXMgPSBbXTtcbiAgfVxuXG4gIHZ0a0Fic3RyYWN0TWFwcGVyKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnQgZGVmYXVsdCB7IGV4dGVuZCB9O1xuIiwiaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcblxuaW1wb3J0IHZ0a0Fic3RyYWN0TWFwcGVyIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL0Fic3RyYWN0TWFwcGVyJztcbmltcG9ydCAqIGFzIHZ0a01hdGggZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvTWF0aCc7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtBYnN0cmFjdE1hcHBlciBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a0Fic3RyYWN0TWFwcGVyM0QocHVibGljQVBJLCBtb2RlbCkge1xuICBwdWJsaWNBUEkuZ2V0Qm91bmRzID0gKCkgPT4gMDtcblxuICBwdWJsaWNBUEkuZ2V0Qm91bmRzID0gKGJvdW5kcykgPT4ge1xuICAgIHB1YmxpY0FQSS5nZXRCb3VuZHMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgYm91bmRzW2ldID0gbW9kZWwuYm91bmRzW2ldO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0Q2VudGVyID0gKCkgPT4ge1xuICAgIHB1YmxpY0FQSS5nZXRCb3VuZHMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgbW9kZWwuY2VudGVyW2ldID0gKG1vZGVsLmJvdW5kc1syICogaSArIDFdICsgbW9kZWwuYm91bmRzWzIgKiBpXSkgLyAyLjA7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbC5jZW50ZXIuc2xpY2UoKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0TGVuZ3RoID0gKCkgPT4ge1xuICAgIGxldCBkaWZmID0gMC4wO1xuICAgIGxldCBsID0gMC4wO1xuICAgIHB1YmxpY0FQSS5nZXRCb3VuZHMoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgZGlmZiA9IG1vZGVsLmJvdW5kc1syICogaSArIDFdIC0gbW9kZWwuYm91bmRzWzIgKiBpXTtcbiAgICAgIGwgKz0gZGlmZiAqIGRpZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguc3FydChsKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0Q2xpcHBpbmdQbGFuZUluRGF0YUNvb3JkcyA9IChwcm9wTWF0cml4LCBpLCBobm9ybWFsKSA9PiB7XG4gICAgY29uc3QgY2xpcFBsYW5lcyA9IG1vZGVsLmNsaXBwaW5nUGxhbmVzO1xuICAgIGNvbnN0IG1hdCA9IHByb3BNYXRyaXg7XG5cbiAgICBpZiAoY2xpcFBsYW5lcykge1xuICAgICAgY29uc3QgbiA9IGNsaXBQbGFuZXMubGVuZ3RoO1xuICAgICAgaWYgKGkgPj0gMCAmJiBpIDwgbikge1xuICAgICAgICAvLyBHZXQgdGhlIHBsYW5lXG4gICAgICAgIGNvbnN0IHBsYW5lID0gY2xpcFBsYW5lc1tpXTtcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gcGxhbmUuZ2V0Tm9ybWFsKCk7XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHBsYW5lLmdldE9yaWdpbigpO1xuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIHBsYW5lIGVxdWF0aW9uXG4gICAgICAgIGNvbnN0IHYxID0gbm9ybWFsWzBdO1xuICAgICAgICBjb25zdCB2MiA9IG5vcm1hbFsxXTtcbiAgICAgICAgY29uc3QgdjMgPSBub3JtYWxbMl07XG4gICAgICAgIGNvbnN0IHY0ID0gLSh2MSAqIG9yaWdpblswXSArIHYyICogb3JpZ2luWzFdICsgdjMgKiBvcmlnaW5bMl0pO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybSBub3JtYWwgZnJvbSB3b3JsZCB0byBkYXRhIGNvb3Jkc1xuICAgICAgICBobm9ybWFsWzBdID0gdjEgKiBtYXRbMF0gKyB2MiAqIG1hdFs0XSArIHYzICogbWF0WzhdICsgdjQgKiBtYXRbMTJdO1xuICAgICAgICBobm9ybWFsWzFdID0gdjEgKiBtYXRbMV0gKyB2MiAqIG1hdFs1XSArIHYzICogbWF0WzldICsgdjQgKiBtYXRbMTNdO1xuICAgICAgICBobm9ybWFsWzJdID0gdjEgKiBtYXRbMl0gKyB2MiAqIG1hdFs2XSArIHYzICogbWF0WzEwXSArIHY0ICogbWF0WzE0XTtcbiAgICAgICAgaG5vcm1hbFszXSA9IHYxICogbWF0WzNdICsgdjIgKiBtYXRbN10gKyB2MyAqIG1hdFsxMV0gKyB2NCAqIG1hdFsxNV07XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBtYWNyby52dGtFcnJvck1hY3JvKGBDbGlwcGluZyBwbGFuZSBpbmRleCAke2l9IGlzIG91dCBvZiByYW5nZS5gKTtcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIGJvdW5kczogWzEsIC0xLCAxLCAtMSwgMSwgLTFdLFxuICBjZW50ZXI6IFswLCAwLCAwXSxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuICAvLyBJbmhlcml0YW5jZVxuICB2dGtBYnN0cmFjdE1hcHBlci5leHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyk7XG5cbiAgaWYgKCFtb2RlbC5ib3VuZHMpIHtcbiAgICB2dGtNYXRoLnVuaW5pdGlhbGl6ZUJvdW5kcyhtb2RlbC5ib3VuZHMpO1xuICB9XG5cbiAgaWYgKCFtb2RlbC5jZW50ZXIpIHtcbiAgICBtb2RlbC5jZW50ZXIgPSBbMC4wLCAwLjAsIDAuMF07XG4gIH1cblxuICB2dGtBYnN0cmFjdE1hcHBlcjNEKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgZXh0ZW5kIH07XG4iLCJpbXBvcnQgeyB2ZWMzLCBtYXQ0IH0gZnJvbSAnZ2wtbWF0cml4JztcbmltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgdnRrUHJvcDNEIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL1Byb3AzRCc7XG5pbXBvcnQgdnRrUHJvcGVydHkgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvUHJvcGVydHknO1xuXG5jb25zdCB7IHZ0a0RlYnVnTWFjcm8gfSA9IG1hY3JvO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtBY3RvciBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a0FjdG9yKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrQWN0b3InKTtcblxuICAvLyBDYXB0dXJlICdwYXJlbnRDbGFzcycgYXBpIGZvciBpbnRlcm5hbCB1c2VcbiAgY29uc3Qgc3VwZXJDbGFzcyA9IHsgLi4ucHVibGljQVBJIH07XG5cbiAgcHVibGljQVBJLmdldEFjdG9ycyA9ICgpID0+IHB1YmxpY0FQSTtcblxuICBwdWJsaWNBUEkuZ2V0SXNPcGFxdWUgPSAoKSA9PiB7XG4gICAgaWYgKG1vZGVsLmZvcmNlT3BhcXVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG1vZGVsLmZvcmNlVHJhbnNsdWNlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgYSBwcm9wZXJ0eVxuICAgIGlmICghbW9kZWwucHJvcGVydHkpIHtcbiAgICAgIC8vIGZvcmNlIGNyZWF0aW9uIG9mIGEgcHJvcGVydHlcbiAgICAgIHB1YmxpY0FQSS5nZXRQcm9wZXJ0eSgpO1xuICAgIH1cblxuICAgIGxldCBpc09wYXF1ZSA9IG1vZGVsLnByb3BlcnR5LmdldE9wYWNpdHkoKSA+PSAxLjA7XG5cbiAgICAvLyBhcmUgd2UgdXNpbmcgYW4gb3BhcXVlIHRleHR1cmUsIGlmIGFueT9cbiAgICBpc09wYXF1ZSA9IGlzT3BhcXVlICYmICghbW9kZWwudGV4dHVyZSB8fCAhbW9kZWwudGV4dHVyZS5pc1RyYW5zbHVjZW50KCkpO1xuXG4gICAgLy8gYXJlIHdlIHVzaW5nIGFuIG9wYXF1ZSBzY2FsYXIgYXJyYXksIGlmIGFueT9cbiAgICBpc09wYXF1ZSA9IGlzT3BhcXVlICYmICghbW9kZWwubWFwcGVyIHx8IG1vZGVsLm1hcHBlci5nZXRJc09wYXF1ZSgpKTtcblxuICAgIHJldHVybiBpc09wYXF1ZTtcbiAgfTtcblxuICBwdWJsaWNBUEkuaGFzVHJhbnNsdWNlbnRQb2x5Z29uYWxHZW9tZXRyeSA9ICgpID0+IHtcbiAgICBpZiAobW9kZWwubWFwcGVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIGEgcHJvcGVydHlcbiAgICBpZiAobW9kZWwucHJvcGVydHkgPT09IG51bGwpIHtcbiAgICAgIC8vIGZvcmNlIGNyZWF0aW9uIG9mIGEgcHJvcGVydHlcbiAgICAgIHB1YmxpY0FQSS5zZXRQcm9wZXJ0eShwdWJsaWNBUEkubWFrZVByb3BlcnR5KCkpO1xuICAgIH1cblxuICAgIC8vIGlzIHRoaXMgYWN0b3Igb3BhcXVlID9cbiAgICByZXR1cm4gIXB1YmxpY0FQSS5nZXRJc09wYXF1ZSgpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5tYWtlUHJvcGVydHkgPSB2dGtQcm9wZXJ0eS5uZXdJbnN0YW5jZTtcblxuICBwdWJsaWNBUEkuZ2V0UHJvcGVydHkgPSAoKSA9PiB7XG4gICAgaWYgKG1vZGVsLnByb3BlcnR5ID09PSBudWxsKSB7XG4gICAgICBtb2RlbC5wcm9wZXJ0eSA9IHB1YmxpY0FQSS5tYWtlUHJvcGVydHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsLnByb3BlcnR5O1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRCb3VuZHMgPSAoKSA9PiB7XG4gICAgaWYgKG1vZGVsLm1hcHBlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG1vZGVsLmJvdW5kcztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgdGhlIHNwZWNpYWwgY2FzZSB3aGVuIHRoZSBtYXBwZXIncyBib3VuZHMgYXJlIHVua25vd25cbiAgICBjb25zdCBiZHMgPSBtb2RlbC5tYXBwZXIuZ2V0Qm91bmRzKCk7XG4gICAgaWYgKCFiZHMgfHwgYmRzLmxlbmd0aCAhPT0gNikge1xuICAgICAgcmV0dXJuIGJkcztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgdGhlIHNwZWNpYWwgY2FzZSB3aGVuIHRoZSBhY3RvciBpcyBlbXB0eS5cbiAgICBpZiAoYmRzWzBdID4gYmRzWzFdKSB7XG4gICAgICBtb2RlbC5tYXBwZXJCb3VuZHMgPSBiZHMuY29uY2F0KCk7IC8vIGNvcHkgdGhlIG1hcHBlcidzIGJvdW5kc1xuICAgICAgbW9kZWwuYm91bmRzID0gWzEsIC0xLCAxLCAtMSwgMSwgLTFdO1xuICAgICAgbW9kZWwuYm91bmRzTVRpbWUubW9kaWZpZWQoKTtcbiAgICAgIHJldHVybiBiZHM7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBjYWNoZWQgdmFsdWVzIGZvciB0aGVzZSBib3VuZHMgLSB3ZSBjYWNoZSB0aGVcbiAgICAvLyB2YWx1ZXMgcmV0dXJuZWQgYnkgbW9kZWwubWFwcGVyLmdldEJvdW5kcygpIGFuZCB3ZSBzdG9yZSB0aGUgdGltZVxuICAgIC8vIG9mIGNhY2hpbmcuIElmIHRoZSB2YWx1ZXMgcmV0dXJuZWQgdGhpcyB0aW1lIGFyZSBkaWZmZXJlbnQsIG9yXG4gICAgLy8gdGhlIG1vZGlmaWVkIHRpbWUgb2YgdGhpcyBjbGFzcyBpcyBuZXdlciB0aGFuIHRoZSBjYWNoZWQgdGltZSxcbiAgICAvLyB0aGVuIHdlIG5lZWQgdG8gcmVidWlsZC5cbiAgICBpZiAoXG4gICAgICAhbW9kZWwubWFwcGVyQm91bmRzIHx8XG4gICAgICBiZHNbMF0gIT09IG1vZGVsLm1hcHBlckJvdW5kc1swXSB8fFxuICAgICAgYmRzWzFdICE9PSBtb2RlbC5tYXBwZXJCb3VuZHNbMV0gfHxcbiAgICAgIGJkc1syXSAhPT0gbW9kZWwubWFwcGVyQm91bmRzWzJdIHx8XG4gICAgICBiZHNbM10gIT09IG1vZGVsLm1hcHBlckJvdW5kc1szXSB8fFxuICAgICAgYmRzWzRdICE9PSBtb2RlbC5tYXBwZXJCb3VuZHNbNF0gfHxcbiAgICAgIGJkc1s1XSAhPT0gbW9kZWwubWFwcGVyQm91bmRzWzVdIHx8XG4gICAgICBwdWJsaWNBUEkuZ2V0TVRpbWUoKSA+IG1vZGVsLmJvdW5kc01UaW1lLmdldE1UaW1lKClcbiAgICApIHtcbiAgICAgIHZ0a0RlYnVnTWFjcm8oJ1JlY29tcHV0aW5nIGJvdW5kcy4uLicpO1xuICAgICAgbW9kZWwubWFwcGVyQm91bmRzID0gYmRzLmNvbmNhdCgpOyAvLyBjb3B5IHRoZSBtYXBwZXIncyBib3VuZHNcbiAgICAgIGNvbnN0IGJib3ggPSBbXG4gICAgICAgIHZlYzMuZnJvbVZhbHVlcyhiZHNbMV0sIGJkc1szXSwgYmRzWzVdKSxcbiAgICAgICAgdmVjMy5mcm9tVmFsdWVzKGJkc1sxXSwgYmRzWzJdLCBiZHNbNV0pLFxuICAgICAgICB2ZWMzLmZyb21WYWx1ZXMoYmRzWzBdLCBiZHNbMl0sIGJkc1s1XSksXG4gICAgICAgIHZlYzMuZnJvbVZhbHVlcyhiZHNbMF0sIGJkc1szXSwgYmRzWzVdKSxcbiAgICAgICAgdmVjMy5mcm9tVmFsdWVzKGJkc1sxXSwgYmRzWzNdLCBiZHNbNF0pLFxuICAgICAgICB2ZWMzLmZyb21WYWx1ZXMoYmRzWzFdLCBiZHNbMl0sIGJkc1s0XSksXG4gICAgICAgIHZlYzMuZnJvbVZhbHVlcyhiZHNbMF0sIGJkc1syXSwgYmRzWzRdKSxcbiAgICAgICAgdmVjMy5mcm9tVmFsdWVzKGJkc1swXSwgYmRzWzNdLCBiZHNbNF0pLFxuICAgICAgXTtcblxuICAgICAgcHVibGljQVBJLmNvbXB1dGVNYXRyaXgoKTtcbiAgICAgIGNvbnN0IHRtcDQgPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgbWF0NC50cmFuc3Bvc2UodG1wNCwgbW9kZWwubWF0cml4KTtcbiAgICAgIGJib3guZm9yRWFjaCgocHQpID0+IHZlYzMudHJhbnNmb3JtTWF0NChwdCwgcHQsIHRtcDQpKTtcblxuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tbXVsdGktYXNzaWduICovXG4gICAgICBtb2RlbC5ib3VuZHNbMF0gPSBtb2RlbC5ib3VuZHNbMl0gPSBtb2RlbC5ib3VuZHNbNF0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgbW9kZWwuYm91bmRzWzFdID0gbW9kZWwuYm91bmRzWzNdID0gbW9kZWwuYm91bmRzWzVdID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW11bHRpLWFzc2lnbiAqL1xuXG4gICAgICBtb2RlbC5ib3VuZHMgPSBtb2RlbC5ib3VuZHMubWFwKChkLCBpKSA9PlxuICAgICAgICBpICUgMiA9PT0gMFxuICAgICAgICAgID8gYmJveC5yZWR1Y2UoKGEsIGIpID0+IChhID4gYltpIC8gMl0gPyBiW2kgLyAyXSA6IGEpLCBkKVxuICAgICAgICAgIDogYmJveC5yZWR1Y2UoKGEsIGIpID0+IChhIDwgYlsoaSAtIDEpIC8gMl0gPyBiWyhpIC0gMSkgLyAyXSA6IGEpLCBkKVxuICAgICAgKTtcblxuICAgICAgbW9kZWwuYm91bmRzTVRpbWUubW9kaWZpZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsLmJvdW5kcztcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0TVRpbWUgPSAoKSA9PiB7XG4gICAgbGV0IG10ID0gc3VwZXJDbGFzcy5nZXRNVGltZSgpO1xuICAgIGlmIChtb2RlbC5wcm9wZXJ0eSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdGltZSA9IG1vZGVsLnByb3BlcnR5LmdldE1UaW1lKCk7XG4gICAgICBtdCA9IHRpbWUgPiBtdCA/IHRpbWUgOiBtdDtcbiAgICB9XG5cbiAgICBpZiAobW9kZWwuYmFja2ZhY2VQcm9wZXJ0eSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgdGltZSA9IG1vZGVsLmJhY2tmYWNlUHJvcGVydHkuZ2V0TVRpbWUoKTtcbiAgICAgIG10ID0gdGltZSA+IG10ID8gdGltZSA6IG10O1xuICAgIH1cblxuICAgIHJldHVybiBtdDtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0UmVkcmF3TVRpbWUgPSAoKSA9PiB7XG4gICAgbGV0IG10ID0gbW9kZWwubXRpbWU7XG4gICAgaWYgKG1vZGVsLm1hcHBlciAhPT0gbnVsbCkge1xuICAgICAgbGV0IHRpbWUgPSBtb2RlbC5tYXBwZXIuZ2V0TVRpbWUoKTtcbiAgICAgIG10ID0gdGltZSA+IG10ID8gdGltZSA6IG10O1xuICAgICAgaWYgKG1vZGVsLm1hcHBlci5nZXRJbnB1dCgpICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEZJWE1FICEhISBnZXRJbnB1dEFsZ29yaXRobSAvIGdldElucHV0XG4gICAgICAgIG1vZGVsLm1hcHBlci5nZXRJbnB1dEFsZ29yaXRobSgpLnVwZGF0ZSgpO1xuICAgICAgICB0aW1lID0gbW9kZWwubWFwcGVyLmdldElucHV0KCkuZ2V0TVRpbWUoKTtcbiAgICAgICAgbXQgPSB0aW1lID4gbXQgPyB0aW1lIDogbXQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtdDtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0U3VwcG9ydHNTZWxlY3Rpb24gPSAoKSA9PlxuICAgIG1vZGVsLm1hcHBlciA/IG1vZGVsLm1hcHBlci5nZXRTdXBwb3J0c1NlbGVjdGlvbigpIDogZmFsc2U7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBtYXBwZXI6IG51bGwsXG4gIHByb3BlcnR5OiBudWxsLFxuICBiYWNrZmFjZVByb3BlcnR5OiBudWxsLFxuXG4gIGZvcmNlT3BhcXVlOiBmYWxzZSxcbiAgZm9yY2VUcmFuc2x1Y2VudDogZmFsc2UsXG5cbiAgYm91bmRzOiBbMSwgLTEsIDEsIC0xLCAxLCAtMV0sXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBJbmhlcml0YW5jZVxuICB2dGtQcm9wM0QuZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIHZ0a1RpbWVTdGFtcFxuICBtb2RlbC5ib3VuZHNNVGltZSA9IHt9O1xuICBtYWNyby5vYmoobW9kZWwuYm91bmRzTVRpbWUpO1xuXG4gIC8vIEJ1aWxkIFZUSyBBUElcbiAgbWFjcm8uc2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsncHJvcGVydHknXSk7XG4gIG1hY3JvLnNldEdldChwdWJsaWNBUEksIG1vZGVsLCBbXG4gICAgJ2JhY2tmYWNlUHJvcGVydHknLFxuICAgICdmb3JjZU9wYXF1ZScsXG4gICAgJ2ZvcmNlVHJhbnNsdWNlbnQnLFxuICAgICdtYXBwZXInLFxuICBdKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICB2dGtBY3RvcihwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQsICd2dGtBY3RvcicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCB9O1xuIiwiaW1wb3J0IHsgcXVhdCwgdmVjMywgdmVjNCwgbWF0NCB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgKiBhcyB2dGtNYXRoIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL01hdGgnO1xuXG5jb25zdCB7IHZ0a0RlYnVnTWFjcm8gfSA9IG1hY3JvO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuZXctY2FwICovXG5cbi8qXG4gKiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhY2Nlc3MgZWxlbWVudHMgb2YgYSBnbC1tYXRyaXguICBJZiBpdCB0dXJuc1xuICogb3V0IEkgaGF2ZSByb3dzIGFuZCBjb2x1bW5zIHN3YXBwZWQgZXZlcnl3aGVyZSwgdGhlbiBJJ2xsIGp1c3QgY2hhbmdlXG4gKiB0aGUgb3JkZXIgb2YgJ3JvdycgYW5kICdjb2wnIHBhcmFtZXRlcnMgaW4gdGhpcyBmdW5jdGlvblxuICovXG4vLyBmdW5jdGlvbiBnZXRNYXRyaXhFbGVtZW50KG1hdHJpeCwgcm93LCBjb2wpIHtcbi8vICAgY29uc3QgaWR4ID0gKHJvdyAqIDQpICsgY29sO1xuLy8gICByZXR1cm4gbWF0cml4W2lkeF07XG4vLyB9XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a0NhbWVyYSBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a0NhbWVyYShwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a0NhbWVyYScpO1xuXG4gIC8vIFNldCB1cCBwcml2YXRlIHZhcmlhYmxlcyBhbmQgbWV0aG9kc1xuICBjb25zdCBvcmlnaW4gPSB2ZWMzLmNyZWF0ZSgpO1xuICBjb25zdCBkb3BiYXNpcyA9IHZlYzMuZnJvbVZhbHVlcygwLjAsIDAuMCwgLTEuMCk7XG4gIGNvbnN0IHVwYmFzaXMgPSB2ZWMzLmZyb21WYWx1ZXMoMC4wLCAxLjAsIDAuMCk7XG4gIGNvbnN0IHRtcE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gIGNvbnN0IHRtcHZlYzEgPSB2ZWMzLmNyZWF0ZSgpO1xuICBjb25zdCB0bXB2ZWMyID0gdmVjMy5jcmVhdGUoKTtcbiAgY29uc3QgdG1wdmVjMyA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgY29uc3Qgcm90YXRlTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgY29uc3QgdHJhbnMgPSBtYXQ0LmNyZWF0ZSgpO1xuICBjb25zdCBuZXdQb3NpdGlvbiA9IHZlYzMuY3JlYXRlKCk7XG4gIGNvbnN0IG5ld0ZvY2FsUG9pbnQgPSB2ZWMzLmNyZWF0ZSgpO1xuXG4gIC8vIEludGVybmFsIEZ1bmN0aW9ucyB0aGF0IGRvbid0IG5lZWQgdG8gYmUgcHVibGljXG4gIGZ1bmN0aW9uIGNvbXB1dGVWaWV3UGxhbmVOb3JtYWwoKSB7XG4gICAgLy8gVlBOIGlzIC1ET1BcbiAgICBtb2RlbC52aWV3UGxhbmVOb3JtYWxbMF0gPSAtbW9kZWwuZGlyZWN0aW9uT2ZQcm9qZWN0aW9uWzBdO1xuICAgIG1vZGVsLnZpZXdQbGFuZU5vcm1hbFsxXSA9IC1tb2RlbC5kaXJlY3Rpb25PZlByb2plY3Rpb25bMV07XG4gICAgbW9kZWwudmlld1BsYW5lTm9ybWFsWzJdID0gLW1vZGVsLmRpcmVjdGlvbk9mUHJvamVjdGlvblsyXTtcbiAgfVxuXG4gIHB1YmxpY0FQSS5vcnRob2dvbmFsaXplVmlld1VwID0gKCkgPT4ge1xuICAgIGNvbnN0IHZ0ID0gcHVibGljQVBJLmdldFZpZXdNYXRyaXgoKTtcbiAgICBtb2RlbC52aWV3VXBbMF0gPSB2dFs0XTtcbiAgICBtb2RlbC52aWV3VXBbMV0gPSB2dFs1XTtcbiAgICBtb2RlbC52aWV3VXBbMl0gPSB2dFs2XTtcblxuICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRQb3NpdGlvbiA9ICh4LCB5LCB6KSA9PiB7XG4gICAgaWYgKFxuICAgICAgeCA9PT0gbW9kZWwucG9zaXRpb25bMF0gJiZcbiAgICAgIHkgPT09IG1vZGVsLnBvc2l0aW9uWzFdICYmXG4gICAgICB6ID09PSBtb2RlbC5wb3NpdGlvblsyXVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1vZGVsLnBvc2l0aW9uWzBdID0geDtcbiAgICBtb2RlbC5wb3NpdGlvblsxXSA9IHk7XG4gICAgbW9kZWwucG9zaXRpb25bMl0gPSB6O1xuXG4gICAgLy8gcmVjb21wdXRlIHRoZSBmb2NhbCBkaXN0YW5jZVxuICAgIHB1YmxpY0FQSS5jb21wdXRlRGlzdGFuY2UoKTtcblxuICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRGb2NhbFBvaW50ID0gKHgsIHksIHopID0+IHtcbiAgICBpZiAoXG4gICAgICB4ID09PSBtb2RlbC5mb2NhbFBvaW50WzBdICYmXG4gICAgICB5ID09PSBtb2RlbC5mb2NhbFBvaW50WzFdICYmXG4gICAgICB6ID09PSBtb2RlbC5mb2NhbFBvaW50WzJdXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbW9kZWwuZm9jYWxQb2ludFswXSA9IHg7XG4gICAgbW9kZWwuZm9jYWxQb2ludFsxXSA9IHk7XG4gICAgbW9kZWwuZm9jYWxQb2ludFsyXSA9IHo7XG5cbiAgICAvLyByZWNvbXB1dGUgdGhlIGZvY2FsIGRpc3RhbmNlXG4gICAgcHVibGljQVBJLmNvbXB1dGVEaXN0YW5jZSgpO1xuXG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldERpc3RhbmNlID0gKGQpID0+IHtcbiAgICBpZiAobW9kZWwuZGlzdGFuY2UgPT09IGQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtb2RlbC5kaXN0YW5jZSA9IGQ7XG5cbiAgICBpZiAobW9kZWwuZGlzdGFuY2UgPCAxZS0yMCkge1xuICAgICAgbW9kZWwuZGlzdGFuY2UgPSAxZS0yMDtcbiAgICAgIHZ0a0RlYnVnTWFjcm8oJ0Rpc3RhbmNlIGlzIHNldCB0byBtaW5pbXVtLicpO1xuICAgIH1cblxuICAgIC8vIHdlIHdhbnQgdG8ga2VlcCB0aGUgY2FtZXJhIHBvaW50aW5nIGluIHRoZSBzYW1lIGRpcmVjdGlvblxuICAgIGNvbnN0IHZlYyA9IG1vZGVsLmRpcmVjdGlvbk9mUHJvamVjdGlvbjtcblxuICAgIC8vIHJlY2FsY3VsYXRlIEZvY2FsUG9pbnRcbiAgICBtb2RlbC5mb2NhbFBvaW50WzBdID0gbW9kZWwucG9zaXRpb25bMF0gKyB2ZWNbMF0gKiBtb2RlbC5kaXN0YW5jZTtcbiAgICBtb2RlbC5mb2NhbFBvaW50WzFdID0gbW9kZWwucG9zaXRpb25bMV0gKyB2ZWNbMV0gKiBtb2RlbC5kaXN0YW5jZTtcbiAgICBtb2RlbC5mb2NhbFBvaW50WzJdID0gbW9kZWwucG9zaXRpb25bMl0gKyB2ZWNbMl0gKiBtb2RlbC5kaXN0YW5jZTtcblxuICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBUaGlzIG1ldGhvZCBtdXN0IGJlIGNhbGxlZCB3aGVuIHRoZSBmb2NhbCBwb2ludCBvciBjYW1lcmEgcG9zaXRpb24gY2hhbmdlc1xuICBwdWJsaWNBUEkuY29tcHV0ZURpc3RhbmNlID0gKCkgPT4ge1xuICAgIGNvbnN0IGR4ID0gbW9kZWwuZm9jYWxQb2ludFswXSAtIG1vZGVsLnBvc2l0aW9uWzBdO1xuICAgIGNvbnN0IGR5ID0gbW9kZWwuZm9jYWxQb2ludFsxXSAtIG1vZGVsLnBvc2l0aW9uWzFdO1xuICAgIGNvbnN0IGR6ID0gbW9kZWwuZm9jYWxQb2ludFsyXSAtIG1vZGVsLnBvc2l0aW9uWzJdO1xuXG4gICAgbW9kZWwuZGlzdGFuY2UgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KTtcblxuICAgIGlmIChtb2RlbC5kaXN0YW5jZSA8IDFlLTIwKSB7XG4gICAgICBtb2RlbC5kaXN0YW5jZSA9IDFlLTIwO1xuICAgICAgdnRrRGVidWdNYWNybygnRGlzdGFuY2UgaXMgc2V0IHRvIG1pbmltdW0uJyk7XG5cbiAgICAgIGNvbnN0IHZlYyA9IG1vZGVsLmRpcmVjdGlvbk9mUHJvamVjdGlvbjtcblxuICAgICAgLy8gcmVjYWxjdWxhdGUgRm9jYWxQb2ludFxuICAgICAgbW9kZWwuZm9jYWxQb2ludFswXSA9IG1vZGVsLnBvc2l0aW9uWzBdICsgdmVjWzBdICogbW9kZWwuZGlzdGFuY2U7XG4gICAgICBtb2RlbC5mb2NhbFBvaW50WzFdID0gbW9kZWwucG9zaXRpb25bMV0gKyB2ZWNbMV0gKiBtb2RlbC5kaXN0YW5jZTtcbiAgICAgIG1vZGVsLmZvY2FsUG9pbnRbMl0gPSBtb2RlbC5wb3NpdGlvblsyXSArIHZlY1syXSAqIG1vZGVsLmRpc3RhbmNlO1xuICAgIH1cblxuICAgIG1vZGVsLmRpcmVjdGlvbk9mUHJvamVjdGlvblswXSA9IGR4IC8gbW9kZWwuZGlzdGFuY2U7XG4gICAgbW9kZWwuZGlyZWN0aW9uT2ZQcm9qZWN0aW9uWzFdID0gZHkgLyBtb2RlbC5kaXN0YW5jZTtcbiAgICBtb2RlbC5kaXJlY3Rpb25PZlByb2plY3Rpb25bMl0gPSBkeiAvIG1vZGVsLmRpc3RhbmNlO1xuXG4gICAgY29tcHV0ZVZpZXdQbGFuZU5vcm1hbCgpO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBNb3ZlIHRoZSBwb3NpdGlvbiBvZiB0aGUgY2FtZXJhIGFsb25nIHRoZSB2aWV3IHBsYW5lIG5vcm1hbC4gTW92aW5nXG4gIC8vIHRvd2FyZHMgdGhlIGZvY2FsIHBvaW50IChlLmcuLCA+IDEpIGlzIGEgZG9sbHktaW4sIG1vdmluZyBhd2F5XG4gIC8vIGZyb20gdGhlIGZvY2FsIHBvaW50IChlLmcuLCA8IDEpIGlzIGEgZG9sbHktb3V0LlxuICBwdWJsaWNBUEkuZG9sbHkgPSAoYW1vdW50KSA9PiB7XG4gICAgaWYgKGFtb3VudCA8PSAwLjApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBkb2xseSBtb3ZlcyB0aGUgY2FtZXJhIHRvd2FyZHMgdGhlIGZvY3VzXG4gICAgY29uc3QgZCA9IG1vZGVsLmRpc3RhbmNlIC8gYW1vdW50O1xuXG4gICAgcHVibGljQVBJLnNldFBvc2l0aW9uKFxuICAgICAgbW9kZWwuZm9jYWxQb2ludFswXSAtIGQgKiBtb2RlbC5kaXJlY3Rpb25PZlByb2plY3Rpb25bMF0sXG4gICAgICBtb2RlbC5mb2NhbFBvaW50WzFdIC0gZCAqIG1vZGVsLmRpcmVjdGlvbk9mUHJvamVjdGlvblsxXSxcbiAgICAgIG1vZGVsLmZvY2FsUG9pbnRbMl0gLSBkICogbW9kZWwuZGlyZWN0aW9uT2ZQcm9qZWN0aW9uWzJdXG4gICAgKTtcbiAgfTtcblxuICBwdWJsaWNBUEkucm9sbCA9IChhbmdsZSkgPT4ge1xuICAgIGNvbnN0IGV5ZSA9IG1vZGVsLnBvc2l0aW9uO1xuICAgIGNvbnN0IGF0ID0gbW9kZWwuZm9jYWxQb2ludDtcbiAgICBjb25zdCB1cCA9IG1vZGVsLnZpZXdVcDtcbiAgICBjb25zdCB2aWV3VXBWZWM0ID0gdmVjNC5mcm9tVmFsdWVzKHVwWzBdLCB1cFsxXSwgdXBbMl0sIDAuMCk7XG5cbiAgICBtYXQ0LmlkZW50aXR5KHJvdGF0ZU1hdHJpeCk7XG4gICAgY29uc3Qgdmlld0RpciA9IHZlYzMuZnJvbVZhbHVlcyhcbiAgICAgIGF0WzBdIC0gZXllWzBdLFxuICAgICAgYXRbMV0gLSBleWVbMV0sXG4gICAgICBhdFsyXSAtIGV5ZVsyXVxuICAgICk7XG4gICAgbWF0NC5yb3RhdGUoXG4gICAgICByb3RhdGVNYXRyaXgsXG4gICAgICByb3RhdGVNYXRyaXgsXG4gICAgICB2dGtNYXRoLnJhZGlhbnNGcm9tRGVncmVlcyhhbmdsZSksXG4gICAgICB2aWV3RGlyXG4gICAgKTtcbiAgICB2ZWM0LnRyYW5zZm9ybU1hdDQodmlld1VwVmVjNCwgdmlld1VwVmVjNCwgcm90YXRlTWF0cml4KTtcblxuICAgIG1vZGVsLnZpZXdVcFswXSA9IHZpZXdVcFZlYzRbMF07XG4gICAgbW9kZWwudmlld1VwWzFdID0gdmlld1VwVmVjNFsxXTtcbiAgICBtb2RlbC52aWV3VXBbMl0gPSB2aWV3VXBWZWM0WzJdO1xuXG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLmF6aW11dGggPSAoYW5nbGUpID0+IHtcbiAgICBjb25zdCBmcCA9IG1vZGVsLmZvY2FsUG9pbnQ7XG5cbiAgICBtYXQ0LmlkZW50aXR5KHRyYW5zKTtcblxuICAgIC8vIHRyYW5zbGF0ZSB0aGUgZm9jYWwgcG9pbnQgdG8gdGhlIG9yaWdpbixcbiAgICAvLyByb3RhdGUgYWJvdXQgdmlldyB1cCxcbiAgICAvLyB0cmFuc2xhdGUgYmFjayBhZ2FpblxuICAgIG1hdDQudHJhbnNsYXRlKHRyYW5zLCB0cmFucywgdmVjMy5mcm9tVmFsdWVzKGZwWzBdLCBmcFsxXSwgZnBbMl0pKTtcbiAgICBtYXQ0LnJvdGF0ZShcbiAgICAgIHRyYW5zLFxuICAgICAgdHJhbnMsXG4gICAgICB2dGtNYXRoLnJhZGlhbnNGcm9tRGVncmVlcyhhbmdsZSksXG4gICAgICB2ZWMzLmZyb21WYWx1ZXMobW9kZWwudmlld1VwWzBdLCBtb2RlbC52aWV3VXBbMV0sIG1vZGVsLnZpZXdVcFsyXSlcbiAgICApO1xuICAgIG1hdDQudHJhbnNsYXRlKHRyYW5zLCB0cmFucywgdmVjMy5mcm9tVmFsdWVzKC1mcFswXSwgLWZwWzFdLCAtZnBbMl0pKTtcblxuICAgIC8vIGFwcGx5IHRoZSB0cmFuc2Zvcm0gdG8gdGhlIHBvc2l0aW9uXG4gICAgdmVjMy50cmFuc2Zvcm1NYXQ0KFxuICAgICAgbmV3UG9zaXRpb24sXG4gICAgICB2ZWMzLmZyb21WYWx1ZXMobW9kZWwucG9zaXRpb25bMF0sIG1vZGVsLnBvc2l0aW9uWzFdLCBtb2RlbC5wb3NpdGlvblsyXSksXG4gICAgICB0cmFuc1xuICAgICk7XG4gICAgcHVibGljQVBJLnNldFBvc2l0aW9uKG5ld1Bvc2l0aW9uWzBdLCBuZXdQb3NpdGlvblsxXSwgbmV3UG9zaXRpb25bMl0pO1xuICB9O1xuXG4gIHB1YmxpY0FQSS55YXcgPSAoYW5nbGUpID0+IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IG1vZGVsLnBvc2l0aW9uO1xuXG4gICAgbWF0NC5pZGVudGl0eSh0cmFucyk7XG5cbiAgICAvLyB0cmFuc2xhdGUgdGhlIGNhbWVyYSB0byB0aGUgb3JpZ2luLFxuICAgIC8vIHJvdGF0ZSBhYm91dCBheGlzLFxuICAgIC8vIHRyYW5zbGF0ZSBiYWNrIGFnYWluXG4gICAgbWF0NC50cmFuc2xhdGUoXG4gICAgICB0cmFucyxcbiAgICAgIHRyYW5zLFxuICAgICAgdmVjMy5mcm9tVmFsdWVzKHBvc2l0aW9uWzBdLCBwb3NpdGlvblsxXSwgcG9zaXRpb25bMl0pXG4gICAgKTtcbiAgICBtYXQ0LnJvdGF0ZShcbiAgICAgIHRyYW5zLFxuICAgICAgdHJhbnMsXG4gICAgICB2dGtNYXRoLnJhZGlhbnNGcm9tRGVncmVlcyhhbmdsZSksXG4gICAgICB2ZWMzLmZyb21WYWx1ZXMobW9kZWwudmlld1VwWzBdLCBtb2RlbC52aWV3VXBbMV0sIG1vZGVsLnZpZXdVcFsyXSlcbiAgICApO1xuICAgIG1hdDQudHJhbnNsYXRlKFxuICAgICAgdHJhbnMsXG4gICAgICB0cmFucyxcbiAgICAgIHZlYzMuZnJvbVZhbHVlcygtcG9zaXRpb25bMF0sIC1wb3NpdGlvblsxXSwgLXBvc2l0aW9uWzJdKVxuICAgICk7XG5cbiAgICAvLyBhcHBseSB0aGUgdHJhbnNmb3JtIHRvIHRoZSBwb3NpdGlvblxuICAgIHZlYzMudHJhbnNmb3JtTWF0NChcbiAgICAgIG5ld0ZvY2FsUG9pbnQsXG4gICAgICB2ZWMzLmZyb21WYWx1ZXMoXG4gICAgICAgIG1vZGVsLmZvY2FsUG9pbnRbMF0sXG4gICAgICAgIG1vZGVsLmZvY2FsUG9pbnRbMV0sXG4gICAgICAgIG1vZGVsLmZvY2FsUG9pbnRbMl1cbiAgICAgICksXG4gICAgICB0cmFuc1xuICAgICk7XG4gICAgcHVibGljQVBJLnNldEZvY2FsUG9pbnQoXG4gICAgICBuZXdGb2NhbFBvaW50WzBdLFxuICAgICAgbmV3Rm9jYWxQb2ludFsxXSxcbiAgICAgIG5ld0ZvY2FsUG9pbnRbMl1cbiAgICApO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5lbGV2YXRpb24gPSAoYW5nbGUpID0+IHtcbiAgICBjb25zdCBmcCA9IG1vZGVsLmZvY2FsUG9pbnQ7XG5cbiAgICAvLyBnZXQgdGhlIGV5ZSAvIGNhbWVyYSBwb3NpdGlvbiBmcm9tIHRoZSB2aWV3TWF0cml4XG4gICAgY29uc3QgdnQgPSBwdWJsaWNBUEkuZ2V0Vmlld01hdHJpeCgpO1xuICAgIGNvbnN0IGF4aXMgPSBbLXZ0WzBdLCAtdnRbMV0sIC12dFsyXV07XG5cbiAgICBtYXQ0LmlkZW50aXR5KHRyYW5zKTtcblxuICAgIC8vIHRyYW5zbGF0ZSB0aGUgZm9jYWwgcG9pbnQgdG8gdGhlIG9yaWdpbixcbiAgICAvLyByb3RhdGUgYWJvdXQgdmlldyB1cCxcbiAgICAvLyB0cmFuc2xhdGUgYmFjayBhZ2FpblxuICAgIG1hdDQudHJhbnNsYXRlKHRyYW5zLCB0cmFucywgdmVjMy5mcm9tVmFsdWVzKGZwWzBdLCBmcFsxXSwgZnBbMl0pKTtcbiAgICBtYXQ0LnJvdGF0ZShcbiAgICAgIHRyYW5zLFxuICAgICAgdHJhbnMsXG4gICAgICB2dGtNYXRoLnJhZGlhbnNGcm9tRGVncmVlcyhhbmdsZSksXG4gICAgICB2ZWMzLmZyb21WYWx1ZXMoYXhpc1swXSwgYXhpc1sxXSwgYXhpc1syXSlcbiAgICApO1xuICAgIG1hdDQudHJhbnNsYXRlKHRyYW5zLCB0cmFucywgdmVjMy5mcm9tVmFsdWVzKC1mcFswXSwgLWZwWzFdLCAtZnBbMl0pKTtcblxuICAgIC8vIGFwcGx5IHRoZSB0cmFuc2Zvcm0gdG8gdGhlIHBvc2l0aW9uXG4gICAgdmVjMy50cmFuc2Zvcm1NYXQ0KFxuICAgICAgbmV3UG9zaXRpb24sXG4gICAgICB2ZWMzLmZyb21WYWx1ZXMobW9kZWwucG9zaXRpb25bMF0sIG1vZGVsLnBvc2l0aW9uWzFdLCBtb2RlbC5wb3NpdGlvblsyXSksXG4gICAgICB0cmFuc1xuICAgICk7XG4gICAgcHVibGljQVBJLnNldFBvc2l0aW9uKG5ld1Bvc2l0aW9uWzBdLCBuZXdQb3NpdGlvblsxXSwgbmV3UG9zaXRpb25bMl0pO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5waXRjaCA9IChhbmdsZSkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbW9kZWwucG9zaXRpb247XG5cbiAgICBjb25zdCB2dCA9IHB1YmxpY0FQSS5nZXRWaWV3TWF0cml4KCk7XG4gICAgY29uc3QgYXhpcyA9IFt2dFswXSwgdnRbMV0sIHZ0WzJdXTtcblxuICAgIG1hdDQuaWRlbnRpdHkodHJhbnMpO1xuXG4gICAgLy8gdHJhbnNsYXRlIHRoZSBjYW1lcmEgdG8gdGhlIG9yaWdpbixcbiAgICAvLyByb3RhdGUgYWJvdXQgYXhpcyxcbiAgICAvLyB0cmFuc2xhdGUgYmFjayBhZ2FpblxuICAgIG1hdDQudHJhbnNsYXRlKFxuICAgICAgdHJhbnMsXG4gICAgICB0cmFucyxcbiAgICAgIHZlYzMuZnJvbVZhbHVlcyhwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIHBvc2l0aW9uWzJdKVxuICAgICk7XG4gICAgbWF0NC5yb3RhdGUoXG4gICAgICB0cmFucyxcbiAgICAgIHRyYW5zLFxuICAgICAgdnRrTWF0aC5yYWRpYW5zRnJvbURlZ3JlZXMoYW5nbGUpLFxuICAgICAgdmVjMy5mcm9tVmFsdWVzKGF4aXNbMF0sIGF4aXNbMV0sIGF4aXNbMl0pXG4gICAgKTtcbiAgICBtYXQ0LnRyYW5zbGF0ZShcbiAgICAgIHRyYW5zLFxuICAgICAgdHJhbnMsXG4gICAgICB2ZWMzLmZyb21WYWx1ZXMoLXBvc2l0aW9uWzBdLCAtcG9zaXRpb25bMV0sIC1wb3NpdGlvblsyXSlcbiAgICApO1xuXG4gICAgLy8gYXBwbHkgdGhlIHRyYW5zZm9ybSB0byB0aGUgZm9jYWwgcG9pbnRcbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDQoXG4gICAgICBuZXdGb2NhbFBvaW50LFxuICAgICAgdmVjMy5mcm9tVmFsdWVzKC4uLm1vZGVsLmZvY2FsUG9pbnQpLFxuICAgICAgdHJhbnNcbiAgICApO1xuICAgIHB1YmxpY0FQSS5zZXRGb2NhbFBvaW50KC4uLm5ld0ZvY2FsUG9pbnQpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS56b29tID0gKGZhY3RvcikgPT4ge1xuICAgIGlmIChmYWN0b3IgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobW9kZWwucGFyYWxsZWxQcm9qZWN0aW9uKSB7XG4gICAgICBtb2RlbC5wYXJhbGxlbFNjYWxlIC89IGZhY3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWwudmlld0FuZ2xlIC89IGZhY3RvcjtcbiAgICB9XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLnRyYW5zbGF0ZSA9ICh4LCB5LCB6KSA9PiB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gW3gsIHksIHpdO1xuXG4gICAgdnRrTWF0aC5hZGQobW9kZWwucG9zaXRpb24sIG9mZnNldCwgbW9kZWwucG9zaXRpb24pO1xuICAgIHZ0a01hdGguYWRkKG1vZGVsLmZvY2FsUG9pbnQsIG9mZnNldCwgbW9kZWwuZm9jYWxQb2ludCk7XG5cbiAgICBwdWJsaWNBUEkuY29tcHV0ZURpc3RhbmNlKCk7XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLmFwcGx5VHJhbnNmb3JtID0gKHRyYW5zZm9ybU1hdDQpID0+IHtcbiAgICBjb25zdCB2dU9sZCA9IFsuLi5tb2RlbC52aWV3VXAsIDEuMF07XG4gICAgY29uc3QgcG9zTmV3ID0gW107XG4gICAgY29uc3QgZnBOZXcgPSBbXTtcbiAgICBjb25zdCB2dU5ldyA9IFtdO1xuXG4gICAgdnVPbGRbMF0gKz0gbW9kZWwucG9zaXRpb25bMF07XG4gICAgdnVPbGRbMV0gKz0gbW9kZWwucG9zaXRpb25bMV07XG4gICAgdnVPbGRbMl0gKz0gbW9kZWwucG9zaXRpb25bMl07XG5cbiAgICB2ZWM0LnRyYW5zZm9ybU1hdDQocG9zTmV3LCBbLi4ubW9kZWwucG9zaXRpb24sIDEuMF0sIHRyYW5zZm9ybU1hdDQpO1xuICAgIHZlYzQudHJhbnNmb3JtTWF0NChmcE5ldywgWy4uLm1vZGVsLmZvY2FsUG9pbnQsIDEuMF0sIHRyYW5zZm9ybU1hdDQpO1xuICAgIHZlYzQudHJhbnNmb3JtTWF0NCh2dU5ldywgdnVPbGQsIHRyYW5zZm9ybU1hdDQpO1xuXG4gICAgdnVOZXdbMF0gLT0gcG9zTmV3WzBdO1xuICAgIHZ1TmV3WzFdIC09IHBvc05ld1sxXTtcbiAgICB2dU5ld1syXSAtPSBwb3NOZXdbMl07XG5cbiAgICBwdWJsaWNBUEkuc2V0UG9zaXRpb24oLi4ucG9zTmV3LnNsaWNlKDAsIDMpKTtcbiAgICBwdWJsaWNBUEkuc2V0Rm9jYWxQb2ludCguLi5mcE5ldy5zbGljZSgwLCAzKSk7XG4gICAgcHVibGljQVBJLnNldFZpZXdVcCguLi52dU5ldy5zbGljZSgwLCAzKSk7XG4gIH07XG5cbiAgcHVibGljQVBJLmdldFRoaWNrbmVzcyA9ICgpID0+XG4gICAgbW9kZWwuY2xpcHBpbmdSYW5nZVsxXSAtIG1vZGVsLmNsaXBwaW5nUmFuZ2VbMF07XG5cbiAgcHVibGljQVBJLnNldFRoaWNrbmVzcyA9ICh0aGlja25lc3MpID0+IHtcbiAgICBsZXQgdCA9IHRoaWNrbmVzcztcbiAgICBpZiAodCA8IDFlLTIwKSB7XG4gICAgICB0ID0gMWUtMjA7XG4gICAgICB2dGtEZWJ1Z01hY3JvKCdUaGlja25lc3MgaXMgc2V0IHRvIG1pbmltdW0uJyk7XG4gICAgfVxuICAgIHB1YmxpY0FQSS5zZXRDbGlwcGluZ1JhbmdlKFxuICAgICAgbW9kZWwuY2xpcHBpbmdSYW5nZVswXSxcbiAgICAgIG1vZGVsLmNsaXBwaW5nUmFuZ2VbMF0gKyB0XG4gICAgKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0VGhpY2tuZXNzRnJvbUZvY2FsUG9pbnQgPSAodGhpY2tuZXNzKSA9PiB7XG4gICAgbGV0IHQgPSB0aGlja25lc3M7XG4gICAgaWYgKHQgPCAxZS0yMCkge1xuICAgICAgdCA9IDFlLTIwO1xuICAgICAgdnRrRGVidWdNYWNybygnVGhpY2tuZXNzIGlzIHNldCB0byBtaW5pbXVtLicpO1xuICAgIH1cbiAgICBwdWJsaWNBUEkuc2V0Q2xpcHBpbmdSYW5nZShtb2RlbC5kaXN0YW5jZSAtIHQgLyAyLCBtb2RlbC5kaXN0YW5jZSArIHQgLyAyKTtcbiAgfTtcblxuICAvLyBVbmltcGxlbWVudGVkIGZ1bmN0aW9uc1xuICBwdWJsaWNBUEkuc2V0Um9sbCA9IChhbmdsZSkgPT4ge307IC8vIGRlcGVuZGVuY3kgb24gR2V0T3JpZW50YXRpb24oKSBhbmQgYSBtb2RlbC5WaWV3VHJhbnNmb3JtIG9iamVjdCwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9LaXR3YXJlL1ZUSy9ibG9iL21hc3Rlci9Db21tb24vVHJhbnNmb3Jtcy92dGtUcmFuc2Zvcm0uY3h4IGFuZCBodHRwczovL3Z0ay5vcmcvZG9jL25pZ2h0bHkvaHRtbC9jbGFzc3Z0a1RyYW5zZm9ybS5odG1sXG4gIHB1YmxpY0FQSS5nZXRSb2xsID0gKCkgPT4ge307XG4gIHB1YmxpY0FQSS5zZXRPYmxpcXVlQW5nbGVzID0gKGFscGhhLCBiZXRhKSA9PiB7fTtcbiAgcHVibGljQVBJLmdldE9yaWVudGF0aW9uID0gKCkgPT4ge307XG4gIHB1YmxpY0FQSS5nZXRPcmllbnRhdGlvbldYWVogPSAoKSA9PiB7fTtcbiAgcHVibGljQVBJLmdldEZydXN0dW1QbGFuZXMgPSAoYXNwZWN0KSA9PiB7XG4gICAgLy8gUmV0dXJuIGFycmF5IG9mIDI0IHBhcmFtcyAoNCBwYXJhbXMgZm9yIGVhY2ggb2YgNiBwbGFuZSBlcXVhdGlvbnMpXG4gIH07XG4gIHB1YmxpY0FQSS5nZXRDYW1lcmFMaWdodFRyYW5zZm9ybU1hdHJpeCA9ICgpID0+IHt9O1xuICBwdWJsaWNBUEkuZGVlcENvcHkgPSAoc291cmNlQ2FtZXJhKSA9PiB7fTtcblxuICBwdWJsaWNBUEkucGh5c2ljYWxPcmllbnRhdGlvblRvV29ybGREaXJlY3Rpb24gPSAob3JpKSA9PiB7XG4gICAgLy8gcHVzaCB0aGUgeCBheGlzIHRocm91Z2ggdGhlIG9yaWVudGF0aW9uIHF1YXRcbiAgICBjb25zdCBvcmlxID0gcXVhdC5mcm9tVmFsdWVzKG9yaVswXSwgb3JpWzFdLCBvcmlbMl0sIG9yaVszXSk7XG4gICAgY29uc3QgY29yaXEgPSBxdWF0LmNyZWF0ZSgpO1xuICAgIGNvbnN0IHFkaXIgPSBxdWF0LmZyb21WYWx1ZXMoMC4wLCAwLjAsIDEuMCwgMC4wKTtcbiAgICBxdWF0LmNvbmp1Z2F0ZShjb3JpcSwgb3JpcSk7XG5cbiAgICAvLyByb3RhdGUgdGhlIHogYXhpcyBieSB0aGUgcXVhdFxuICAgIHF1YXQubXVsdGlwbHkocWRpciwgb3JpcSwgcWRpcik7XG4gICAgcXVhdC5tdWx0aXBseShxZGlyLCBxZGlyLCBjb3JpcSk7XG5cbiAgICAvLyByZXR1cm4gdGhlIHogYXhpcyBpbiB3b3JsZCBjb29yZHNcbiAgICByZXR1cm4gW3FkaXJbMF0sIHFkaXJbMV0sIHFkaXJbMl1dO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRQaHlzaWNhbFRvV29ybGRNYXRyaXggPSAocmVzdWx0KSA9PiB7XG4gICAgcHVibGljQVBJLmdldFdvcmxkVG9QaHlzaWNhbE1hdHJpeChyZXN1bHQpO1xuICAgIG1hdDQuaW52ZXJ0KHJlc3VsdCwgcmVzdWx0KTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0V29ybGRUb1BoeXNpY2FsTWF0cml4ID0gKHJlc3VsdCkgPT4ge1xuICAgIG1hdDQuaWRlbnRpdHkocmVzdWx0KTtcblxuICAgIC8vIG5vdyB0aGUgcGh5c2ljYWwgdG8gdnRrIHdvcmxkIHJvdGF0aW9uIHRmb3JtXG4gICAgY29uc3QgcGh5c1ZSaWdodCA9IFszXTtcbiAgICB2dGtNYXRoLmNyb3NzKG1vZGVsLnBoeXNpY2FsVmlld05vcnRoLCBtb2RlbC5waHlzaWNhbFZpZXdVcCwgcGh5c1ZSaWdodCk7XG4gICAgcmVzdWx0WzBdID0gcGh5c1ZSaWdodFswXTtcbiAgICByZXN1bHRbMV0gPSBwaHlzVlJpZ2h0WzFdO1xuICAgIHJlc3VsdFsyXSA9IHBoeXNWUmlnaHRbMl07XG4gICAgcmVzdWx0WzRdID0gbW9kZWwucGh5c2ljYWxWaWV3VXBbMF07XG4gICAgcmVzdWx0WzVdID0gbW9kZWwucGh5c2ljYWxWaWV3VXBbMV07XG4gICAgcmVzdWx0WzZdID0gbW9kZWwucGh5c2ljYWxWaWV3VXBbMl07XG4gICAgcmVzdWx0WzhdID0gLW1vZGVsLnBoeXNpY2FsVmlld05vcnRoWzBdO1xuICAgIHJlc3VsdFs5XSA9IC1tb2RlbC5waHlzaWNhbFZpZXdOb3J0aFsxXTtcbiAgICByZXN1bHRbMTBdID0gLW1vZGVsLnBoeXNpY2FsVmlld05vcnRoWzJdO1xuICAgIG1hdDQudHJhbnNwb3NlKHJlc3VsdCwgcmVzdWx0KTtcblxuICAgIHZlYzMuc2V0KFxuICAgICAgdG1wdmVjMSxcbiAgICAgIDEgLyBtb2RlbC5waHlzaWNhbFNjYWxlLFxuICAgICAgMSAvIG1vZGVsLnBoeXNpY2FsU2NhbGUsXG4gICAgICAxIC8gbW9kZWwucGh5c2ljYWxTY2FsZVxuICAgICk7XG5cbiAgICBtYXQ0LnNjYWxlKHJlc3VsdCwgcmVzdWx0LCB0bXB2ZWMxKTtcbiAgICBtYXQ0LnRyYW5zbGF0ZShyZXN1bHQsIHJlc3VsdCwgbW9kZWwucGh5c2ljYWxUcmFuc2xhdGlvbik7XG4gIH07XG5cbiAgcHVibGljQVBJLmNvbXB1dGVWaWV3UGFyYW1ldGVyc0Zyb21WaWV3TWF0cml4ID0gKHZtYXQpID0+IHtcbiAgICAvLyBpbnZlcnQgdG8gZ2V0IHZpZXcgdG8gd29ybGRcbiAgICBtYXQ0LmludmVydCh0bXBNYXRyaXgsIHZtYXQpO1xuXG4gICAgLy8gbm90ZSB3aXRoIGdsbWF0cml4IG9wZXJhdGlvbnMgaGFwcGVuIGluXG4gICAgLy8gdGhlIHJldmVyc2Ugb3JkZXJcbiAgICAvLyBtYXQuc2NhbGVcbiAgICAvLyBtYXQudHJhbnNsYXRlXG4gICAgLy8gd2lsbCByZXN1bHQgaW4gdGhlIHRyYW5zbGF0aW9uIHRoZW4gdGhlIHNjYWxlXG4gICAgLy8gbWF0Lm11bHQoYSxiKVxuICAgIC8vIHJlc3VsdHMgaW4gcGVyZm9ybSB0aGUgQiB0cmFuc2Zvcm1hdGlvbiB0aGVuIEFcblxuICAgIC8vIHRoZW4gZXh0cmFjdCB0aGUgcGFyYW1zIHBvc2l0aW9uLCBvcmllbnRhdGlvblxuICAgIC8vIHB1c2ggMCwwLDAgdGhyb3VnaCB0byBnZXQgYSB0cmFuc2xhdGlvblxuICAgIHZlYzMudHJhbnNmb3JtTWF0NCh0bXB2ZWMxLCBvcmlnaW4sIHRtcE1hdHJpeCk7XG4gICAgcHVibGljQVBJLmNvbXB1dGVEaXN0YW5jZSgpO1xuICAgIGNvbnN0IG9sZERpc3QgPSBtb2RlbC5kaXN0YW5jZTtcbiAgICBwdWJsaWNBUEkuc2V0UG9zaXRpb24odG1wdmVjMVswXSwgdG1wdmVjMVsxXSwgdG1wdmVjMVsyXSk7XG5cbiAgICAvLyBwdXNoIGJhc2lzIHZlY3RvcnMgdG8gZ2V0IG9yaWVudGF0aW9uXG4gICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHRtcHZlYzIsIGRvcGJhc2lzLCB0bXBNYXRyaXgpO1xuICAgIHZlYzMuc3VidHJhY3QodG1wdmVjMiwgdG1wdmVjMiwgdG1wdmVjMSk7XG4gICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMiwgdG1wdmVjMik7XG4gICAgcHVibGljQVBJLnNldERpcmVjdGlvbk9mUHJvamVjdGlvbih0bXB2ZWMyWzBdLCB0bXB2ZWMyWzFdLCB0bXB2ZWMyWzJdKTtcblxuICAgIHZlYzMudHJhbnNmb3JtTWF0NCh0bXB2ZWMzLCB1cGJhc2lzLCB0bXBNYXRyaXgpO1xuICAgIHZlYzMuc3VidHJhY3QodG1wdmVjMywgdG1wdmVjMywgdG1wdmVjMSk7XG4gICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XG4gICAgcHVibGljQVBJLnNldFZpZXdVcCh0bXB2ZWMzWzBdLCB0bXB2ZWMzWzFdLCB0bXB2ZWMzWzJdKTtcblxuICAgIHB1YmxpY0FQSS5zZXREaXN0YW5jZShvbGREaXN0KTtcbiAgfTtcblxuICAvLyB0aGUgcHJvdmlkZWQgbWF0cml4IHNob3VsZCBpbmNsdWRlXG4gIC8vIHRyYW5zbGF0aW9uIGFuZCBvcmllbnRhdGlvbiBvbmx5XG4gIC8vIG1hdCBpcyBwaHlzaWNhbCB0byB2aWV3XG4gIHB1YmxpY0FQSS5jb21wdXRlVmlld1BhcmFtZXRlcnNGcm9tUGh5c2ljYWxNYXRyaXggPSAobWF0KSA9PiB7XG4gICAgLy8gZ2V0IHRoZSBXb3JsZFRvUGh5c2ljYWxNYXRyaXhcbiAgICBwdWJsaWNBUEkuZ2V0V29ybGRUb1BoeXNpY2FsTWF0cml4KHRtcE1hdHJpeCk7XG5cbiAgICAvLyBmaXJzdCBjb252ZXJ0IHRoZSBwaHlzaWNhbCAtPiB2aWV3IG1hdHJpeCB0byBiZVxuICAgIC8vIHdvcmxkIC0+IHZpZXdcbiAgICBtYXQ0Lm11bHRpcGx5KHRtcE1hdHJpeCwgbWF0LCB0bXBNYXRyaXgpO1xuXG4gICAgcHVibGljQVBJLmNvbXB1dGVWaWV3UGFyYW1ldGVyc0Zyb21WaWV3TWF0cml4KHRtcE1hdHJpeCk7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldFZpZXdNYXRyaXggPSAobWF0KSA9PiB7XG4gICAgbW9kZWwudmlld01hdHJpeCA9IG1hdDtcbiAgICBpZiAobW9kZWwudmlld01hdHJpeCkge1xuICAgICAgbWF0NC5jb3B5KHRtcE1hdHJpeCwgbW9kZWwudmlld01hdHJpeCk7XG4gICAgICBwdWJsaWNBUEkuY29tcHV0ZVZpZXdQYXJhbWV0ZXJzRnJvbVZpZXdNYXRyaXgodG1wTWF0cml4KTtcbiAgICAgIG1hdDQudHJhbnNwb3NlKG1vZGVsLnZpZXdNYXRyaXgsIG1vZGVsLnZpZXdNYXRyaXgpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0Vmlld01hdHJpeCA9ICgpID0+IHtcbiAgICBpZiAobW9kZWwudmlld01hdHJpeCkge1xuICAgICAgcmV0dXJuIG1vZGVsLnZpZXdNYXRyaXg7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gbWF0NC5jcmVhdGUoKTtcblxuICAgIG1hdDQubG9va0F0KFxuICAgICAgdG1wTWF0cml4LFxuICAgICAgdmVjMy5mcm9tVmFsdWVzKC4uLm1vZGVsLnBvc2l0aW9uKSwgLy8gZXllXG4gICAgICB2ZWMzLmZyb21WYWx1ZXMoLi4ubW9kZWwuZm9jYWxQb2ludCksIC8vIGF0XG4gICAgICB2ZWMzLmZyb21WYWx1ZXMoLi4ubW9kZWwudmlld1VwKSAvLyB1cFxuICAgICk7XG5cbiAgICBtYXQ0LnRyYW5zcG9zZSh0bXBNYXRyaXgsIHRtcE1hdHJpeCk7XG5cbiAgICBtYXQ0LmNvcHkocmVzdWx0LCB0bXBNYXRyaXgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldFByb2plY3Rpb25NYXRyaXggPSAobWF0KSA9PiB7XG4gICAgbW9kZWwucHJvamVjdGlvbk1hdHJpeCA9IG1hdDtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0UHJvamVjdGlvbk1hdHJpeCA9IChhc3BlY3QsIG5lYXJ6LCBmYXJ6KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gbWF0NC5jcmVhdGUoKTtcblxuICAgIGlmIChtb2RlbC5wcm9qZWN0aW9uTWF0cml4KSB7XG4gICAgICBjb25zdCBzY2FsZSA9IDEgLyBtb2RlbC5waHlzaWNhbFNjYWxlO1xuICAgICAgdmVjMy5zZXQodG1wdmVjMSwgc2NhbGUsIHNjYWxlLCBzY2FsZSk7XG5cbiAgICAgIG1hdDQuY29weShyZXN1bHQsIG1vZGVsLnByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgbWF0NC5zY2FsZShyZXN1bHQsIHJlc3VsdCwgdG1wdmVjMSk7XG4gICAgICBtYXQ0LnRyYW5zcG9zZShyZXN1bHQsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIG1hdDQuaWRlbnRpdHkodG1wTWF0cml4KTtcblxuICAgIC8vIEZJWE1FOiBOb3Qgc3VyZSB3aGF0IHRvIGRvIGFib3V0IGFkanVzdCB6IGJ1ZmZlciBoZXJlXG4gICAgLy8gYWRqdXN0IFotYnVmZmVyIHJhbmdlXG4gICAgLy8gdGhpcy0+UHJvamVjdGlvblRyYW5zZm9ybS0+QWRqdXN0WkJ1ZmZlciggLTEsICsxLCBuZWFyeiwgZmFyeiApO1xuICAgIGNvbnN0IGNXaWR0aCA9IG1vZGVsLmNsaXBwaW5nUmFuZ2VbMV0gLSBtb2RlbC5jbGlwcGluZ1JhbmdlWzBdO1xuICAgIGNvbnN0IGNSYW5nZSA9IFtcbiAgICAgIG1vZGVsLmNsaXBwaW5nUmFuZ2VbMF0gKyAoKG5lYXJ6ICsgMSkgKiBjV2lkdGgpIC8gMi4wLFxuICAgICAgbW9kZWwuY2xpcHBpbmdSYW5nZVswXSArICgoZmFyeiArIDEpICogY1dpZHRoKSAvIDIuMCxcbiAgICBdO1xuXG4gICAgaWYgKG1vZGVsLnBhcmFsbGVsUHJvamVjdGlvbikge1xuICAgICAgLy8gc2V0IHVwIGEgcmVjdGFuZ3VsYXIgcGFyYWxsZWxpcGlwZWRcbiAgICAgIGNvbnN0IHdpZHRoID0gbW9kZWwucGFyYWxsZWxTY2FsZSAqIGFzcGVjdDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IG1vZGVsLnBhcmFsbGVsU2NhbGU7XG5cbiAgICAgIGNvbnN0IHhtaW4gPSAobW9kZWwud2luZG93Q2VudGVyWzBdIC0gMS4wKSAqIHdpZHRoO1xuICAgICAgY29uc3QgeG1heCA9IChtb2RlbC53aW5kb3dDZW50ZXJbMF0gKyAxLjApICogd2lkdGg7XG4gICAgICBjb25zdCB5bWluID0gKG1vZGVsLndpbmRvd0NlbnRlclsxXSAtIDEuMCkgKiBoZWlnaHQ7XG4gICAgICBjb25zdCB5bWF4ID0gKG1vZGVsLndpbmRvd0NlbnRlclsxXSArIDEuMCkgKiBoZWlnaHQ7XG5cbiAgICAgIG1hdDQub3J0aG8odG1wTWF0cml4LCB4bWluLCB4bWF4LCB5bWluLCB5bWF4LCBjUmFuZ2VbMF0sIGNSYW5nZVsxXSk7XG4gICAgICBtYXQ0LnRyYW5zcG9zZSh0bXBNYXRyaXgsIHRtcE1hdHJpeCk7XG4gICAgfSBlbHNlIGlmIChtb2RlbC51c2VPZmZBeGlzUHJvamVjdGlvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdPZmYtQXhpcyBwcm9qZWN0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgYXQgdGhpcyB0aW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRtcCA9IE1hdGgudGFuKHZ0a01hdGgucmFkaWFuc0Zyb21EZWdyZWVzKG1vZGVsLnZpZXdBbmdsZSkgLyAyLjApO1xuICAgICAgbGV0IHdpZHRoO1xuICAgICAgbGV0IGhlaWdodDtcbiAgICAgIGlmIChtb2RlbC51c2VIb3Jpem9udGFsVmlld0FuZ2xlID09PSB0cnVlKSB7XG4gICAgICAgIHdpZHRoID0gbW9kZWwuY2xpcHBpbmdSYW5nZVswXSAqIHRtcDtcbiAgICAgICAgaGVpZ2h0ID0gKG1vZGVsLmNsaXBwaW5nUmFuZ2VbMF0gKiB0bXApIC8gYXNwZWN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSBtb2RlbC5jbGlwcGluZ1JhbmdlWzBdICogdG1wICogYXNwZWN0O1xuICAgICAgICBoZWlnaHQgPSBtb2RlbC5jbGlwcGluZ1JhbmdlWzBdICogdG1wO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB4bWluID0gKG1vZGVsLndpbmRvd0NlbnRlclswXSAtIDEuMCkgKiB3aWR0aDtcbiAgICAgIGNvbnN0IHhtYXggPSAobW9kZWwud2luZG93Q2VudGVyWzBdICsgMS4wKSAqIHdpZHRoO1xuICAgICAgY29uc3QgeW1pbiA9IChtb2RlbC53aW5kb3dDZW50ZXJbMV0gLSAxLjApICogaGVpZ2h0O1xuICAgICAgY29uc3QgeW1heCA9IChtb2RlbC53aW5kb3dDZW50ZXJbMV0gKyAxLjApICogaGVpZ2h0O1xuICAgICAgY29uc3Qgem5lYXIgPSBjUmFuZ2VbMF07XG4gICAgICBjb25zdCB6ZmFyID0gY1JhbmdlWzFdO1xuXG4gICAgICB0bXBNYXRyaXhbMF0gPSAoMi4wICogem5lYXIpIC8gKHhtYXggLSB4bWluKTtcbiAgICAgIHRtcE1hdHJpeFs1XSA9ICgyLjAgKiB6bmVhcikgLyAoeW1heCAtIHltaW4pO1xuICAgICAgdG1wTWF0cml4WzJdID0gKHhtaW4gKyB4bWF4KSAvICh4bWF4IC0geG1pbik7XG4gICAgICB0bXBNYXRyaXhbNl0gPSAoeW1pbiArIHltYXgpIC8gKHltYXggLSB5bWluKTtcbiAgICAgIHRtcE1hdHJpeFsxMF0gPSAtKHpuZWFyICsgemZhcikgLyAoemZhciAtIHpuZWFyKTtcbiAgICAgIHRtcE1hdHJpeFsxNF0gPSAtMS4wO1xuICAgICAgdG1wTWF0cml4WzExXSA9ICgtMi4wICogem5lYXIgKiB6ZmFyKSAvICh6ZmFyIC0gem5lYXIpO1xuICAgICAgdG1wTWF0cml4WzE1XSA9IDAuMDtcbiAgICB9XG5cbiAgICBtYXQ0LmNvcHkocmVzdWx0LCB0bXBNYXRyaXgpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0Q29tcG9zaXRlUHJvamVjdGlvbk1hdHJpeCA9IChhc3BlY3QsIG5lYXJ6LCBmYXJ6KSA9PiB7XG4gICAgY29uc3Qgdk1hdCA9IHB1YmxpY0FQSS5nZXRWaWV3TWF0cml4KCk7XG4gICAgY29uc3QgcE1hdCA9IHB1YmxpY0FQSS5nZXRQcm9qZWN0aW9uTWF0cml4KGFzcGVjdCwgbmVhcnosIGZhcnopO1xuICAgIGNvbnN0IHJlc3VsdCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgLy8gbWF0cyBhcmUgdHJhbnNwb3NlZCBzbyB0aGUgb3JkZXIgaXMgQSB0aGVuIEJcbiAgICBtYXQ0Lm11bHRpcGx5KHJlc3VsdCwgdk1hdCwgcE1hdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0RGlyZWN0aW9uT2ZQcm9qZWN0aW9uID0gKHgsIHksIHopID0+IHtcbiAgICBpZiAoXG4gICAgICBtb2RlbC5kaXJlY3Rpb25PZlByb2plY3Rpb25bMF0gPT09IHggJiZcbiAgICAgIG1vZGVsLmRpcmVjdGlvbk9mUHJvamVjdGlvblsxXSA9PT0geSAmJlxuICAgICAgbW9kZWwuZGlyZWN0aW9uT2ZQcm9qZWN0aW9uWzJdID09PSB6XG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbW9kZWwuZGlyZWN0aW9uT2ZQcm9qZWN0aW9uWzBdID0geDtcbiAgICBtb2RlbC5kaXJlY3Rpb25PZlByb2plY3Rpb25bMV0gPSB5O1xuICAgIG1vZGVsLmRpcmVjdGlvbk9mUHJvamVjdGlvblsyXSA9IHo7XG5cbiAgICBjb25zdCB2ZWMgPSBtb2RlbC5kaXJlY3Rpb25PZlByb2plY3Rpb247XG5cbiAgICAvLyByZWNhbGN1bGF0ZSBGb2NhbFBvaW50XG4gICAgbW9kZWwuZm9jYWxQb2ludFswXSA9IG1vZGVsLnBvc2l0aW9uWzBdICsgdmVjWzBdICogbW9kZWwuZGlzdGFuY2U7XG4gICAgbW9kZWwuZm9jYWxQb2ludFsxXSA9IG1vZGVsLnBvc2l0aW9uWzFdICsgdmVjWzFdICogbW9kZWwuZGlzdGFuY2U7XG4gICAgbW9kZWwuZm9jYWxQb2ludFsyXSA9IG1vZGVsLnBvc2l0aW9uWzJdICsgdmVjWzJdICogbW9kZWwuZGlzdGFuY2U7XG4gICAgY29tcHV0ZVZpZXdQbGFuZU5vcm1hbCgpO1xuICB9O1xuXG4gIC8vIHVzZWQgdG8gaGFuZGxlIGNvbnZlcnQganMgZGV2aWNlIG9yaWVudGF0aW9uIGFuZ2xlc1xuICAvLyB3aGVuIHlvdSB1c2UgdGhpcyBtZXRob2QgdGhlIGNhbWVyYSB3aWxsIGFkanVzdCB0byB0aGVcbiAgLy8gZGV2aWNlIG9yaWVudGF0aW9uIHN1Y2ggdGhhdCB0aGUgcGh5c2ljYWxWaWV3VXAgeW91IHNldFxuICAvLyBpbiB3b3JsZCBjb29yZGluYXRlcyBsb29rcyB1cCwgYW5kIHRoZSBwaHlzaWNhbFZpZXdOb3J0aFxuICAvLyB5b3Ugc2V0IGluIHdvcmxkIGNvb3JpbmRhdGVzIHdpbGwgKG1heWJlKSBwb2ludCBub3J0aFxuICAvL1xuICAvLyBOT1RFIFdBUk5JTkcgLSBtdWNoIG9mIHRoZSBkb2N1bWVudGF0aW9uIG91dCB0aGVyZSBvbiBob3dcbiAgLy8gb3JpZW50YXRpb24gd29ya3MgaXMgc2VyaW91c2x5IHdyb25nLiBFdmVuIHdvcnNlIHRoZSBDaHJvbWVcbiAgLy8gZGV2aWNlIG9yaWVudGF0aW9uIHNpbXVsYXRvciBpcyBjb21wbGV0ZWx5IHdyb25nIGFuZCBzaG91bGRcbiAgLy8gbmV2ZXIgYmUgdXNlZC4gT01HIGl0IGlzIHNvIG1lc3NlZCB1cC5cbiAgLy9cbiAgLy8gaG93IGl0IHNlZW1zIHRvIHdvcmsgb24gaU9TIGlzIHRoYXQgdGhlIGRldmljZSBvcmllbnRhdGlvblxuICAvLyBpcyBzcGVjaWZpZWQgaW4gZXh0cmluc2ljIGFuZ2xlcyB3aXRoIGEgYWxwaGEsIGJldGEsIGdhbW1hXG4gIC8vIGNvbnZlbnRpb24gd2l0aCBheGVzIG9mIFosIFgsIFkgKHRoZSBjb2RlIGJlbG93IHN1YnN0aXR1dGVzXG4gIC8vIHRoZSBwaHlzaWNhbCBjb29yZGluYXRlIHN5c3RlbSBmb3IgdGhlc2UgYXhlcyB0byBnZXQgdGhlIHJpZ2h0XG4gIC8vIG1vZGlmaWVkIGNvb3JkaW5hdGUgc3lzdGVtLlxuICBwdWJsaWNBUEkuc2V0RGV2aWNlQW5nbGVzID0gKGFscGhhLCBiZXRhLCBnYW1tYSwgc2NyZWVuKSA9PiB7XG4gICAgY29uc3QgcGh5c1ZSaWdodCA9IFszXTtcbiAgICB2dGtNYXRoLmNyb3NzKG1vZGVsLnBoeXNpY2FsVmlld05vcnRoLCBtb2RlbC5waHlzaWNhbFZpZXdVcCwgcGh5c1ZSaWdodCk7XG5cbiAgICBjb25zdCByb3RtYXQgPSBtYXQ0LmNyZWF0ZSgpOyAvLyBwaG9uZSB0byBwaHlzaWNhbCBjb29yZGluYXRlc1xuICAgIG1hdDQucm90YXRlKFxuICAgICAgcm90bWF0LFxuICAgICAgcm90bWF0LFxuICAgICAgdnRrTWF0aC5yYWRpYW5zRnJvbURlZ3JlZXMoYWxwaGEpLFxuICAgICAgbW9kZWwucGh5c2ljYWxWaWV3VXBcbiAgICApO1xuICAgIG1hdDQucm90YXRlKHJvdG1hdCwgcm90bWF0LCB2dGtNYXRoLnJhZGlhbnNGcm9tRGVncmVlcyhiZXRhKSwgcGh5c1ZSaWdodCk7XG4gICAgbWF0NC5yb3RhdGUoXG4gICAgICByb3RtYXQsXG4gICAgICByb3RtYXQsXG4gICAgICB2dGtNYXRoLnJhZGlhbnNGcm9tRGVncmVlcyhnYW1tYSksXG4gICAgICBtb2RlbC5waHlzaWNhbFZpZXdOb3J0aFxuICAgICk7XG5cbiAgICBtYXQ0LnJvdGF0ZShcbiAgICAgIHJvdG1hdCxcbiAgICAgIHJvdG1hdCxcbiAgICAgIHZ0a01hdGgucmFkaWFuc0Zyb21EZWdyZWVzKC1zY3JlZW4pLFxuICAgICAgbW9kZWwucGh5c2ljYWxWaWV3VXBcbiAgICApO1xuXG4gICAgY29uc3QgZG9wID0gdmVjMy5mcm9tVmFsdWVzKFxuICAgICAgLW1vZGVsLnBoeXNpY2FsVmlld1VwWzBdLFxuICAgICAgLW1vZGVsLnBoeXNpY2FsVmlld1VwWzFdLFxuICAgICAgLW1vZGVsLnBoeXNpY2FsVmlld1VwWzJdXG4gICAgKTtcbiAgICBjb25zdCB2dXAgPSB2ZWMzLmZyb21WYWx1ZXMoXG4gICAgICBtb2RlbC5waHlzaWNhbFZpZXdOb3J0aFswXSxcbiAgICAgIG1vZGVsLnBoeXNpY2FsVmlld05vcnRoWzFdLFxuICAgICAgbW9kZWwucGh5c2ljYWxWaWV3Tm9ydGhbMl1cbiAgICApO1xuICAgIHZlYzMudHJhbnNmb3JtTWF0NChkb3AsIGRvcCwgcm90bWF0KTtcbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDQodnVwLCB2dXAsIHJvdG1hdCk7XG5cbiAgICBwdWJsaWNBUEkuc2V0RGlyZWN0aW9uT2ZQcm9qZWN0aW9uKGRvcFswXSwgZG9wWzFdLCBkb3BbMl0pO1xuICAgIHB1YmxpY0FQSS5zZXRWaWV3VXAodnVwWzBdLCB2dXBbMV0sIHZ1cFsyXSk7XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldE9yaWVudGF0aW9uV1hZWiA9IChkZWdyZWVzLCB4LCB5LCB6KSA9PiB7XG4gICAgY29uc3QgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgICBpZiAoZGVncmVlcyAhPT0gMC4wICYmICh4ICE9PSAwLjAgfHwgeSAhPT0gMC4wIHx8IHogIT09IDAuMCkpIHtcbiAgICAgIC8vIGNvbnZlcnQgdG8gcmFkaWFuc1xuICAgICAgY29uc3QgYW5nbGUgPSB2dGtNYXRoLnJhZGlhbnNGcm9tRGVncmVlcyhkZWdyZWVzKTtcbiAgICAgIGNvbnN0IHEgPSBxdWF0LmNyZWF0ZSgpO1xuICAgICAgcXVhdC5zZXRBeGlzQW5nbGUocSwgW3gsIHksIHpdLCBhbmdsZSk7XG4gICAgICBtYXQ0LmZyb21RdWF0KHF1YXRNYXQsIHEpO1xuICAgIH1cblxuICAgIGNvbnN0IGRvcCA9IHZlYzMuZnJvbVZhbHVlcygwLjAsIDAuMCwgLTEuMCk7XG4gICAgY29uc3QgbmV3ZG9wID0gdmVjMy5jcmVhdGUoKTtcbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDQobmV3ZG9wLCBkb3AsIHF1YXRNYXQpO1xuXG4gICAgY29uc3QgdnVwID0gdmVjMy5mcm9tVmFsdWVzKDAuMCwgMS4wLCAwLjApO1xuICAgIGNvbnN0IG5ld3Z1cCA9IHZlYzMuY3JlYXRlKCk7XG4gICAgdmVjMy50cmFuc2Zvcm1NYXQ0KG5ld3Z1cCwgdnVwLCBxdWF0TWF0KTtcblxuICAgIHB1YmxpY0FQSS5zZXREaXJlY3Rpb25PZlByb2plY3Rpb24oLi4ubmV3ZG9wKTtcbiAgICBwdWJsaWNBUEkuc2V0Vmlld1VwKC4uLm5ld3Z1cCk7XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLmNvbXB1dGVDbGlwcGluZ1JhbmdlID0gKGJvdW5kcykgPT4ge1xuICAgIGxldCB2biA9IG51bGw7XG4gICAgbGV0IHBvc2l0aW9uID0gbnVsbDtcblxuICAgIHZuID0gbW9kZWwudmlld1BsYW5lTm9ybWFsO1xuICAgIHBvc2l0aW9uID0gbW9kZWwucG9zaXRpb247XG5cbiAgICBjb25zdCBhID0gLXZuWzBdO1xuICAgIGNvbnN0IGIgPSAtdm5bMV07XG4gICAgY29uc3QgYyA9IC12blsyXTtcbiAgICBjb25zdCBkID0gLShhICogcG9zaXRpb25bMF0gKyBiICogcG9zaXRpb25bMV0gKyBjICogcG9zaXRpb25bMl0pO1xuXG4gICAgLy8gU2V0IHRoZSBtYXggbmVhciBjbGlwcGluZyBwbGFuZSBhbmQgdGhlIG1pbiBmYXIgY2xpcHBpbmcgcGxhbmVcbiAgICBjb25zdCByYW5nZSA9IFthICogYm91bmRzWzBdICsgYiAqIGJvdW5kc1syXSArIGMgKiBib3VuZHNbNF0gKyBkLCAxZS0xOF07XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IC8gZmFydGhlc3QgYm91bmRpbmcgYm94IHZlcnRleFxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgMjsgaysrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI7IGorKykge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGRpc3QgPVxuICAgICAgICAgICAgYSAqIGJvdW5kc1tpXSArIGIgKiBib3VuZHNbMiArIGpdICsgYyAqIGJvdW5kc1s0ICsga10gKyBkO1xuICAgICAgICAgIHJhbmdlWzBdID0gZGlzdCA8IHJhbmdlWzBdID8gZGlzdCA6IHJhbmdlWzBdO1xuICAgICAgICAgIHJhbmdlWzFdID0gZGlzdCA+IHJhbmdlWzFdID8gZGlzdCA6IHJhbmdlWzFdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIHBvc2l0aW9uOiBbMCwgMCwgMV0sXG4gIGZvY2FsUG9pbnQ6IFswLCAwLCAwXSxcbiAgdmlld1VwOiBbMCwgMSwgMF0sXG4gIGRpcmVjdGlvbk9mUHJvamVjdGlvbjogWzAsIDAsIC0xXSxcbiAgcGFyYWxsZWxQcm9qZWN0aW9uOiBmYWxzZSxcbiAgdXNlSG9yaXpvbnRhbFZpZXdBbmdsZTogZmFsc2UsXG4gIHZpZXdBbmdsZTogMzAsXG4gIHBhcmFsbGVsU2NhbGU6IDEsXG4gIGNsaXBwaW5nUmFuZ2U6IFswLjAxLCAxMDAwLjAxXSxcbiAgd2luZG93Q2VudGVyOiBbMCwgMF0sXG4gIHZpZXdQbGFuZU5vcm1hbDogWzAsIDAsIDFdLFxuICB1c2VPZmZBeGlzUHJvamVjdGlvbjogZmFsc2UsXG4gIHNjcmVlbkJvdHRvbUxlZnQ6IFstMC41LCAtMC41LCAtMC41XSxcbiAgc2NyZWVuQm90dG9tUmlnaHQ6IFswLjUsIC0wLjUsIC0wLjVdLFxuICBzY3JlZW5Ub3BSaWdodDogWzAuNSwgMC41LCAtMC41XSxcbiAgZnJlZXplRm9jYWxQb2ludDogZmFsc2UsXG4gIHByb2plY3Rpb25NYXRyaXg6IG51bGwsXG4gIHZpZXdNYXRyaXg6IG51bGwsXG5cbiAgLy8gdXNlZCBmb3Igd29ybGQgdG8gcGh5c2ljYWwgdHJhbnNmb3JtYXRpb25zXG4gIHBoeXNpY2FsVHJhbnNsYXRpb246IFswLCAwLCAwXSxcbiAgcGh5c2ljYWxTY2FsZTogMS4wLFxuICBwaHlzaWNhbFZpZXdVcDogWzAsIDEsIDBdLFxuICBwaHlzaWNhbFZpZXdOb3J0aDogWzAsIDAsIC0xXSxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEJ1aWxkIFZUSyBBUElcbiAgbWFjcm8ub2JqKHB1YmxpY0FQSSwgbW9kZWwpO1xuXG4gIG1hY3JvLmdldChwdWJsaWNBUEksIG1vZGVsLCBbJ2Rpc3RhbmNlJ10pO1xuXG4gIG1hY3JvLnNldEdldChwdWJsaWNBUEksIG1vZGVsLCBbXG4gICAgJ3BhcmFsbGVsUHJvamVjdGlvbicsXG4gICAgJ3VzZUhvcml6b250YWxWaWV3QW5nbGUnLFxuICAgICd2aWV3QW5nbGUnLFxuICAgICdwYXJhbGxlbFNjYWxlJyxcbiAgICAndXNlT2ZmQXhpc1Byb2plY3Rpb24nLFxuICAgICdmcmVlemVGb2NhbFBvaW50JyxcbiAgICAncGh5c2ljYWxTY2FsZScsXG4gIF0pO1xuXG4gIG1hY3JvLmdldEFycmF5KHB1YmxpY0FQSSwgbW9kZWwsIFtcbiAgICAnZGlyZWN0aW9uT2ZQcm9qZWN0aW9uJyxcbiAgICAndmlld1BsYW5lTm9ybWFsJyxcbiAgICAncG9zaXRpb24nLFxuICAgICdmb2NhbFBvaW50JyxcbiAgXSk7XG5cbiAgbWFjcm8uc2V0R2V0QXJyYXkocHVibGljQVBJLCBtb2RlbCwgWydjbGlwcGluZ1JhbmdlJywgJ3dpbmRvd0NlbnRlciddLCAyKTtcblxuICBtYWNyby5zZXRHZXRBcnJheShcbiAgICBwdWJsaWNBUEksXG4gICAgbW9kZWwsXG4gICAgW1xuICAgICAgJ3ZpZXdVcCcsXG4gICAgICAnc2NyZWVuQm90dG9tTGVmdCcsXG4gICAgICAnc2NyZWVuQm90dG9tUmlnaHQnLFxuICAgICAgJ3NjcmVlblRvcFJpZ2h0JyxcbiAgICAgICdwaHlzaWNhbFRyYW5zbGF0aW9uJyxcbiAgICAgICdwaHlzaWNhbFZpZXdVcCcsXG4gICAgICAncGh5c2ljYWxWaWV3Tm9ydGgnLFxuICAgIF0sXG4gICAgM1xuICApO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIHZ0a0NhbWVyYShwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQsICd2dGtDYW1lcmEnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImV4cG9ydCBjb25zdCBTbGljaW5nTW9kZSA9IHtcbiAgTk9ORTogLTEsXG4gIEk6IDAsXG4gIEo6IDEsXG4gIEs6IDIsXG4gIFg6IDMsXG4gIFk6IDQsXG4gIFo6IDUsXG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFNsaWNpbmdNb2RlLFxufTtcbiIsImV4cG9ydCBjb25zdCBJbnRlcnBvbGF0aW9uVHlwZSA9IHtcbiAgTkVBUkVTVDogMCxcbiAgTElORUFSOiAxLFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBJbnRlcnBvbGF0aW9uVHlwZSxcbn07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0IHZ0a1JlbmRlcldpbmRvd0ludGVyYWN0b3IgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvUmVuZGVyV2luZG93SW50ZXJhY3Rvcic7XG5cbmNvbnN0IHsgdnRrRXJyb3JNYWNybywgVk9JRCB9ID0gbWFjcm87XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdsb2JhbCBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246XG4vLyBUcmFuc2Zvcm0gZnJvbSB3b3JsZCB0byBkaXNwbGF5IGNvb3JkaW5hdGVzLlxuZnVuY3Rpb24gY29tcHV0ZVdvcmxkVG9EaXNwbGF5KHJlbmRlcmVyLCB4LCB5LCB6KSB7XG4gIGNvbnN0IHZpZXcgPSByZW5kZXJlci5nZXRSZW5kZXJXaW5kb3coKS5nZXRWaWV3cygpWzBdO1xuICByZXR1cm4gdmlldy53b3JsZFRvRGlzcGxheSh4LCB5LCB6LCByZW5kZXJlcik7XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGVzY3JpcHRpb246XG4vLyBUcmFuc2Zvcm0gZnJvbSBkaXNwbGF5IHRvIHdvcmxkIGNvb3JkaW5hdGVzLlxuZnVuY3Rpb24gY29tcHV0ZURpc3BsYXlUb1dvcmxkKHJlbmRlcmVyLCB4LCB5LCB6KSB7XG4gIGNvbnN0IHZpZXcgPSByZW5kZXJlci5nZXRSZW5kZXJXaW5kb3coKS5nZXRWaWV3cygpWzBdO1xuICByZXR1cm4gdmlldy5kaXNwbGF5VG9Xb3JsZCh4LCB5LCB6LCByZW5kZXJlcik7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFN0YXRpYyBBUElcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBjb25zdCBTVEFUSUMgPSB7XG4gIGNvbXB1dGVXb3JsZFRvRGlzcGxheSxcbiAgY29tcHV0ZURpc3BsYXlUb1dvcmxkLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrSW50ZXJhY3Rvck9ic2VydmVyIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrSW50ZXJhY3Rvck9ic2VydmVyKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrSW50ZXJhY3Rvck9ic2VydmVyJyk7XG5cbiAgY29uc3Qgc3VwZXJDbGFzcyA9IHsgLi4ucHVibGljQVBJIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGZ1bmN0aW9uIHVuc3Vic2NyaWJlRnJvbUV2ZW50cygpIHtcbiAgICB3aGlsZSAobW9kZWwuc3Vic2NyaWJlZEV2ZW50cy5sZW5ndGgpIHtcbiAgICAgIG1vZGVsLnN1YnNjcmliZWRFdmVudHMucG9wKCkudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gQ2hlY2sgd2hhdCBldmVudHMgd2UgY2FuIGhhbmRsZSBhbmQgcmVnaXN0ZXIgY2FsbGJhY2tzXG4gIGZ1bmN0aW9uIHN1YnNjcmliZVRvRXZlbnRzKCkge1xuICAgIHZ0a1JlbmRlcldpbmRvd0ludGVyYWN0b3IuaGFuZGxlZEV2ZW50cy5mb3JFYWNoKChldmVudE5hbWUpID0+IHtcbiAgICAgIGlmIChwdWJsaWNBUElbYGhhbmRsZSR7ZXZlbnROYW1lfWBdKSB7XG4gICAgICAgIG1vZGVsLnN1YnNjcmliZWRFdmVudHMucHVzaChcbiAgICAgICAgICBtb2RlbC5pbnRlcmFjdG9yW2BvbiR7ZXZlbnROYW1lfWBdKChjYWxsRGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKG1vZGVsLnByb2Nlc3NFdmVudHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHB1YmxpY0FQSVtgaGFuZGxlJHtldmVudE5hbWV9YF0oY2FsbERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFZPSUQ7XG4gICAgICAgICAgfSwgbW9kZWwucHJpb3JpdHkpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUHVibGljIEFQSSBtZXRob2RzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuc2V0SW50ZXJhY3RvciA9IChpKSA9PiB7XG4gICAgaWYgKGkgPT09IG1vZGVsLmludGVyYWN0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1bnN1YnNjcmliZUZyb21FdmVudHMoKTtcblxuICAgIG1vZGVsLmludGVyYWN0b3IgPSBpO1xuXG4gICAgaWYgKGkgJiYgbW9kZWwuZW5hYmxlZCkge1xuICAgICAgc3Vic2NyaWJlVG9FdmVudHMoKTtcbiAgICB9XG5cbiAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLnNldEVuYWJsZWQgPSAoZW5hYmxlKSA9PiB7XG4gICAgaWYgKGVuYWJsZSA9PT0gbW9kZWwuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVuc3Vic2NyaWJlRnJvbUV2ZW50cygpO1xuXG4gICAgaWYgKGVuYWJsZSkge1xuICAgICAgaWYgKG1vZGVsLmludGVyYWN0b3IpIHtcbiAgICAgICAgc3Vic2NyaWJlVG9FdmVudHMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZ0a0Vycm9yTWFjcm8oYFxuICAgICAgICAgIFRoZSBpbnRlcmFjdG9yIG11c3QgYmUgc2V0IGJlZm9yZSBzdWJzY3JpYmluZyB0byBldmVudHNcbiAgICAgICAgYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW9kZWwuZW5hYmxlZCA9IGVuYWJsZTtcbiAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gRGVzY3JpcHRpb246XG4gIC8vIFRyYW5zZm9ybSBmcm9tIGRpc3BsYXkgdG8gd29ybGQgY29vcmRpbmF0ZXMuXG4gIHB1YmxpY0FQSS5jb21wdXRlRGlzcGxheVRvV29ybGQgPSAocmVuZGVyZXIsIHgsIHksIHopID0+IHtcbiAgICBpZiAoIXJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9kZWwuaW50ZXJhY3Rvci5nZXRWaWV3KCkuZGlzcGxheVRvV29ybGQoeCwgeSwgeiwgcmVuZGVyZXIpO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBEZXNjcmlwdGlvbjpcbiAgLy8gVHJhbnNmb3JtIGZyb20gd29ybGQgdG8gZGlzcGxheSBjb29yZGluYXRlcy5cbiAgcHVibGljQVBJLmNvbXB1dGVXb3JsZFRvRGlzcGxheSA9IChyZW5kZXJlciwgeCwgeSwgeikgPT4ge1xuICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlbC5pbnRlcmFjdG9yLmdldFZpZXcoKS53b3JsZFRvRGlzcGxheSh4LCB5LCB6LCByZW5kZXJlcik7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgcHVibGljQVBJLnNldFByaW9yaXR5ID0gKHByaW9yaXR5KSA9PiB7XG4gICAgY29uc3QgbW9kaWZpZWQgPSBzdXBlckNsYXNzLnNldFByaW9yaXR5KHByaW9yaXR5KTtcblxuICAgIGlmIChtb2RpZmllZCAmJiBtb2RlbC5pbnRlcmFjdG9yKSB7XG4gICAgICB1bnN1YnNjcmliZUZyb21FdmVudHMoKTtcbiAgICAgIHN1YnNjcmliZVRvRXZlbnRzKCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgaW50ZXJhY3RvcjogbnVsbCxcbiAgcHJpb3JpdHk6IDAuMCxcbiAgcHJvY2Vzc0V2ZW50czogdHJ1ZSxcbiAgc3Vic2NyaWJlZEV2ZW50czogW10sXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICBtYWNyby5vYmoocHVibGljQVBJLCBtb2RlbCk7XG5cbiAgbWFjcm8uZXZlbnQocHVibGljQVBJLCBtb2RlbCwgJ0ludGVyYWN0aW9uRXZlbnQnKTtcbiAgbWFjcm8uZXZlbnQocHVibGljQVBJLCBtb2RlbCwgJ1N0YXJ0SW50ZXJhY3Rpb25FdmVudCcpO1xuICBtYWNyby5ldmVudChwdWJsaWNBUEksIG1vZGVsLCAnRW5kSW50ZXJhY3Rpb25FdmVudCcpO1xuXG4gIC8vIENyZWF0ZSBnZXQtb25seSBtYWNyb3NcbiAgbWFjcm8uZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsnaW50ZXJhY3RvcicsICdlbmFibGVkJ10pO1xuXG4gIC8vIENyZWF0ZSBnZXQtc2V0IG1hY3Jvc1xuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgWydwcmlvcml0eScsICdwcm9jZXNzRXZlbnRzJ10pO1xuXG4gIC8vIEZvciBtb3JlIG1hY3JvIG1ldGhvZHMsIHNlZSBcIlNvdXJjZXMvbWFjcm8uanNcIlxuXG4gIC8vIE9iamVjdCBzcGVjaWZpYyBtZXRob2RzXG4gIHZ0a0ludGVyYWN0b3JPYnNlcnZlcihwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQsICd2dGtJbnRlcmFjdG9yT2JzZXJ2ZXInKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQsIC4uLlNUQVRJQyB9O1xuIiwiZXhwb3J0IGNvbnN0IFN0YXRlcyA9IHtcbiAgSVNfU1RBUlQ6IDAsXG4gIElTX05PTkU6IDAsXG5cbiAgSVNfUk9UQVRFOiAxLFxuICBJU19QQU46IDIsXG4gIElTX1NQSU46IDMsXG4gIElTX0RPTExZOiA0LFxuXG4gIElTX0NBTUVSQV9QT1NFOiAxMSxcblxuICBJU19XSU5ET1dfTEVWRUw6IDEwMjQsXG4gIElTX1NMSUNFOiAxMDI1LFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBTdGF0ZXMsXG59O1xuIiwiaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB2dGtJbnRlcmFjdG9yT2JzZXJ2ZXIgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvSW50ZXJhY3Rvck9ic2VydmVyJztcbmltcG9ydCBDb25zdGFudHMgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvSW50ZXJhY3RvclN0eWxlL0NvbnN0YW50cyc7XG5cbmNvbnN0IHsgU3RhdGVzIH0gPSBDb25zdGFudHM7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdsb2JhbCBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIEFkZCBtb2R1bGUtbGV2ZWwgZnVuY3Rpb25zIG9yIGFwaSB0aGF0IHlvdSB3YW50IHRvIGV4cG9zZSBzdGF0aWNhbGx5IHZpYVxuLy8gdGhlIG5leHQgc2VjdGlvbi4uLlxuXG5jb25zdCBzdGF0ZU5hbWVzID0ge1xuICBSb3RhdGU6IFN0YXRlcy5JU19ST1RBVEUsXG4gIFBhbjogU3RhdGVzLklTX1BBTixcbiAgU3BpbjogU3RhdGVzLklTX1NQSU4sXG4gIERvbGx5OiBTdGF0ZXMuSVNfRE9MTFksXG4gIENhbWVyYVBvc2U6IFN0YXRlcy5JU19DQU1FUkFfUE9TRSxcbiAgV2luZG93TGV2ZWw6IFN0YXRlcy5JU19XSU5ET1dfTEVWRUwsXG4gIFNsaWNlOiBTdGF0ZXMuSVNfU0xJQ0UsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtJbnRlcmFjdG9yU3R5bGUgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtJbnRlcmFjdG9yU3R5bGUocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtJbnRlcmFjdG9yU3R5bGUnKTtcblxuICAvLyBQdWJsaWMgQVBJIG1ldGhvZHNcbiAgLy8gY3JlYXRlIGJ1bmNoIG9mIFN0YXJ0L0VuZFN0YXRlIG1ldGhvZHNcbiAgT2JqZWN0LmtleXMoc3RhdGVOYW1lcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgbWFjcm8uZXZlbnQocHVibGljQVBJLCBtb2RlbCwgYFN0YXJ0JHtrZXl9RXZlbnRgKTtcbiAgICBwdWJsaWNBUElbYHN0YXJ0JHtrZXl9YF0gPSAoKSA9PiB7XG4gICAgICBpZiAobW9kZWwuc3RhdGUgIT09IFN0YXRlcy5JU19OT05FKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1vZGVsLnN0YXRlID0gc3RhdGVOYW1lc1trZXldO1xuICAgICAgbW9kZWwuaW50ZXJhY3Rvci5yZXF1ZXN0QW5pbWF0aW9uKHB1YmxpY0FQSSk7XG4gICAgICBwdWJsaWNBUEkuaW52b2tlU3RhcnRJbnRlcmFjdGlvbkV2ZW50KHsgdHlwZTogJ1N0YXJ0SW50ZXJhY3Rpb25FdmVudCcgfSk7XG4gICAgICBwdWJsaWNBUElbYGludm9rZVN0YXJ0JHtrZXl9RXZlbnRgXSh7IHR5cGU6IGBTdGFydCR7a2V5fUV2ZW50YCB9KTtcbiAgICB9O1xuICAgIG1hY3JvLmV2ZW50KHB1YmxpY0FQSSwgbW9kZWwsIGBFbmQke2tleX1FdmVudGApO1xuICAgIHB1YmxpY0FQSVtgZW5kJHtrZXl9YF0gPSAoKSA9PiB7XG4gICAgICBpZiAobW9kZWwuc3RhdGUgIT09IHN0YXRlTmFtZXNba2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtb2RlbC5zdGF0ZSA9IFN0YXRlcy5JU19OT05FO1xuICAgICAgbW9kZWwuaW50ZXJhY3Rvci5jYW5jZWxBbmltYXRpb24ocHVibGljQVBJKTtcbiAgICAgIHB1YmxpY0FQSS5pbnZva2VFbmRJbnRlcmFjdGlvbkV2ZW50KHsgdHlwZTogJ0VuZEludGVyYWN0aW9uRXZlbnQnIH0pO1xuICAgICAgcHVibGljQVBJW2BpbnZva2VFbmQke2tleX1FdmVudGBdKHsgdHlwZTogYEVuZCR7a2V5fUV2ZW50YCB9KTtcbiAgICAgIG1vZGVsLmludGVyYWN0b3IucmVuZGVyKCk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5oYW5kbGVLZXlQcmVzcyA9IChjYWxsRGF0YSkgPT4ge1xuICAgIGNvbnN0IHJ3aSA9IG1vZGVsLmludGVyYWN0b3I7XG4gICAgbGV0IGFjID0gbnVsbDtcbiAgICBzd2l0Y2ggKGNhbGxEYXRhLmtleSkge1xuICAgICAgY2FzZSAncic6XG4gICAgICBjYXNlICdSJzpcbiAgICAgICAgY2FsbERhdGEucG9rZWRSZW5kZXJlci5yZXNldENhbWVyYSgpO1xuICAgICAgICByd2kucmVuZGVyKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd3JzpcbiAgICAgIGNhc2UgJ1cnOlxuICAgICAgICBhYyA9IGNhbGxEYXRhLnBva2VkUmVuZGVyZXIuZ2V0QWN0b3JzKCk7XG4gICAgICAgIGFjLmZvckVhY2goKGFuQWN0b3IpID0+IHtcbiAgICAgICAgICBjb25zdCBwcm9wID0gYW5BY3Rvci5nZXRQcm9wZXJ0eSgpO1xuICAgICAgICAgIGlmIChwcm9wLnNldFJlcHJlc2VudGF0aW9uVG9XaXJlZnJhbWUpIHtcbiAgICAgICAgICAgIHByb3Auc2V0UmVwcmVzZW50YXRpb25Ub1dpcmVmcmFtZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJ3aS5yZW5kZXIoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgY2FzZSAnUyc6XG4gICAgICAgIGFjID0gY2FsbERhdGEucG9rZWRSZW5kZXJlci5nZXRBY3RvcnMoKTtcbiAgICAgICAgYWMuZm9yRWFjaCgoYW5BY3RvcikgPT4ge1xuICAgICAgICAgIGNvbnN0IHByb3AgPSBhbkFjdG9yLmdldFByb3BlcnR5KCk7XG4gICAgICAgICAgaWYgKHByb3Auc2V0UmVwcmVzZW50YXRpb25Ub1N1cmZhY2UpIHtcbiAgICAgICAgICAgIHByb3Auc2V0UmVwcmVzZW50YXRpb25Ub1N1cmZhY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByd2kucmVuZGVyKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2JzpcbiAgICAgIGNhc2UgJ1YnOlxuICAgICAgICBhYyA9IGNhbGxEYXRhLnBva2VkUmVuZGVyZXIuZ2V0QWN0b3JzKCk7XG4gICAgICAgIGFjLmZvckVhY2goKGFuQWN0b3IpID0+IHtcbiAgICAgICAgICBjb25zdCBwcm9wID0gYW5BY3Rvci5nZXRQcm9wZXJ0eSgpO1xuICAgICAgICAgIGlmIChwcm9wLnNldFJlcHJlc2VudGF0aW9uVG9Qb2ludHMpIHtcbiAgICAgICAgICAgIHByb3Auc2V0UmVwcmVzZW50YXRpb25Ub1BvaW50cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJ3aS5yZW5kZXIoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIHN0YXRlOiBTdGF0ZXMuSVNfTk9ORSxcbiAgaGFuZGxlT2JzZXJ2ZXJzOiAxLFxuICBhdXRvQWRqdXN0Q2FtZXJhQ2xpcHBpbmdSYW5nZTogMSxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEluaGVyaXRhbmNlXG4gIHZ0a0ludGVyYWN0b3JPYnNlcnZlci5leHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gT2JqZWN0IHNwZWNpZmljIG1ldGhvZHNcbiAgdnRrSW50ZXJhY3RvclN0eWxlKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a0ludGVyYWN0b3JTdHlsZScpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCwgLi4uQ29uc3RhbnRzIH07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0ICogYXMgdnRrTWF0aCBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9NYXRoJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgTElHSFRfVFlQRVMgPSBbJ0hlYWRMaWdodCcsICdDYW1lcmFMaWdodCcsICdTY2VuZUxpZ2h0J107XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a0xpZ2h0IG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrTGlnaHQocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtMaWdodCcpO1xuXG4gIHB1YmxpY0FQSS5nZXRUcmFuc2Zvcm1lZFBvc2l0aW9uID0gKCkgPT4ge1xuICAgIGlmIChtb2RlbC50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgIHJldHVybiBbXTsgLy8gRklYTUUgISEhIVxuICAgIH1cbiAgICByZXR1cm4gW10uY29uY2F0KG1vZGVsLnBvc2l0aW9uKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0VHJhbnNmb3JtZWRGb2NhbFBvaW50ID0gKCkgPT4ge1xuICAgIGlmIChtb2RlbC50cmFuc2Zvcm1NYXRyaXgpIHtcbiAgICAgIHJldHVybiBbXTsgLy8gRklYTUUgISEhIVxuICAgIH1cbiAgICByZXR1cm4gW10uY29uY2F0KG1vZGVsLmZvY2FsUG9pbnQpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXREaXJlY3Rpb24gPSAoKSA9PiB7XG4gICAgaWYgKG1vZGVsLmRpcmVjdGlvbk1UaW1lIDwgbW9kZWwubXRpbWUpIHtcbiAgICAgIG1vZGVsLmRpcmVjdGlvblswXSA9IG1vZGVsLmZvY2FsUG9pbnRbMF0gLSBtb2RlbC5wb3NpdGlvblswXTtcbiAgICAgIG1vZGVsLmRpcmVjdGlvblsxXSA9IG1vZGVsLmZvY2FsUG9pbnRbMV0gLSBtb2RlbC5wb3NpdGlvblsxXTtcbiAgICAgIG1vZGVsLmRpcmVjdGlvblsyXSA9IG1vZGVsLmZvY2FsUG9pbnRbMl0gLSBtb2RlbC5wb3NpdGlvblsyXTtcbiAgICAgIHZ0a01hdGgubm9ybWFsaXplKG1vZGVsLmRpcmVjdGlvbik7XG4gICAgICBtb2RlbC5kaXJlY3Rpb25NVGltZSA9IG1vZGVsLm10aW1lO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWwuZGlyZWN0aW9uO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXREaXJlY3Rpb25BbmdsZSA9IChlbGV2YXRpb24sIGF6aW11dGgpID0+IHtcbiAgICBjb25zdCBlbGV2YXRpb25SYWRpYW5zID0gdnRrTWF0aC5yYWRpYW5zRnJvbURlZ3JlZXMoZWxldmF0aW9uKTtcbiAgICBjb25zdCBhemltdXRoUmFkaWFucyA9IHZ0a01hdGgucmFkaWFuc0Zyb21EZWdyZWVzKGF6aW11dGgpO1xuXG4gICAgcHVibGljQVBJLnNldFBvc2l0aW9uKFxuICAgICAgTWF0aC5jb3MoZWxldmF0aW9uUmFkaWFucykgKiBNYXRoLnNpbihhemltdXRoUmFkaWFucyksXG4gICAgICBNYXRoLnNpbihlbGV2YXRpb25SYWRpYW5zKSxcbiAgICAgIE1hdGguY29zKGVsZXZhdGlvblJhZGlhbnMpICogTWF0aC5jb3MoYXppbXV0aFJhZGlhbnMpXG4gICAgKTtcblxuICAgIHB1YmxpY0FQSS5zZXRGb2NhbFBvaW50KDAsIDAsIDApO1xuICAgIHB1YmxpY0FQSS5zZXRQb3NpdGlvbmFsKDApO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRMaWdodFR5cGVUb0hlYWRMaWdodCA9ICgpID0+IHtcbiAgICBwdWJsaWNBUEkuc2V0TGlnaHRUeXBlKCdIZWFkTGlnaHQnKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0TGlnaHRUeXBlVG9DYW1lcmFMaWdodCA9ICgpID0+IHtcbiAgICBwdWJsaWNBUEkuc2V0TGlnaHRUeXBlKCdDYW1lcmFMaWdodCcpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRMaWdodFR5cGVUb1NjZW5lTGlnaHQgPSAoKSA9PiB7XG4gICAgcHVibGljQVBJLnNldFRyYW5zZm9ybU1hdHJpeChudWxsKTtcbiAgICBwdWJsaWNBUEkuc2V0TGlnaHRUeXBlKCdTY2VuZUxpZ2h0Jyk7XG4gIH07XG5cbiAgcHVibGljQVBJLmxpZ2h0VHlwZUlzSGVhZExpZ2h0ID0gKCkgPT4gbW9kZWwubGlnaHRUeXBlID09PSAnSGVhZExpZ2h0JztcblxuICBwdWJsaWNBUEkubGlnaHRUeXBlSXNTY2VuZUxpZ2h0ID0gKCkgPT4gbW9kZWwubGlnaHRUeXBlID09PSAnU2NlbmVMaWdodCc7XG5cbiAgcHVibGljQVBJLmxpZ2h0VHlwZUlzQ2FtZXJhTGlnaHQgPSAoKSA9PiBtb2RlbC5saWdodFR5cGUgPT09ICdDYW1lcmFMaWdodCc7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBzd2l0Y2g6IHRydWUsXG4gIGludGVuc2l0eTogMSxcbiAgY29sb3I6IFsxLCAxLCAxXSxcbiAgcG9zaXRpb246IFswLCAwLCAxXSxcbiAgZm9jYWxQb2ludDogWzAsIDAsIDBdLFxuICBwb3NpdGlvbmFsOiBmYWxzZSxcbiAgZXhwb25lbnQ6IDEsXG4gIGNvbmVBbmdsZTogMzAsXG4gIGF0dGVudWF0aW9uVmFsdWVzOiBbMSwgMCwgMF0sXG4gIHRyYW5zZm9ybU1hdHJpeDogbnVsbCxcbiAgbGlnaHRUeXBlOiAnU2NlbmVMaWdodCcsXG4gIHNoYWRvd0F0dGVudWF0aW9uOiAxLFxuICBkaXJlY3Rpb246IFswLCAwLCAwXSxcbiAgZGlyZWN0aW9uTVRpbWU6IDAsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBCdWlsZCBWVEsgQVBJXG4gIG1hY3JvLm9iaihwdWJsaWNBUEksIG1vZGVsKTtcbiAgbWFjcm8uc2V0R2V0KHB1YmxpY0FQSSwgbW9kZWwsIFtcbiAgICAnaW50ZW5zaXR5JyxcbiAgICAnc3dpdGNoJyxcbiAgICAncG9zaXRpb25hbCcsXG4gICAgJ2V4cG9uZW50JyxcbiAgICAnY29uZUFuZ2xlJyxcbiAgICAndHJhbnNmb3JtTWF0cml4JyxcbiAgICAnbGlnaHRUeXBlJyxcbiAgICAnc2hhZG93QXR0ZW51YXRpb24nLFxuICBdKTtcbiAgbWFjcm8uc2V0R2V0QXJyYXkoXG4gICAgcHVibGljQVBJLFxuICAgIG1vZGVsLFxuICAgIFsnY29sb3InLCAncG9zaXRpb24nLCAnZm9jYWxQb2ludCcsICdhdHRlbnVhdGlvblZhbHVlcyddLFxuICAgIDNcbiAgKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICB2dGtMaWdodChwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQsICd2dGtMaWdodCcpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCwgTElHSFRfVFlQRVMgfTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIGFycm93LWJvZHktc3R5bGUgKi9cbmltcG9ydCBvdGhlclN0YXRpY01ldGhvZHMgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvTWFwcGVyL1N0YXRpYyc7XG5pbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuXG5mdW5jdGlvbiBhZGRDb2luY2lkZW50VG9wb2xvZ3lNZXRob2RzKHB1YmxpY0FQSSwgbW9kZWwsIG5hbWVMaXN0KSB7XG4gIG5hbWVMaXN0LmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICBwdWJsaWNBUElbYGdldCR7aXRlbS5tZXRob2R9YF0gPSAoKSA9PiBtb2RlbFtpdGVtLmtleV07XG4gICAgcHVibGljQVBJW2BzZXQke2l0ZW0ubWV0aG9kfWBdID0gKGZhY3Rvciwgb2Zmc2V0KSA9PiB7XG4gICAgICBtb2RlbFtpdGVtLmtleV0gPSB7IGZhY3Rvciwgb2Zmc2V0IH07XG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCBjb25zdCBDQVRFR09SSUVTID0gWydQb2x5Z29uJywgJ0xpbmUnLCAnUG9pbnQnXTtcblxuLy8gQ29pbmNpZGVudFRvcG9sb2d5IHN0YXRpYyBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBzdGF0aWNPZmZzZXRNb2RlbCA9IHtcbiAgUG9seWdvbjogeyBmYWN0b3I6IDIsIG9mZnNldDogMCB9LFxuICBMaW5lOiB7IGZhY3RvcjogMSwgb2Zmc2V0OiAtMSB9LFxuICBQb2ludDogeyBmYWN0b3I6IDAsIG9mZnNldDogLTIgfSxcbn07XG5jb25zdCBzdGF0aWNPZmZzZXRBUEkgPSB7fTtcblxuYWRkQ29pbmNpZGVudFRvcG9sb2d5TWV0aG9kcyhcbiAgc3RhdGljT2Zmc2V0QVBJLFxuICBzdGF0aWNPZmZzZXRNb2RlbCxcbiAgQ0FURUdPUklFUy5tYXAoKGtleSkgPT4gKHtcbiAgICBrZXksXG4gICAgbWV0aG9kOiBgUmVzb2x2ZUNvaW5jaWRlbnRUb3BvbG9neSR7a2V5fU9mZnNldFBhcmFtZXRlcnNgLFxuICB9KSlcbik7XG5cbmZ1bmN0aW9uIGltcGxlbWVudENvaW5jaWRlbnRUb3BvbG9neU1ldGhvZHMocHVibGljQVBJLCBtb2RlbCkge1xuICBpZiAobW9kZWwucmVzb2x2ZUNvaW5jaWRlbnRUb3BvbG9neSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbW9kZWwucmVzb2x2ZUNvaW5jaWRlbnRUb3BvbG9neSA9IGZhbHNlO1xuICB9XG5cbiAgbWFjcm8uc2V0R2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsncmVzb2x2ZUNvaW5jaWRlbnRUb3BvbG9neSddKTtcblxuICAvLyBSZWxhdGl2ZSBtZXRob2RzXG4gIG1vZGVsLnRvcG9sb2d5T2Zmc2V0ID0ge1xuICAgIFBvbHlnb246IHsgZmFjdG9yOiAwLCBvZmZzZXQ6IDAgfSxcbiAgICBMaW5lOiB7IGZhY3RvcjogMCwgb2Zmc2V0OiAwIH0sXG4gICAgUG9pbnQ6IHsgZmFjdG9yOiAwLCBvZmZzZXQ6IDAgfSxcbiAgfTtcblxuICAvLyBBZGQgU3RhdGljIG1ldGhvZHMgdG8gb3VyIGluc3RhbmNlXG4gIE9iamVjdC5rZXlzKG90aGVyU3RhdGljTWV0aG9kcykuZm9yRWFjaCgobWV0aG9kTmFtZSkgPT4ge1xuICAgIHB1YmxpY0FQSVttZXRob2ROYW1lXSA9IG90aGVyU3RhdGljTWV0aG9kc1ttZXRob2ROYW1lXTtcbiAgfSk7XG4gIE9iamVjdC5rZXlzKHN0YXRpY09mZnNldEFQSSkuZm9yRWFjaCgobWV0aG9kTmFtZSkgPT4ge1xuICAgIHB1YmxpY0FQSVttZXRob2ROYW1lXSA9IHN0YXRpY09mZnNldEFQSVttZXRob2ROYW1lXTtcbiAgfSk7XG5cbiAgYWRkQ29pbmNpZGVudFRvcG9sb2d5TWV0aG9kcyhcbiAgICBwdWJsaWNBUEksXG4gICAgbW9kZWwudG9wb2xvZ3lPZmZzZXQsXG4gICAgQ0FURUdPUklFUy5tYXAoKGtleSkgPT4gKHtcbiAgICAgIGtleSxcbiAgICAgIG1ldGhvZDogYFJlbGF0aXZlQ29pbmNpZGVudFRvcG9sb2d5JHtrZXl9T2Zmc2V0UGFyYW1ldGVyc2AsXG4gICAgfSkpXG4gICk7XG5cbiAgcHVibGljQVBJLmdldENvaW5jaWRlbnRUb3BvbG9neVBvbHlnb25PZmZzZXRQYXJhbWV0ZXJzID0gKCkgPT4ge1xuICAgIGNvbnN0IGdsb2JhbFZhbHVlID0gc3RhdGljT2Zmc2V0QVBJLmdldFJlc29sdmVDb2luY2lkZW50VG9wb2xvZ3lQb2x5Z29uT2Zmc2V0UGFyYW1ldGVycygpO1xuICAgIGNvbnN0IGxvY2FsVmFsdWUgPSBwdWJsaWNBUEkuZ2V0UmVsYXRpdmVDb2luY2lkZW50VG9wb2xvZ3lQb2x5Z29uT2Zmc2V0UGFyYW1ldGVycygpO1xuICAgIHJldHVybiB7XG4gICAgICBmYWN0b3I6IGdsb2JhbFZhbHVlLmZhY3RvciArIGxvY2FsVmFsdWUuZmFjdG9yLFxuICAgICAgb2Zmc2V0OiBnbG9iYWxWYWx1ZS5vZmZzZXQgKyBsb2NhbFZhbHVlLm9mZnNldCxcbiAgICB9O1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRDb2luY2lkZW50VG9wb2xvZ3lMaW5lT2Zmc2V0UGFyYW1ldGVycyA9ICgpID0+IHtcbiAgICBjb25zdCBnbG9iYWxWYWx1ZSA9IHN0YXRpY09mZnNldEFQSS5nZXRSZXNvbHZlQ29pbmNpZGVudFRvcG9sb2d5TGluZU9mZnNldFBhcmFtZXRlcnMoKTtcbiAgICBjb25zdCBsb2NhbFZhbHVlID0gcHVibGljQVBJLmdldFJlbGF0aXZlQ29pbmNpZGVudFRvcG9sb2d5TGluZU9mZnNldFBhcmFtZXRlcnMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZmFjdG9yOiBnbG9iYWxWYWx1ZS5mYWN0b3IgKyBsb2NhbFZhbHVlLmZhY3RvcixcbiAgICAgIG9mZnNldDogZ2xvYmFsVmFsdWUub2Zmc2V0ICsgbG9jYWxWYWx1ZS5vZmZzZXQsXG4gICAgfTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0Q29pbmNpZGVudFRvcG9sb2d5UG9pbnRPZmZzZXRQYXJhbWV0ZXIgPSAoKSA9PiB7XG4gICAgY29uc3QgZ2xvYmFsVmFsdWUgPSBzdGF0aWNPZmZzZXRBUEkuZ2V0UmVzb2x2ZUNvaW5jaWRlbnRUb3BvbG9neVBvaW50T2Zmc2V0UGFyYW1ldGVycygpO1xuICAgIGNvbnN0IGxvY2FsVmFsdWUgPSBwdWJsaWNBUEkuZ2V0UmVsYXRpdmVDb2luY2lkZW50VG9wb2xvZ3lQb2ludE9mZnNldFBhcmFtZXRlcnMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZmFjdG9yOiBnbG9iYWxWYWx1ZS5mYWN0b3IgKyBsb2NhbFZhbHVlLmZhY3RvcixcbiAgICAgIG9mZnNldDogZ2xvYmFsVmFsdWUub2Zmc2V0ICsgbG9jYWxWYWx1ZS5vZmZzZXQsXG4gICAgfTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBpbXBsZW1lbnRDb2luY2lkZW50VG9wb2xvZ3lNZXRob2RzLFxuICBzdGF0aWNPZmZzZXRBUEksXG4gIG90aGVyU3RhdGljTWV0aG9kcyxcbiAgQ0FURUdPUklFUyxcbn07XG4iLCJleHBvcnQgY29uc3QgQ29sb3JNb2RlID0ge1xuICBERUZBVUxUOiAwLFxuICBNQVBfU0NBTEFSUzogMSxcbiAgRElSRUNUX1NDQUxBUlM6IDIsXG59O1xuXG5leHBvcnQgY29uc3QgU2NhbGFyTW9kZSA9IHtcbiAgREVGQVVMVDogMCxcbiAgVVNFX1BPSU5UX0RBVEE6IDEsXG4gIFVTRV9DRUxMX0RBVEE6IDIsXG4gIFVTRV9QT0lOVF9GSUVMRF9EQVRBOiAzLFxuICBVU0VfQ0VMTF9GSUVMRF9EQVRBOiA0LFxuICBVU0VfRklFTERfREFUQTogNSxcbn07XG5cbmV4cG9ydCBjb25zdCBHZXRBcnJheSA9IHtcbiAgQllfSUQ6IDAsXG4gIEJZX05BTUU6IDEsXG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIENvbG9yTW9kZSxcbiAgR2V0QXJyYXksXG4gIFNjYWxhck1vZGUsXG59O1xuIiwibGV0IHJlc29sdmVDb2luY2lkZW50VG9wb2xvZ3lQb2x5Z29uT2Zmc2V0RmFjZXMgPSAxO1xubGV0IHJlc29sdmVDb2luY2lkZW50VG9wb2xvZ3kgPSAwO1xuXG5leHBvcnQgY29uc3QgUkVTT0xWRV9DT0lOQ0lERU5UX1RPUE9MT0dZX01PREUgPSBbXG4gICdWVEtfUkVTT0xWRV9PRkYnLFxuICAnVlRLX1JFU09MVkVfUE9MWUdPTl9PRkZTRVQnLFxuXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJlc29sdmVDb2luY2lkZW50VG9wb2xvZ3lQb2x5Z29uT2Zmc2V0RmFjZXMoKSB7XG4gIHJldHVybiByZXNvbHZlQ29pbmNpZGVudFRvcG9sb2d5UG9seWdvbk9mZnNldEZhY2VzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0UmVzb2x2ZUNvaW5jaWRlbnRUb3BvbG9neVBvbHlnb25PZmZzZXRGYWNlcyh2YWx1ZSkge1xuICByZXNvbHZlQ29pbmNpZGVudFRvcG9sb2d5UG9seWdvbk9mZnNldEZhY2VzID0gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZXNvbHZlQ29pbmNpZGVudFRvcG9sb2d5KCkge1xuICByZXR1cm4gcmVzb2x2ZUNvaW5jaWRlbnRUb3BvbG9neTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFJlc29sdmVDb2luY2lkZW50VG9wb2xvZ3kobW9kZSA9IDApIHtcbiAgcmVzb2x2ZUNvaW5jaWRlbnRUb3BvbG9neSA9IG1vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRSZXNvbHZlQ29pbmNpZGVudFRvcG9sb2d5VG9EZWZhdWx0KCkge1xuICBzZXRSZXNvbHZlQ29pbmNpZGVudFRvcG9sb2d5KDApOyAvLyBWVEtfUkVTT0xWRV9PRkZcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldFJlc29sdmVDb2luY2lkZW50VG9wb2xvZ3lUb09mZigpIHtcbiAgc2V0UmVzb2x2ZUNvaW5jaWRlbnRUb3BvbG9neSgwKTsgLy8gVlRLX1JFU09MVkVfT0ZGXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRSZXNvbHZlQ29pbmNpZGVudFRvcG9sb2d5VG9Qb2x5Z29uT2Zmc2V0KCkge1xuICBzZXRSZXNvbHZlQ29pbmNpZGVudFRvcG9sb2d5KDEpOyAvLyBWVEtfUkVTT0xWRV9QT0xZR09OX09GRlNFVFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVzb2x2ZUNvaW5jaWRlbnRUb3BvbG9neUFzU3RyaW5nKCkge1xuICByZXR1cm4gUkVTT0xWRV9DT0lOQ0lERU5UX1RPUE9MT0dZX01PREVbcmVzb2x2ZUNvaW5jaWRlbnRUb3BvbG9neV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0UmVzb2x2ZUNvaW5jaWRlbnRUb3BvbG9neUFzU3RyaW5nLFxuICBnZXRSZXNvbHZlQ29pbmNpZGVudFRvcG9sb2d5UG9seWdvbk9mZnNldEZhY2VzLFxuICBnZXRSZXNvbHZlQ29pbmNpZGVudFRvcG9sb2d5LFxuICBzZXRSZXNvbHZlQ29pbmNpZGVudFRvcG9sb2d5LFxuICBzZXRSZXNvbHZlQ29pbmNpZGVudFRvcG9sb2d5UG9seWdvbk9mZnNldEZhY2VzLFxuICBzZXRSZXNvbHZlQ29pbmNpZGVudFRvcG9sb2d5VG9EZWZhdWx0LFxuICBzZXRSZXNvbHZlQ29pbmNpZGVudFRvcG9sb2d5VG9PZmYsXG4gIHNldFJlc29sdmVDb2luY2lkZW50VG9wb2xvZ3lUb1BvbHlnb25PZmZzZXQsXG59O1xuIiwiaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB2dGtBYnN0cmFjdE1hcHBlcjNEIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL0Fic3RyYWN0TWFwcGVyM0QnO1xuaW1wb3J0IHZ0a0RhdGFBcnJheSBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9EYXRhQXJyYXknO1xuaW1wb3J0IHZ0a0ltYWdlRGF0YSBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0ltYWdlRGF0YSc7XG5pbXBvcnQgdnRrTG9va3VwVGFibGUgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvTG9va3VwVGFibGUnO1xuaW1wb3J0ICogYXMgdnRrTWF0aCBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9NYXRoJztcbmltcG9ydCB2dGtTY2FsYXJzVG9Db2xvcnMgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvU2NhbGFyc1RvQ29sb3JzL0NvbnN0YW50cyc7IC8vIE5lZWQgdG8gZ28gaW5zaWRlIENvbnN0YW50cyBvdGhlcndpc2UgZGVwZW5kZW5jeSBsb29wXG5cbmltcG9ydCBDb2luY2lkZW50VG9wb2xvZ3lIZWxwZXIgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvTWFwcGVyL0NvaW5jaWRlbnRUb3BvbG9neUhlbHBlcic7XG5pbXBvcnQgQ29uc3RhbnRzIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL01hcHBlci9Db25zdGFudHMnO1xuXG5jb25zdCB7IHN0YXRpY09mZnNldEFQSSwgb3RoZXJTdGF0aWNNZXRob2RzIH0gPSBDb2luY2lkZW50VG9wb2xvZ3lIZWxwZXI7XG5cbmNvbnN0IHsgQ29sb3JNb2RlLCBTY2FsYXJNb2RlLCBHZXRBcnJheSB9ID0gQ29uc3RhbnRzO1xuY29uc3QgeyBWZWN0b3JNb2RlIH0gPSB2dGtTY2FsYXJzVG9Db2xvcnM7XG5jb25zdCB7IFZ0a0RhdGFUeXBlcyB9ID0gdnRrRGF0YUFycmF5O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIG5vdEltcGxlbWVudGVkKG1ldGhvZCkge1xuICByZXR1cm4gKCkgPT4gbWFjcm8udnRrRXJyb3JNYWNybyhgdnRrTWFwcGVyOjoke21ldGhvZH0gLSBOT1QgSU1QTEVNRU5URURgKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrTWFwcGVyIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrTWFwcGVyKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrTWFwcGVyJyk7XG5cbiAgcHVibGljQVBJLmdldEJvdW5kcyA9ICgpID0+IHtcbiAgICBjb25zdCBpbnB1dCA9IHB1YmxpY0FQSS5nZXRJbnB1dERhdGEoKTtcbiAgICBpZiAoIWlucHV0KSB7XG4gICAgICBtb2RlbC5ib3VuZHMgPSB2dGtNYXRoLmNyZWF0ZVVuaW5pdGlhbGl6ZWRCb3VuZHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFtb2RlbC5zdGF0aWMpIHtcbiAgICAgICAgcHVibGljQVBJLnVwZGF0ZSgpO1xuICAgICAgfVxuICAgICAgbW9kZWwuYm91bmRzID0gaW5wdXQuZ2V0Qm91bmRzKCk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbC5ib3VuZHM7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldEZvcmNlQ29tcGlsZU9ubHkgPSAodikgPT4ge1xuICAgIG1vZGVsLmZvcmNlQ29tcGlsZU9ubHkgPSB2O1xuICAgIC8vIG1ha2Ugc3VyZSB3ZSBkbyBOT1QgY2FsbCBtb2RpZmllZCgpXG4gIH07XG5cbiAgcHVibGljQVBJLmNyZWF0ZURlZmF1bHRMb29rdXBUYWJsZSA9ICgpID0+IHtcbiAgICBtb2RlbC5sb29rdXBUYWJsZSA9IHZ0a0xvb2t1cFRhYmxlLm5ld0luc3RhbmNlKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLmdldENvbG9yTW9kZUFzU3RyaW5nID0gKCkgPT5cbiAgICBtYWNyby5lbnVtVG9TdHJpbmcoQ29sb3JNb2RlLCBtb2RlbC5jb2xvck1vZGUpO1xuXG4gIHB1YmxpY0FQSS5zZXRDb2xvck1vZGVUb0RlZmF1bHQgPSAoKSA9PiBwdWJsaWNBUEkuc2V0Q29sb3JNb2RlKDApO1xuICBwdWJsaWNBUEkuc2V0Q29sb3JNb2RlVG9NYXBTY2FsYXJzID0gKCkgPT4gcHVibGljQVBJLnNldENvbG9yTW9kZSgxKTtcbiAgcHVibGljQVBJLnNldENvbG9yTW9kZVRvRGlyZWN0U2NhbGFycyA9ICgpID0+IHB1YmxpY0FQSS5zZXRDb2xvck1vZGUoMik7XG5cbiAgcHVibGljQVBJLmdldFNjYWxhck1vZGVBc1N0cmluZyA9ICgpID0+XG4gICAgbWFjcm8uZW51bVRvU3RyaW5nKFNjYWxhck1vZGUsIG1vZGVsLnNjYWxhck1vZGUpO1xuXG4gIHB1YmxpY0FQSS5zZXRTY2FsYXJNb2RlVG9EZWZhdWx0ID0gKCkgPT4gcHVibGljQVBJLnNldFNjYWxhck1vZGUoMCk7XG4gIHB1YmxpY0FQSS5zZXRTY2FsYXJNb2RlVG9Vc2VQb2ludERhdGEgPSAoKSA9PiBwdWJsaWNBUEkuc2V0U2NhbGFyTW9kZSgxKTtcbiAgcHVibGljQVBJLnNldFNjYWxhck1vZGVUb1VzZUNlbGxEYXRhID0gKCkgPT4gcHVibGljQVBJLnNldFNjYWxhck1vZGUoMik7XG4gIHB1YmxpY0FQSS5zZXRTY2FsYXJNb2RlVG9Vc2VQb2ludEZpZWxkRGF0YSA9ICgpID0+IHB1YmxpY0FQSS5zZXRTY2FsYXJNb2RlKDMpO1xuICBwdWJsaWNBUEkuc2V0U2NhbGFyTW9kZVRvVXNlQ2VsbEZpZWxkRGF0YSA9ICgpID0+IHB1YmxpY0FQSS5zZXRTY2FsYXJNb2RlKDQpO1xuICBwdWJsaWNBUEkuc2V0U2NhbGFyTW9kZVRvVXNlRmllbGREYXRhID0gKCkgPT4gcHVibGljQVBJLnNldFNjYWxhck1vZGUoNSk7XG5cbiAgcHVibGljQVBJLmdldEFic3RyYWN0U2NhbGFycyA9IChcbiAgICBpbnB1dCxcbiAgICBzY2FsYXJNb2RlLFxuICAgIGFycmF5QWNjZXNzTW9kZSxcbiAgICBhcnJheUlkLFxuICAgIGFycmF5TmFtZVxuICApID0+IHtcbiAgICAvLyBtYWtlIHN1cmUgd2UgaGF2ZSBhbiBpbnB1dFxuICAgIGlmICghaW5wdXQgfHwgIW1vZGVsLnNjYWxhclZpc2liaWxpdHkpIHtcbiAgICAgIHJldHVybiB7IHNjYWxhcnM6IG51bGwsIGNlbGxGTGFnOiBmYWxzZSB9O1xuICAgIH1cblxuICAgIGxldCBzY2FsYXJzID0gbnVsbDtcbiAgICBsZXQgY2VsbEZsYWcgPSBmYWxzZTtcblxuICAgIC8vIGdldCBhbmQgc2NhbGFyIGRhdGEgYWNjb3JkaW5nIHRvIHNjYWxhciBtb2RlXG4gICAgaWYgKHNjYWxhck1vZGUgPT09IFNjYWxhck1vZGUuREVGQVVMVCkge1xuICAgICAgc2NhbGFycyA9IGlucHV0LmdldFBvaW50RGF0YSgpLmdldFNjYWxhcnMoKTtcbiAgICAgIGlmICghc2NhbGFycykge1xuICAgICAgICBzY2FsYXJzID0gaW5wdXQuZ2V0Q2VsbERhdGEoKS5nZXRTY2FsYXJzKCk7XG4gICAgICAgIGNlbGxGbGFnID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjYWxhck1vZGUgPT09IFNjYWxhck1vZGUuVVNFX1BPSU5UX0RBVEEpIHtcbiAgICAgIHNjYWxhcnMgPSBpbnB1dC5nZXRQb2ludERhdGEoKS5nZXRTY2FsYXJzKCk7XG4gICAgfSBlbHNlIGlmIChzY2FsYXJNb2RlID09PSBTY2FsYXJNb2RlLlVTRV9DRUxMX0RBVEEpIHtcbiAgICAgIHNjYWxhcnMgPSBpbnB1dC5nZXRDZWxsRGF0YSgpLmdldFNjYWxhcnMoKTtcbiAgICAgIGNlbGxGbGFnID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHNjYWxhck1vZGUgPT09IFNjYWxhck1vZGUuVVNFX1BPSU5UX0ZJRUxEX0RBVEEpIHtcbiAgICAgIGNvbnN0IHBkID0gaW5wdXQuZ2V0UG9pbnREYXRhKCk7XG4gICAgICBpZiAoYXJyYXlBY2Nlc3NNb2RlID09PSBHZXRBcnJheS5CWV9JRCkge1xuICAgICAgICBzY2FsYXJzID0gcGQuZ2V0QXJyYXlCeUluZGV4KGFycmF5SWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGFycyA9IHBkLmdldEFycmF5QnlOYW1lKGFycmF5TmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY2FsYXJNb2RlID09PSBTY2FsYXJNb2RlLlVTRV9DRUxMX0ZJRUxEX0RBVEEpIHtcbiAgICAgIGNvbnN0IGNkID0gaW5wdXQuZ2V0Q2VsbERhdGEoKTtcbiAgICAgIGNlbGxGbGFnID0gdHJ1ZTtcbiAgICAgIGlmIChhcnJheUFjY2Vzc01vZGUgPT09IEdldEFycmF5LkJZX0lEKSB7XG4gICAgICAgIHNjYWxhcnMgPSBjZC5nZXRBcnJheUJ5SW5kZXgoYXJyYXlJZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsYXJzID0gY2QuZ2V0QXJyYXlCeU5hbWUoYXJyYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjYWxhck1vZGUgPT09IFNjYWxhck1vZGUuVVNFX0ZJRUxEX0RBVEEpIHtcbiAgICAgIGNvbnN0IGZkID0gaW5wdXQuZ2V0RmllbGREYXRhKCk7XG4gICAgICBpZiAoYXJyYXlBY2Nlc3NNb2RlID09PSBHZXRBcnJheS5CWV9JRCkge1xuICAgICAgICBzY2FsYXJzID0gZmQuZ2V0QXJyYXlCeUluZGV4KGFycmF5SWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGFycyA9IGZkLmdldEFycmF5QnlOYW1lKGFycmF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgc2NhbGFycywgY2VsbEZsYWcgfTtcbiAgfTtcblxuICBwdWJsaWNBUEkubWFwU2NhbGFycyA9IChpbnB1dCwgYWxwaGEpID0+IHtcbiAgICBjb25zdCBzY2FsYXJzID0gcHVibGljQVBJLmdldEFic3RyYWN0U2NhbGFycyhcbiAgICAgIGlucHV0LFxuICAgICAgbW9kZWwuc2NhbGFyTW9kZSxcbiAgICAgIG1vZGVsLmFycmF5QWNjZXNzTW9kZSxcbiAgICAgIG1vZGVsLmFycmF5SWQsXG4gICAgICBtb2RlbC5jb2xvckJ5QXJyYXlOYW1lXG4gICAgKS5zY2FsYXJzO1xuXG4gICAgaWYgKCFzY2FsYXJzKSB7XG4gICAgICBtb2RlbC5jb2xvckNvb3JkaW5hdGVzID0gbnVsbDtcbiAgICAgIG1vZGVsLmNvbG9yVGV4dHVyZU1hcCA9IG51bGw7XG4gICAgICBtb2RlbC5jb2xvck1hcENvbG9ycyA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFtb2RlbC51c2VMb29rdXBUYWJsZVNjYWxhclJhbmdlKSB7XG4gICAgICBwdWJsaWNBUElcbiAgICAgICAgLmdldExvb2t1cFRhYmxlKClcbiAgICAgICAgLnNldFJhbmdlKG1vZGVsLnNjYWxhclJhbmdlWzBdLCBtb2RlbC5zY2FsYXJSYW5nZVsxXSk7XG4gICAgfVxuXG4gICAgLy8gRGVjaWRlIGJldHdlZW4gdGV4dHVyZSBjb2xvciBvciB2ZXJ0ZXggY29sb3IuXG4gICAgLy8gQ2VsbCBkYXRhIGFsd2F5cyB1c2VzIHZlcnRleCBjb2xvci5cbiAgICAvLyBPbmx5IHBvaW50IGRhdGEgY2FuIHVzZSBib3RoIHRleHR1cmUgYW5kIHZlcnRleCBjb2xvcmluZy5cbiAgICBpZiAocHVibGljQVBJLmNhblVzZVRleHR1cmVNYXBGb3JDb2xvcmluZyhpbnB1dCkpIHtcbiAgICAgIHB1YmxpY0FQSS5tYXBTY2FsYXJzVG9UZXh0dXJlKHNjYWxhcnMsIGFscGhhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtb2RlbC5jb2xvckNvb3JkaW5hdGVzID0gbnVsbDtcbiAgICBtb2RlbC5jb2xvclRleHR1cmVNYXAgPSBudWxsO1xuXG4gICAgY29uc3QgbHV0ID0gcHVibGljQVBJLmdldExvb2t1cFRhYmxlKCk7XG4gICAgaWYgKGx1dCkge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGxvb2t1cCB0YWJsZSBpcyBidWlsdFxuICAgICAgbHV0LmJ1aWxkKCk7XG4gICAgICBtb2RlbC5jb2xvck1hcENvbG9ycyA9IGx1dC5tYXBTY2FsYXJzKHNjYWxhcnMsIG1vZGVsLmNvbG9yTW9kZSwgLTEpO1xuICAgIH1cbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5zY2FsYXJUb1RleHR1cmVDb29yZGluYXRlID0gKFxuICAgIHNjYWxhclZhbHVlLCAvLyBJbnB1dCBzY2FsYXJcbiAgICByYW5nZU1pbiwgLy8gcmFuZ2VbMF1cbiAgICBpbnZSYW5nZVdpZHRoXG4gICkgPT4ge1xuICAgIC8vIDEvKHJhbmdlWzFdLXJhbmdlWzBdKVxuICAgIGxldCB0ZXhDb29yZFMgPSAwLjU7IC8vIFNjYWxhciB2YWx1ZSBpcyBhcmJpdHJhcnkgd2hlbiBOYU5cbiAgICBsZXQgdGV4Q29vcmRUID0gMS4wOyAvLyAxLjAgaW4gdCBjb29yZGluYXRlIG1lYW5zIE5hTlxuICAgIGlmICghdnRrTWF0aC5pc05hbihzY2FsYXJWYWx1ZSkpIHtcbiAgICAgIC8vIDAuMCBpbiB0IGNvb3JkaW5hdGUgbWVhbnMgbm90IE5hTi4gIFNvIHdoeSBhbSBJIHNldHRpbmcgaXQgdG8gMC40OT9cbiAgICAgIC8vIEJlY2F1c2Ugd2hlbiB5b3UgYXJlIG1hcHBpbmcgc2NhbGFycyBhbmQgeW91IGhhdmUgYSBOYU4gYWRqYWNlbnQgdG9cbiAgICAgIC8vIGFueXRoaW5nIGVsc2UsIHRoZSBpbnRlcnBvbGF0aW9uIGV2ZXJ5d2hlcmUgc2hvdWxkIGJlIE5hTi4gIFRodXMsIElcbiAgICAgIC8vIHdhbnQgdGhlIE5hTiBjb2xvciBldmVyeXdoZXJlIGV4Y2VwdCByaWdodCBvbiB0aGUgbm9uLU5hTiBuZWlnaGJvcnMuXG4gICAgICAvLyBUbyBzaW11bGF0ZSB0aGlzLCBJIHNldCB0aGUgdCBjb29yZCBmb3IgdGhlIHJlYWwgbnVtYmVycyBjbG9zZSB0b1xuICAgICAgLy8gdGhlIHRocmVzaG9sZCBzbyB0aGF0IHRoZSBpbnRlcnBvbGF0aW9uIGFsbW9zdCBpbW1lZGlhdGVseSBsb29rcyB1cFxuICAgICAgLy8gdGhlIE5hTiB2YWx1ZS5cbiAgICAgIHRleENvb3JkVCA9IDAuNDk7XG5cbiAgICAgIHRleENvb3JkUyA9IChzY2FsYXJWYWx1ZSAtIHJhbmdlTWluKSAqIGludlJhbmdlV2lkdGg7XG5cbiAgICAgIC8vIFNvbWUgaW1wbGVtZW50YXRpb25zIGFwcGFyZW50bHkgZG9uJ3QgaGFuZGxlIHJlbGF0aXZlbHkgbGFyZ2VcbiAgICAgIC8vIG51bWJlcnMgKGNvbXBhcmVkIHRvIHRoZSByYW5nZSBbMC4wLCAxLjBdKSB2ZXJ5IHdlbGwuIEluIGZhY3QsXG4gICAgICAvLyB2YWx1ZXMgYWJvdmUgMTEyMi4wZiBhcHBlYXIgdG8gY2F1c2UgdGV4dHVyZSB3cmFwLWFyb3VuZCBvblxuICAgICAgLy8gc29tZSBzeXN0ZW1zIGV2ZW4gd2hlbiBlZGdlIGNsYW1waW5nIGlzIGVuYWJsZWQuIFdoeSAxMTIyLjBmPyBJXG4gICAgICAvLyBkb24ndCBrbm93LiBGb3Igc2FmZXR5LCB3ZSdsbCBjbGFtcCBhdCArLy0gMTAwMC4gVGhpcyB3aWxsXG4gICAgICAvLyByZXN1bHQgaW4gaW5jb3JyZWN0IGltYWdlcyB3aGVuIHRoZSB0ZXh0dXJlIHZhbHVlIHNob3VsZCBiZVxuICAgICAgLy8gYWJvdmUgb3IgYmVsb3cgMTAwMCwgYnV0IEkgZG9uJ3QgaGF2ZSBhIGJldHRlciBzb2x1dGlvbi5cbiAgICAgIGlmICh0ZXhDb29yZFMgPiAxMDAwLjApIHtcbiAgICAgICAgdGV4Q29vcmRTID0gMTAwMC4wO1xuICAgICAgfSBlbHNlIGlmICh0ZXhDb29yZFMgPCAtMTAwMC4wKSB7XG4gICAgICAgIHRleENvb3JkUyA9IC0xMDAwLjA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHRleENvb3JkUywgdGV4Q29vcmRUIH07XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuY3JlYXRlQ29sb3JUZXh0dXJlQ29vcmRpbmF0ZXMgPSAoXG4gICAgaW5wdXQsXG4gICAgb3V0cHV0LFxuICAgIG51bVNjYWxhcnMsXG4gICAgbnVtQ29tcHMsXG4gICAgY29tcG9uZW50LFxuICAgIHJhbmdlLFxuICAgIHRhYmxlUmFuZ2UsXG4gICAgdGFibGVOdW1iZXJPZkNvbG9ycyxcbiAgICB1c2VMb2dTY2FsZVxuICApID0+IHtcbiAgICAvLyBXZSBoYXZlIHRvIGNoYW5nZSB0aGUgcmFuZ2UgdXNlZCBmb3IgY29tcHV0aW5nIHRleHR1cmVcbiAgICAvLyBjb29yZGluYXRlcyBzbGlnaHRseSB0byBhY2NvbW1vZGF0ZSB0aGUgc3BlY2lhbCBhYm92ZS0gYW5kXG4gICAgLy8gYmVsb3ctcmFuZ2UgY29sb3JzIHRoYXQgYXJlIHRoZSBmaXJzdCBhbmQgbGFzdCB0ZXhlbHMsXG4gICAgLy8gcmVzcGVjdGl2ZWx5LlxuICAgIGNvbnN0IHNjYWxhclRleGVsV2lkdGggPSAocmFuZ2VbMV0gLSByYW5nZVswXSkgLyB0YWJsZU51bWJlck9mQ29sb3JzO1xuXG4gICAgY29uc3QgcGFkZGVkUmFuZ2UgPSBbXTtcbiAgICBwYWRkZWRSYW5nZVswXSA9IHJhbmdlWzBdIC0gc2NhbGFyVGV4ZWxXaWR0aDtcbiAgICBwYWRkZWRSYW5nZVsxXSA9IHJhbmdlWzFdICsgc2NhbGFyVGV4ZWxXaWR0aDtcbiAgICBjb25zdCBpbnZSYW5nZVdpZHRoID0gMS4wIC8gKHBhZGRlZFJhbmdlWzFdIC0gcGFkZGVkUmFuZ2VbMF0pO1xuXG4gICAgY29uc3Qgb3V0cHV0ViA9IG91dHB1dC5nZXREYXRhKCk7XG4gICAgY29uc3QgaW5wdXRWID0gaW5wdXQuZ2V0RGF0YSgpO1xuXG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBsZXQgb3V0cHV0Q291bnQgPSAwO1xuICAgIGlmIChjb21wb25lbnQgPCAwIHx8IGNvbXBvbmVudCA+PSBudW1Db21wcykge1xuICAgICAgZm9yIChsZXQgc2NhbGFySWR4ID0gMDsgc2NhbGFySWR4IDwgbnVtU2NhbGFyczsgKytzY2FsYXJJZHgpIHtcbiAgICAgICAgbGV0IHN1bSA9IDA7XG4gICAgICAgIGZvciAobGV0IGNvbXBJZHggPSAwOyBjb21wSWR4IDwgbnVtQ29tcHM7ICsrY29tcElkeCkge1xuICAgICAgICAgIHN1bSArPSBpbnB1dFZbY291bnRdICogaW5wdXRWW2NvdW50XTtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYWduaXR1ZGUgPSBNYXRoLnNxcnQoc3VtKTtcbiAgICAgICAgaWYgKHVzZUxvZ1NjYWxlKSB7XG4gICAgICAgICAgbWFnbml0dWRlID0gdnRrTG9va3VwVGFibGUuYXBwbHlMb2dTY2FsZShcbiAgICAgICAgICAgIG1hZ25pdHVkZSxcbiAgICAgICAgICAgIHRhYmxlUmFuZ2UsXG4gICAgICAgICAgICByYW5nZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0cyA9IHB1YmxpY0FQSS5zY2FsYXJUb1RleHR1cmVDb29yZGluYXRlKFxuICAgICAgICAgIG1hZ25pdHVkZSxcbiAgICAgICAgICBwYWRkZWRSYW5nZVswXSxcbiAgICAgICAgICBpbnZSYW5nZVdpZHRoXG4gICAgICAgICk7XG4gICAgICAgIG91dHB1dFZbb3V0cHV0Q291bnRdID0gb3V0cHV0cy50ZXhDb29yZFM7XG4gICAgICAgIG91dHB1dFZbb3V0cHV0Q291bnQgKyAxXSA9IG91dHB1dHMudGV4Q29vcmRUO1xuICAgICAgICBvdXRwdXRDb3VudCArPSAyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCArPSBjb21wb25lbnQ7XG4gICAgICBmb3IgKGxldCBzY2FsYXJJZHggPSAwOyBzY2FsYXJJZHggPCBudW1TY2FsYXJzOyArK3NjYWxhcklkeCkge1xuICAgICAgICBsZXQgaW5wdXRWYWx1ZSA9IGlucHV0Vltjb3VudF07XG4gICAgICAgIGlmICh1c2VMb2dTY2FsZSkge1xuICAgICAgICAgIGlucHV0VmFsdWUgPSB2dGtMb29rdXBUYWJsZS5hcHBseUxvZ1NjYWxlKFxuICAgICAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgICAgIHRhYmxlUmFuZ2UsXG4gICAgICAgICAgICByYW5nZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0cyA9IHB1YmxpY0FQSS5zY2FsYXJUb1RleHR1cmVDb29yZGluYXRlKFxuICAgICAgICAgIGlucHV0VmFsdWUsXG4gICAgICAgICAgcGFkZGVkUmFuZ2VbMF0sXG4gICAgICAgICAgaW52UmFuZ2VXaWR0aFxuICAgICAgICApO1xuICAgICAgICBvdXRwdXRWW291dHB1dENvdW50XSA9IG91dHB1dHMudGV4Q29vcmRTO1xuICAgICAgICBvdXRwdXRWW291dHB1dENvdW50ICsgMV0gPSBvdXRwdXRzLnRleENvb3JkVDtcbiAgICAgICAgb3V0cHV0Q291bnQgKz0gMjtcbiAgICAgICAgY291bnQgKz0gbnVtQ29tcHM7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5tYXBTY2FsYXJzVG9UZXh0dXJlID0gKHNjYWxhcnMsIGFscGhhKSA9PiB7XG4gICAgY29uc3QgcmFuZ2UgPSBtb2RlbC5sb29rdXBUYWJsZS5nZXRSYW5nZSgpO1xuICAgIGNvbnN0IHVzZUxvZ1NjYWxlID0gbW9kZWwubG9va3VwVGFibGUudXNpbmdMb2dTY2FsZSgpO1xuICAgIGlmICh1c2VMb2dTY2FsZSkge1xuICAgICAgLy8gY29udmVydCByYW5nZSB0byBsb2cuXG4gICAgICB2dGtMb29rdXBUYWJsZS5nZXRMb2dSYW5nZShyYW5nZSwgcmFuZ2UpO1xuICAgIH1cblxuICAgIGNvbnN0IG9yaWdBbHBoYSA9IG1vZGVsLmxvb2t1cFRhYmxlLmdldEFscGhhKCk7XG5cbiAgICAvLyBHZXQgcmlkIG9mIHZlcnRleCBjb2xvciBhcnJheS4gIE9ubHkgdGV4dHVyZSBvciB2ZXJ0ZXggY29sb3JpbmdcbiAgICAvLyBjYW4gYmUgYWN0aXZlIGF0IG9uZSB0aW1lLiAgVGhlIGV4aXN0ZW5jZSBvZiB0aGUgYXJyYXkgaXMgdGhlXG4gICAgLy8gc2lnbmFsIHRvIHVzZSB0aGF0IHRlY2huaXF1ZS5cbiAgICBtb2RlbC5jb2xvck1hcENvbG9ycyA9IG51bGw7XG5cbiAgICAvLyBJZiB0aGUgbG9va3VwIHRhYmxlIGhhcyBjaGFuZ2VkLCB0aGVuIHJlY3JlYXRlIHRoZSBjb2xvciB0ZXh0dXJlIG1hcC5cbiAgICAvLyBTZXQgYSBuZXcgbG9va3VwIHRhYmxlIGNoYW5nZXMgdGhpcy0+TVRpbWUuXG4gICAgaWYgKFxuICAgICAgbW9kZWwuY29sb3JUZXh0dXJlTWFwID09IG51bGwgfHxcbiAgICAgIHB1YmxpY0FQSS5nZXRNVGltZSgpID4gbW9kZWwuY29sb3JUZXh0dXJlTWFwLmdldE1UaW1lKCkgfHxcbiAgICAgIG1vZGVsLmxvb2t1cFRhYmxlLmdldE1UaW1lKCkgPiBtb2RlbC5jb2xvclRleHR1cmVNYXAuZ2V0TVRpbWUoKSB8fFxuICAgICAgbW9kZWwubG9va3VwVGFibGUuZ2V0QWxwaGEoKSAhPT0gYWxwaGFcbiAgICApIHtcbiAgICAgIG1vZGVsLmxvb2t1cFRhYmxlLnNldEFscGhhKGFscGhhKTtcbiAgICAgIG1vZGVsLmNvbG9yVGV4dHVyZU1hcCA9IG51bGw7XG5cbiAgICAgIC8vIEdldCB0aGUgdGV4dHVyZSBtYXAgZnJvbSB0aGUgbG9va3VwIHRhYmxlLlxuICAgICAgLy8gQ3JlYXRlIGEgZHVtbXkgcmFtcCBvZiBzY2FsYXJzLlxuICAgICAgLy8gSW4gdGhlIGZ1dHVyZSwgd2UgY291bGQgZXh0ZW5kIHZ0a1NjYWxhcnNUb0NvbG9ycy5cbiAgICAgIG1vZGVsLmxvb2t1cFRhYmxlLmJ1aWxkKCk7XG4gICAgICBsZXQgbnVtYmVyT2ZDb2xvcnMgPSBtb2RlbC5sb29rdXBUYWJsZS5nZXROdW1iZXJPZkF2YWlsYWJsZUNvbG9ycygpO1xuICAgICAgaWYgKG51bWJlck9mQ29sb3JzID4gNDA5NCkge1xuICAgICAgICBudW1iZXJPZkNvbG9ycyA9IDQwOTQ7XG4gICAgICB9XG4gICAgICBudW1iZXJPZkNvbG9ycyArPSAyO1xuICAgICAgY29uc3QgayA9IChyYW5nZVsxXSAtIHJhbmdlWzBdKSAvIChudW1iZXJPZkNvbG9ycyAtIDEgLSAyKTtcblxuICAgICAgY29uc3QgbmV3QXJyYXkgPSBuZXcgRmxvYXQ2NEFycmF5KG51bWJlck9mQ29sb3JzICogMik7XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDb2xvcnM7ICsraSkge1xuICAgICAgICBuZXdBcnJheVtpXSA9IHJhbmdlWzBdICsgaSAqIGsgLSBrOyAvLyBtaW51cyBrIHRvIHN0YXJ0IGF0IGJlbG93IHJhbmdlIGNvbG9yXG4gICAgICAgIGlmICh1c2VMb2dTY2FsZSkge1xuICAgICAgICAgIG5ld0FycmF5W2ldID0gMTAuMCAqKiBuZXdBcnJheVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRGltZW5zaW9uIG9uIE5hTi5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDb2xvcnM7ICsraSkge1xuICAgICAgICBuZXdBcnJheVtpICsgbnVtYmVyT2ZDb2xvcnNdID0gTmFOO1xuICAgICAgfVxuXG4gICAgICBtb2RlbC5jb2xvclRleHR1cmVNYXAgPSB2dGtJbWFnZURhdGEubmV3SW5zdGFuY2UoKTtcbiAgICAgIG1vZGVsLmNvbG9yVGV4dHVyZU1hcC5zZXRFeHRlbnQoMCwgbnVtYmVyT2ZDb2xvcnMgLSAxLCAwLCAxLCAwLCAwKTtcblxuICAgICAgY29uc3QgdG1wID0gdnRrRGF0YUFycmF5Lm5ld0luc3RhbmNlKHtcbiAgICAgICAgbnVtYmVyT2ZDb21wb25lbnRzOiAxLFxuICAgICAgICB2YWx1ZXM6IG5ld0FycmF5LFxuICAgICAgfSk7XG5cbiAgICAgIG1vZGVsLmNvbG9yVGV4dHVyZU1hcFxuICAgICAgICAuZ2V0UG9pbnREYXRhKClcbiAgICAgICAgLnNldFNjYWxhcnMobW9kZWwubG9va3VwVGFibGUubWFwU2NhbGFycyh0bXAsIG1vZGVsLmNvbG9yTW9kZSwgMCkpO1xuICAgICAgbW9kZWwubG9va3VwVGFibGUuc2V0QWxwaGEob3JpZ0FscGhhKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbmV3IGNvb3JkaW5hdGVzIGlmIG5lY2Vzc2FyeS5cbiAgICAvLyBOZWVkIHRvIGNvbXBhcmUgbG9va3VwIHRhYmxlIGluIGNhc2UgdGhlIHJhbmdlIGhhcyBjaGFuZ2VkLlxuICAgIGlmIChcbiAgICAgICFtb2RlbC5jb2xvckNvb3JkaW5hdGVzIHx8XG4gICAgICBwdWJsaWNBUEkuZ2V0TVRpbWUoKSA+IG1vZGVsLmNvbG9yQ29vcmRpbmF0ZXMuZ2V0TVRpbWUoKSB8fFxuICAgICAgcHVibGljQVBJLmdldElucHV0RGF0YSgwKS5nZXRNVGltZSgpID5cbiAgICAgICAgbW9kZWwuY29sb3JDb29yZGluYXRlcy5nZXRNVGltZSgpIHx8XG4gICAgICBtb2RlbC5sb29rdXBUYWJsZS5nZXRNVGltZSgpID4gbW9kZWwuY29sb3JDb29yZGluYXRlcy5nZXRNVGltZSgpXG4gICAgKSB7XG4gICAgICAvLyBHZXQgcmlkIG9mIG9sZCBjb2xvcnNcbiAgICAgIG1vZGVsLmNvbG9yQ29vcmRpbmF0ZXMgPSBudWxsO1xuXG4gICAgICAvLyBOb3cgY3JlYXRlIHRoZSBjb2xvciB0ZXh0dXJlIGNvb3JkaW5hdGVzLlxuICAgICAgY29uc3QgbnVtQ29tcHMgPSBzY2FsYXJzLmdldE51bWJlck9mQ29tcG9uZW50cygpO1xuICAgICAgY29uc3QgbnVtID0gc2NhbGFycy5nZXROdW1iZXJPZlR1cGxlcygpO1xuXG4gICAgICAvLyBjb25zdCBmQXJyYXkgPSBuZXcgRmxvYXRBcnJheShudW0gKiAyKTtcbiAgICAgIG1vZGVsLmNvbG9yQ29vcmRpbmF0ZXMgPSB2dGtEYXRhQXJyYXkubmV3SW5zdGFuY2Uoe1xuICAgICAgICBudW1iZXJPZkNvbXBvbmVudHM6IDIsXG4gICAgICAgIHZhbHVlczogbmV3IEZsb2F0MzJBcnJheShudW0gKiAyKSxcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgc2NhbGFyQ29tcG9uZW50ID0gbW9kZWwubG9va3VwVGFibGUuZ2V0VmVjdG9yQ29tcG9uZW50KCk7XG4gICAgICAvLyBBbHRob3VnaCBJIGxpa2UgdGhlIGZlYXR1cmUgb2YgYXBwbHlpbmcgbWFnbml0dWRlIHRvIHNpbmdsZSBjb21wb25lbnRcbiAgICAgIC8vIHNjYWxhcnMsIGl0IGlzIG5vdCBob3cgdGhlIG9sZCBNYXBTY2FsYXJzIGZvciB2ZXJ0ZXggY29sb3Jpbmcgd29ya3MuXG4gICAgICBpZiAoXG4gICAgICAgIG1vZGVsLmxvb2t1cFRhYmxlLmdldFZlY3Rvck1vZGUoKSA9PT0gVmVjdG9yTW9kZS5NQUdOSVRVREUgJiZcbiAgICAgICAgc2NhbGFycy5nZXROdW1iZXJPZkNvbXBvbmVudHMoKSA+IDFcbiAgICAgICkge1xuICAgICAgICBzY2FsYXJDb21wb25lbnQgPSAtMTtcbiAgICAgIH1cblxuICAgICAgcHVibGljQVBJLmNyZWF0ZUNvbG9yVGV4dHVyZUNvb3JkaW5hdGVzKFxuICAgICAgICBzY2FsYXJzLFxuICAgICAgICBtb2RlbC5jb2xvckNvb3JkaW5hdGVzLFxuICAgICAgICBudW0sXG4gICAgICAgIG51bUNvbXBzLFxuICAgICAgICBzY2FsYXJDb21wb25lbnQsXG4gICAgICAgIHJhbmdlLFxuICAgICAgICBtb2RlbC5sb29rdXBUYWJsZS5nZXRSYW5nZSgpLFxuICAgICAgICBtb2RlbC5jb2xvclRleHR1cmVNYXAuZ2V0UG9pbnREYXRhKCkuZ2V0U2NhbGFycygpLmdldE51bWJlck9mVHVwbGVzKCkgL1xuICAgICAgICAgIDIgLVxuICAgICAgICAgIDIsXG4gICAgICAgIHVzZUxvZ1NjYWxlXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0SXNPcGFxdWUgPSAoKSA9PiB7XG4gICAgY29uc3QgbHV0ID0gcHVibGljQVBJLmdldExvb2t1cFRhYmxlKCk7XG4gICAgaWYgKGx1dCkge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGxvb2t1cCB0YWJsZSBpcyBidWlsdFxuICAgICAgbHV0LmJ1aWxkKCk7XG4gICAgICByZXR1cm4gbHV0LmlzT3BhcXVlKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5jYW5Vc2VUZXh0dXJlTWFwRm9yQ29sb3JpbmcgPSAoaW5wdXQpID0+IHtcbiAgICBpZiAoIW1vZGVsLmludGVycG9sYXRlU2NhbGFyc0JlZm9yZU1hcHBpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gdXNlciBkb2Vzbid0IHdhbnQgdXMgdG8gdXNlIHRleHR1cmUgbWFwcyBhdCBhbGwuXG4gICAgfVxuXG4gICAgLy8gaW5kZXggY29sb3IgZG9lcyBub3QgdXNlIHRleHR1cmVzXG4gICAgaWYgKG1vZGVsLmxvb2t1cFRhYmxlICYmIG1vZGVsLmxvb2t1cFRhYmxlLmdldEluZGV4ZWRMb29rdXAoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGdhc1Jlc3VsdCA9IHB1YmxpY0FQSS5nZXRBYnN0cmFjdFNjYWxhcnMoXG4gICAgICBpbnB1dCxcbiAgICAgIG1vZGVsLnNjYWxhck1vZGUsXG4gICAgICBtb2RlbC5hcnJheUFjY2Vzc01vZGUsXG4gICAgICBtb2RlbC5hcnJheUlkLFxuICAgICAgbW9kZWwuY29sb3JCeUFycmF5TmFtZVxuICAgICk7XG4gICAgY29uc3Qgc2NhbGFycyA9IGdhc1Jlc3VsdC5zY2FsYXJzO1xuXG4gICAgaWYgKCFzY2FsYXJzKSB7XG4gICAgICAvLyBubyBzY2FsYXJzIG9uIHRoaXMgZGF0YXNldCwgd2UgZG9uJ3QgY2FyZSBpZiB0ZXh0dXJlIGlzIHVzZWQgYXQgYWxsLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChnYXNSZXN1bHQuY2VsbEZsYWcpIHtcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gY2VsbCBkYXRhIGNvbG9ycywgZG9uJ3QgdXNlIHRleHR1cmVzLlxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIChtb2RlbC5jb2xvck1vZGUgPT09IENvbG9yTW9kZS5ERUZBVUxUICYmXG4gICAgICAgIHNjYWxhcnMuZ2V0RGF0YVR5cGUoKSA9PT0gVnRrRGF0YVR5cGVzLlVOU0lHTkVEX0NIQVIpIHx8XG4gICAgICBtb2RlbC5jb2xvck1vZGUgPT09IENvbG9yTW9kZS5ESVJFQ1RfU0NBTEFSU1xuICAgICkge1xuICAgICAgLy8gRG9uJ3QgdXNlIHRleHR1cmUgaXMgZGlyZWN0IGNvbG9yaW5nIHVzaW5nIFJHQiB1bnNpZ25lZCBjaGFycyBpc1xuICAgICAgLy8gcmVxdWVzdGVkLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5jbGVhckNvbG9yQXJyYXlzID0gKCkgPT4ge1xuICAgIG1vZGVsLmNvbG9yTWFwQ29sb3JzID0gbnVsbDtcbiAgICBtb2RlbC5jb2xvckNvb3JkaW5hdGVzID0gbnVsbDtcbiAgICBtb2RlbC5jb2xvclRleHR1cmVNYXAgPSBudWxsO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRMb29rdXBUYWJsZSA9ICgpID0+IHtcbiAgICBpZiAoIW1vZGVsLmxvb2t1cFRhYmxlKSB7XG4gICAgICBwdWJsaWNBUEkuY3JlYXRlRGVmYXVsdExvb2t1cFRhYmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbC5sb29rdXBUYWJsZTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0TVRpbWUgPSAoKSA9PiB7XG4gICAgbGV0IG10ID0gbW9kZWwubXRpbWU7XG4gICAgaWYgKG1vZGVsLmxvb2t1cFRhYmxlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0aW1lID0gbW9kZWwubG9va3VwVGFibGUuZ2V0TVRpbWUoKTtcbiAgICAgIG10ID0gdGltZSA+IG10ID8gdGltZSA6IG10O1xuICAgIH1cbiAgICByZXR1cm4gbXQ7XG4gIH07XG5cbiAgcHVibGljQVBJLmdldFByaW1pdGl2ZUNvdW50ID0gKCkgPT4ge1xuICAgIGNvbnN0IGlucHV0ID0gcHVibGljQVBJLmdldElucHV0RGF0YSgpO1xuICAgIGNvbnN0IHBjb3VudCA9IHtcbiAgICAgIHBvaW50czogaW5wdXQuZ2V0UG9pbnRzKCkuZ2V0TnVtYmVyT2ZWYWx1ZXMoKSAvIDMsXG4gICAgICB2ZXJ0czpcbiAgICAgICAgaW5wdXQuZ2V0VmVydHMoKS5nZXROdW1iZXJPZlZhbHVlcygpIC1cbiAgICAgICAgaW5wdXQuZ2V0VmVydHMoKS5nZXROdW1iZXJPZkNlbGxzKCksXG4gICAgICBsaW5lczpcbiAgICAgICAgaW5wdXQuZ2V0TGluZXMoKS5nZXROdW1iZXJPZlZhbHVlcygpIC1cbiAgICAgICAgMiAqIGlucHV0LmdldExpbmVzKCkuZ2V0TnVtYmVyT2ZDZWxscygpLFxuICAgICAgdHJpYW5nbGVzOlxuICAgICAgICBpbnB1dC5nZXRQb2x5cygpLmdldE51bWJlck9mVmFsdWVzKCkgLVxuICAgICAgICAzICogaW5wdXQuZ2V0TGluZXMoKS5nZXROdW1iZXJPZkNlbGxzKCksXG4gICAgfTtcbiAgICByZXR1cm4gcGNvdW50O1xuICB9O1xuXG4gIHB1YmxpY0FQSS5hY3F1aXJlSW52ZXJ0aWJsZUxvb2t1cFRhYmxlID0gbm90SW1wbGVtZW50ZWQoXG4gICAgJ0FjcXVpcmVJbnZlcnRpYmxlTG9va3VwVGFibGUnXG4gICk7XG4gIHB1YmxpY0FQSS52YWx1ZVRvQ29sb3IgPSBub3RJbXBsZW1lbnRlZCgnVmFsdWVUb0NvbG9yJyk7XG4gIHB1YmxpY0FQSS5jb2xvclRvVmFsdWUgPSBub3RJbXBsZW1lbnRlZCgnQ29sb3JUb1ZhbHVlJyk7XG4gIHB1YmxpY0FQSS51c2VJbnZlcnRpYmxlQ29sb3JGb3IgPSBub3RJbXBsZW1lbnRlZCgnVXNlSW52ZXJ0aWJsZUNvbG9yRm9yJyk7XG4gIHB1YmxpY0FQSS5jbGVhckludmVydGlibGVDb2xvciA9IG5vdEltcGxlbWVudGVkKCdDbGVhckludmVydGlibGVDb2xvcicpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgY29sb3JNYXBDb2xvcnM6IG51bGwsIC8vIFNhbWUgYXMgdGhpcy0+Q29sb3JzXG5cbiAgc3RhdGljOiBmYWxzZSxcbiAgbG9va3VwVGFibGU6IG51bGwsXG5cbiAgc2NhbGFyVmlzaWJpbGl0eTogdHJ1ZSxcbiAgc2NhbGFyUmFuZ2U6IFswLCAxXSxcbiAgdXNlTG9va3VwVGFibGVTY2FsYXJSYW5nZTogZmFsc2UsXG5cbiAgY29sb3JNb2RlOiAwLFxuICBzY2FsYXJNb2RlOiAwLFxuICBhcnJheUFjY2Vzc01vZGU6IDEsIC8vIEJ5X05BTUVcblxuICByZW5kZXJUaW1lOiAwLFxuXG4gIGNvbG9yQnlBcnJheU5hbWU6IG51bGwsXG5cbiAgZmllbGREYXRhVHVwbGVJZDogLTEsXG5cbiAgaW50ZXJwb2xhdGVTY2FsYXJzQmVmb3JlTWFwcGluZzogZmFsc2UsXG4gIGNvbG9yQ29vcmRpbmF0ZXM6IG51bGwsXG4gIGNvbG9yVGV4dHVyZU1hcDogbnVsbCxcblxuICBmb3JjZUNvbXBpbGVPbmx5OiAwLFxuXG4gIHVzZUludmVydGlibGVDb2xvcnM6IGZhbHNlLFxuICBpbnZlcnRpYmxlU2NhbGFyczogbnVsbCxcblxuICB2aWV3U3BlY2lmaWNQcm9wZXJ0aWVzOiBudWxsLFxuXG4gIGN1c3RvbVNoYWRlckF0dHJpYnV0ZXM6IFtdLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gSW5oZXJpdGFuY2VcbiAgdnRrQWJzdHJhY3RNYXBwZXIzRC5leHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyk7XG5cbiAgbWFjcm8uZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIFtcbiAgICAnY29sb3JDb29yZGluYXRlcycsXG4gICAgJ2NvbG9yTWFwQ29sb3JzJyxcbiAgICAnY29sb3JUZXh0dXJlTWFwJyxcbiAgXSk7XG4gIG1hY3JvLnNldEdldChwdWJsaWNBUEksIG1vZGVsLCBbXG4gICAgJ2NvbG9yQnlBcnJheU5hbWUnLFxuICAgICdhcnJheUFjY2Vzc01vZGUnLFxuICAgICdjb2xvck1vZGUnLFxuICAgICdmaWVsZERhdGFUdXBsZUlkJyxcbiAgICAnaW50ZXJwb2xhdGVTY2FsYXJzQmVmb3JlTWFwcGluZycsXG4gICAgJ2xvb2t1cFRhYmxlJyxcbiAgICAncmVuZGVyVGltZScsXG4gICAgJ3NjYWxhck1vZGUnLFxuICAgICdzY2FsYXJWaXNpYmlsaXR5JyxcbiAgICAnc3RhdGljJyxcbiAgICAndXNlTG9va3VwVGFibGVTY2FsYXJSYW5nZScsXG4gICAgJ3ZpZXdTcGVjaWZpY1Byb3BlcnRpZXMnLFxuICAgICdjdXN0b21TaGFkZXJBdHRyaWJ1dGVzJywgLy8gcG9pbnQgZGF0YSBhcnJheSBuYW1lcyB0aGF0IHdpbGwgYmUgdHJhbnNmZXJyZWQgdG8gdGhlIFZCT1xuICBdKTtcbiAgbWFjcm8uc2V0R2V0QXJyYXkocHVibGljQVBJLCBtb2RlbCwgWydzY2FsYXJSYW5nZSddLCAyKTtcblxuICBpZiAoIW1vZGVsLnZpZXdTcGVjaWZpY1Byb3BlcnRpZXMpIHtcbiAgICBtb2RlbC52aWV3U3BlY2lmaWNQcm9wZXJ0aWVzID0ge307XG4gIH1cblxuICBDb2luY2lkZW50VG9wb2xvZ3lIZWxwZXIuaW1wbGVtZW50Q29pbmNpZGVudFRvcG9sb2d5TWV0aG9kcyhwdWJsaWNBUEksIG1vZGVsKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICB2dGtNYXBwZXIocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrTWFwcGVyJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuZXdJbnN0YW5jZSxcbiAgZXh0ZW5kLFxuICAuLi5zdGF0aWNPZmZzZXRBUEksXG4gIC4uLm90aGVyU3RhdGljTWV0aG9kcyxcbiAgLi4uQ29uc3RhbnRzLFxufTtcbiIsImltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5cbmZ1bmN0aW9uIG5vdEltcGxlbWVudGVkKG1ldGhvZCkge1xuICByZXR1cm4gKCkgPT4gbWFjcm8udnRrRXJyb3JNYWNybyhgdnRrUHJvcDo6JHttZXRob2R9IC0gTk9UIElNUExFTUVOVEVEYCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a1Byb3AgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtQcm9wKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrUHJvcCcpO1xuXG4gIHB1YmxpY0FQSS5nZXRNVGltZSA9ICgpID0+IHtcbiAgICBsZXQgbTEgPSBtb2RlbC5tdGltZTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbW9kZWwudGV4dHVyZXMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICBjb25zdCBtMiA9IG1vZGVsLnRleHR1cmVzW2luZGV4XS5nZXRNVGltZSgpO1xuICAgICAgaWYgKG0yID4gbTEpIHtcbiAgICAgICAgbTEgPSBtMjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG0xO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXROZXN0ZWRQcm9wcyA9ICgpID0+IG51bGw7XG4gIHB1YmxpY0FQSS5nZXRBY3RvcnMgPSAoKSA9PiBbXTtcbiAgcHVibGljQVBJLmdldEFjdG9yczJEID0gKCkgPT4gW107XG4gIHB1YmxpY0FQSS5nZXRWb2x1bWVzID0gKCkgPT4gW107XG5cbiAgcHVibGljQVBJLnBpY2sgPSBub3RJbXBsZW1lbnRlZCgncGljaycpO1xuICBwdWJsaWNBUEkuaGFzS2V5ID0gbm90SW1wbGVtZW50ZWQoJ2hhc0tleScpO1xuXG4gIHB1YmxpY0FQSS5nZXRSZWRyYXdNVGltZSA9ICgpID0+IG1vZGVsLm10aW1lO1xuXG4gIHB1YmxpY0FQSS5zZXRFc3RpbWF0ZWRSZW5kZXJUaW1lID0gKHQpID0+IHtcbiAgICBtb2RlbC5lc3RpbWF0ZWRSZW5kZXJUaW1lID0gdDtcbiAgICBtb2RlbC5zYXZlZEVzdGltYXRlZFJlbmRlclRpbWUgPSB0O1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZXN0b3JlRXN0aW1hdGVkUmVuZGVyVGltZSA9ICgpID0+IHtcbiAgICBtb2RlbC5lc3RpbWF0ZWRSZW5kZXJUaW1lID0gbW9kZWwuc2F2ZWRFc3RpbWF0ZWRSZW5kZXJUaW1lO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5hZGRFc3RpbWF0ZWRSZW5kZXJUaW1lID0gKHQpID0+IHtcbiAgICBtb2RlbC5lc3RpbWF0ZWRSZW5kZXJUaW1lICs9IHQ7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldEFsbG9jYXRlZFJlbmRlclRpbWUgPSAodCkgPT4ge1xuICAgIG1vZGVsLmFsbG9jYXRlZFJlbmRlclRpbWUgPSB0O1xuICAgIG1vZGVsLnNhdmVkRXN0aW1hdGVkUmVuZGVyVGltZSA9IG1vZGVsLmVzdGltYXRlZFJlbmRlclRpbWU7XG4gICAgbW9kZWwuZXN0aW1hdGVkUmVuZGVyVGltZSA9IDA7XG4gIH07XG5cbiAgcHVibGljQVBJLmdldFN1cHBvcnRzU2VsZWN0aW9uID0gKCkgPT4gZmFsc2U7XG5cbiAgcHVibGljQVBJLmdldFRleHR1cmVzID0gKCkgPT4gbW9kZWwudGV4dHVyZXM7XG4gIHB1YmxpY0FQSS5oYXNUZXh0dXJlID0gKHRleHR1cmUpID0+IG1vZGVsLnRleHR1cmVzLmluZGV4T2YodGV4dHVyZSkgIT09IC0xO1xuICBwdWJsaWNBUEkuYWRkVGV4dHVyZSA9ICh0ZXh0dXJlKSA9PiB7XG4gICAgaWYgKHRleHR1cmUgJiYgIXB1YmxpY0FQSS5oYXNUZXh0dXJlKHRleHR1cmUpKSB7XG4gICAgICBtb2RlbC50ZXh0dXJlcyA9IG1vZGVsLnRleHR1cmVzLmNvbmNhdCh0ZXh0dXJlKTtcbiAgICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkucmVtb3ZlVGV4dHVyZSA9ICh0ZXh0dXJlKSA9PiB7XG4gICAgY29uc3QgbmV3VGV4dHVyZUxpc3QgPSBtb2RlbC50ZXh0dXJlcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0gIT09IHRleHR1cmUpO1xuICAgIGlmIChtb2RlbC50ZXh0dXJlcy5sZW5ndGggIT09IG5ld1RleHR1cmVMaXN0Lmxlbmd0aCkge1xuICAgICAgbW9kZWwudGV4dHVyZXMgPSBuZXdUZXh0dXJlTGlzdDtcbiAgICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkucmVtb3ZlQWxsVGV4dHVyZXMgPSAoKSA9PiB7XG4gICAgbW9kZWwudGV4dHVyZXMgPSBbXTtcbiAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIHZpc2liaWxpdHk6IHRydWUsXG4gIHBpY2thYmxlOiB0cnVlLFxuICBkcmFnYWJsZTogdHJ1ZSxcbiAgdXNlQm91bmRzOiB0cnVlLFxuICBhbGxvY2F0ZWRSZW5kZXJUaW1lOiAxMCxcbiAgZXN0aW1hdGVkUmVuZGVyVGltZTogMCxcbiAgc2F2ZWRFc3RpbWF0ZWRSZW5kZXJUaW1lOiAwLFxuICByZW5kZXJUaW1lTXVsdGlwbGllcjogMSxcbiAgcGF0aHM6IG51bGwsXG4gIHRleHR1cmVzOiBbXSxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEJ1aWxkIFZUSyBBUElcbiAgbWFjcm8ub2JqKHB1YmxpY0FQSSwgbW9kZWwpO1xuICBtYWNyby5nZXQocHVibGljQVBJLCBtb2RlbCwgWydlc3RpbWF0ZWRSZW5kZXJUaW1lJywgJ2FsbG9jYXRlZFJlbmRlclRpbWUnXSk7XG4gIG1hY3JvLnNldEdldChwdWJsaWNBUEksIG1vZGVsLCBbXG4gICAgJ3Zpc2liaWxpdHknLFxuICAgICdwaWNrYWJsZScsXG4gICAgJ2RyYWdhYmxlJyxcbiAgICAndXNlQm91bmRzJyxcbiAgICAncmVuZGVyVGltZU11bHRpcGxpZXInLFxuICBdKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICB2dGtQcm9wKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a1Byb3AnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImltcG9ydCB7IHZlYzMsIHF1YXQsIG1hdDQgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5pbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0IHZ0a0JvdW5kaW5nQm94IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvQm91bmRpbmdCb3gnO1xuaW1wb3J0ICogYXMgdnRrTWF0aCBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9NYXRoJztcbmltcG9ydCB2dGtQcm9wIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL1Byb3AnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtQcm9wM0QgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtQcm9wM0QocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtQcm9wM0QnKTtcblxuICBwdWJsaWNBUEkuYWRkUG9zaXRpb24gPSAoZGVsdGFYWVopID0+IHtcbiAgICBtb2RlbC5wb3NpdGlvbiA9IG1vZGVsLnBvc2l0aW9uLm1hcChcbiAgICAgICh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlICsgZGVsdGFYWVpbaW5kZXhdXG4gICAgKTtcbiAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0T3JpZW50YXRpb25XWFlaID0gKCkgPT4ge1xuICAgIGNvbnN0IHEgPSBxdWF0LmNyZWF0ZSgpO1xuICAgIG1hdDQuZ2V0Um90YXRpb24ocSwgbW9kZWwucm90YXRpb24pO1xuICAgIGNvbnN0IG9heGlzID0gdmVjMy5jcmVhdGUoKTtcbiAgICBjb25zdCB3ID0gcXVhdC5nZXRBeGlzQW5nbGUob2F4aXMsIHEpO1xuICAgIHJldHVybiBbdnRrTWF0aC5kZWdyZWVzRnJvbVJhZGlhbnModyksIG9heGlzWzBdLCBvYXhpc1sxXSwgb2F4aXNbMl1dO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yb3RhdGVYID0gKHZhbCkgPT4ge1xuICAgIGlmICh2YWwgPT09IDAuMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXQ0LnJvdGF0ZVgoXG4gICAgICBtb2RlbC5yb3RhdGlvbixcbiAgICAgIG1vZGVsLnJvdGF0aW9uLFxuICAgICAgdnRrTWF0aC5yYWRpYW5zRnJvbURlZ3JlZXModmFsKVxuICAgICk7XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLnJvdGF0ZVkgPSAodmFsKSA9PiB7XG4gICAgaWYgKHZhbCA9PT0gMC4wKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdDQucm90YXRlWShcbiAgICAgIG1vZGVsLnJvdGF0aW9uLFxuICAgICAgbW9kZWwucm90YXRpb24sXG4gICAgICB2dGtNYXRoLnJhZGlhbnNGcm9tRGVncmVlcyh2YWwpXG4gICAgKTtcbiAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgfTtcblxuICBwdWJsaWNBUEkucm90YXRlWiA9ICh2YWwpID0+IHtcbiAgICBpZiAodmFsID09PSAwLjApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWF0NC5yb3RhdGVaKFxuICAgICAgbW9kZWwucm90YXRpb24sXG4gICAgICBtb2RlbC5yb3RhdGlvbixcbiAgICAgIHZ0a01hdGgucmFkaWFuc0Zyb21EZWdyZWVzKHZhbClcbiAgICApO1xuICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yb3RhdGVXWFlaID0gKGRlZ3JlZXMsIHgsIHksIHopID0+IHtcbiAgICBpZiAoZGVncmVlcyA9PT0gMC4wIHx8ICh4ID09PSAwLjAgJiYgeSA9PT0gMC4wICYmIHogPT09IDAuMCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IHRvIHJhZGlhbnNcbiAgICBjb25zdCBhbmdsZSA9IHZ0a01hdGgucmFkaWFuc0Zyb21EZWdyZWVzKGRlZ3JlZXMpO1xuXG4gICAgY29uc3QgcSA9IHF1YXQuY3JlYXRlKCk7XG4gICAgcXVhdC5zZXRBeGlzQW5nbGUocSwgW3gsIHksIHpdLCBhbmdsZSk7XG5cbiAgICBjb25zdCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAgICBtYXQ0LmZyb21RdWF0KHF1YXRNYXQsIHEpO1xuICAgIG1hdDQubXVsdGlwbHkobW9kZWwucm90YXRpb24sIG1vZGVsLnJvdGF0aW9uLCBxdWF0TWF0KTtcbiAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0T3JpZW50YXRpb24gPSAoeCwgeSwgeikgPT4ge1xuICAgIGlmIChcbiAgICAgIHggPT09IG1vZGVsLm9yaWVudGF0aW9uWzBdICYmXG4gICAgICB5ID09PSBtb2RlbC5vcmllbnRhdGlvblsxXSAmJlxuICAgICAgeiA9PT0gbW9kZWwub3JpZW50YXRpb25bMl1cbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW9kZWwub3JpZW50YXRpb24gPSBbeCwgeSwgel07XG4gICAgbWF0NC5pZGVudGl0eShtb2RlbC5yb3RhdGlvbik7XG4gICAgcHVibGljQVBJLnJvdGF0ZVooeik7XG4gICAgcHVibGljQVBJLnJvdGF0ZVgoeCk7XG4gICAgcHVibGljQVBJLnJvdGF0ZVkoeSk7XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldFVzZXJNYXRyaXggPSAobWF0cml4KSA9PiB7XG4gICAgbWF0NC5jb3B5KG1vZGVsLnVzZXJNYXRyaXgsIG1hdHJpeCk7XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLmdldE1hdHJpeCA9ICgpID0+IHtcbiAgICBwdWJsaWNBUEkuY29tcHV0ZU1hdHJpeCgpO1xuICAgIHJldHVybiBtb2RlbC5tYXRyaXg7XG4gIH07XG5cbiAgcHVibGljQVBJLmNvbXB1dGVNYXRyaXggPSAoKSA9PiB7XG4gICAgLy8gY2hlY2sgd2hldGhlciBvciBub3QgbmVlZCB0byByZWJ1aWxkIHRoZSBtYXRyaXhcbiAgICBpZiAocHVibGljQVBJLmdldE1UaW1lKCkgPiBtb2RlbC5tYXRyaXhNVGltZS5nZXRNVGltZSgpKSB7XG4gICAgICBtYXQ0LmlkZW50aXR5KG1vZGVsLm1hdHJpeCk7XG4gICAgICBpZiAobW9kZWwudXNlck1hdHJpeCkge1xuICAgICAgICBtYXQ0Lm11bHRpcGx5KG1vZGVsLm1hdHJpeCwgbW9kZWwubWF0cml4LCBtb2RlbC51c2VyTWF0cml4KTtcbiAgICAgIH1cbiAgICAgIG1hdDQudHJhbnNsYXRlKG1vZGVsLm1hdHJpeCwgbW9kZWwubWF0cml4LCBtb2RlbC5vcmlnaW4pO1xuICAgICAgbWF0NC50cmFuc2xhdGUobW9kZWwubWF0cml4LCBtb2RlbC5tYXRyaXgsIG1vZGVsLnBvc2l0aW9uKTtcbiAgICAgIG1hdDQubXVsdGlwbHkobW9kZWwubWF0cml4LCBtb2RlbC5tYXRyaXgsIG1vZGVsLnJvdGF0aW9uKTtcbiAgICAgIG1hdDQuc2NhbGUobW9kZWwubWF0cml4LCBtb2RlbC5tYXRyaXgsIG1vZGVsLnNjYWxlKTtcbiAgICAgIG1hdDQudHJhbnNsYXRlKG1vZGVsLm1hdHJpeCwgbW9kZWwubWF0cml4LCBbXG4gICAgICAgIC1tb2RlbC5vcmlnaW5bMF0sXG4gICAgICAgIC1tb2RlbC5vcmlnaW5bMV0sXG4gICAgICAgIC1tb2RlbC5vcmlnaW5bMl0sXG4gICAgICBdKTtcbiAgICAgIG1hdDQudHJhbnNwb3NlKG1vZGVsLm1hdHJpeCwgbW9kZWwubWF0cml4KTtcblxuICAgICAgLy8gY2hlY2sgZm9yIGlkZW50aXR5XG4gICAgICBtb2RlbC5pc0lkZW50aXR5ID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgKytqKSB7XG4gICAgICAgICAgaWYgKChpID09PSBqID8gMS4wIDogMC4wKSAhPT0gbW9kZWwubWF0cml4W2kgKyBqICogNF0pIHtcbiAgICAgICAgICAgIG1vZGVsLmlzSWRlbnRpdHkgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1vZGVsLm1hdHJpeE1UaW1lLm1vZGlmaWVkKCk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRDZW50ZXIgPSAoKSA9PiB2dGtCb3VuZGluZ0JveC5nZXRDZW50ZXIobW9kZWwuYm91bmRzKTtcbiAgcHVibGljQVBJLmdldExlbmd0aCA9ICgpID0+IHZ0a0JvdW5kaW5nQm94LmdldExlbmd0aChtb2RlbC5ib3VuZHMpO1xuICBwdWJsaWNBUEkuZ2V0WFJhbmdlID0gKCkgPT4gdnRrQm91bmRpbmdCb3guZ2V0WFJhbmdlKG1vZGVsLmJvdW5kcyk7XG4gIHB1YmxpY0FQSS5nZXRZUmFuZ2UgPSAoKSA9PiB2dGtCb3VuZGluZ0JveC5nZXRZUmFuZ2UobW9kZWwuYm91bmRzKTtcbiAgcHVibGljQVBJLmdldFpSYW5nZSA9ICgpID0+IHZ0a0JvdW5kaW5nQm94LmdldFpSYW5nZShtb2RlbC5ib3VuZHMpO1xuXG4gIHB1YmxpY0FQSS5nZXRVc2VyTWF0cml4ID0gKCkgPT4gbW9kZWwudXNlck1hdHJpeDtcblxuICBmdW5jdGlvbiB1cGRhdGVJZGVudGl0eUZsYWcoKSB7XG4gICAgcHVibGljQVBJLmNvbXB1dGVNYXRyaXgoKTtcbiAgfVxuXG4gIHB1YmxpY0FQSS5vbk1vZGlmaWVkKHVwZGF0ZUlkZW50aXR5RmxhZyk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBvcmlnaW46IFswLCAwLCAwXSxcbiAgcG9zaXRpb246IFswLCAwLCAwXSxcbiAgb3JpZW50YXRpb246IFswLCAwLCAwXSxcbiAgcm90YXRpb246IG51bGwsXG4gIHNjYWxlOiBbMSwgMSwgMV0sXG4gIGJvdW5kczogWzEsIC0xLCAxLCAtMSwgMSwgLTFdLFxuXG4gIHVzZXJNYXRyaXg6IG51bGwsXG4gIHVzZXJNYXRyaXhNVGltZTogbnVsbCxcblxuICBjYWNoZWRQcm9wM0Q6IG51bGwsXG4gIGlzSWRlbnRpdHk6IHRydWUsXG4gIG1hdHJpeE1UaW1lOiBudWxsLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gSW5oZXJpdGFuY2VcbiAgdnRrUHJvcC5leHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyk7XG5cbiAgbW9kZWwubWF0cml4TVRpbWUgPSB7fTtcbiAgbWFjcm8ub2JqKG1vZGVsLm1hdHJpeE1UaW1lKTtcblxuICAvLyBCdWlsZCBWVEsgQVBJXG4gIG1hY3JvLmdldChwdWJsaWNBUEksIG1vZGVsLCBbJ2JvdW5kcycsICdpc0lkZW50aXR5J10pO1xuICBtYWNyby5nZXRBcnJheShwdWJsaWNBUEksIG1vZGVsLCBbJ29yaWVudGF0aW9uJ10pO1xuICBtYWNyby5zZXRHZXRBcnJheShwdWJsaWNBUEksIG1vZGVsLCBbJ29yaWdpbicsICdwb3NpdGlvbicsICdzY2FsZSddLCAzKTtcblxuICAvLyBPYmplY3QgaW50ZXJuYWwgaW5zdGFuY2VcbiAgbW9kZWwubWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgbW9kZWwucm90YXRpb24gPSBtYXQ0LmNyZWF0ZSgpO1xuICBtb2RlbC51c2VyTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgbW9kZWwudHJhbnNmb3JtID0gbnVsbDsgLy8gRklYTUVcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICB2dGtQcm9wM0QocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrUHJvcDNEJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kIH07XG4iLCJleHBvcnQgY29uc3QgU2hhZGluZyA9IHtcbiAgRkxBVDogMCxcbiAgR09VUkFVRDogMSxcbiAgUEhPTkc6IDIsXG59O1xuXG5leHBvcnQgY29uc3QgUmVwcmVzZW50YXRpb24gPSB7XG4gIFBPSU5UUzogMCxcbiAgV0lSRUZSQU1FOiAxLFxuICBTVVJGQUNFOiAyLFxufTtcblxuZXhwb3J0IGNvbnN0IEludGVycG9sYXRpb24gPSBTaGFkaW5nO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFNoYWRpbmcsXG4gIFJlcHJlc2VudGF0aW9uLFxuICBJbnRlcnBvbGF0aW9uLFxufTtcbiIsImltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgQ29uc3RhbnRzIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL1Byb3BlcnR5L0NvbnN0YW50cyc7XG5cbmNvbnN0IHsgUmVwcmVzZW50YXRpb24sIEludGVycG9sYXRpb24gfSA9IENvbnN0YW50cztcblxuZnVuY3Rpb24gbm90SW1wbGVtZW50ZWQobWV0aG9kKSB7XG4gIHJldHVybiAoKSA9PiBtYWNyby52dGtFcnJvck1hY3JvKGB2dGtQcm9wZXJ0eTo6JHttZXRob2R9IC0gTk9UIElNUExFTUVOVEVEYCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a1Byb3BlcnR5IG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrUHJvcGVydHkocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtQcm9wZXJ0eScpO1xuXG4gIHB1YmxpY0FQSS5zZXRDb2xvciA9IChyLCBnLCBiKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocikpIHtcbiAgICAgIGlmIChcbiAgICAgICAgbW9kZWwuY29sb3JbMF0gIT09IHJbMF0gfHxcbiAgICAgICAgbW9kZWwuY29sb3JbMV0gIT09IHJbMV0gfHxcbiAgICAgICAgbW9kZWwuY29sb3JbMl0gIT09IHJbMl1cbiAgICAgICkge1xuICAgICAgICBtb2RlbC5jb2xvclswXSA9IHJbMF07XG4gICAgICAgIG1vZGVsLmNvbG9yWzFdID0gclsxXTtcbiAgICAgICAgbW9kZWwuY29sb3JbMl0gPSByWzJdO1xuICAgICAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgbW9kZWwuY29sb3JbMF0gIT09IHIgfHxcbiAgICAgIG1vZGVsLmNvbG9yWzFdICE9PSBnIHx8XG4gICAgICBtb2RlbC5jb2xvclsyXSAhPT0gYlxuICAgICkge1xuICAgICAgbW9kZWwuY29sb3JbMF0gPSByO1xuICAgICAgbW9kZWwuY29sb3JbMV0gPSBnO1xuICAgICAgbW9kZWwuY29sb3JbMl0gPSBiO1xuICAgICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gICAgfVxuXG4gICAgcHVibGljQVBJLnNldERpZmZ1c2VDb2xvcihtb2RlbC5jb2xvcik7XG4gICAgcHVibGljQVBJLnNldEFtYmllbnRDb2xvcihtb2RlbC5jb2xvcik7XG4gICAgcHVibGljQVBJLnNldFNwZWN1bGFyQ29sb3IobW9kZWwuY29sb3IpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5jb21wdXRlQ29tcG9zaXRlQ29sb3IgPSBub3RJbXBsZW1lbnRlZCgnQ29tcHV0ZUNvbXBvc2l0ZUNvbG9yJyk7XG4gIHB1YmxpY0FQSS5nZXRDb2xvciA9ICgpID0+IHtcbiAgICAvLyBJbmxpbmUgY29tcHV0ZUNvbXBvc2l0ZUNvbG9yXG4gICAgbGV0IG5vcm0gPSAwLjA7XG4gICAgaWYgKG1vZGVsLmFtYmllbnQgKyBtb2RlbC5kaWZmdXNlICsgbW9kZWwuc3BlY3VsYXIgPiAwKSB7XG4gICAgICBub3JtID0gMS4wIC8gKG1vZGVsLmFtYmllbnQgKyBtb2RlbC5kaWZmdXNlICsgbW9kZWwuc3BlY3VsYXIpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICBtb2RlbC5jb2xvcltpXSA9XG4gICAgICAgIG5vcm0gKlxuICAgICAgICAobW9kZWwuYW1iaWVudCAqIG1vZGVsLmFtYmllbnRDb2xvcltpXSArXG4gICAgICAgICAgbW9kZWwuZGlmZnVzZSAqIG1vZGVsLmRpZmZ1c2VDb2xvcltpXSArXG4gICAgICAgICAgbW9kZWwuc3BlY3VsYXIgKiBtb2RlbC5zcGVjdWxhckNvbG9yW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW10uY29uY2F0KG1vZGVsLmNvbG9yKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuYWRkU2hhZGVyVmFyaWFibGUgPSBub3RJbXBsZW1lbnRlZCgnQWRkU2hhZGVyVmFyaWFibGUnKTtcblxuICBwdWJsaWNBUEkuc2V0SW50ZXJwb2xhdGlvblRvRmxhdCA9ICgpID0+XG4gICAgcHVibGljQVBJLnNldEludGVycG9sYXRpb24oSW50ZXJwb2xhdGlvbi5GTEFUKTtcbiAgcHVibGljQVBJLnNldEludGVycG9sYXRpb25Ub0dvdXJhdWQgPSAoKSA9PlxuICAgIHB1YmxpY0FQSS5zZXRJbnRlcnBvbGF0aW9uKEludGVycG9sYXRpb24uR09VUkFVRCk7XG4gIHB1YmxpY0FQSS5zZXRJbnRlcnBvbGF0aW9uVG9QaG9uZyA9ICgpID0+XG4gICAgcHVibGljQVBJLnNldEludGVycG9sYXRpb24oSW50ZXJwb2xhdGlvbi5QSE9ORyk7XG4gIHB1YmxpY0FQSS5nZXRJbnRlcnBvbGF0aW9uQXNTdHJpbmcgPSAoKSA9PlxuICAgIG1hY3JvLmVudW1Ub1N0cmluZyhJbnRlcnBvbGF0aW9uLCBtb2RlbC5pbnRlcnBvbGF0aW9uKTtcblxuICBwdWJsaWNBUEkuc2V0UmVwcmVzZW50YXRpb25Ub1dpcmVmcmFtZSA9ICgpID0+XG4gICAgcHVibGljQVBJLnNldFJlcHJlc2VudGF0aW9uKFJlcHJlc2VudGF0aW9uLldJUkVGUkFNRSk7XG4gIHB1YmxpY0FQSS5zZXRSZXByZXNlbnRhdGlvblRvU3VyZmFjZSA9ICgpID0+XG4gICAgcHVibGljQVBJLnNldFJlcHJlc2VudGF0aW9uKFJlcHJlc2VudGF0aW9uLlNVUkZBQ0UpO1xuICBwdWJsaWNBUEkuc2V0UmVwcmVzZW50YXRpb25Ub1BvaW50cyA9ICgpID0+XG4gICAgcHVibGljQVBJLnNldFJlcHJlc2VudGF0aW9uKFJlcHJlc2VudGF0aW9uLlBPSU5UUyk7XG4gIHB1YmxpY0FQSS5nZXRSZXByZXNlbnRhdGlvbkFzU3RyaW5nID0gKCkgPT5cbiAgICBtYWNyby5lbnVtVG9TdHJpbmcoUmVwcmVzZW50YXRpb24sIG1vZGVsLnJlcHJlc2VudGF0aW9uKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIGNvbG9yOiBbMSwgMSwgMV0sXG4gIGFtYmllbnRDb2xvcjogWzEsIDEsIDFdLFxuICBkaWZmdXNlQ29sb3I6IFsxLCAxLCAxXSxcbiAgc3BlY3VsYXJDb2xvcjogWzEsIDEsIDFdLFxuICBlZGdlQ29sb3I6IFswLCAwLCAwXSxcblxuICBhbWJpZW50OiAwLFxuICBkaWZmdXNlOiAxLFxuICBzcGVjdWxhcjogMCxcbiAgc3BlY3VsYXJQb3dlcjogMSxcbiAgb3BhY2l0eTogMSxcbiAgaW50ZXJwb2xhdGlvbjogSW50ZXJwb2xhdGlvbi5HT1VSQVVELFxuICByZXByZXNlbnRhdGlvbjogUmVwcmVzZW50YXRpb24uU1VSRkFDRSxcbiAgZWRnZVZpc2liaWxpdHk6IGZhbHNlLFxuICBiYWNrZmFjZUN1bGxpbmc6IGZhbHNlLFxuICBmcm9udGZhY2VDdWxsaW5nOiBmYWxzZSxcbiAgcG9pbnRTaXplOiAxLFxuICBsaW5lV2lkdGg6IDEsXG4gIGxpZ2h0aW5nOiB0cnVlLFxuXG4gIHNoYWRpbmc6IGZhbHNlLFxuICBtYXRlcmlhbE5hbWU6IG51bGwsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBCdWlsZCBWVEsgQVBJXG4gIG1hY3JvLm9iaihwdWJsaWNBUEksIG1vZGVsKTtcblxuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgW1xuICAgICdsaWdodGluZycsXG4gICAgJ2ludGVycG9sYXRpb24nLFxuICAgICdhbWJpZW50JyxcbiAgICAnZGlmZnVzZScsXG4gICAgJ3NwZWN1bGFyJyxcbiAgICAnc3BlY3VsYXJQb3dlcicsXG4gICAgJ29wYWNpdHknLFxuICAgICdlZGdlVmlzaWJpbGl0eScsXG4gICAgJ2xpbmVXaWR0aCcsXG4gICAgJ3BvaW50U2l6ZScsXG4gICAgJ2JhY2tmYWNlQ3VsbGluZycsXG4gICAgJ2Zyb250ZmFjZUN1bGxpbmcnLFxuICAgICdyZXByZXNlbnRhdGlvbicsXG4gIF0pO1xuICBtYWNyby5zZXRHZXRBcnJheShcbiAgICBwdWJsaWNBUEksXG4gICAgbW9kZWwsXG4gICAgWydhbWJpZW50Q29sb3InLCAnc3BlY3VsYXJDb2xvcicsICdkaWZmdXNlQ29sb3InLCAnZWRnZUNvbG9yJ10sXG4gICAgM1xuICApO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIHZ0a1Byb3BlcnR5KHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a1Byb3BlcnR5Jyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kLCAuLi5Db25zdGFudHMgfTtcbiIsImltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a1JlbmRlcldpbmRvdyBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a1JlbmRlcldpbmRvdyhwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a1JlbmRlcldpbmRvdycpO1xuXG4gIC8vIEFkZCByZW5kZXJlclxuICBwdWJsaWNBUEkuYWRkUmVuZGVyZXIgPSAocmVuZGVyZXIpID0+IHtcbiAgICBpZiAocHVibGljQVBJLmhhc1JlbmRlcmVyKHJlbmRlcmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZW5kZXJlci5zZXRSZW5kZXJXaW5kb3cocHVibGljQVBJKTtcbiAgICBtb2RlbC5yZW5kZXJlcnMucHVzaChyZW5kZXJlcik7XG5cbiAgICAvLyBmb3IgKHRoaXMtPlJlbmRlcmVycy0+SW5pdFRyYXZlcnNhbChyc2l0KTtcbiAgICAvLyAgICAgIChhcmVuID0gdGhpcy0+UmVuZGVyZXJzLT5HZXROZXh0UmVuZGVyZXIocnNpdCkpOyApXG4gICAgLy8gICB7XG4gICAgLy8gICBhcmVuLT5TZXRBbGxvY2F0ZWRSZW5kZXJUaW1lXG4gICAgLy8gICAgICgxLjAvKHRoaXMtPkRlc2lyZWRVcGRhdGVSYXRlKnRoaXMtPlJlbmRlcmVycy0+R2V0TnVtYmVyT2ZJdGVtcygpKSk7XG4gICAgLy8gICB9XG5cbiAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgfTtcblxuICAvLyBSZW1vdmUgcmVuZGVyZXJcbiAgcHVibGljQVBJLnJlbW92ZVJlbmRlcmVyID0gKHJlbmRlcmVyKSA9PiB7XG4gICAgbW9kZWwucmVuZGVyZXJzID0gbW9kZWwucmVuZGVyZXJzLmZpbHRlcigocikgPT4gciAhPT0gcmVuZGVyZXIpO1xuICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5oYXNSZW5kZXJlciA9IChyZW4pID0+IG1vZGVsLnJlbmRlcmVycy5pbmRleE9mKHJlbikgIT09IC0xO1xuXG4gIC8vIEFkZCByZW5kZXJlclxuICBwdWJsaWNBUEkuYWRkVmlldyA9ICh2aWV3KSA9PiB7XG4gICAgaWYgKHB1YmxpY0FQSS5oYXNWaWV3KHZpZXcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZpZXcuc2V0UmVuZGVyYWJsZShwdWJsaWNBUEkpO1xuICAgIG1vZGVsLnZpZXdzLnB1c2godmlldyk7XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIHJlbmRlcmVyXG4gIHB1YmxpY0FQSS5yZW1vdmVWaWV3ID0gKHZpZXcpID0+IHtcbiAgICBtb2RlbC52aWV3cyA9IG1vZGVsLnZpZXdzLmZpbHRlcigocikgPT4gciAhPT0gdmlldyk7XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLmhhc1ZpZXcgPSAodmlldykgPT4gbW9kZWwudmlld3MuaW5kZXhPZih2aWV3KSAhPT0gLTE7XG5cbiAgcHVibGljQVBJLnJlbmRlciA9ICgpID0+IHtcbiAgICBpZiAobW9kZWwuaW50ZXJhY3Rvcikge1xuICAgICAgbW9kZWwuaW50ZXJhY3Rvci5yZW5kZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWwudmlld3MuZm9yRWFjaCgodmlldykgPT4gdmlldy50cmF2ZXJzZUFsbFBhc3NlcygpKTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmdldFN0YXRpc3RpY3MgPSAoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHsgcHJvcENvdW50OiAwLCBpbnZpc2libGVQcm9wQ291bnQ6IDAgfTtcbiAgICBtb2RlbC5yZW5kZXJlcnMuZm9yRWFjaCgocmVuKSA9PiB7XG4gICAgICBjb25zdCBwcm9wcyA9IHJlbi5nZXRWaWV3UHJvcHMoKTtcbiAgICAgIHByb3BzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKHByb3AuZ2V0VmlzaWJpbGl0eSgpKSB7XG4gICAgICAgICAgcmVzdWx0cy5wcm9wQ291bnQgKz0gMTtcbiAgICAgICAgICBjb25zdCBtcHIgPSBwcm9wLmdldE1hcHBlciAmJiBwcm9wLmdldE1hcHBlcigpO1xuICAgICAgICAgIGlmIChtcHIgJiYgbXByLmdldFByaW1pdGl2ZUNvdW50KSB7XG4gICAgICAgICAgICBjb25zdCBwY291bnQgPSBtcHIuZ2V0UHJpbWl0aXZlQ291bnQoKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBjb3VudCkuZm9yRWFjaCgoa2V5TmFtZSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXJlc3VsdHNba2V5TmFtZV0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzW2tleU5hbWVdID0gMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHRzW2tleU5hbWVdICs9IHBjb3VudFtrZXlOYW1lXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRzLmludmlzaWJsZVByb3BDb3VudCArPSAxO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXN1bHRzLnN0ciA9IE9iamVjdC5rZXlzKHJlc3VsdHMpXG4gICAgICAubWFwKChrZXlOYW1lKSA9PiBgJHtrZXlOYW1lfTogJHtyZXN1bHRzW2tleU5hbWVdfWApXG4gICAgICAuam9pbignXFxuJyk7XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICBwdWJsaWNBUEkuY2FwdHVyZUltYWdlcyA9IChmb3JtYXQgPSAnaW1hZ2UvcG5nJykgPT4ge1xuICAgIG1hY3JvLnNldEltbWVkaWF0ZShwdWJsaWNBUEkucmVuZGVyKTtcbiAgICByZXR1cm4gbW9kZWwudmlld3NcbiAgICAgIC5tYXAoKHZpZXcpID0+XG4gICAgICAgIHZpZXcuY2FwdHVyZU5leHRJbWFnZSA/IHZpZXcuY2FwdHVyZU5leHRJbWFnZShmb3JtYXQpIDogdW5kZWZpbmVkXG4gICAgICApXG4gICAgICAuZmlsdGVyKChpKSA9PiAhIWkpO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIHJlbmRlcmVyczogW10sXG4gIHZpZXdzOiBbXSxcbiAgaW50ZXJhY3RvcjogbnVsbCxcbiAgbmV2ZXJSZW5kZXJlZDogdHJ1ZSxcbiAgbnVtYmVyT2ZMYXllcnM6IDEsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBCdWlsZCBWVEsgQVBJXG4gIG1hY3JvLm9iaihwdWJsaWNBUEksIG1vZGVsKTtcbiAgbWFjcm8uc2V0R2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsnaW50ZXJhY3RvcicsICdudW1iZXJPZkxheWVycycsICd2aWV3cyddKTtcbiAgbWFjcm8uZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsnbmV2ZXJSZW5kZXJlZCddKTtcbiAgbWFjcm8uZ2V0QXJyYXkocHVibGljQVBJLCBtb2RlbCwgWydyZW5kZXJlcnMnXSk7XG4gIG1hY3JvLmV2ZW50KHB1YmxpY0FQSSwgbW9kZWwsICdjb21wbGV0aW9uJyk7XG5cbiAgLy8gT2JqZWN0IG1ldGhvZHNcbiAgdnRrUmVuZGVyV2luZG93KHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a1JlbmRlcldpbmRvdycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCB9O1xuIiwiZXhwb3J0IGNvbnN0IERldmljZSA9IHtcbiAgVW5rbm93bjogMCxcbiAgTGVmdENvbnRyb2xsZXI6IDEsXG4gIFJpZ2h0Q29udHJvbGxlcjogMixcbn07XG5cbmV4cG9ydCBjb25zdCBJbnB1dCA9IHtcbiAgVW5rbm93bjogMCxcbiAgVHJpZ2dlcjogMSxcbiAgVHJhY2tQYWQ6IDIsXG4gIEdyaXA6IDMsXG4gIEFwcGxpY2F0aW9uTWVudTogNCxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgRGV2aWNlLFxuICBJbnB1dCxcbn07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0ICogYXMgdnRrTWF0aCBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9NYXRoJztcblxuaW1wb3J0IENvbnN0YW50cyBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9SZW5kZXJXaW5kb3dJbnRlcmFjdG9yL0NvbnN0YW50cyc7XG5cbmNvbnN0IHsgRGV2aWNlLCBJbnB1dCB9ID0gQ29uc3RhbnRzO1xuY29uc3Qge1xuICB2dGtXYXJuaW5nTWFjcm8sXG4gIHZ0a0Vycm9yTWFjcm8sXG4gIG5vcm1hbGl6ZVdoZWVsLFxuICB2dGtPbmNlRXJyb3JNYWNybyxcbn0gPSBtYWNybztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gR2xvYmFsIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgZGV2aWNlSW5wdXRNYXAgPSB7XG4gICdPcGVuVlIgR2FtZXBhZCc6IFtcbiAgICBJbnB1dC5UcmFja1BhZCxcbiAgICBJbnB1dC5UcmlnZ2VyLFxuICAgIElucHV0LkdyaXAsXG4gICAgSW5wdXQuQXBwbGljYXRpb25NZW51LFxuICBdLFxufTtcblxuY29uc3QgaGFuZGxlZEV2ZW50cyA9IFtcbiAgJ1N0YXJ0QW5pbWF0aW9uJyxcbiAgJ0FuaW1hdGlvbicsXG4gICdFbmRBbmltYXRpb24nLFxuICAnU3RhcnRNb3VzZU1vdmUnLFxuICAnTW91c2VNb3ZlJyxcbiAgJ0VuZE1vdXNlTW92ZScsXG4gICdMZWZ0QnV0dG9uUHJlc3MnLFxuICAnTGVmdEJ1dHRvblJlbGVhc2UnLFxuICAnTWlkZGxlQnV0dG9uUHJlc3MnLFxuICAnTWlkZGxlQnV0dG9uUmVsZWFzZScsXG4gICdSaWdodEJ1dHRvblByZXNzJyxcbiAgJ1JpZ2h0QnV0dG9uUmVsZWFzZScsXG4gICdLZXlQcmVzcycsXG4gICdLZXlEb3duJyxcbiAgJ0tleVVwJyxcbiAgJ1N0YXJ0TW91c2VXaGVlbCcsXG4gICdNb3VzZVdoZWVsJyxcbiAgJ0VuZE1vdXNlV2hlZWwnLFxuICAnU3RhcnRQaW5jaCcsXG4gICdQaW5jaCcsXG4gICdFbmRQaW5jaCcsXG4gICdTdGFydFBhbicsXG4gICdQYW4nLFxuICAnRW5kUGFuJyxcbiAgJ1N0YXJ0Um90YXRlJyxcbiAgJ1JvdGF0ZScsXG4gICdFbmRSb3RhdGUnLFxuICAnQnV0dG9uM0QnLFxuICAnTW92ZTNEJyxcbiAgJ1N0YXJ0UG9pbnRlckxvY2snLFxuICAnRW5kUG9pbnRlckxvY2snLFxuICAnU3RhcnRJbnRlcmFjdGlvbkV2ZW50JyxcbiAgJ0ludGVyYWN0aW9uRXZlbnQnLFxuICAnRW5kSW50ZXJhY3Rpb25FdmVudCcsXG5dO1xuXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtSZW5kZXJXaW5kb3dJbnRlcmFjdG9yIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrUmVuZGVyV2luZG93SW50ZXJhY3RvcihwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a1JlbmRlcldpbmRvd0ludGVyYWN0b3InKTtcblxuICAvLyBJbml0aWFsaXplIGxpc3Qgb2YgcmVxdWVzdGVyc1xuICBjb25zdCBhbmltYXRpb25SZXF1ZXN0ZXJzID0gbmV3IFNldCgpO1xuXG4gIC8vIHRyYWNrIGFjdGl2ZSBldmVudCBsaXN0ZW5lcnMgdG8gaGFuZGxlIHNpbXVsdGFuZW91cyBidXR0b24gdHJhY2tpbmdcbiAgbGV0IGFjdGl2ZUxpc3RlbmVyQ291bnQgPSAwO1xuXG4gIC8vIFB1YmxpYyBBUEkgbWV0aG9kc1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuc3RhcnQgPSAoKSA9PiB7XG4gICAgLy8gTGV0IHRoZSBjb21wb3NpdGluZyBoYW5kbGUgdGhlIGV2ZW50IGxvb3AgaWYgaXQgd2FudHMgdG8uXG4gICAgLy8gaWYgKHB1YmxpY0FQSS5IYXNPYnNlcnZlcih2dGtDb21tYW5kOjpTdGFydEV2ZW50KSAmJiAhcHVibGljQVBJLkhhbmRsZUV2ZW50TG9vcCkge1xuICAgIC8vICAgcHVibGljQVBJLmludm9rZUV2ZW50KHsgdHlwZTogJ1N0YXJ0RXZlbnQnIH0pO1xuICAgIC8vICAgcmV0dXJuO1xuICAgIC8vIH1cblxuICAgIC8vIEFzIGEgY29udmVuaWVuY2UsIGluaXRpYWxpemUgaWYgd2UgYXJlbid0IGluaXRpYWxpemVkIHlldC5cbiAgICBpZiAoIW1vZGVsLmluaXRpYWxpemVkKSB7XG4gICAgICBwdWJsaWNBUEkuaW5pdGlhbGl6ZSgpO1xuICAgICAgaWYgKCFtb2RlbC5pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFBhc3MgZXhlY3V0aW9uIHRvIHRoZSBzdWJjbGFzcyB3aGljaCB3aWxsIHJ1biB0aGUgZXZlbnQgbG9vcCxcbiAgICAvLyB0aGlzIHdpbGwgbm90IHJldHVybiB1bnRpbCBUZXJtaW5hdGVBcHAgaXMgY2FsbGVkLlxuICAgIHB1YmxpY0FQSS5zdGFydEV2ZW50TG9vcCgpO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuc2V0UmVuZGVyV2luZG93ID0gKGFyZW4pID0+IHtcbiAgICB2dGtFcnJvck1hY3JvKFxuICAgICAgJ3lvdSB3YW50IHRvIGNhbGwgc2V0Vmlldyh2aWV3KSBpbnN0ZWFkIG9mIHNldFJlbmRlcldpbmRvdyBvbiBhIHZ0ay5qcyBpbnRlcmFjdG9yJ1xuICAgICk7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5zZXRJbnRlcmFjdG9yU3R5bGUgPSAoc3R5bGUpID0+IHtcbiAgICBpZiAobW9kZWwuaW50ZXJhY3RvclN0eWxlICE9PSBzdHlsZSkge1xuICAgICAgaWYgKG1vZGVsLmludGVyYWN0b3JTdHlsZSAhPSBudWxsKSB7XG4gICAgICAgIG1vZGVsLmludGVyYWN0b3JTdHlsZS5zZXRJbnRlcmFjdG9yKG51bGwpO1xuICAgICAgfVxuICAgICAgbW9kZWwuaW50ZXJhY3RvclN0eWxlID0gc3R5bGU7XG4gICAgICBpZiAobW9kZWwuaW50ZXJhY3RvclN0eWxlICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG1vZGVsLmludGVyYWN0b3JTdHlsZS5nZXRJbnRlcmFjdG9yKCkgIT09IHB1YmxpY0FQSSkge1xuICAgICAgICAgIG1vZGVsLmludGVyYWN0b3JTdHlsZS5zZXRJbnRlcmFjdG9yKHB1YmxpY0FQSSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmluaXRpYWxpemUgPSAoKSA9PiB7XG4gICAgbW9kZWwuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHB1YmxpY0FQSS5lbmFibGUoKTtcbiAgICBwdWJsaWNBUEkucmVuZGVyKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLmVuYWJsZSA9ICgpID0+IHB1YmxpY0FQSS5zZXRFbmFibGVkKHRydWUpO1xuXG4gIHB1YmxpY0FQSS5kaXNhYmxlID0gKCkgPT4gcHVibGljQVBJLnNldEVuYWJsZWQoZmFsc2UpO1xuXG4gIHB1YmxpY0FQSS5zdGFydEV2ZW50TG9vcCA9ICgpID0+IHZ0a1dhcm5pbmdNYWNybygnZW1wdHkgZXZlbnQgbG9vcCcpO1xuXG4gIGZ1bmN0aW9uIHVwZGF0ZUN1cnJlbnRSZW5kZXJlcih4LCB5KSB7XG4gICAgbW9kZWwuY3VycmVudFJlbmRlcmVyID0gcHVibGljQVBJLmZpbmRQb2tlZFJlbmRlcmVyKHgsIHkpO1xuICB9XG5cbiAgcHVibGljQVBJLmdldEN1cnJlbnRSZW5kZXJlciA9ICgpID0+IHtcbiAgICBpZiAobW9kZWwuY3VycmVudFJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gbW9kZWwuY3VycmVudFJlbmRlcmVyO1xuICAgIH1cbiAgICB1cGRhdGVDdXJyZW50UmVuZGVyZXIoMCwgMCk7XG4gICAgcmV0dXJuIG1vZGVsLmN1cnJlbnRSZW5kZXJlcjtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRTY3JlZW5FdmVudFBvc2l0aW9uRm9yKHNvdXJjZSkge1xuICAgIGNvbnN0IGJvdW5kcyA9IG1vZGVsLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBjYW52YXMgPSBtb2RlbC52aWV3LmdldENhbnZhcygpO1xuICAgIGNvbnN0IHNjYWxlWCA9IGNhbnZhcy53aWR0aCAvIGJvdW5kcy53aWR0aDtcbiAgICBjb25zdCBzY2FsZVkgPSBjYW52YXMuaGVpZ2h0IC8gYm91bmRzLmhlaWdodDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgIHg6IHNjYWxlWCAqIChzb3VyY2UuY2xpZW50WCAtIGJvdW5kcy5sZWZ0KSxcbiAgICAgIHk6IHNjYWxlWSAqIChib3VuZHMuaGVpZ2h0IC0gc291cmNlLmNsaWVudFkgKyBib3VuZHMudG9wKSxcbiAgICAgIHo6IDAsXG4gICAgfTtcbiAgICB1cGRhdGVDdXJyZW50UmVuZGVyZXIocG9zaXRpb24ueCwgcG9zaXRpb24ueSk7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VG91Y2hFdmVudFBvc2l0aW9uc0Zvcih0b3VjaGVzKSB7XG4gICAgY29uc3QgcG9zaXRpb25zID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB0b3VjaCA9IHRvdWNoZXNbaV07XG4gICAgICBwb3NpdGlvbnNbdG91Y2guaWRlbnRpZmllcl0gPSBnZXRTY3JlZW5FdmVudFBvc2l0aW9uRm9yKHRvdWNoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1vZGlmaWVyS2V5c0ZvcihldmVudCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb250cm9sS2V5OiBldmVudC5jdHJsS2V5LFxuICAgICAgYWx0S2V5OiBldmVudC5hbHRLZXksXG4gICAgICBzaGlmdEtleTogZXZlbnQuc2hpZnRLZXksXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEtleXNGb3IoZXZlbnQpIHtcbiAgICBjb25zdCBtb2RpZmllcktleXMgPSBnZXRNb2RpZmllcktleXNGb3IoZXZlbnQpO1xuICAgIGNvbnN0IGtleXMgPSB7XG4gICAgICBrZXk6IGV2ZW50LmtleSxcbiAgICAgIGtleUNvZGU6IGV2ZW50LmNoYXJDb2RlLFxuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbihrZXlzLCBtb2RpZmllcktleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gaW50ZXJhY3Rpb25SZWdpc3RyYXRpb24oYWRkTGlzdGVuZXJzLCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgcm9vdEVsbSA9IGRvY3VtZW50O1xuICAgIGNvbnN0IG1ldGhvZCA9IGFkZExpc3RlbmVycyA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgICBjb25zdCBpbnZNZXRob2QgPSBhZGRMaXN0ZW5lcnMgPyAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgOiAnYWRkRXZlbnRMaXN0ZW5lcic7XG5cbiAgICBpZiAoIWZvcmNlICYmICFhZGRMaXN0ZW5lcnMgJiYgYWN0aXZlTGlzdGVuZXJDb3VudCA+IDApIHtcbiAgICAgIC0tYWN0aXZlTGlzdGVuZXJDb3VudDtcbiAgICB9XG5cbiAgICAvLyBvbmx5IGFkZC9yZW1vdmUgbGlzdGVuZXJzIHdoZW4gdGhlcmUgYXJlIG5vIHJlZ2lzdGVyZWQgbGlzdGVuZXJzXG4gICAgaWYgKCFhY3RpdmVMaXN0ZW5lckNvdW50IHx8IGZvcmNlKSB7XG4gICAgICBhY3RpdmVMaXN0ZW5lckNvdW50ID0gMDtcblxuICAgICAgaWYgKG1vZGVsLmNvbnRhaW5lcikge1xuICAgICAgICBtb2RlbC5jb250YWluZXJbaW52TWV0aG9kXSgnbW91c2Vtb3ZlJywgcHVibGljQVBJLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICB9XG5cbiAgICAgIHJvb3RFbG1bbWV0aG9kXSgnbW91c2V1cCcsIHB1YmxpY0FQSS5oYW5kbGVNb3VzZVVwKTtcbiAgICAgIC8vIHJvb3RFbG1bbWV0aG9kXSgnbW91c2VsZWF2ZScsIHB1YmxpY0FQSS5oYW5kbGVNb3VzZVVwKTtcbiAgICAgIHJvb3RFbG1bbWV0aG9kXSgnbW91c2Vtb3ZlJywgcHVibGljQVBJLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICByb290RWxtW21ldGhvZF0oJ3RvdWNoZW5kJywgcHVibGljQVBJLmhhbmRsZVRvdWNoRW5kLCBmYWxzZSk7XG4gICAgICByb290RWxtW21ldGhvZF0oJ3RvdWNoY2FuY2VsJywgcHVibGljQVBJLmhhbmRsZVRvdWNoRW5kLCBmYWxzZSk7XG4gICAgICByb290RWxtW21ldGhvZF0oJ3RvdWNobW92ZScsIHB1YmxpY0FQSS5oYW5kbGVUb3VjaE1vdmUsIGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAoIWZvcmNlICYmIGFkZExpc3RlbmVycykge1xuICAgICAgKythY3RpdmVMaXN0ZW5lckNvdW50O1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpY0FQSS5iaW5kRXZlbnRzID0gKGNvbnRhaW5lcikgPT4ge1xuICAgIG1vZGVsLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBwcmV2ZW50RGVmYXVsdCk7XG4gICAgLy8gY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcHJldmVudERlZmF1bHQpOyAvLyBBdm9pZCBzdG9wcGluZyBldmVudCBwcm9wYWdhdGlvblxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHB1YmxpY0FQSS5oYW5kbGVXaGVlbCk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgcHVibGljQVBJLmhhbmRsZVdoZWVsKTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgcHVibGljQVBJLmhhbmRsZU1vdXNlTW92ZSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHB1YmxpY0FQSS5oYW5kbGVNb3VzZURvd24pO1xuICAgIGRvY3VtZW50XG4gICAgICAucXVlcnlTZWxlY3RvcignYm9keScpXG4gICAgICAuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBwdWJsaWNBUEkuaGFuZGxlS2V5UHJlc3MpO1xuICAgIGRvY3VtZW50XG4gICAgICAucXVlcnlTZWxlY3RvcignYm9keScpXG4gICAgICAuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHB1YmxpY0FQSS5oYW5kbGVLZXlEb3duKTtcbiAgICBkb2N1bWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKVxuICAgICAgLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgcHVibGljQVBJLmhhbmRsZUtleVVwKTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAncG9pbnRlcmxvY2tjaGFuZ2UnLFxuICAgICAgcHVibGljQVBJLmhhbmRsZVBvaW50ZXJMb2NrQ2hhbmdlXG4gICAgKTtcblxuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgcHVibGljQVBJLmhhbmRsZVRvdWNoU3RhcnQsIGZhbHNlKTtcbiAgfTtcblxuICBwdWJsaWNBUEkudW5iaW5kRXZlbnRzID0gKCkgPT4ge1xuICAgIC8vIGZvcmNlIHVuYmluZGluZyBsaXN0ZW5lcnNcbiAgICBpbnRlcmFjdGlvblJlZ2lzdHJhdGlvbihmYWxzZSwgdHJ1ZSk7XG4gICAgbW9kZWwuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NvbnRleHRtZW51JywgcHJldmVudERlZmF1bHQpO1xuICAgIC8vIG1vZGVsLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHByZXZlbnREZWZhdWx0KTsgLy8gQXZvaWQgc3RvcHBpbmcgZXZlbnQgcHJvcGFnYXRpb25cbiAgICBtb2RlbC5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBwdWJsaWNBUEkuaGFuZGxlV2hlZWwpO1xuICAgIG1vZGVsLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgJ0RPTU1vdXNlU2Nyb2xsJyxcbiAgICAgIHB1YmxpY0FQSS5oYW5kbGVXaGVlbFxuICAgICk7XG4gICAgbW9kZWwuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHB1YmxpY0FQSS5oYW5kbGVNb3VzZU1vdmUpO1xuICAgIG1vZGVsLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBwdWJsaWNBUEkuaGFuZGxlTW91c2VEb3duKTtcbiAgICBkb2N1bWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKVxuICAgICAgLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgcHVibGljQVBJLmhhbmRsZUtleVByZXNzKTtcbiAgICBkb2N1bWVudFxuICAgICAgLnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKVxuICAgICAgLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBwdWJsaWNBUEkuaGFuZGxlS2V5RG93bik7XG4gICAgZG9jdW1lbnRcbiAgICAgIC5xdWVyeVNlbGVjdG9yKCdib2R5JylcbiAgICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHB1YmxpY0FQSS5oYW5kbGVLZXlVcCk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICdwb2ludGVybG9ja2NoYW5nZScsXG4gICAgICBwdWJsaWNBUEkuaGFuZGxlUG9pbnRlckxvY2tDaGFuZ2VcbiAgICApO1xuICAgIG1vZGVsLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgcHVibGljQVBJLmhhbmRsZVRvdWNoU3RhcnRcbiAgICApO1xuICAgIG1vZGVsLmNvbnRhaW5lciA9IG51bGw7XG4gIH07XG5cbiAgcHVibGljQVBJLmhhbmRsZUtleVByZXNzID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGdldEtleXNGb3IoZXZlbnQpO1xuICAgIHB1YmxpY0FQSS5rZXlQcmVzc0V2ZW50KGRhdGEpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5oYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGdldEtleXNGb3IoZXZlbnQpO1xuICAgIHB1YmxpY0FQSS5rZXlEb3duRXZlbnQoZGF0YSk7XG4gIH07XG5cbiAgcHVibGljQVBJLmhhbmRsZUtleVVwID0gKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IGdldEtleXNGb3IoZXZlbnQpO1xuICAgIHB1YmxpY0FQSS5rZXlVcEV2ZW50KGRhdGEpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5oYW5kbGVNb3VzZURvd24gPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uID4gMikge1xuICAgICAgLy8gaWdub3JlIGV2ZW50cyBmcm9tIGV4dHJhIG1vdXNlIGJ1dHRvbnMgc3VjaCBhcyBgYmFja2AgYW5kIGBmb3J3YXJkYFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludGVyYWN0aW9uUmVnaXN0cmF0aW9uKHRydWUpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjb25zdCBjYWxsRGF0YSA9IHtcbiAgICAgIHBvc2l0aW9uOiBnZXRTY3JlZW5FdmVudFBvc2l0aW9uRm9yKGV2ZW50KSxcbiAgICB9O1xuICAgIGNvbnN0IGtleXMgPSBnZXRNb2RpZmllcktleXNGb3IoZXZlbnQpO1xuICAgIE9iamVjdC5hc3NpZ24oY2FsbERhdGEsIGtleXMpO1xuICAgIHN3aXRjaCAoZXZlbnQuYnV0dG9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHB1YmxpY0FQSS5sZWZ0QnV0dG9uUHJlc3NFdmVudChjYWxsRGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBwdWJsaWNBUEkubWlkZGxlQnV0dG9uUHJlc3NFdmVudChjYWxsRGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBwdWJsaWNBUEkucmlnaHRCdXR0b25QcmVzc0V2ZW50KGNhbGxEYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2dGtFcnJvck1hY3JvKGBVbmtub3duIG1vdXNlIGJ1dHRvbiBwcmVzc2VkOiAke2V2ZW50LmJ1dHRvbn1gKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkucmVxdWVzdFBvaW50ZXJMb2NrID0gKCkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IHB1YmxpY0FQSS5nZXRWaWV3KCkuZ2V0Q2FudmFzKCk7XG4gICAgY2FudmFzLnJlcXVlc3RQb2ludGVyTG9jaygpO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuZXhpdFBvaW50ZXJMb2NrID0gKCkgPT4gZG9jdW1lbnQuZXhpdFBvaW50ZXJMb2NrKCk7XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5pc1BvaW50ZXJMb2NrZWQgPSAoKSA9PiAhIWRvY3VtZW50LnBvaW50ZXJMb2NrRWxlbWVudDtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmhhbmRsZVBvaW50ZXJMb2NrQ2hhbmdlID0gKCkgPT4ge1xuICAgIGlmIChwdWJsaWNBUEkuaXNQb2ludGVyTG9ja2VkKCkpIHtcbiAgICAgIHB1YmxpY0FQSS5zdGFydFBvaW50ZXJMb2NrRXZlbnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVibGljQVBJLmVuZFBvaW50ZXJMb2NrRXZlbnQoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIGZ1bmN0aW9uIGZvcmNlUmVuZGVyKCkge1xuICAgIGlmIChtb2RlbC52aWV3ICYmIG1vZGVsLmVuYWJsZWQgJiYgbW9kZWwuZW5hYmxlUmVuZGVyKSB7XG4gICAgICBtb2RlbC5pblJlbmRlciA9IHRydWU7XG4gICAgICBtb2RlbC52aWV3LnRyYXZlcnNlQWxsUGFzc2VzKCk7XG4gICAgICBtb2RlbC5pblJlbmRlciA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBvdXRzaWRlIHRoZSBhYm92ZSB0ZXN0IHNvIHRoYXQgdGhpcmQtcGFydHkgY29kZSBjYW4gcmVkaXJlY3RcbiAgICAvLyB0aGUgcmVuZGVyIHRvIHRoZSBhcHByb3ByaWF0ZSBjbGFzc1xuICAgIHB1YmxpY0FQSS5pbnZva2VSZW5kZXJFdmVudCgpO1xuICB9XG5cbiAgcHVibGljQVBJLnJlcXVlc3RBbmltYXRpb24gPSAocmVxdWVzdG9yKSA9PiB7XG4gICAgaWYgKHJlcXVlc3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKGB1bmRlZmluZWQgcmVxdWVzdGVyLCBjYW4gbm90IHN0YXJ0IGFuaW1hdGluZ2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uUmVxdWVzdGVycy5oYXMocmVxdWVzdG9yKSkge1xuICAgICAgdnRrV2FybmluZ01hY3JvKGByZXF1ZXN0ZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkIGZvciBhbmltYXRpbmdgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbWF0aW9uUmVxdWVzdGVycy5hZGQocmVxdWVzdG9yKTtcbiAgICBpZiAoYW5pbWF0aW9uUmVxdWVzdGVycy5zaXplID09PSAxKSB7XG4gICAgICBtb2RlbC5sYXN0RnJhbWVUaW1lID0gMC4xO1xuICAgICAgbW9kZWwubGFzdEZyYW1lU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgbW9kZWwuYW5pbWF0aW9uUmVxdWVzdCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShwdWJsaWNBUEkuaGFuZGxlQW5pbWF0aW9uKTtcbiAgICAgIHB1YmxpY0FQSS5zdGFydEFuaW1hdGlvbkV2ZW50KCk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5pc0FuaW1hdGluZyA9ICgpID0+XG4gICAgbW9kZWwudnJBbmltYXRpb24gfHwgbW9kZWwuYW5pbWF0aW9uUmVxdWVzdCAhPT0gbnVsbDtcblxuICBwdWJsaWNBUEkuY2FuY2VsQW5pbWF0aW9uID0gKHJlcXVlc3Rvciwgc2tpcFdhcm5pbmcgPSBmYWxzZSkgPT4ge1xuICAgIGlmICghYW5pbWF0aW9uUmVxdWVzdGVycy5oYXMocmVxdWVzdG9yKSkge1xuICAgICAgaWYgKCFza2lwV2FybmluZykge1xuICAgICAgICBjb25zdCByZXF1ZXN0U3RyID1cbiAgICAgICAgICByZXF1ZXN0b3IgJiYgcmVxdWVzdG9yLmdldENsYXNzTmFtZVxuICAgICAgICAgICAgPyByZXF1ZXN0b3IuZ2V0Q2xhc3NOYW1lKClcbiAgICAgICAgICAgIDogcmVxdWVzdG9yO1xuICAgICAgICB2dGtXYXJuaW5nTWFjcm8oYCR7cmVxdWVzdFN0cn0gZGlkIG5vdCByZXF1ZXN0IGFuIGFuaW1hdGlvbmApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1hdGlvblJlcXVlc3RlcnMuZGVsZXRlKHJlcXVlc3Rvcik7XG4gICAgaWYgKG1vZGVsLmFuaW1hdGlvblJlcXVlc3QgJiYgYW5pbWF0aW9uUmVxdWVzdGVycy5zaXplID09PSAwKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShtb2RlbC5hbmltYXRpb25SZXF1ZXN0KTtcbiAgICAgIG1vZGVsLmFuaW1hdGlvblJlcXVlc3QgPSBudWxsO1xuICAgICAgcHVibGljQVBJLmVuZEFuaW1hdGlvbkV2ZW50KCk7XG4gICAgICBwdWJsaWNBUEkucmVuZGVyKCk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5zd2l0Y2hUb1ZSQW5pbWF0aW9uID0gKCkgPT4ge1xuICAgIC8vIGNhbmNlbCBleGlzdGluZyBhbmltYXRpb24gaWYgYW55XG4gICAgaWYgKG1vZGVsLmFuaW1hdGlvblJlcXVlc3QpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKG1vZGVsLmFuaW1hdGlvblJlcXVlc3QpO1xuICAgICAgbW9kZWwuYW5pbWF0aW9uUmVxdWVzdCA9IG51bGw7XG4gICAgfVxuICAgIG1vZGVsLnZyQW5pbWF0aW9uID0gdHJ1ZTtcbiAgfTtcblxuICBwdWJsaWNBUEkucmV0dXJuRnJvbVZSQW5pbWF0aW9uID0gKCkgPT4ge1xuICAgIG1vZGVsLnZyQW5pbWF0aW9uID0gZmFsc2U7XG4gICAgaWYgKGFuaW1hdGlvblJlcXVlc3RlcnMuc2l6ZSAhPT0gMCkge1xuICAgICAgbW9kZWwuRnJhbWVUaW1lID0gLTE7XG4gICAgICBtb2RlbC5hbmltYXRpb25SZXF1ZXN0ID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHB1YmxpY0FQSS5oYW5kbGVBbmltYXRpb24pO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkudXBkYXRlR2FtZXBhZHMgPSAoZGlzcGxheUlkKSA9PiB7XG4gICAgY29uc3QgZ2FtZXBhZHMgPSBuYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKTtcblxuICAgIC8vIHdhdGNoIGZvciB3aGVuIGJ1dHRvbnMgY2hhbmdlIHN0YXRlIGFuZCBmaXJlIGV2ZW50c1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2FtZXBhZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGdwID0gZ2FtZXBhZHNbaV07XG4gICAgICBpZiAoZ3AgJiYgZ3AuZGlzcGxheUlkID09PSBkaXNwbGF5SWQpIHtcbiAgICAgICAgaWYgKCEoZ3AuaW5kZXggaW4gbW9kZWwubGFzdEdhbWVwYWRWYWx1ZXMpKSB7XG4gICAgICAgICAgbW9kZWwubGFzdEdhbWVwYWRWYWx1ZXNbZ3AuaW5kZXhdID0geyBidXR0b25zOiB7fSB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGIgPSAwOyBiIDwgZ3AuYnV0dG9ucy5sZW5ndGg7ICsrYikge1xuICAgICAgICAgIGlmICghKGIgaW4gbW9kZWwubGFzdEdhbWVwYWRWYWx1ZXNbZ3AuaW5kZXhdLmJ1dHRvbnMpKSB7XG4gICAgICAgICAgICBtb2RlbC5sYXN0R2FtZXBhZFZhbHVlc1tncC5pbmRleF0uYnV0dG9uc1tiXSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBtb2RlbC5sYXN0R2FtZXBhZFZhbHVlc1tncC5pbmRleF0uYnV0dG9uc1tiXSAhPT1cbiAgICAgICAgICAgIGdwLmJ1dHRvbnNbYl0ucHJlc3NlZFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgcHVibGljQVBJLmJ1dHRvbjNERXZlbnQoe1xuICAgICAgICAgICAgICBnYW1lcGFkOiBncCxcbiAgICAgICAgICAgICAgcG9zaXRpb246IGdwLnBvc2UucG9zaXRpb24sXG4gICAgICAgICAgICAgIG9yaWVudGF0aW9uOiBncC5wb3NlLm9yaWVudGF0aW9uLFxuICAgICAgICAgICAgICBwcmVzc2VkOiBncC5idXR0b25zW2JdLnByZXNzZWQsXG4gICAgICAgICAgICAgIGRldmljZTpcbiAgICAgICAgICAgICAgICBncC5oYW5kID09PSAnbGVmdCdcbiAgICAgICAgICAgICAgICAgID8gRGV2aWNlLkxlZnRDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICA6IERldmljZS5SaWdodENvbnRyb2xsZXIsXG4gICAgICAgICAgICAgIGlucHV0OlxuICAgICAgICAgICAgICAgIGRldmljZUlucHV0TWFwW2dwLmlkXSAmJiBkZXZpY2VJbnB1dE1hcFtncC5pZF1bYl1cbiAgICAgICAgICAgICAgICAgID8gZGV2aWNlSW5wdXRNYXBbZ3AuaWRdW2JdXG4gICAgICAgICAgICAgICAgICA6IElucHV0LlRyaWdnZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1vZGVsLmxhc3RHYW1lcGFkVmFsdWVzW2dwLmluZGV4XS5idXR0b25zW2JdID1cbiAgICAgICAgICAgICAgZ3AuYnV0dG9uc1tiXS5wcmVzc2VkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kZWwubGFzdEdhbWVwYWRWYWx1ZXNbZ3AuaW5kZXhdLmJ1dHRvbnNbYl0pIHtcbiAgICAgICAgICAgIHB1YmxpY0FQSS5tb3ZlM0RFdmVudCh7XG4gICAgICAgICAgICAgIGdhbWVwYWQ6IGdwLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogZ3AucG9zZS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgb3JpZW50YXRpb246IGdwLnBvc2Uub3JpZW50YXRpb24sXG4gICAgICAgICAgICAgIGRldmljZTpcbiAgICAgICAgICAgICAgICBncC5oYW5kID09PSAnbGVmdCdcbiAgICAgICAgICAgICAgICAgID8gRGV2aWNlLkxlZnRDb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICA6IERldmljZS5SaWdodENvbnRyb2xsZXIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmhhbmRsZU1vdXNlTW92ZSA9IChldmVudCkgPT4ge1xuICAgIC8vIERvIG5vdCBjb25zdW1lIGV2ZW50IGZvciBtb3ZlXG4gICAgLy8gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgLy8gZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGNvbnN0IGNhbGxEYXRhID0ge1xuICAgICAgcG9zaXRpb246IGdldFNjcmVlbkV2ZW50UG9zaXRpb25Gb3IoZXZlbnQpLFxuICAgIH07XG4gICAgY29uc3Qga2V5cyA9IGdldE1vZGlmaWVyS2V5c0ZvcihldmVudCk7XG4gICAgT2JqZWN0LmFzc2lnbihjYWxsRGF0YSwga2V5cyk7XG5cbiAgICBpZiAobW9kZWwubW92ZVRpbWVvdXRJRCA9PT0gMCkge1xuICAgICAgcHVibGljQVBJLnN0YXJ0TW91c2VNb3ZlRXZlbnQoY2FsbERhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdWJsaWNBUEkubW91c2VNb3ZlRXZlbnQoY2FsbERhdGEpO1xuICAgICAgY2xlYXJUaW1lb3V0KG1vZGVsLm1vdmVUaW1lb3V0SUQpO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0IGEgdGltZXIgdG8ga2VlcCB1cyBhbmltYXRpbmcgd2hpbGUgd2UgZ2V0IG1vdXNlIG1vdmUgZXZlbnRzXG4gICAgbW9kZWwubW92ZVRpbWVvdXRJRCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcHVibGljQVBJLmVuZE1vdXNlTW92ZUV2ZW50KCk7XG4gICAgICBtb2RlbC5tb3ZlVGltZW91dElEID0gMDtcbiAgICB9LCAyMDApO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5oYW5kbGVBbmltYXRpb24gPSAoKSA9PiB7XG4gICAgY29uc3QgY3VyclRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGlmIChtb2RlbC5GcmFtZVRpbWUgPT09IC0xLjApIHtcbiAgICAgIG1vZGVsLmxhc3RGcmFtZVRpbWUgPSAwLjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsLmxhc3RGcmFtZVRpbWUgPSAoY3VyclRpbWUgLSBtb2RlbC5sYXN0RnJhbWVTdGFydCkgLyAxMDAwLjA7XG4gICAgfVxuICAgIG1vZGVsLmxhc3RGcmFtZVRpbWUgPSBNYXRoLm1heCgwLjAxLCBtb2RlbC5sYXN0RnJhbWVUaW1lKTtcbiAgICBtb2RlbC5sYXN0RnJhbWVTdGFydCA9IGN1cnJUaW1lO1xuICAgIHB1YmxpY0FQSS5hbmltYXRpb25FdmVudCgpO1xuICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgbW9kZWwuYW5pbWF0aW9uUmVxdWVzdCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShwdWJsaWNBUEkuaGFuZGxlQW5pbWF0aW9uKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuaGFuZGxlV2hlZWwgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLyoqXG4gICAgICogd2hlZWwgZXZlbnQgdmFsdWVzIGNhbiB2YXJ5IHNpZ25pZmljYW50bHkgYWNyb3NzIGJyb3dzZXJzLCBwbGF0Zm9ybXNcbiAgICAgKiBhbmQgZGV2aWNlcyBbMV0uIGBub3JtYWxpemVXaGVlbGAgdXNlcyBmYWNlYm9vaydzIHNvbHV0aW9uIGZyb20gdGhlaXJcbiAgICAgKiBmaXhlZC1kYXRhLXRhYmxlIHJlcG9zaXRvcnkgWzJdLlxuICAgICAqXG4gICAgICogWzFdIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0V2ZW50cy9tb3VzZXdoZWVsXG4gICAgICogWzJdIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2FyY2hpdmUvZml4ZWQtZGF0YS10YWJsZS9ibG9iL21hc3Rlci9zcmMvdmVuZG9yX3Vwc3RyZWFtL2RvbS9ub3JtYWxpemVXaGVlbC5qc1xuICAgICAqXG4gICAgICogVGhpcyBjb2RlIHdpbGwgcmV0dXJuIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXM6XG4gICAgICpcbiAgICAgKiAgIHNwaW5YICAgLS0gbm9ybWFsaXplZCBzcGluIHNwZWVkICh1c2UgZm9yIHpvb20pIC0geCBwbGFuZVxuICAgICAqICAgc3BpblkgICAtLSBcIiAtIHkgcGxhbmVcbiAgICAgKiAgIHBpeGVsWCAgLS0gbm9ybWFsaXplZCBkaXN0YW5jZSAodG8gcGl4ZWxzKSAtIHggcGxhbmVcbiAgICAgKiAgIHBpeGVsWSAgLS0gXCIgLSB5IHBsYW5lXG4gICAgICpcbiAgICAgKi9cbiAgICBjb25zdCBjYWxsRGF0YSA9IG5vcm1hbGl6ZVdoZWVsKGV2ZW50KTtcbiAgICBjb25zdCBrZXlzID0gZ2V0TW9kaWZpZXJLZXlzRm9yKGV2ZW50KTtcbiAgICBPYmplY3QuYXNzaWduKGNhbGxEYXRhLCBrZXlzKTtcblxuICAgIGlmIChtb2RlbC53aGVlbFRpbWVvdXRJRCA9PT0gMCkge1xuICAgICAgcHVibGljQVBJLnN0YXJ0TW91c2VXaGVlbEV2ZW50KGNhbGxEYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVibGljQVBJLm1vdXNlV2hlZWxFdmVudChjYWxsRGF0YSk7XG4gICAgICBjbGVhclRpbWVvdXQobW9kZWwud2hlZWxUaW1lb3V0SUQpO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0IGEgdGltZXIgdG8ga2VlcCB1cyBhbmltYXRpbmcgd2hpbGUgd2UgZ2V0IHdoZWVsIGV2ZW50c1xuICAgIG1vZGVsLndoZWVsVGltZW91dElEID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBwdWJsaWNBUEkuZW5kTW91c2VXaGVlbEV2ZW50KCk7XG4gICAgICBtb2RlbC53aGVlbFRpbWVvdXRJRCA9IDA7XG4gICAgfSwgMjAwKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuaGFuZGxlTW91c2VVcCA9IChldmVudCkgPT4ge1xuICAgIGludGVyYWN0aW9uUmVnaXN0cmF0aW9uKGZhbHNlKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgY2FsbERhdGEgPSB7XG4gICAgICBwb3NpdGlvbjogZ2V0U2NyZWVuRXZlbnRQb3NpdGlvbkZvcihldmVudCksXG4gICAgfTtcbiAgICBjb25zdCBrZXlzID0gZ2V0TW9kaWZpZXJLZXlzRm9yKGV2ZW50KTtcbiAgICBPYmplY3QuYXNzaWduKGNhbGxEYXRhLCBrZXlzKTtcbiAgICBzd2l0Y2ggKGV2ZW50LmJ1dHRvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBwdWJsaWNBUEkubGVmdEJ1dHRvblJlbGVhc2VFdmVudChjYWxsRGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICBwdWJsaWNBUEkubWlkZGxlQnV0dG9uUmVsZWFzZUV2ZW50KGNhbGxEYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHB1YmxpY0FQSS5yaWdodEJ1dHRvblJlbGVhc2VFdmVudChjYWxsRGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdnRrRXJyb3JNYWNybyhgVW5rbm93biBtb3VzZSBidXR0b24gcmVsZWFzZWQ6ICR7ZXZlbnQuYnV0dG9ufWApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmhhbmRsZVRvdWNoU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICBpbnRlcmFjdGlvblJlZ2lzdHJhdGlvbih0cnVlKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgLy8gSWYgbXVsdGl0b3VjaFxuICAgIGlmIChtb2RlbC5yZWNvZ25pemVHZXN0dXJlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IGdldFRvdWNoRXZlbnRQb3NpdGlvbnNGb3IoZXZlbnQudG91Y2hlcyk7XG4gICAgICAvLyBkaWQgd2UganVzdCB0cmFuc2l0aW9uIHRvIG11bHRpdG91Y2g/XG4gICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgY29uc3QgdG91Y2ggPSBldmVudC50b3VjaGVzWzBdO1xuICAgICAgICBjb25zdCBjYWxsRGF0YSA9IHtcbiAgICAgICAgICBwb3NpdGlvbjogZ2V0U2NyZWVuRXZlbnRQb3NpdGlvbkZvcih0b3VjaCksXG4gICAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICAgIGFsdEtleTogZmFsc2UsXG4gICAgICAgICAgY29udHJvbEtleTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHB1YmxpY0FQSS5sZWZ0QnV0dG9uUmVsZWFzZUV2ZW50KGNhbGxEYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIGhhbmRsZSB0aGUgZ2VzdHVyZVxuICAgICAgcHVibGljQVBJLnJlY29nbml6ZUdlc3R1cmUoJ1RvdWNoU3RhcnQnLCBwb3NpdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICBjb25zdCBjYWxsRGF0YSA9IHtcbiAgICAgICAgcG9zaXRpb246IGdldFNjcmVlbkV2ZW50UG9zaXRpb25Gb3IodG91Y2gpLFxuICAgICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICAgIGFsdEtleTogZmFsc2UsXG4gICAgICAgIGNvbnRyb2xLZXk6IGZhbHNlLFxuICAgICAgfTtcbiAgICAgIHB1YmxpY0FQSS5sZWZ0QnV0dG9uUHJlc3NFdmVudChjYWxsRGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5oYW5kbGVUb3VjaE1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgaWYgKG1vZGVsLnJlY29nbml6ZUdlc3R1cmVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgcG9zaXRpb25zID0gZ2V0VG91Y2hFdmVudFBvc2l0aW9uc0ZvcihldmVudC50b3VjaGVzKTtcbiAgICAgIHB1YmxpY0FQSS5yZWNvZ25pemVHZXN0dXJlKCdUb3VjaE1vdmUnLCBwb3NpdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LnRvdWNoZXNbMF07XG4gICAgICBjb25zdCBjYWxsRGF0YSA9IHtcbiAgICAgICAgcG9zaXRpb246IGdldFNjcmVlbkV2ZW50UG9zaXRpb25Gb3IodG91Y2gpLFxuICAgICAgICBzaGlmdEtleTogZmFsc2UsXG4gICAgICAgIGFsdEtleTogZmFsc2UsXG4gICAgICAgIGNvbnRyb2xLZXk6IGZhbHNlLFxuICAgICAgfTtcbiAgICAgIHB1YmxpY0FQSS5tb3VzZU1vdmVFdmVudChjYWxsRGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5oYW5kbGVUb3VjaEVuZCA9IChldmVudCkgPT4ge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBpZiAobW9kZWwucmVjb2duaXplR2VzdHVyZXMpIHtcbiAgICAgIC8vIE5vIG1vcmUgZmluZ2VycyBkb3duXG4gICAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gSWYganVzdCBvbmUgZmluZ2VyIHJlbGVhc2VkLCBjb25zaWRlciBhcyBsZWZ0IGJ1dHRvblxuICAgICAgICBpZiAoZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgY29uc3QgdG91Y2ggPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgICBjb25zdCBjYWxsRGF0YSA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBnZXRTY3JlZW5FdmVudFBvc2l0aW9uRm9yKHRvdWNoKSxcbiAgICAgICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICAgICAgICAgIGFsdEtleTogZmFsc2UsXG4gICAgICAgICAgICBjb250cm9sS2V5OiBmYWxzZSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHB1YmxpY0FQSS5sZWZ0QnV0dG9uUmVsZWFzZUV2ZW50KGNhbGxEYXRhKTtcbiAgICAgICAgICBpbnRlcmFjdGlvblJlZ2lzdHJhdGlvbihmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIgcmVsZWFzZWQsIHJlY29nbml6ZSB0b3VjaGVuZFxuICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IGdldFRvdWNoRXZlbnRQb3NpdGlvbnNGb3IoZXZlbnQuY2hhbmdlZFRvdWNoZXMpO1xuICAgICAgICAgIHB1YmxpY0FQSS5yZWNvZ25pemVHZXN0dXJlKCdUb3VjaEVuZCcsIHBvc2l0aW9ucyk7XG4gICAgICAgICAgaW50ZXJhY3Rpb25SZWdpc3RyYXRpb24oZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIElmIG9uZSBmaW5nZXIgbGVmdCwgZW5kIHRvdWNoIGFuZCBzdGFydCBidXR0b24gcHJlc3NcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gZ2V0VG91Y2hFdmVudFBvc2l0aW9uc0ZvcihldmVudC5jaGFuZ2VkVG91Y2hlcyk7XG4gICAgICAgIHB1YmxpY0FQSS5yZWNvZ25pemVHZXN0dXJlKCdUb3VjaEVuZCcsIHBvc2l0aW9ucyk7XG4gICAgICAgIGNvbnN0IHRvdWNoID0gZXZlbnQudG91Y2hlc1swXTtcbiAgICAgICAgY29uc3QgY2FsbERhdGEgPSB7XG4gICAgICAgICAgcG9zaXRpb246IGdldFNjcmVlbkV2ZW50UG9zaXRpb25Gb3IodG91Y2gpLFxuICAgICAgICAgIHNoaWZ0S2V5OiBmYWxzZSxcbiAgICAgICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgICAgIGNvbnRyb2xLZXk6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBwdWJsaWNBUEkubGVmdEJ1dHRvblByZXNzRXZlbnQoY2FsbERhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbW9yZSB0aGFuIG9uZSBmaW5nZXIgbGVmdCwga2VlcCB0b3VjaCBtb3ZlXG4gICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IGdldFRvdWNoRXZlbnRQb3NpdGlvbnNGb3IoZXZlbnQudG91Y2hlcyk7XG4gICAgICAgIHB1YmxpY0FQSS5yZWNvZ25pemVHZXN0dXJlKCdUb3VjaE1vdmUnLCBwb3NpdGlvbnMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgY29uc3QgY2FsbERhdGEgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBnZXRTY3JlZW5FdmVudFBvc2l0aW9uRm9yKHRvdWNoKSxcbiAgICAgICAgc2hpZnRLZXk6IGZhbHNlLFxuICAgICAgICBhbHRLZXk6IGZhbHNlLFxuICAgICAgICBjb250cm9sS2V5OiBmYWxzZSxcbiAgICAgIH07XG4gICAgICBwdWJsaWNBUEkubGVmdEJ1dHRvblJlbGVhc2VFdmVudChjYWxsRGF0YSk7XG4gICAgICBpbnRlcmFjdGlvblJlZ2lzdHJhdGlvbihmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRWaWV3ID0gKHZhbCkgPT4ge1xuICAgIGlmIChtb2RlbC52aWV3ID09PSB2YWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbW9kZWwudmlldyA9IHZhbDtcbiAgICBtb2RlbC52aWV3LmdldFJlbmRlcmFibGUoKS5zZXRJbnRlcmFjdG9yKHB1YmxpY0FQSSk7XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLmZpbmRQb2tlZFJlbmRlcmVyID0gKHggPSAwLCB5ID0gMCkgPT4ge1xuICAgIGlmICghbW9kZWwudmlldykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJjID0gbW9kZWwudmlldy5nZXRSZW5kZXJhYmxlKCkuZ2V0UmVuZGVyZXJzQnlSZWZlcmVuY2UoKTtcbiAgICByYy5zb3J0KChhLCBiKSA9PiBhLmdldExheWVyKCkgLSBiLmdldExheWVyKCkpO1xuICAgIGxldCBpbnRlcmFjdGl2ZXJlbiA9IG51bGw7XG4gICAgbGV0IHZpZXdwb3J0cmVuID0gbnVsbDtcbiAgICBsZXQgY3VycmVudFJlbmRlcmVyID0gbnVsbDtcblxuICAgIGxldCBjb3VudCA9IHJjLmxlbmd0aDtcbiAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgY29uc3QgYXJlbiA9IHJjW2NvdW50XTtcbiAgICAgIGlmIChtb2RlbC52aWV3LmlzSW5WaWV3cG9ydCh4LCB5LCBhcmVuKSAmJiBhcmVuLmdldEludGVyYWN0aXZlKCkpIHtcbiAgICAgICAgY3VycmVudFJlbmRlcmVyID0gYXJlbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnRlcmFjdGl2ZXJlbiA9PT0gbnVsbCAmJiBhcmVuLmdldEludGVyYWN0aXZlKCkpIHtcbiAgICAgICAgLy8gU2F2ZSB0aGlzIHJlbmRlcmVyIGluIGNhc2Ugd2UgY2FuJ3QgZmluZCBvbmUgaW4gdGhlIHZpZXdwb3J0IHRoYXRcbiAgICAgICAgLy8gaXMgaW50ZXJhY3RpdmUuXG4gICAgICAgIGludGVyYWN0aXZlcmVuID0gYXJlbjtcbiAgICAgIH1cbiAgICAgIGlmICh2aWV3cG9ydHJlbiA9PT0gbnVsbCAmJiBtb2RlbC52aWV3LmlzSW5WaWV3cG9ydCh4LCB5LCBhcmVuKSkge1xuICAgICAgICAvLyBTYXZlIHRoaXMgcmVuZGVyZXIgaW4gY2FzZSB3ZSBjYW4ndCBmaW5kIG9uZSBpbiB0aGUgdmlld3BvcnQgdGhhdFxuICAgICAgICAvLyBpcyBpbnRlcmFjdGl2ZS5cbiAgICAgICAgdmlld3BvcnRyZW4gPSBhcmVuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdlIG11c3QgaGF2ZSBhIHZhbHVlLiAgSWYgd2UgZm91bmQgYW4gaW50ZXJhY3RpdmUgcmVuZGVyZXIgYmVmb3JlLCB0aGF0J3NcbiAgICAvLyBiZXR0ZXIgdGhhbiBhIG5vbi1pbnRlcmFjdGl2ZSByZW5kZXJlci5cbiAgICBpZiAoY3VycmVudFJlbmRlcmVyID09PSBudWxsKSB7XG4gICAgICBjdXJyZW50UmVuZGVyZXIgPSBpbnRlcmFjdGl2ZXJlbjtcbiAgICB9XG5cbiAgICAvLyBXZSBtdXN0IGhhdmUgYSB2YWx1ZS4gIElmIHdlIGZvdW5kIGEgcmVuZGVyZXIgdGhhdCBpcyBpbiB0aGUgdmlld3BvcnQsXG4gICAgLy8gdGhhdCBpcyBiZXR0ZXIgdGhhbiBhbnkgb2xkIHZpZXdwb3J0IChidXQgbm90IGFzIGdvb2QgYXMgYW4gaW50ZXJhY3RpdmVcbiAgICAvLyBvbmUpLlxuICAgIGlmIChjdXJyZW50UmVuZGVyZXIgPT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnRSZW5kZXJlciA9IHZpZXdwb3J0cmVuO1xuICAgIH1cblxuICAgIC8vIFdlIG11c3QgaGF2ZSBhIHZhbHVlIC0gdGFrZSBhbnl0aGluZy5cbiAgICBpZiAoY3VycmVudFJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgIGN1cnJlbnRSZW5kZXJlciA9IHJjWzBdO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50UmVuZGVyZXI7XG4gIH07XG5cbiAgLy8gb25seSByZW5kZXIgaWYgd2UgYXJlIG5vdCBhbmltYXRpbmcuIElmIHdlIGFyZSBhbmltYXRpbmdcbiAgLy8gdGhlbiByZW5kZXJzIHdpbGwgaGFwcGVuIG5hdHVyYWxseSBhbnlob3cgYW5kIHdlIGRlZmluaXRlbHlcbiAgLy8gZG8gbm90IHdhbnQgZXh0cmEgcmVuZGVycyBhcyB0aGUgbWFrZSB0aGUgYXBwYXJlbnQgaW50ZXJhY3Rpb25cbiAgLy8gcmF0ZSBzbG93ZXIuXG4gIHB1YmxpY0FQSS5yZW5kZXIgPSAoKSA9PiB7XG4gICAgaWYgKG1vZGVsLmFuaW1hdGlvblJlcXVlc3QgPT09IG51bGwgJiYgIW1vZGVsLmluUmVuZGVyKSB7XG4gICAgICBmb3JjZVJlbmRlcigpO1xuICAgIH1cbiAgfTtcblxuICAvLyBjcmVhdGUgdGhlIGdlbmVyaWMgRXZlbnQgbWV0aG9kc1xuICBoYW5kbGVkRXZlbnRzLmZvckVhY2goKGV2ZW50TmFtZSkgPT4ge1xuICAgIGNvbnN0IGxvd2VyRmlyc3QgPSBldmVudE5hbWUuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBldmVudE5hbWUuc2xpY2UoMSk7XG4gICAgcHVibGljQVBJW2Ake2xvd2VyRmlyc3R9RXZlbnRgXSA9IChhcmcpID0+IHtcbiAgICAgIC8vIENoZWNrIHRoYXQgaW50ZXJhY3RvciBlbmFibGVkXG4gICAgICBpZiAoIW1vZGVsLmVuYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB0aGF0IGEgcG9rZWQgcmVuZGVyZXIgZXhpc3RzXG4gICAgICBjb25zdCByZW5kZXJlciA9IHB1YmxpY0FQSS5nZXRDdXJyZW50UmVuZGVyZXIoKTtcbiAgICAgIGlmICghcmVuZGVyZXIpIHtcbiAgICAgICAgdnRrT25jZUVycm9yTWFjcm8oYFxuICAgICAgICAgIENhbiBub3QgZm9yd2FyZCBldmVudHMgd2l0aG91dCBhIGN1cnJlbnQgcmVuZGVyZXIgb24gdGhlIGludGVyYWN0b3IuXG4gICAgICAgIGApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFBhc3MgdGhlIGV2ZW50TmFtZSBhbmQgdGhlIHBva2VkIHJlbmRlcmVyXG4gICAgICBjb25zdCBjYWxsRGF0YSA9IHtcbiAgICAgICAgdHlwZTogZXZlbnROYW1lLFxuICAgICAgICBwb2tlZFJlbmRlcmVyOiBtb2RlbC5jdXJyZW50UmVuZGVyZXIsXG4gICAgICB9O1xuXG4gICAgICAvLyBBZGQgdGhlIGFyZ3VtZW50cyB0byB0aGUgY2FsbCBkYXRhXG4gICAgICBPYmplY3QuYXNzaWduKGNhbGxEYXRhLCBhcmcpO1xuXG4gICAgICAvLyBDYWxsIGludm9rZVxuICAgICAgcHVibGljQVBJW2BpbnZva2Uke2V2ZW50TmFtZX1gXShjYWxsRGF0YSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gd2Uga25vdyB3ZSBhcmUgaW4gbXVsdGl0b3VjaCBub3csIHNvIHN0YXJ0IHJlY29nbml6aW5nXG4gIHB1YmxpY0FQSS5yZWNvZ25pemVHZXN0dXJlID0gKGV2ZW50LCBwb3NpdGlvbnMpID0+IHtcbiAgICAvLyBtb3JlIHRoYW4gdHdvIHBvaW50ZXJzIHdlIGlnbm9yZVxuICAgIGlmIChPYmplY3Qua2V5cyhwb3NpdGlvbnMpLmxlbmd0aCA+IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW1vZGVsLnN0YXJ0aW5nRXZlbnRQb3NpdGlvbnMpIHtcbiAgICAgIG1vZGVsLnN0YXJ0aW5nRXZlbnRQb3NpdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBzdG9yZSB0aGUgaW5pdGlhbCBwb3NpdGlvbnNcbiAgICBpZiAoZXZlbnQgPT09ICdUb3VjaFN0YXJ0Jykge1xuICAgICAgT2JqZWN0LmtleXMocG9zaXRpb25zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbW9kZWwuc3RhcnRpbmdFdmVudFBvc2l0aW9uc1trZXldID0gcG9zaXRpb25zW2tleV07XG4gICAgICB9KTtcbiAgICAgIC8vIHdlIGRvIG5vdCBrbm93IHdoYXQgdGhlIGdlc3R1cmUgaXMgeWV0XG4gICAgICBtb2RlbC5jdXJyZW50R2VzdHVyZSA9ICdTdGFydCc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZW5kIHRoZSBnZXN0dXJlIGlmIG5lZWRlZFxuICAgIGlmIChldmVudCA9PT0gJ1RvdWNoRW5kJykge1xuICAgICAgaWYgKG1vZGVsLmN1cnJlbnRHZXN0dXJlID09PSAnUGluY2gnKSB7XG4gICAgICAgIHB1YmxpY0FQSS5yZW5kZXIoKTtcbiAgICAgICAgcHVibGljQVBJLmVuZFBpbmNoRXZlbnQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbC5jdXJyZW50R2VzdHVyZSA9PT0gJ1JvdGF0ZScpIHtcbiAgICAgICAgcHVibGljQVBJLnJlbmRlcigpO1xuICAgICAgICBwdWJsaWNBUEkuZW5kUm90YXRlRXZlbnQoKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbC5jdXJyZW50R2VzdHVyZSA9PT0gJ1BhbicpIHtcbiAgICAgICAgcHVibGljQVBJLnJlbmRlcigpO1xuICAgICAgICBwdWJsaWNBUEkuZW5kUGFuRXZlbnQoKTtcbiAgICAgIH1cbiAgICAgIG1vZGVsLmN1cnJlbnRHZXN0dXJlID0gJ1N0YXJ0JztcbiAgICAgIG1vZGVsLnN0YXJ0aW5nRXZlbnRQb3NpdGlvbnMgPSB7fTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB3aGF0IGFyZSB0aGUgdHdvIHBvaW50ZXJzIHdlIGFyZSB3b3JraW5nIHdpdGhcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGNvbnN0IHBvc1ZhbHMgPSBbXTtcbiAgICBjb25zdCBzdGFydFZhbHMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhwb3NpdGlvbnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgcG9zVmFsc1tjb3VudF0gPSBwb3NpdGlvbnNba2V5XTtcbiAgICAgIHN0YXJ0VmFsc1tjb3VudF0gPSBtb2RlbC5zdGFydGluZ0V2ZW50UG9zaXRpb25zW2tleV07XG4gICAgICBjb3VudCsrO1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIG1lYXQgb2YgdGhlIGFsZ29yaXRobVxuICAgIC8vIG9uIG1vdmUgZXZlbnRzIHdlIGFuYWx5emUgdGhlbSB0byBkZXRlcm1pbmUgd2hhdCB0eXBlXG4gICAgLy8gb2YgbW92ZW1lbnQgaXQgaXMgYW5kIHRoZW4gZGVhbCB3aXRoIGl0LlxuICAgIC8vIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2VzXG4gICAgY29uc3Qgb3JpZ2luYWxEaXN0YW5jZSA9IE1hdGguc3FydChcbiAgICAgIChzdGFydFZhbHNbMF0ueCAtIHN0YXJ0VmFsc1sxXS54KSAqIChzdGFydFZhbHNbMF0ueCAtIHN0YXJ0VmFsc1sxXS54KSArXG4gICAgICAgIChzdGFydFZhbHNbMF0ueSAtIHN0YXJ0VmFsc1sxXS55KSAqIChzdGFydFZhbHNbMF0ueSAtIHN0YXJ0VmFsc1sxXS55KVxuICAgICk7XG4gICAgY29uc3QgbmV3RGlzdGFuY2UgPSBNYXRoLnNxcnQoXG4gICAgICAocG9zVmFsc1swXS54IC0gcG9zVmFsc1sxXS54KSAqIChwb3NWYWxzWzBdLnggLSBwb3NWYWxzWzFdLngpICtcbiAgICAgICAgKHBvc1ZhbHNbMF0ueSAtIHBvc1ZhbHNbMV0ueSkgKiAocG9zVmFsc1swXS55IC0gcG9zVmFsc1sxXS55KVxuICAgICk7XG5cbiAgICAvLyBjYWxjdWxhdGUgcm90YXRpb25zXG4gICAgbGV0IG9yaWdpbmFsQW5nbGUgPSB2dGtNYXRoLmRlZ3JlZXNGcm9tUmFkaWFucyhcbiAgICAgIE1hdGguYXRhbjIoXG4gICAgICAgIHN0YXJ0VmFsc1sxXS55IC0gc3RhcnRWYWxzWzBdLnksXG4gICAgICAgIHN0YXJ0VmFsc1sxXS54IC0gc3RhcnRWYWxzWzBdLnhcbiAgICAgIClcbiAgICApO1xuICAgIGxldCBuZXdBbmdsZSA9IHZ0a01hdGguZGVncmVlc0Zyb21SYWRpYW5zKFxuICAgICAgTWF0aC5hdGFuMihwb3NWYWxzWzFdLnkgLSBwb3NWYWxzWzBdLnksIHBvc1ZhbHNbMV0ueCAtIHBvc1ZhbHNbMF0ueClcbiAgICApO1xuXG4gICAgLy8gYW5nbGVzIGFyZSBjeWNsaWMgc28gd2F0Y2ggZm9yIHRoYXQsIDEgYW5kIDM1OSBhcmUgb25seSAyIGFwYXJ0IDopXG4gICAgbGV0IGFuZ2xlRGV2aWF0aW9uID0gbmV3QW5nbGUgLSBvcmlnaW5hbEFuZ2xlO1xuICAgIG5ld0FuZ2xlID0gbmV3QW5nbGUgKyAxODAuMCA+PSAzNjAuMCA/IG5ld0FuZ2xlIC0gMTgwLjAgOiBuZXdBbmdsZSArIDE4MC4wO1xuICAgIG9yaWdpbmFsQW5nbGUgPVxuICAgICAgb3JpZ2luYWxBbmdsZSArIDE4MC4wID49IDM2MC4wXG4gICAgICAgID8gb3JpZ2luYWxBbmdsZSAtIDE4MC4wXG4gICAgICAgIDogb3JpZ2luYWxBbmdsZSArIDE4MC4wO1xuICAgIGlmIChNYXRoLmFicyhuZXdBbmdsZSAtIG9yaWdpbmFsQW5nbGUpIDwgTWF0aC5hYnMoYW5nbGVEZXZpYXRpb24pKSB7XG4gICAgICBhbmdsZURldmlhdGlvbiA9IG5ld0FuZ2xlIC0gb3JpZ2luYWxBbmdsZTtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHRyYW5zbGF0aW9uc1xuICAgIGNvbnN0IHRyYW5zID0gW107XG4gICAgdHJhbnNbMF0gPVxuICAgICAgKHBvc1ZhbHNbMF0ueCAtIHN0YXJ0VmFsc1swXS54ICsgcG9zVmFsc1sxXS54IC0gc3RhcnRWYWxzWzFdLngpIC8gMi4wO1xuICAgIHRyYW5zWzFdID1cbiAgICAgIChwb3NWYWxzWzBdLnkgLSBzdGFydFZhbHNbMF0ueSArIHBvc1ZhbHNbMV0ueSAtIHN0YXJ0VmFsc1sxXS55KSAvIDIuMDtcblxuICAgIGlmIChldmVudCA9PT0gJ1RvdWNoTW92ZScpIHtcbiAgICAgIC8vIE9LIHdlIHdhbnQgdG9cbiAgICAgIC8vIC0gaW1tZWRpYXRlbHkgcmVzcG9uZCB0byB0aGUgdXNlclxuICAgICAgLy8gLSBhbGxvdyB0aGUgdXNlciB0byB6b29tIHdpdGhvdXQgcGFubmluZyAoc2F2ZXMgZm9jYWwgcG9pbnQpXG4gICAgICAvLyAtIGFsbG93IHRoZSB1c2VyIHRvIHJvdGF0ZSB3aXRob3V0IHBhbm5pbmcgKHNhdmVzIGZvY2FsIHBvaW50KVxuXG4gICAgICAvLyBkbyB3ZSBrbm93IHdoYXQgZ2VzdHVyZSB3ZSBhcmUgZG9pbmcgeWV0PyBJZiBub3RcbiAgICAgIC8vIHNlZSBpZiB3ZSBjYW4gZmlndXJlIGl0IG91dFxuICAgICAgaWYgKG1vZGVsLmN1cnJlbnRHZXN0dXJlID09PSAnU3RhcnQnKSB7XG4gICAgICAgIC8vIHBpbmNoIGlzIGEgbW92ZSB0by9mcm9tIHRoZSBjZW50ZXIgcG9pbnRcbiAgICAgICAgLy8gcm90YXRlIGlzIGEgbW92ZSBhbG9uZyB0aGUgY2lyY3VtZmVyZW5jZVxuICAgICAgICAvLyBwYW4gaXMgYSBtb3ZlIG9mIHRoZSBjZW50ZXIgcG9pbnRcbiAgICAgICAgLy8gY29tcHV0ZSB0aGUgZGlzdGFuY2UgYWxvbmcgZWFjaCBvZiB0aGVzZSBheGVzIGluIHBpeGVsc1xuICAgICAgICAvLyB0aGUgZmlyc3QgdG8gYnJlYWsgdGhyZXNoIHdpbnNcbiAgICAgICAgbGV0IHRocmVzaCA9XG4gICAgICAgICAgMC4wMSAqXG4gICAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgbW9kZWwuY29udGFpbmVyLmNsaWVudFdpZHRoICogbW9kZWwuY29udGFpbmVyLmNsaWVudFdpZHRoICtcbiAgICAgICAgICAgICAgbW9kZWwuY29udGFpbmVyLmNsaWVudEhlaWdodCAqIG1vZGVsLmNvbnRhaW5lci5jbGllbnRIZWlnaHRcbiAgICAgICAgICApO1xuICAgICAgICBpZiAodGhyZXNoIDwgMTUuMCkge1xuICAgICAgICAgIHRocmVzaCA9IDE1LjA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGluY2hEaXN0YW5jZSA9IE1hdGguYWJzKG5ld0Rpc3RhbmNlIC0gb3JpZ2luYWxEaXN0YW5jZSk7XG4gICAgICAgIGNvbnN0IHJvdGF0ZURpc3RhbmNlID1cbiAgICAgICAgICAobmV3RGlzdGFuY2UgKiAzLjE0MTU5MjYgKiBNYXRoLmFicyhhbmdsZURldmlhdGlvbikpIC8gMzYwLjA7XG4gICAgICAgIGNvbnN0IHBhbkRpc3RhbmNlID0gTWF0aC5zcXJ0KFxuICAgICAgICAgIHRyYW5zWzBdICogdHJhbnNbMF0gKyB0cmFuc1sxXSAqIHRyYW5zWzFdXG4gICAgICAgICk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwaW5jaERpc3RhbmNlID4gdGhyZXNoICYmXG4gICAgICAgICAgcGluY2hEaXN0YW5jZSA+IHJvdGF0ZURpc3RhbmNlICYmXG4gICAgICAgICAgcGluY2hEaXN0YW5jZSA+IHBhbkRpc3RhbmNlXG4gICAgICAgICkge1xuICAgICAgICAgIG1vZGVsLmN1cnJlbnRHZXN0dXJlID0gJ1BpbmNoJztcbiAgICAgICAgICBjb25zdCBjYWxsRGF0YSA9IHtcbiAgICAgICAgICAgIHNjYWxlOiAxLjAsXG4gICAgICAgICAgICB0b3VjaGVzOiBwb3NpdGlvbnMsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBwdWJsaWNBUEkuc3RhcnRQaW5jaEV2ZW50KGNhbGxEYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChyb3RhdGVEaXN0YW5jZSA+IHRocmVzaCAmJiByb3RhdGVEaXN0YW5jZSA+IHBhbkRpc3RhbmNlKSB7XG4gICAgICAgICAgbW9kZWwuY3VycmVudEdlc3R1cmUgPSAnUm90YXRlJztcbiAgICAgICAgICBjb25zdCBjYWxsRGF0YSA9IHtcbiAgICAgICAgICAgIHJvdGF0aW9uOiAwLjAsXG4gICAgICAgICAgICB0b3VjaGVzOiBwb3NpdGlvbnMsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBwdWJsaWNBUEkuc3RhcnRSb3RhdGVFdmVudChjYWxsRGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAocGFuRGlzdGFuY2UgPiB0aHJlc2gpIHtcbiAgICAgICAgICBtb2RlbC5jdXJyZW50R2VzdHVyZSA9ICdQYW4nO1xuICAgICAgICAgIGNvbnN0IGNhbGxEYXRhID0ge1xuICAgICAgICAgICAgdHJhbnNsYXRpb246IFswLCAwXSxcbiAgICAgICAgICAgIHRvdWNoZXM6IHBvc2l0aW9ucyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHB1YmxpY0FQSS5zdGFydFBhbkV2ZW50KGNhbGxEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBmb3VuZCBhIHNwZWNpZmljIHR5cGUgb2YgbW92ZW1lbnQgdGhlblxuICAgICAgICAvLyBoYW5kbGUgaXRcbiAgICAgICAgaWYgKG1vZGVsLmN1cnJlbnRHZXN0dXJlID09PSAnUm90YXRlJykge1xuICAgICAgICAgIGNvbnN0IGNhbGxEYXRhID0ge1xuICAgICAgICAgICAgcm90YXRpb246IGFuZ2xlRGV2aWF0aW9uLFxuICAgICAgICAgICAgdG91Y2hlczogcG9zaXRpb25zLFxuICAgICAgICAgIH07XG4gICAgICAgICAgcHVibGljQVBJLnJvdGF0ZUV2ZW50KGNhbGxEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RlbC5jdXJyZW50R2VzdHVyZSA9PT0gJ1BpbmNoJykge1xuICAgICAgICAgIGNvbnN0IGNhbGxEYXRhID0ge1xuICAgICAgICAgICAgc2NhbGU6IG5ld0Rpc3RhbmNlIC8gb3JpZ2luYWxEaXN0YW5jZSxcbiAgICAgICAgICAgIHRvdWNoZXM6IHBvc2l0aW9ucyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHB1YmxpY0FQSS5waW5jaEV2ZW50KGNhbGxEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RlbC5jdXJyZW50R2VzdHVyZSA9PT0gJ1BhbicpIHtcbiAgICAgICAgICBjb25zdCBjYWxsRGF0YSA9IHtcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uOiB0cmFucyxcbiAgICAgICAgICAgIHRvdWNoZXM6IHBvc2l0aW9ucyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHB1YmxpY0FQSS5wYW5FdmVudChjYWxsRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UgPSAoKSA9PiB7XG4gICAgbW9kZWwubGFzdEZyYW1lU3RhcnQgPSBEYXRlLm5vdygpO1xuICB9O1xuXG4gIC8vIFN0b3AgYW5pbWF0aW5nIGlmIHRoZSByZW5kZXJXaW5kb3dJbnRlcmFjdG9yIGlzIGRlbGV0ZWQuXG4gIGNvbnN0IHN1cGVyRGVsZXRlID0gcHVibGljQVBJLmRlbGV0ZTtcbiAgcHVibGljQVBJLmRlbGV0ZSA9ICgpID0+IHtcbiAgICB3aGlsZSAoYW5pbWF0aW9uUmVxdWVzdGVycy5zaXplKSB7XG4gICAgICBwdWJsaWNBUEkuY2FuY2VsQW5pbWF0aW9uKGFuaW1hdGlvblJlcXVlc3RlcnMudmFsdWVzKCkubmV4dCgpLnZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudC5oaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAndmlzaWJpbGl0eWNoYW5nZScsXG4gICAgICAgIHB1YmxpY0FQSS5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlXG4gICAgICApO1xuICAgIH1cbiAgICBzdXBlckRlbGV0ZSgpO1xuICB9O1xuXG4gIC8vIFVzZSB0aGUgUGFnZSBWaXNpYmlsaXR5IEFQSSB0byBkZXRlY3Qgd2hlbiB3ZSBzd2l0Y2ggYXdheSBmcm9tIG9yIGJhY2sgdG9cbiAgLy8gdGhpcyB0YWIsIGFuZCByZXNldCB0aGUgbGFzdEZyYW1lU3RhcnQuIFdoZW4gdGFicyBhcmUgbm90IGFjdGl2ZSwgYnJvd3NlcnNcbiAgLy8gd2lsbCBzdG9wIGNhbGxpbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGNhbGxiYWNrcy5cbiAgaWYgKHR5cGVvZiBkb2N1bWVudC5oaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICd2aXNpYmlsaXR5Y2hhbmdlJyxcbiAgICAgIHB1YmxpY0FQSS5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlLFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICByZW5kZXJXaW5kb3c6IG51bGwsXG4gIGludGVyYWN0b3JTdHlsZTogbnVsbCxcbiAgcGlja2VyOiBudWxsLFxuICBwaWNraW5nTWFuYWdlcjogbnVsbCxcbiAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICBlbmFibGVkOiBmYWxzZSxcbiAgZW5hYmxlUmVuZGVyOiB0cnVlLFxuICBjdXJyZW50UmVuZGVyZXI6IG51bGwsXG4gIGxpZ2h0Rm9sbG93Q2FtZXJhOiB0cnVlLFxuICBkZXNpcmVkVXBkYXRlUmF0ZTogMzAuMCxcbiAgc3RpbGxVcGRhdGVSYXRlOiAyLjAsXG4gIGNvbnRhaW5lcjogbnVsbCxcbiAgdmlldzogbnVsbCxcbiAgcmVjb2duaXplR2VzdHVyZXM6IHRydWUsXG4gIGN1cnJlbnRHZXN0dXJlOiAnU3RhcnQnLFxuICBhbmltYXRpb25SZXF1ZXN0OiBudWxsLFxuICBsYXN0RnJhbWVUaW1lOiAwLjEsXG4gIHdoZWVsVGltZW91dElEOiAwLFxuICBtb3ZlVGltZW91dElEOiAwLFxuICBsYXN0R2FtZXBhZFZhbHVlczoge30sXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICBtYWNyby5vYmoocHVibGljQVBJLCBtb2RlbCk7XG5cbiAgbWFjcm8uZXZlbnQocHVibGljQVBJLCBtb2RlbCwgJ1JlbmRlckV2ZW50Jyk7XG4gIGhhbmRsZWRFdmVudHMuZm9yRWFjaCgoZXZlbnROYW1lKSA9PlxuICAgIG1hY3JvLmV2ZW50KHB1YmxpY0FQSSwgbW9kZWwsIGV2ZW50TmFtZSlcbiAgKTtcblxuICAvLyBDcmVhdGUgZ2V0LW9ubHkgbWFjcm9zXG4gIG1hY3JvLmdldChwdWJsaWNBUEksIG1vZGVsLCBbXG4gICAgJ2luaXRpYWxpemVkJyxcbiAgICAnY29udGFpbmVyJyxcbiAgICAnZW5hYmxlZCcsXG4gICAgJ2VuYWJsZVJlbmRlcicsXG4gICAgJ2ludGVyYWN0b3JTdHlsZScsXG4gICAgJ2xhc3RGcmFtZVRpbWUnLFxuICAgICd2aWV3JyxcbiAgXSk7XG5cbiAgLy8gQ3JlYXRlIGdldC1zZXQgbWFjcm9zXG4gIG1hY3JvLnNldEdldChwdWJsaWNBUEksIG1vZGVsLCBbXG4gICAgJ2xpZ2h0Rm9sbG93Q2FtZXJhJyxcbiAgICAnZW5hYmxlZCcsXG4gICAgJ3JlY29nbml6ZUdlc3R1cmVzJyxcbiAgICAnZGVzaXJlZFVwZGF0ZVJhdGUnLFxuICAgICdzdGlsbFVwZGF0ZVJhdGUnLFxuICAgICdwaWNrZXInLFxuICBdKTtcblxuICAvLyBGb3IgbW9yZSBtYWNybyBtZXRob2RzLCBzZWUgXCJTb3VyY2VzL21hY3JvLmpzXCJcblxuICAvLyBPYmplY3Qgc3BlY2lmaWMgbWV0aG9kc1xuICB2dGtSZW5kZXJXaW5kb3dJbnRlcmFjdG9yKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKFxuICBleHRlbmQsXG4gICd2dGtSZW5kZXJXaW5kb3dJbnRlcmFjdG9yJ1xuKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQsIGhhbmRsZWRFdmVudHMsIC4uLkNvbnN0YW50cyB9O1xuIiwiaW1wb3J0IHsgbWF0NCwgdmVjMyB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmltcG9ydCAqIGFzIG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB2dGtDYW1lcmEgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvQ2FtZXJhJztcbmltcG9ydCB2dGtMaWdodCBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9MaWdodCc7XG5pbXBvcnQgKiBhcyB2dGtNYXRoIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL01hdGgnO1xuaW1wb3J0IHZ0a1ZpZXdwb3J0IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL1ZpZXdwb3J0JztcbmltcG9ydCB2dGtCb3VuZGluZ0JveCBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL0JvdW5kaW5nQm94JztcblxuY29uc3QgeyB2dGtEZWJ1Z01hY3JvLCB2dGtFcnJvck1hY3JvLCB2dGtXYXJuaW5nTWFjcm8gfSA9IG1hY3JvO1xuXG5mdW5jdGlvbiBub3RJbXBsZW1lbnRlZChtZXRob2QpIHtcbiAgcmV0dXJuICgpID0+IHZ0a0Vycm9yTWFjcm8oYHZ0a1JlbmRlcmVyOjoke21ldGhvZH0gLSBOT1QgSU1QTEVNRU5URURgKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrUmVuZGVyZXIgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtSZW5kZXJlcihwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a1JlbmRlcmVyJyk7XG5cbiAgLy8gbWFrZSBzdXJlIGJhY2tncm91bmQgaGFzIDQgZW50cmllcy4gRGVmYXVsdCB0byBvcGFxdWUgYmxhY2tcbiAgaWYgKCFtb2RlbC5iYWNrZ3JvdW5kKSBtb2RlbC5iYWNrZ3JvdW5kID0gWzAsIDAsIDAsIDFdO1xuICB3aGlsZSAobW9kZWwuYmFja2dyb3VuZC5sZW5ndGggPCAzKSBtb2RlbC5iYWNrZ3JvdW5kLnB1c2goMCk7XG4gIGlmIChtb2RlbC5iYWNrZ3JvdW5kLmxlbmd0aCA9PT0gMykgbW9kZWwuYmFja2dyb3VuZC5wdXNoKDEpO1xuXG4gIC8vIEV2ZW50c1xuICBjb25zdCBDT01QVVRFX1ZJU0lCTEVfUFJPUF9CT1VORFNfRVZFTlQgPSB7XG4gICAgdHlwZTogJ0NvbXB1dGVWaXNpYmxlUHJvcEJvdW5kc0V2ZW50JyxcbiAgICByZW5kZXJlcjogcHVibGljQVBJLFxuICB9O1xuICBjb25zdCBSRVNFVF9DQU1FUkFfQ0xJUFBJTkdfUkFOR0VfRVZFTlQgPSB7XG4gICAgdHlwZTogJ1Jlc2V0Q2FtZXJhQ2xpcHBpbmdSYW5nZUV2ZW50JyxcbiAgICByZW5kZXJlcjogcHVibGljQVBJLFxuICB9O1xuICBjb25zdCBSRVNFVF9DQU1FUkFfRVZFTlQgPSB7XG4gICAgdHlwZTogJ1Jlc2V0Q2FtZXJhRXZlbnQnLFxuICAgIHJlbmRlcmVyOiBwdWJsaWNBUEksXG4gIH07XG5cbiAgcHVibGljQVBJLnVwZGF0ZUNhbWVyYSA9ICgpID0+IHtcbiAgICBpZiAoIW1vZGVsLmFjdGl2ZUNhbWVyYSkge1xuICAgICAgdnRrRGVidWdNYWNybygnTm8gY2FtZXJhcyBhcmUgb24sIGNyZWF0aW5nIG9uZS4nKTtcbiAgICAgIC8vIHRoZSBnZXQgbWV0aG9kIHdpbGwgYXV0b21hZ2ljYWxseSBjcmVhdGUgYSBjYW1lcmFcbiAgICAgIC8vIGFuZCByZXNldCBpdCBzaW5jZSBvbmUgaGFzbid0IGJlZW4gc3BlY2lmaWVkIHlldC5cbiAgICAgIHB1YmxpY0FQSS5nZXRBY3RpdmVDYW1lcmFBbmRSZXNldElmQ3JlYXRlZCgpO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0aGUgdmlld2luZyB0cmFuc2Zvcm1hdGlvblxuICAgIG1vZGVsLmFjdGl2ZUNhbWVyYS5yZW5kZXIocHVibGljQVBJKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS51cGRhdGVMaWdodHNHZW9tZXRyeVRvRm9sbG93Q2FtZXJhID0gKCkgPT4ge1xuICAgIC8vIG9ubHkgdXBkYXRlIHRoZSBsaWdodCdzIGdlb21ldHJ5IGlmIHRoaXMgUmVuZGVyZXIgaXMgdHJhY2tpbmdcbiAgICAvLyB0aGlzIGxpZ2h0cy4gIFRoYXQgYWxsb3dzIG9uZSByZW5kZXJlciB0byB2aWV3IHRoZSBsaWdodHMgdGhhdFxuICAgIC8vIGFub3RoZXIgcmVuZGVyZXIgaXMgc2V0dGluZyB1cC5cbiAgICBjb25zdCBjYW1lcmEgPSBwdWJsaWNBUEkuZ2V0QWN0aXZlQ2FtZXJhQW5kUmVzZXRJZkNyZWF0ZWQoKTtcblxuICAgIG1vZGVsLmxpZ2h0cy5mb3JFYWNoKChsaWdodCkgPT4ge1xuICAgICAgaWYgKGxpZ2h0LmxpZ2h0VHlwZUlzU2NlbmVMaWdodCgpIHx8IGxpZ2h0LmxpZ2h0VHlwZUlzQ2FtZXJhTGlnaHQoKSkge1xuICAgICAgICAvLyBEbyBub3RoaW5nLiBEb24ndCByZXNldCB0aGUgdHJhbnNmb3JtIG1hdHJpeCBiZWNhdXNlIGFwcGxpY2F0aW9uc1xuICAgICAgICAvLyBtYXkgaGF2ZSBzZXQgYSBjdXN0b20gbWF0cml4LiBPbmx5IHJlc2V0IHRoZSB0cmFuc2Zvcm0gbWF0cml4IGluXG4gICAgICAgIC8vIHZ0a0xpZ2h0OjpTZXRMaWdodFR5cGVUb1NjZW5lTGlnaHQoKVxuICAgICAgfSBlbHNlIGlmIChsaWdodC5saWdodFR5cGVJc0hlYWRMaWdodCgpKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBwb3NpdGlvbiBhbmQgb3JpZW50YXRpb24gb2YgbGlnaHQgdG8gbWF0Y2ggY2FtZXJhLlxuICAgICAgICBsaWdodC5zZXRQb3NpdGlvbkZyb20oY2FtZXJhLmdldFBvc2l0aW9uQnlSZWZlcmVuY2UoKSk7XG4gICAgICAgIGxpZ2h0LnNldEZvY2FsUG9pbnRGcm9tKGNhbWVyYS5nZXRGb2NhbFBvaW50QnlSZWZlcmVuY2UoKSk7XG4gICAgICAgIGxpZ2h0Lm1vZGlmaWVkKGNhbWVyYS5nZXRNVGltZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZ0a0Vycm9yTWFjcm8oJ2xpZ2h0IGhhcyB1bmtub3duIGxpZ2h0IHR5cGUnLCBsaWdodC5nZXQoKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcHVibGljQVBJLnVwZGF0ZUxpZ2h0R2VvbWV0cnkgPSAoKSA9PiB7XG4gICAgaWYgKG1vZGVsLmxpZ2h0Rm9sbG93Q2FtZXJhKSB7XG4gICAgICAvLyBvbmx5IHVwZGF0ZSB0aGUgbGlnaHQncyBnZW9tZXRyeSBpZiB0aGlzIFJlbmRlcmVyIGlzIHRyYWNraW5nXG4gICAgICAvLyB0aGlzIGxpZ2h0cy4gIFRoYXQgYWxsb3dzIG9uZSByZW5kZXJlciB0byB2aWV3IHRoZSBsaWdodHMgdGhhdFxuICAgICAgLy8gYW5vdGhlciByZW5kZXJlciBpcyBzZXR0aW5nIHVwLlxuICAgICAgcmV0dXJuIHB1YmxpY0FQSS51cGRhdGVMaWdodHNHZW9tZXRyeVRvRm9sbG93Q2FtZXJhKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5hbGxvY2F0ZVRpbWUgPSBub3RJbXBsZW1lbnRlZCgnYWxsb2NhdGVUaW1lJyk7XG4gIHB1YmxpY0FQSS51cGRhdGVHZW9tZXRyeSA9IG5vdEltcGxlbWVudGVkKCd1cGRhdGVHZW9tZXRyeScpO1xuXG4gIHB1YmxpY0FQSS5nZXRWVEtXaW5kb3cgPSAoKSA9PiBtb2RlbC5yZW5kZXJXaW5kb3c7XG5cbiAgcHVibGljQVBJLnNldExheWVyID0gKGxheWVyKSA9PiB7XG4gICAgdnRrRGVidWdNYWNybyhcbiAgICAgIHB1YmxpY0FQSS5nZXRDbGFzc05hbWUoKSxcbiAgICAgIHB1YmxpY0FQSSxcbiAgICAgICdzZXR0aW5nIExheWVyIHRvICcsXG4gICAgICBsYXllclxuICAgICk7XG4gICAgaWYgKG1vZGVsLmxheWVyICE9PSBsYXllcikge1xuICAgICAgbW9kZWwubGF5ZXIgPSBsYXllcjtcbiAgICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICAgIH1cbiAgICBwdWJsaWNBUEkuc2V0UHJlc2VydmVDb2xvckJ1ZmZlcighIWxheWVyKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0QWN0aXZlQ2FtZXJhID0gKGNhbWVyYSkgPT4ge1xuICAgIGlmIChtb2RlbC5hY3RpdmVDYW1lcmEgPT09IGNhbWVyYSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1vZGVsLmFjdGl2ZUNhbWVyYSA9IGNhbWVyYTtcbiAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgICBwdWJsaWNBUEkuaW52b2tlRXZlbnQoeyB0eXBlOiAnQWN0aXZlQ2FtZXJhRXZlbnQnLCBjYW1lcmEgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLm1ha2VDYW1lcmEgPSAoKSA9PiB7XG4gICAgY29uc3QgY2FtZXJhID0gdnRrQ2FtZXJhLm5ld0luc3RhbmNlKCk7XG4gICAgcHVibGljQVBJLmludm9rZUV2ZW50KHsgdHlwZTogJ0NyZWF0ZUNhbWVyYUV2ZW50JywgY2FtZXJhIH0pO1xuICAgIHJldHVybiBjYW1lcmE7XG4gIH07XG5cbiAgLy8gUmVwbGFjZSB0aGUgc2V0L2dldCBtYWNybyBtZXRob2RcbiAgcHVibGljQVBJLmdldEFjdGl2ZUNhbWVyYSA9ICgpID0+IHtcbiAgICBpZiAoIW1vZGVsLmFjdGl2ZUNhbWVyYSkge1xuICAgICAgbW9kZWwuYWN0aXZlQ2FtZXJhID0gcHVibGljQVBJLm1ha2VDYW1lcmEoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsLmFjdGl2ZUNhbWVyYTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0QWN0aXZlQ2FtZXJhQW5kUmVzZXRJZkNyZWF0ZWQgPSAoKSA9PiB7XG4gICAgaWYgKCFtb2RlbC5hY3RpdmVDYW1lcmEpIHtcbiAgICAgIHB1YmxpY0FQSS5nZXRBY3RpdmVDYW1lcmEoKTtcbiAgICAgIHB1YmxpY0FQSS5yZXNldENhbWVyYSgpO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWwuYWN0aXZlQ2FtZXJhO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRBY3RvcnMgPSAoKSA9PiB7XG4gICAgbW9kZWwuYWN0b3JzID0gW107XG4gICAgbW9kZWwucHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgbW9kZWwuYWN0b3JzID0gbW9kZWwuYWN0b3JzLmNvbmNhdChwcm9wLmdldEFjdG9ycygpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbW9kZWwuYWN0b3JzO1xuICB9O1xuICBwdWJsaWNBUEkuYWRkQWN0b3IgPSBwdWJsaWNBUEkuYWRkVmlld1Byb3A7XG4gIHB1YmxpY0FQSS5yZW1vdmVBY3RvciA9IChhY3RvcikgPT4ge1xuICAgIG1vZGVsLmFjdG9ycyA9IG1vZGVsLmFjdG9ycy5maWx0ZXIoKGEpID0+IGEgIT09IGFjdG9yKTtcbiAgICBwdWJsaWNBUEkucmVtb3ZlVmlld1Byb3AoYWN0b3IpO1xuICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICB9O1xuICBwdWJsaWNBUEkucmVtb3ZlQWxsQWN0b3JzID0gKCkgPT4ge1xuICAgIG1vZGVsLmFjdG9ycy5mb3JFYWNoKChhY3RvcikgPT4ge1xuICAgICAgcHVibGljQVBJLnJlbW92ZVZpZXdQcm9wKGFjdG9yKTtcbiAgICB9KTtcbiAgICBtb2RlbC5hY3RvcnMgPSBbXTtcbiAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0Vm9sdW1lcyA9ICgpID0+IHtcbiAgICBtb2RlbC52b2x1bWVzID0gW107XG4gICAgbW9kZWwucHJvcHMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgbW9kZWwudm9sdW1lcyA9IG1vZGVsLnZvbHVtZXMuY29uY2F0KHByb3AuZ2V0Vm9sdW1lcygpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbW9kZWwudm9sdW1lcztcbiAgfTtcbiAgcHVibGljQVBJLmFkZFZvbHVtZSA9IHB1YmxpY0FQSS5hZGRWaWV3UHJvcDtcbiAgcHVibGljQVBJLnJlbW92ZVZvbHVtZSA9ICh2b2x1bWUpID0+IHtcbiAgICBtb2RlbC52b2x1bWVzID0gbW9kZWwudm9sdW1lcy5maWx0ZXIoKHYpID0+IHYgIT09IHZvbHVtZSk7XG4gICAgcHVibGljQVBJLnJlbW92ZVZpZXdQcm9wKHZvbHVtZSk7XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG4gIHB1YmxpY0FQSS5yZW1vdmVBbGxWb2x1bWVzID0gKCkgPT4ge1xuICAgIG1vZGVsLnZvbHVtZXMuZm9yRWFjaCgodm9sdW1lKSA9PiB7XG4gICAgICBwdWJsaWNBUEkucmVtb3ZlVmlld1Byb3Aodm9sdW1lKTtcbiAgICB9KTtcbiAgICBtb2RlbC52b2x1bWVzID0gW107XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLmFkZExpZ2h0ID0gKGxpZ2h0KSA9PiB7XG4gICAgbW9kZWwubGlnaHRzID0gW10uY29uY2F0KG1vZGVsLmxpZ2h0cywgbGlnaHQpO1xuICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICB9O1xuICBwdWJsaWNBUEkucmVtb3ZlTGlnaHQgPSAobGlnaHQpID0+IHtcbiAgICBtb2RlbC5saWdodHMgPSBtb2RlbC5saWdodHMuZmlsdGVyKChsKSA9PiBsICE9PSBsaWdodCk7XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG4gIHB1YmxpY0FQSS5yZW1vdmVBbGxMaWdodHMgPSAoKSA9PiB7XG4gICAgbW9kZWwubGlnaHRzID0gW107XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG4gIHB1YmxpY0FQSS5zZXRMaWdodENvbGxlY3Rpb24gPSAobGlnaHRzKSA9PiB7XG4gICAgbW9kZWwubGlnaHRzID0gbGlnaHRzO1xuICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5tYWtlTGlnaHQgPSB2dGtMaWdodC5uZXdJbnN0YW5jZTtcblxuICBwdWJsaWNBUEkuY3JlYXRlTGlnaHQgPSAoKSA9PiB7XG4gICAgaWYgKCFtb2RlbC5hdXRvbWF0aWNMaWdodENyZWF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1vZGVsLmNyZWF0ZWRMaWdodCkge1xuICAgICAgcHVibGljQVBJLnJlbW92ZUxpZ2h0KG1vZGVsLmNyZWF0ZWRMaWdodCk7XG4gICAgICBtb2RlbC5jcmVhdGVkTGlnaHQuZGVsZXRlKCk7XG4gICAgICBtb2RlbC5jcmVhdGVkTGlnaHQgPSBudWxsO1xuICAgIH1cblxuICAgIG1vZGVsLmNyZWF0ZWRMaWdodCA9IHB1YmxpY0FQSS5tYWtlTGlnaHQoKTtcbiAgICBwdWJsaWNBUEkuYWRkTGlnaHQobW9kZWwuY3JlYXRlZExpZ2h0KTtcblxuICAgIG1vZGVsLmNyZWF0ZWRMaWdodC5zZXRMaWdodFR5cGVUb0hlYWRMaWdodCgpO1xuXG4gICAgLy8gc2V0IHRoZXNlIHZhbHVlcyBqdXN0IHRvIGhhdmUgYSBnb29kIGRlZmF1bHQgc2hvdWxkIExpZ2h0Rm9sbG93Q2FtZXJhXG4gICAgLy8gYmUgdHVybmVkIG9mZi5cbiAgICBtb2RlbC5jcmVhdGVkTGlnaHQuc2V0UG9zaXRpb24ocHVibGljQVBJLmdldEFjdGl2ZUNhbWVyYSgpLmdldFBvc2l0aW9uKCkpO1xuICAgIG1vZGVsLmNyZWF0ZWRMaWdodC5zZXRGb2NhbFBvaW50KFxuICAgICAgcHVibGljQVBJLmdldEFjdGl2ZUNhbWVyYSgpLmdldEZvY2FsUG9pbnQoKVxuICAgICk7XG4gIH07XG5cbiAgLy8gcmVxdWlyZXMgdGhlIGFzcGVjdCByYXRpbyBvZiB0aGUgdmlld3BvcnQgYXMgWC9ZXG4gIHB1YmxpY0FQSS5ub3JtYWxpemVkRGlzcGxheVRvV29ybGQgPSAoeCwgeSwgeiwgYXNwZWN0KSA9PiB7XG4gICAgbGV0IHZwZCA9IHB1YmxpY0FQSS5ub3JtYWxpemVkRGlzcGxheVRvUHJvamVjdGlvbih4LCB5LCB6KTtcbiAgICB2cGQgPSBwdWJsaWNBUEkucHJvamVjdGlvblRvVmlldyh2cGRbMF0sIHZwZFsxXSwgdnBkWzJdLCBhc3BlY3QpO1xuXG4gICAgcmV0dXJuIHB1YmxpY0FQSS52aWV3VG9Xb3JsZCh2cGRbMF0sIHZwZFsxXSwgdnBkWzJdKTtcbiAgfTtcblxuICAvLyByZXF1aXJlcyB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSB2aWV3cG9ydCBhcyBYL1lcbiAgcHVibGljQVBJLndvcmxkVG9Ob3JtYWxpemVkRGlzcGxheSA9ICh4LCB5LCB6LCBhc3BlY3QpID0+IHtcbiAgICBsZXQgdnBkID0gcHVibGljQVBJLndvcmxkVG9WaWV3KHgsIHksIHopO1xuICAgIHZwZCA9IHB1YmxpY0FQSS52aWV3VG9Qcm9qZWN0aW9uKHZwZFswXSwgdnBkWzFdLCB2cGRbMl0sIGFzcGVjdCk7XG5cbiAgICByZXR1cm4gcHVibGljQVBJLnByb2plY3Rpb25Ub05vcm1hbGl6ZWREaXNwbGF5KHZwZFswXSwgdnBkWzFdLCB2cGRbMl0pO1xuICB9O1xuXG4gIC8vIHJlcXVpcmVzIHRoZSBhc3BlY3QgcmF0aW8gb2YgdGhlIHZpZXdwb3J0IGFzIFgvWVxuICBwdWJsaWNBUEkudmlld1RvV29ybGQgPSAoeCwgeSwgeikgPT4ge1xuICAgIGlmIChtb2RlbC5hY3RpdmVDYW1lcmEgPT09IG51bGwpIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oXG4gICAgICAgICdWaWV3VG9Xb3JsZDogbm8gYWN0aXZlIGNhbWVyYSwgY2Fubm90IGNvbXB1dGUgdmlldyB0byB3b3JsZCwgcmV0dXJuaW5nIDAsMCwwJ1xuICAgICAgKTtcbiAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSB2aWV3IG1hdHJpeCBmcm9tIHRoZSBhY3RpdmUgY2FtZXJhXG4gICAgY29uc3QgbWF0cml4ID0gbW9kZWwuYWN0aXZlQ2FtZXJhLmdldFZpZXdNYXRyaXgoKTtcblxuICAgIG1hdDQuaW52ZXJ0KG1hdHJpeCwgbWF0cml4KTtcbiAgICBtYXQ0LnRyYW5zcG9zZShtYXRyaXgsIG1hdHJpeCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcG9pbnQgdG8gd29ybGQgY29vcmRpbmF0ZXNcbiAgICBjb25zdCByZXN1bHQgPSB2ZWMzLmZyb21WYWx1ZXMoeCwgeSwgeik7XG4gICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHJlc3VsdCwgcmVzdWx0LCBtYXRyaXgpO1xuICAgIHJldHVybiBbcmVzdWx0WzBdLCByZXN1bHRbMV0sIHJlc3VsdFsyXV07XG4gIH07XG5cbiAgcHVibGljQVBJLnByb2plY3Rpb25Ub1ZpZXcgPSAoeCwgeSwgeiwgYXNwZWN0KSA9PiB7XG4gICAgaWYgKG1vZGVsLmFjdGl2ZUNhbWVyYSA9PT0gbnVsbCkge1xuICAgICAgdnRrRXJyb3JNYWNybyhcbiAgICAgICAgJ1Byb2plY3Rpb25Ub1ZpZXc6IG5vIGFjdGl2ZSBjYW1lcmEsIGNhbm5vdCBjb21wdXRlIHByb2plY3Rpb24gdG8gdmlldywgcmV0dXJuaW5nIDAsMCwwJ1xuICAgICAgKTtcbiAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBwcm9qZWN0aW9uIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIGFjdGl2ZSBjYW1lcmFcbiAgICBjb25zdCBtYXRyaXggPSBtb2RlbC5hY3RpdmVDYW1lcmEuZ2V0UHJvamVjdGlvbk1hdHJpeChhc3BlY3QsIC0xLjAsIDEuMCk7XG5cbiAgICBtYXQ0LmludmVydChtYXRyaXgsIG1hdHJpeCk7XG4gICAgbWF0NC50cmFuc3Bvc2UobWF0cml4LCBtYXRyaXgpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHBvaW50IHRvIHdvcmxkIGNvb3JkaW5hdGVzXG4gICAgY29uc3QgcmVzdWx0ID0gdmVjMy5mcm9tVmFsdWVzKHgsIHksIHopO1xuICAgIHZlYzMudHJhbnNmb3JtTWF0NChyZXN1bHQsIHJlc3VsdCwgbWF0cml4KTtcbiAgICByZXR1cm4gW3Jlc3VsdFswXSwgcmVzdWx0WzFdLCByZXN1bHRbMl1dO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgd29ybGQgcG9pbnQgY29vcmRpbmF0ZXMgdG8gdmlldyBjb29yZGluYXRlcy5cbiAgcHVibGljQVBJLndvcmxkVG9WaWV3ID0gKHgsIHksIHopID0+IHtcbiAgICBpZiAobW9kZWwuYWN0aXZlQ2FtZXJhID09PSBudWxsKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKFxuICAgICAgICAnV29ybGRUb1ZpZXc6IG5vIGFjdGl2ZSBjYW1lcmEsIGNhbm5vdCBjb21wdXRlIHZpZXcgdG8gd29ybGQsIHJldHVybmluZyAwLDAsMCdcbiAgICAgICk7XG4gICAgICByZXR1cm4gWzAsIDAsIDBdO1xuICAgIH1cblxuICAgIC8vIGdldCB0aGUgdmlldyB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRoZSBhY3RpdmUgY2FtZXJhXG4gICAgY29uc3QgbWF0cml4ID0gbW9kZWwuYWN0aXZlQ2FtZXJhLmdldFZpZXdNYXRyaXgoKTtcbiAgICBtYXQ0LnRyYW5zcG9zZShtYXRyaXgsIG1hdHJpeCk7XG5cbiAgICBjb25zdCByZXN1bHQgPSB2ZWMzLmZyb21WYWx1ZXMoeCwgeSwgeik7XG4gICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHJlc3VsdCwgcmVzdWx0LCBtYXRyaXgpO1xuICAgIHJldHVybiBbcmVzdWx0WzBdLCByZXN1bHRbMV0sIHJlc3VsdFsyXV07XG4gIH07XG5cbiAgLy8gQ29udmVydCB3b3JsZCBwb2ludCBjb29yZGluYXRlcyB0byB2aWV3IGNvb3JkaW5hdGVzLlxuICAvLyByZXF1aXJlcyB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSB2aWV3cG9ydCBhcyBYL1lcbiAgcHVibGljQVBJLnZpZXdUb1Byb2plY3Rpb24gPSAoeCwgeSwgeiwgYXNwZWN0KSA9PiB7XG4gICAgaWYgKG1vZGVsLmFjdGl2ZUNhbWVyYSA9PT0gbnVsbCkge1xuICAgICAgdnRrRXJyb3JNYWNybyhcbiAgICAgICAgJ1ZpZXdUb1Byb2plY3Rpb246IG5vIGFjdGl2ZSBjYW1lcmEsIGNhbm5vdCBjb21wdXRlIHZpZXcgdG8gcHJvamVjdGlvbiwgcmV0dXJuaW5nIDAsMCwwJ1xuICAgICAgKTtcbiAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBwcm9qZWNpdG9uIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIGFjdGl2ZSBjYW1lcmFcbiAgICBjb25zdCBtYXRyaXggPSBtb2RlbC5hY3RpdmVDYW1lcmEuZ2V0UHJvamVjdGlvbk1hdHJpeChhc3BlY3QsIC0xLjAsIDEuMCk7XG4gICAgbWF0NC50cmFuc3Bvc2UobWF0cml4LCBtYXRyaXgpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gdmVjMy5mcm9tVmFsdWVzKHgsIHksIHopO1xuICAgIHZlYzMudHJhbnNmb3JtTWF0NChyZXN1bHQsIHJlc3VsdCwgbWF0cml4KTtcbiAgICByZXR1cm4gW3Jlc3VsdFswXSwgcmVzdWx0WzFdLCByZXN1bHRbMl1dO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5jb21wdXRlVmlzaWJsZVByb3BCb3VuZHMgPSAoKSA9PiB7XG4gICAgbW9kZWwuYWxsQm91bmRzWzBdID0gdnRrQm91bmRpbmdCb3guSU5JVF9CT1VORFNbMF07XG4gICAgbW9kZWwuYWxsQm91bmRzWzFdID0gdnRrQm91bmRpbmdCb3guSU5JVF9CT1VORFNbMV07XG4gICAgbW9kZWwuYWxsQm91bmRzWzJdID0gdnRrQm91bmRpbmdCb3guSU5JVF9CT1VORFNbMl07XG4gICAgbW9kZWwuYWxsQm91bmRzWzNdID0gdnRrQm91bmRpbmdCb3guSU5JVF9CT1VORFNbM107XG4gICAgbW9kZWwuYWxsQm91bmRzWzRdID0gdnRrQm91bmRpbmdCb3guSU5JVF9CT1VORFNbNF07XG4gICAgbW9kZWwuYWxsQm91bmRzWzVdID0gdnRrQm91bmRpbmdCb3guSU5JVF9CT1VORFNbNV07XG4gICAgbGV0IG5vdGhpbmdWaXNpYmxlID0gdHJ1ZTtcblxuICAgIHB1YmxpY0FQSS5pbnZva2VFdmVudChDT01QVVRFX1ZJU0lCTEVfUFJPUF9CT1VORFNfRVZFTlQpO1xuXG4gICAgLy8gbG9vcCB0aHJvdWdoIGFsbCBwcm9wc1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtb2RlbC5wcm9wcy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIGNvbnN0IHByb3AgPSBtb2RlbC5wcm9wc1tpbmRleF07XG4gICAgICBpZiAocHJvcC5nZXRWaXNpYmlsaXR5KCkgJiYgcHJvcC5nZXRVc2VCb3VuZHMoKSkge1xuICAgICAgICBjb25zdCBib3VuZHMgPSBwcm9wLmdldEJvdW5kcygpO1xuICAgICAgICBpZiAoYm91bmRzICYmIHZ0a01hdGguYXJlQm91bmRzSW5pdGlhbGl6ZWQoYm91bmRzKSkge1xuICAgICAgICAgIG5vdGhpbmdWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAgICAgICBpZiAoYm91bmRzWzBdIDwgbW9kZWwuYWxsQm91bmRzWzBdKSB7XG4gICAgICAgICAgICBtb2RlbC5hbGxCb3VuZHNbMF0gPSBib3VuZHNbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChib3VuZHNbMV0gPiBtb2RlbC5hbGxCb3VuZHNbMV0pIHtcbiAgICAgICAgICAgIG1vZGVsLmFsbEJvdW5kc1sxXSA9IGJvdW5kc1sxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJvdW5kc1syXSA8IG1vZGVsLmFsbEJvdW5kc1syXSkge1xuICAgICAgICAgICAgbW9kZWwuYWxsQm91bmRzWzJdID0gYm91bmRzWzJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYm91bmRzWzNdID4gbW9kZWwuYWxsQm91bmRzWzNdKSB7XG4gICAgICAgICAgICBtb2RlbC5hbGxCb3VuZHNbM10gPSBib3VuZHNbM107XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChib3VuZHNbNF0gPCBtb2RlbC5hbGxCb3VuZHNbNF0pIHtcbiAgICAgICAgICAgIG1vZGVsLmFsbEJvdW5kc1s0XSA9IGJvdW5kc1s0XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJvdW5kc1s1XSA+IG1vZGVsLmFsbEJvdW5kc1s1XSkge1xuICAgICAgICAgICAgbW9kZWwuYWxsQm91bmRzWzVdID0gYm91bmRzWzVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChub3RoaW5nVmlzaWJsZSkge1xuICAgICAgdnRrTWF0aC51bmluaXRpYWxpemVCb3VuZHMobW9kZWwuYWxsQm91bmRzKTtcbiAgICAgIHZ0a0RlYnVnTWFjcm8oXCJDYW4ndCBjb21wdXRlIGJvdW5kcywgbm8gM0QgcHJvcHMgYXJlIHZpc2libGVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGVsLmFsbEJvdW5kcztcbiAgfTtcblxuICBwdWJsaWNBUEkucmVzZXRDYW1lcmEgPSAoYm91bmRzID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IGJvdW5kc1RvVXNlID0gYm91bmRzIHx8IHB1YmxpY0FQSS5jb21wdXRlVmlzaWJsZVByb3BCb3VuZHMoKTtcbiAgICBjb25zdCBjZW50ZXIgPSBbMCwgMCwgMF07XG5cbiAgICBpZiAoIXZ0a01hdGguYXJlQm91bmRzSW5pdGlhbGl6ZWQoYm91bmRzVG9Vc2UpKSB7XG4gICAgICB2dGtEZWJ1Z01hY3JvKCdDYW5ub3QgcmVzZXQgY2FtZXJhIScpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxldCB2biA9IG51bGw7XG5cbiAgICBpZiAocHVibGljQVBJLmdldEFjdGl2ZUNhbWVyYSgpKSB7XG4gICAgICB2biA9IG1vZGVsLmFjdGl2ZUNhbWVyYS5nZXRWaWV3UGxhbmVOb3JtYWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdnRrRXJyb3JNYWNybygnVHJ5aW5nIHRvIHJlc2V0IG5vbi1leGlzdGVudCBjYW1lcmEnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCB0aGUgcGVyc3BlY3RpdmUgem9vbSBmYWN0b3JzLCBvdGhlcndpc2Ugc3Vic2VxdWVudCB6b29tcyB3aWxsIGNhdXNlXG4gICAgLy8gdGhlIHZpZXcgYW5nbGUgdG8gYmVjb21lIHZlcnkgc21hbGwgYW5kIGNhdXNlIGJhZCBkZXB0aCBzb3J0aW5nLlxuICAgIG1vZGVsLmFjdGl2ZUNhbWVyYS5zZXRWaWV3QW5nbGUoMzAuMCk7XG5cbiAgICBjZW50ZXJbMF0gPSAoYm91bmRzVG9Vc2VbMF0gKyBib3VuZHNUb1VzZVsxXSkgLyAyLjA7XG4gICAgY2VudGVyWzFdID0gKGJvdW5kc1RvVXNlWzJdICsgYm91bmRzVG9Vc2VbM10pIC8gMi4wO1xuICAgIGNlbnRlclsyXSA9IChib3VuZHNUb1VzZVs0XSArIGJvdW5kc1RvVXNlWzVdKSAvIDIuMDtcblxuICAgIGxldCB3MSA9IGJvdW5kc1RvVXNlWzFdIC0gYm91bmRzVG9Vc2VbMF07XG4gICAgbGV0IHcyID0gYm91bmRzVG9Vc2VbM10gLSBib3VuZHNUb1VzZVsyXTtcbiAgICBsZXQgdzMgPSBib3VuZHNUb1VzZVs1XSAtIGJvdW5kc1RvVXNlWzRdO1xuICAgIHcxICo9IHcxO1xuICAgIHcyICo9IHcyO1xuICAgIHczICo9IHczO1xuICAgIGxldCByYWRpdXMgPSB3MSArIHcyICsgdzM7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGp1c3QgYSBzaW5nbGUgcG9pbnQsIHBpY2sgYSByYWRpdXMgb2YgMS4wXG4gICAgcmFkaXVzID0gcmFkaXVzID09PSAwID8gMS4wIDogcmFkaXVzO1xuXG4gICAgLy8gY29tcHV0ZSB0aGUgcmFkaXVzIG9mIHRoZSBlbmNsb3Npbmcgc3BoZXJlXG4gICAgcmFkaXVzID0gTWF0aC5zcXJ0KHJhZGl1cykgKiAwLjU7XG5cbiAgICAvLyBkZWZhdWx0IHNvIHRoYXQgdGhlIGJvdW5kaW5nIHNwaGVyZSBmaXRzIHdpdGhpbiB0aGUgdmlldyBmdXN0cnVtXG5cbiAgICAvLyBjb21wdXRlIHRoZSBkaXN0YW5jZSBmcm9tIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHZpZXcgZnJ1c3R1bSB3aXRoIHRoZVxuICAgIC8vIGJvdW5kaW5nIHNwaGVyZS4gQmFzaWNhbGx5IGluIDJEIGRyYXcgYSBjaXJjbGUgcmVwcmVzZW50aW5nIHRoZSBib3VuZGluZ1xuICAgIC8vIHNwaGVyZSBpbiAyRCB0aGVuIGRyYXcgYSBob3Jpem9udGFsIGxpbmUgZ29pbmcgb3V0IGZyb20gdGhlIGNlbnRlciBvZlxuICAgIC8vIHRoZSBjaXJjbGUuIFRoYXQgaXMgdGhlIGNhbWVyYSB2aWV3LiBUaGVuIGRyYXcgYSBsaW5lIGZyb20gdGhlIGNhbWVyYVxuICAgIC8vIHBvc2l0aW9uIHRvIHRoZSBwb2ludCB3aGVyZSBpdCBpbnRlcnNlY3RzIHRoZSBjaXJjbGUuIChpdCB3aWxsIGJlIHRhbmdlbnRcbiAgICAvLyB0byB0aGUgY2lyY2xlIGF0IHRoaXMgcG9pbnQsIHRoaXMgaXMgaW1wb3J0YW50LCBvbmx5IGdvIHRvIHRoZSB0YW5nZW50XG4gICAgLy8gcG9pbnQsIGRvIG5vdCBkcmF3IGFsbCB0aGUgd2F5IHRvIHRoZSB2aWV3IHBsYW5lKS4gVGhlbiBkcmF3IHRoZSByYWRpdXNcbiAgICAvLyBmcm9tIHRoZSB0YW5nZW50IHBvaW50IHRvIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZS4gWW91IHdpbGwgbm90ZSB0aGF0XG4gICAgLy8gdGhpcyBmb3JtcyBhIHJpZ2h0IHRyaWFuZ2xlIHdpdGggb25lIHNpZGUgYmVpbmcgdGhlIHJhZGl1cywgYW5vdGhlciBiZWluZ1xuICAgIC8vIHRoZSB0YXJnZXQgZGlzdGFuY2UgZm9yIHRoZSBjYW1lcmEsIHRoZW4ganVzdCBmaW5kIHRoZSB0YXJnZXQgZGlzdCB1c2luZ1xuICAgIC8vIGEgc2luLlxuICAgIGNvbnN0IGFuZ2xlID0gdnRrTWF0aC5yYWRpYW5zRnJvbURlZ3JlZXMobW9kZWwuYWN0aXZlQ2FtZXJhLmdldFZpZXdBbmdsZSgpKTtcbiAgICBjb25zdCBwYXJhbGxlbFNjYWxlID0gcmFkaXVzO1xuICAgIGNvbnN0IGRpc3RhbmNlID0gcmFkaXVzIC8gTWF0aC5zaW4oYW5nbGUgKiAwLjUpO1xuXG4gICAgLy8gY2hlY2sgdmlldy11cCB2ZWN0b3IgYWdhaW5zdCB2aWV3IHBsYW5lIG5vcm1hbFxuICAgIGNvbnN0IHZ1cCA9IG1vZGVsLmFjdGl2ZUNhbWVyYS5nZXRWaWV3VXAoKTtcbiAgICBpZiAoTWF0aC5hYnModnRrTWF0aC5kb3QodnVwLCB2bikpID4gMC45OTkpIHtcbiAgICAgIHZ0a1dhcm5pbmdNYWNybygnUmVzZXR0aW5nIHZpZXctdXAgc2luY2UgdmlldyBwbGFuZSBub3JtYWwgaXMgcGFyYWxsZWwnKTtcbiAgICAgIG1vZGVsLmFjdGl2ZUNhbWVyYS5zZXRWaWV3VXAoLXZ1cFsyXSwgdnVwWzBdLCB2dXBbMV0pO1xuICAgIH1cblxuICAgIC8vIHVwZGF0ZSB0aGUgY2FtZXJhXG4gICAgbW9kZWwuYWN0aXZlQ2FtZXJhLnNldEZvY2FsUG9pbnQoY2VudGVyWzBdLCBjZW50ZXJbMV0sIGNlbnRlclsyXSk7XG4gICAgbW9kZWwuYWN0aXZlQ2FtZXJhLnNldFBvc2l0aW9uKFxuICAgICAgY2VudGVyWzBdICsgZGlzdGFuY2UgKiB2blswXSxcbiAgICAgIGNlbnRlclsxXSArIGRpc3RhbmNlICogdm5bMV0sXG4gICAgICBjZW50ZXJbMl0gKyBkaXN0YW5jZSAqIHZuWzJdXG4gICAgKTtcblxuICAgIHB1YmxpY0FQSS5yZXNldENhbWVyYUNsaXBwaW5nUmFuZ2UoYm91bmRzVG9Vc2UpO1xuXG4gICAgLy8gc2V0dXAgZGVmYXVsdCBwYXJhbGxlbCBzY2FsZVxuICAgIG1vZGVsLmFjdGl2ZUNhbWVyYS5zZXRQYXJhbGxlbFNjYWxlKHBhcmFsbGVsU2NhbGUpO1xuXG4gICAgLy8gdXBkYXRlIHJlYXNvbmFibGUgd29ybGQgdG8gcGh5c2ljYWwgdmFsdWVzXG4gICAgbW9kZWwuYWN0aXZlQ2FtZXJhLnNldFBoeXNpY2FsU2NhbGUocmFkaXVzKTtcbiAgICBtb2RlbC5hY3RpdmVDYW1lcmEuc2V0UGh5c2ljYWxUcmFuc2xhdGlvbihcbiAgICAgIC1jZW50ZXJbMF0sXG4gICAgICAtY2VudGVyWzFdLFxuICAgICAgLWNlbnRlclsyXVxuICAgICk7XG5cbiAgICAvLyBIZXJlIHRvIGxldCBwYXJhbGxlbC9kaXN0cmlidXRlZCBjb21wb3NpdGluZyBpbnRlcmNlcHRcbiAgICAvLyBhbmQgZG8gdGhlIHJpZ2h0IHRoaW5nLlxuICAgIHB1YmxpY0FQSS5pbnZva2VFdmVudChSRVNFVF9DQU1FUkFfRVZFTlQpO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLnJlc2V0Q2FtZXJhQ2xpcHBpbmdSYW5nZSA9IChib3VuZHMgPSBudWxsKSA9PiB7XG4gICAgY29uc3QgYm91bmRzVG9Vc2UgPSBib3VuZHMgfHwgcHVibGljQVBJLmNvbXB1dGVWaXNpYmxlUHJvcEJvdW5kcygpO1xuXG4gICAgaWYgKCF2dGtNYXRoLmFyZUJvdW5kc0luaXRpYWxpemVkKGJvdW5kc1RvVXNlKSkge1xuICAgICAgdnRrRGVidWdNYWNybygnQ2Fubm90IHJlc2V0IGNhbWVyYSBjbGlwcGluZyByYW5nZSEnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhbiBhY3RpdmUgY2FtZXJhXG4gICAgcHVibGljQVBJLmdldEFjdGl2ZUNhbWVyYUFuZFJlc2V0SWZDcmVhdGVkKCk7XG4gICAgaWYgKCFtb2RlbC5hY3RpdmVDYW1lcmEpIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oJ1RyeWluZyB0byByZXNldCBjbGlwcGluZyByYW5nZSBvZiBub24tZXhpc3RlbnQgY2FtZXJhJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBleGFjdCByYW5nZSBmb3IgdGhlIGJvdW5kc1xuICAgIGNvbnN0IHJhbmdlID0gbW9kZWwuYWN0aXZlQ2FtZXJhLmNvbXB1dGVDbGlwcGluZ1JhbmdlKGJvdW5kc1RvVXNlKTtcblxuICAgIC8vIGRvIG5vdCBsZXQgZmFyIC0gbmVhciBiZSBsZXNzIHRoYW4gMC4xIG9mIHRoZSB3aW5kb3cgaGVpZ2h0XG4gICAgLy8gdGhpcyBpcyBmb3IgY2FzZXMgc3VjaCBhcyAyRCBpbWFnZXMgd2hpY2ggbWF5IGhhdmUgemVybyByYW5nZVxuICAgIGxldCBtaW5HYXAgPSAwLjA7XG4gICAgaWYgKG1vZGVsLmFjdGl2ZUNhbWVyYS5nZXRQYXJhbGxlbFByb2plY3Rpb24oKSkge1xuICAgICAgbWluR2FwID0gMC4xICogbW9kZWwuYWN0aXZlQ2FtZXJhLmdldFBhcmFsbGVsU2NhbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYW5nbGUgPSB2dGtNYXRoLnJhZGlhbnNGcm9tRGVncmVlcyhcbiAgICAgICAgbW9kZWwuYWN0aXZlQ2FtZXJhLmdldFZpZXdBbmdsZSgpXG4gICAgICApO1xuICAgICAgbWluR2FwID0gMC4yICogTWF0aC50YW4oYW5nbGUgLyAyLjApICogcmFuZ2VbMV07XG4gICAgfVxuXG4gICAgaWYgKHJhbmdlWzFdIC0gcmFuZ2VbMF0gPCBtaW5HYXApIHtcbiAgICAgIG1pbkdhcCA9IG1pbkdhcCAtIHJhbmdlWzFdICsgcmFuZ2VbMF07XG4gICAgICByYW5nZVsxXSArPSBtaW5HYXAgLyAyLjA7XG4gICAgICByYW5nZVswXSAtPSBtaW5HYXAgLyAyLjA7XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGxldCB0aGUgcmFuZ2UgYmVoaW5kIHRoZSBjYW1lcmEgdGhyb3cgb2ZmIHRoZSBjYWxjdWxhdGlvbi5cbiAgICBpZiAocmFuZ2VbMF0gPCAwLjApIHtcbiAgICAgIHJhbmdlWzBdID0gMC4wO1xuICAgIH1cblxuICAgIC8vIEdpdmUgb3Vyc2VsdmVzIGEgbGl0dGxlIGJyZWF0aGluZyByb29tXG4gICAgcmFuZ2VbMF0gPVxuICAgICAgMC45OSAqIHJhbmdlWzBdIC0gKHJhbmdlWzFdIC0gcmFuZ2VbMF0pICogbW9kZWwuY2xpcHBpbmdSYW5nZUV4cGFuc2lvbjtcbiAgICByYW5nZVsxXSA9XG4gICAgICAxLjAxICogcmFuZ2VbMV0gKyAocmFuZ2VbMV0gLSByYW5nZVswXSkgKiBtb2RlbC5jbGlwcGluZ1JhbmdlRXhwYW5zaW9uO1xuXG4gICAgLy8gTWFrZSBzdXJlIG5lYXIgaXMgbm90IGJpZ2dlciB0aGFuIGZhclxuICAgIHJhbmdlWzBdID0gcmFuZ2VbMF0gPj0gcmFuZ2VbMV0gPyAwLjAxICogcmFuZ2VbMV0gOiByYW5nZVswXTtcblxuICAgIC8vIE1ha2Ugc3VyZSBuZWFyIGlzIGF0IGxlYXN0IHNvbWUgZnJhY3Rpb24gb2YgZmFyIC0gdGhpcyBwcmV2ZW50cyBuZWFyXG4gICAgLy8gZnJvbSBiZWluZyBiZWhpbmQgdGhlIGNhbWVyYSBvciB0b28gY2xvc2UgaW4gZnJvbnQuIEhvdyBjbG9zZSBpcyB0b29cbiAgICAvLyBjbG9zZSBkZXBlbmRzIG9uIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBkZXB0aCBidWZmZXJcbiAgICBpZiAoIW1vZGVsLm5lYXJDbGlwcGluZ1BsYW5lVG9sZXJhbmNlKSB7XG4gICAgICBtb2RlbC5uZWFyQ2xpcHBpbmdQbGFuZVRvbGVyYW5jZSA9IDAuMDE7XG4gICAgfVxuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBmcm9udCBjbGlwcGluZyByYW5nZSBpcyBub3QgdG9vIGZhciBmcm9tIHRoZSBmYXIgY2xpcHBuaWdcbiAgICAvLyByYW5nZSwgdGhpcyBpcyB0byBtYWtlIHN1cmUgdGhhdCB0aGUgemJ1ZmZlciByZXNvbHV0aW9uIGlzIGVmZmVjdGl2ZWx5XG4gICAgLy8gdXNlZFxuICAgIGlmIChyYW5nZVswXSA8IG1vZGVsLm5lYXJDbGlwcGluZ1BsYW5lVG9sZXJhbmNlICogcmFuZ2VbMV0pIHtcbiAgICAgIHJhbmdlWzBdID0gbW9kZWwubmVhckNsaXBwaW5nUGxhbmVUb2xlcmFuY2UgKiByYW5nZVsxXTtcbiAgICB9XG4gICAgbW9kZWwuYWN0aXZlQ2FtZXJhLnNldENsaXBwaW5nUmFuZ2UocmFuZ2VbMF0sIHJhbmdlWzFdKTtcblxuICAgIC8vIEhlcmUgdG8gbGV0IHBhcmFsbGVsL2Rpc3RyaWJ1dGVkIGNvbXBvc2l0aW5nIGludGVyY2VwdFxuICAgIC8vIGFuZCBkbyB0aGUgcmlnaHQgdGhpbmcuXG4gICAgcHVibGljQVBJLmludm9rZUV2ZW50KFJFU0VUX0NBTUVSQV9DTElQUElOR19SQU5HRV9FVkVOVCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRSZW5kZXJXaW5kb3cgPSAocmVuZGVyV2luZG93KSA9PiB7XG4gICAgaWYgKHJlbmRlcldpbmRvdyAhPT0gbW9kZWwucmVuZGVyV2luZG93KSB7XG4gICAgICBtb2RlbC52dGtXaW5kb3cgPSByZW5kZXJXaW5kb3c7XG4gICAgICBtb2RlbC5yZW5kZXJXaW5kb3cgPSByZW5kZXJXaW5kb3c7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS52aXNpYmxlQWN0b3JDb3VudCA9ICgpID0+XG4gICAgbW9kZWwucHJvcHMuZmlsdGVyKChwcm9wKSA9PiBwcm9wLmdldFZpc2liaWxpdHkoKSkubGVuZ3RoO1xuICBwdWJsaWNBUEkudmlzaWJsZVZvbHVtZUNvdW50ID0gcHVibGljQVBJLnZpc2libGVBY3RvckNvdW50O1xuXG4gIHB1YmxpY0FQSS5nZXRNVGltZSA9ICgpID0+IHtcbiAgICBsZXQgbTEgPSBtb2RlbC5tdGltZTtcbiAgICBjb25zdCBtMiA9IG1vZGVsLmFjdGl2ZUNhbWVyYSA/IG1vZGVsLmFjdGl2ZUNhbWVyYS5nZXRNVGltZSgpIDogMDtcbiAgICBpZiAobTIgPiBtMSkge1xuICAgICAgbTEgPSBtMjtcbiAgICB9XG4gICAgY29uc3QgbTMgPSBtb2RlbC5jcmVhdGVkTGlnaHQgPyBtb2RlbC5jcmVhdGVkTGlnaHQuZ2V0TVRpbWUoKSA6IDA7XG4gICAgaWYgKG0zID4gbTEpIHtcbiAgICAgIG0xID0gbTM7XG4gICAgfVxuICAgIHJldHVybiBtMTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0VHJhbnNwYXJlbnQgPSAoKSA9PiAhIW1vZGVsLnByZXNlcnZlQ29sb3JCdWZmZXI7XG5cbiAgcHVibGljQVBJLmlzQWN0aXZlQ2FtZXJhQ3JlYXRlZCA9ICgpID0+ICEhbW9kZWwuYWN0aXZlQ2FtZXJhO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgcGlja2VkUHJvcDogbnVsbCxcbiAgYWN0aXZlQ2FtZXJhOiBudWxsLFxuXG4gIGFsbEJvdW5kczogW10sXG4gIGFtYmllbnQ6IFsxLCAxLCAxXSxcblxuICBhbGxvY2F0ZWRSZW5kZXJUaW1lOiAxMDAsXG4gIHRpbWVGYWN0b3I6IDEsXG5cbiAgY3JlYXRlZExpZ2h0OiBudWxsLFxuICBhdXRvbWF0aWNMaWdodENyZWF0aW9uOiB0cnVlLFxuXG4gIHR3b1NpZGVkTGlnaHRpbmc6IHRydWUsXG4gIGxhc3RSZW5kZXJUaW1lSW5TZWNvbmRzOiAtMSxcblxuICByZW5kZXJXaW5kb3c6IG51bGwsXG4gIGxpZ2h0czogW10sXG4gIGFjdG9yczogW10sXG4gIHZvbHVtZXM6IFtdLFxuXG4gIGxpZ2h0Rm9sbG93Q2FtZXJhOiB0cnVlLFxuXG4gIG51bWJlck9mUHJvcHNSZW5kZXJlZDogMCxcblxuICBwcm9wQXJyYXk6IG51bGwsXG5cbiAgcGF0aEFycmF5OiBudWxsLFxuXG4gIGxheWVyOiAwLFxuICBwcmVzZXJ2ZUNvbG9yQnVmZmVyOiBmYWxzZSxcbiAgcHJlc2VydmVEZXB0aEJ1ZmZlcjogZmFsc2UsXG5cbiAgY29tcHV0ZVZpc2libGVQcm9wQm91bmRzOiB2dGtNYXRoLmNyZWF0ZVVuaW5pdGlhbGl6ZWRCb3VuZHMoKSxcblxuICBpbnRlcmFjdGl2ZTogdHJ1ZSxcblxuICBuZWFyQ2xpcHBpbmdQbGFuZVRvbGVyYW5jZTogMCxcbiAgY2xpcHBpbmdSYW5nZUV4cGFuc2lvbjogMC4wNSxcblxuICBlcmFzZTogdHJ1ZSxcbiAgZHJhdzogdHJ1ZSxcblxuICB1c2VTaGFkb3dzOiBmYWxzZSxcblxuICB1c2VEZXB0aFBlZWxpbmc6IGZhbHNlLFxuICBvY2NsdXNpb25SYXRpbzogMCxcbiAgbWF4aW11bU51bWJlck9mUGVlbHM6IDQsXG5cbiAgc2VsZWN0b3I6IG51bGwsXG4gIGRlbGVnYXRlOiBudWxsLFxuXG4gIHRleHR1cmVkQmFja2dyb3VuZDogZmFsc2UsXG4gIGJhY2tncm91bmRUZXh0dXJlOiBudWxsLFxuXG4gIHBhc3M6IDAsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBJbmhlcml0YW5jZVxuICB2dGtWaWV3cG9ydC5leHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gQnVpbGQgVlRLIEFQSVxuICBtYWNyby5nZXQocHVibGljQVBJLCBtb2RlbCwgW1xuICAgICdyZW5kZXJXaW5kb3cnLFxuXG4gICAgJ2FsbG9jYXRlZFJlbmRlclRpbWUnLFxuICAgICd0aW1lRmFjdG9yJyxcblxuICAgICdsYXN0UmVuZGVyVGltZUluU2Vjb25kcycsXG4gICAgJ251bWJlck9mUHJvcHNSZW5kZXJlZCcsXG4gICAgJ2xhc3RSZW5kZXJpbmdVc2VkRGVwdGhQZWVsaW5nJyxcblxuICAgICdzZWxlY3RvcicsXG4gIF0pO1xuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgW1xuICAgICd0d29TaWRlZExpZ2h0aW5nJyxcbiAgICAnbGlnaHRGb2xsb3dDYW1lcmEnLFxuICAgICdhdXRvbWF0aWNMaWdodENyZWF0aW9uJyxcbiAgICAnZXJhc2UnLFxuICAgICdkcmF3JyxcbiAgICAnbmVhckNsaXBwaW5nUGxhbmVUb2xlcmFuY2UnLFxuICAgICdjbGlwcGluZ1JhbmdlRXhwYW5zaW9uJyxcbiAgICAnYmFja2luZ1N0b3JlJyxcbiAgICAnaW50ZXJhY3RpdmUnLFxuICAgICdsYXllcicsXG4gICAgJ3ByZXNlcnZlQ29sb3JCdWZmZXInLFxuICAgICdwcmVzZXJ2ZURlcHRoQnVmZmVyJyxcbiAgICAndXNlRGVwdGhQZWVsaW5nJyxcbiAgICAnb2NjbHVzaW9uUmF0aW8nLFxuICAgICdtYXhpbXVtTnVtYmVyT2ZQZWVscycsXG4gICAgJ2RlbGVnYXRlJyxcbiAgICAnYmFja2dyb3VuZFRleHR1cmUnLFxuICAgICd0ZXh0dXJlZEJhY2tncm91bmQnLFxuICAgICd1c2VTaGFkb3dzJyxcbiAgICAncGFzcycsXG4gIF0pO1xuICBtYWNyby5nZXRBcnJheShwdWJsaWNBUEksIG1vZGVsLCBbJ2FjdG9ycycsICd2b2x1bWVzJywgJ2xpZ2h0cyddKTtcbiAgbWFjcm8uc2V0R2V0QXJyYXkocHVibGljQVBJLCBtb2RlbCwgWydiYWNrZ3JvdW5kJ10sIDQsIDEuMCk7XG5cbiAgLy8gT2JqZWN0IG1ldGhvZHNcbiAgdnRrUmVuZGVyZXIocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrUmVuZGVyZXInKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5cbmNvbnN0IHsgdnRrRXJyb3JNYWNybyB9ID0gbWFjcm87XG5cbmZ1bmN0aW9uIG5vdEltcGxlbWVudGVkKG1ldGhvZCkge1xuICByZXR1cm4gKCkgPT4gdnRrRXJyb3JNYWNybyhgdnRrVmlld3BvcnQ6OiR7bWV0aG9kfSAtIE5PVCBJTVBMRU1FTlRFRGApO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtWaWV3cG9ydCBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a1ZpZXdwb3J0KHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrVmlld3BvcnQnKTtcblxuICAvLyBQdWJsaWMgQVBJIG1ldGhvZHNcbiAgcHVibGljQVBJLmdldFZpZXdQcm9wcyA9ICgpID0+IG1vZGVsLnByb3BzO1xuICBwdWJsaWNBUEkuaGFzVmlld1Byb3AgPSAocHJvcCkgPT5cbiAgICAhIW1vZGVsLnByb3BzLmZpbHRlcigoaXRlbSkgPT4gaXRlbSA9PT0gcHJvcCkubGVuZ3RoO1xuICBwdWJsaWNBUEkuYWRkVmlld1Byb3AgPSAocHJvcCkgPT4ge1xuICAgIGlmIChwcm9wICYmICFwdWJsaWNBUEkuaGFzVmlld1Byb3AocHJvcCkpIHtcbiAgICAgIG1vZGVsLnByb3BzID0gbW9kZWwucHJvcHMuY29uY2F0KHByb3ApO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkucmVtb3ZlVmlld1Byb3AgPSAocHJvcCkgPT4ge1xuICAgIGNvbnN0IG5ld1Byb3BMaXN0ID0gbW9kZWwucHJvcHMuZmlsdGVyKChpdGVtKSA9PiBpdGVtICE9PSBwcm9wKTtcbiAgICBpZiAobW9kZWwucHJvcHMubGVuZ3RoICE9PSBuZXdQcm9wTGlzdC5sZW5ndGgpIHtcbiAgICAgIG1vZGVsLnByb3BzID0gbmV3UHJvcExpc3Q7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5yZW1vdmVBbGxWaWV3UHJvcHMgPSAoKSA9PiB7XG4gICAgbW9kZWwucHJvcHMgPSBbXTtcbiAgfTtcblxuICAvLyB0aGlzIG1ldGhvZCBnZXQgYWxsIHRoZSBwcm9wcyBpbmNsdWRpbmcgYW55IG5lc3RlZCBwcm9wc1xuICBmdW5jdGlvbiBnYXRoZXJQcm9wcyhwcm9wLCBhbGxQcm9wcyA9IFtdKSB7XG4gICAgYWxsUHJvcHMucHVzaChwcm9wKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHByb3AuZ2V0TmVzdGVkUHJvcHMoKTtcbiAgICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGdhdGhlclByb3BzKGNoaWxkcmVuW2ldLCBhbGxQcm9wcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbGxQcm9wcztcbiAgfVxuXG4gIHB1YmxpY0FQSS5nZXRWaWV3UHJvcHNXaXRoTmVzdGVkUHJvcHMgPSAoKSA9PiB7XG4gICAgY29uc3QgYWxsUHJvcHNBcnJheSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kZWwucHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdhdGhlclByb3BzKG1vZGVsLnByb3BzW2ldLCBhbGxQcm9wc0FycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbFByb3BzQXJyYXk7XG4gIH07XG5cbiAgcHVibGljQVBJLmFkZEFjdG9yMkQgPSBwdWJsaWNBUEkuYWRkVmlld1Byb3A7XG4gIHB1YmxpY0FQSS5yZW1vdmVBY3RvcjJEID0gKHByb3ApID0+IHtcbiAgICAvLyBWVEsgd2F5OiBtb2RlbC5hY3RvcnMyRC5SZW1vdmVJdGVtKHByb3ApO1xuICAgIHB1YmxpY0FQSS5yZW1vdmVWaWV3UHJvcChwcm9wKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0QWN0b3JzMkQgPSAoKSA9PiB7XG4gICAgbW9kZWwuYWN0b3JzMkQgPSBbXTtcbiAgICBtb2RlbC5wcm9wcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICBtb2RlbC5hY3RvcnMyRCA9IG1vZGVsLmFjdG9yczJELmNvbmNhdChwcm9wLmdldEFjdG9yczJEKCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBtb2RlbC5hY3RvcnMyRDtcbiAgfTtcblxuICBwdWJsaWNBUEkuZGlzcGxheVRvVmlldyA9ICgpID0+XG4gICAgdnRrRXJyb3JNYWNybygnY2FsbCBkaXNwbGF5VG9WaWV3IG9uIHlvdXIgdmlldyBpbnN0ZWFkJyk7XG4gIHB1YmxpY0FQSS52aWV3VG9EaXNwbGF5ID0gKCkgPT5cbiAgICB2dGtFcnJvck1hY3JvKCdjYWxsdmlld3RvZGlzcGxheSBvbiB5b3VyIHZpZXcgaW5zdGVhZCcpO1xuICBwdWJsaWNBUEkuZ2V0U2l6ZSA9ICgpID0+IHZ0a0Vycm9yTWFjcm8oJ2NhbGwgZ2V0U2l6ZSBvbiB5b3VyIFZpZXcgaW5zdGVhZCcpO1xuXG4gIHB1YmxpY0FQSS5ub3JtYWxpemVkRGlzcGxheVRvUHJvamVjdGlvbiA9ICh4LCB5LCB6KSA9PiB7XG4gICAgLy8gZmlyc3QgdG8gbm9ybWFsaXplZCB2aWV3cG9ydFxuICAgIGNvbnN0IG52cCA9IHB1YmxpY0FQSS5ub3JtYWxpemVkRGlzcGxheVRvTm9ybWFsaXplZFZpZXdwb3J0KHgsIHksIHopO1xuXG4gICAgLy8gdGhlbiB0byB2aWV3XG4gICAgcmV0dXJuIHB1YmxpY0FQSS5ub3JtYWxpemVkVmlld3BvcnRUb1Byb2plY3Rpb24obnZwWzBdLCBudnBbMV0sIG52cFsyXSk7XG4gIH07XG5cbiAgcHVibGljQVBJLm5vcm1hbGl6ZWREaXNwbGF5VG9Ob3JtYWxpemVkVmlld3BvcnQgPSAoeCwgeSwgeikgPT4ge1xuICAgIGNvbnN0IHNjYWxlID0gW1xuICAgICAgbW9kZWwudmlld3BvcnRbMl0gLSBtb2RlbC52aWV3cG9ydFswXSxcbiAgICAgIG1vZGVsLnZpZXdwb3J0WzNdIC0gbW9kZWwudmlld3BvcnRbMV0sXG4gICAgXTtcbiAgICByZXR1cm4gW1xuICAgICAgKHggLSBtb2RlbC52aWV3cG9ydFswXSkgLyBzY2FsZVswXSxcbiAgICAgICh5IC0gbW9kZWwudmlld3BvcnRbMV0pIC8gc2NhbGVbMV0sXG4gICAgICB6LFxuICAgIF07XG4gIH07XG5cbiAgcHVibGljQVBJLm5vcm1hbGl6ZWRWaWV3cG9ydFRvUHJvamVjdGlvbiA9ICh4LCB5LCB6KSA9PiBbXG4gICAgeCAqIDIuMCAtIDEuMCxcbiAgICB5ICogMi4wIC0gMS4wLFxuICAgIHogKiAyLjAgLSAxLjAsXG4gIF07XG5cbiAgcHVibGljQVBJLnByb2plY3Rpb25Ub05vcm1hbGl6ZWREaXNwbGF5ID0gKHgsIHksIHopID0+IHtcbiAgICAvLyBmaXJzdCB0byBudnBcbiAgICBjb25zdCBudnAgPSBwdWJsaWNBUEkucHJvamVjdGlvblRvTm9ybWFsaXplZFZpZXdwb3J0KHgsIHksIHopO1xuXG4gICAgLy8gdGhlbiB0byBuZHBcbiAgICByZXR1cm4gcHVibGljQVBJLm5vcm1hbGl6ZWRWaWV3cG9ydFRvTm9ybWFsaXplZERpc3BsYXkoXG4gICAgICBudnBbMF0sXG4gICAgICBudnBbMV0sXG4gICAgICBudnBbMl1cbiAgICApO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5ub3JtYWxpemVkVmlld3BvcnRUb05vcm1hbGl6ZWREaXNwbGF5ID0gKHgsIHksIHopID0+IHtcbiAgICBjb25zdCBzY2FsZSA9IFtcbiAgICAgIG1vZGVsLnZpZXdwb3J0WzJdIC0gbW9kZWwudmlld3BvcnRbMF0sXG4gICAgICBtb2RlbC52aWV3cG9ydFszXSAtIG1vZGVsLnZpZXdwb3J0WzFdLFxuICAgIF07XG4gICAgcmV0dXJuIFtcbiAgICAgIHggKiBzY2FsZVswXSArIG1vZGVsLnZpZXdwb3J0WzBdLFxuICAgICAgeSAqIHNjYWxlWzFdICsgbW9kZWwudmlld3BvcnRbMV0sXG4gICAgICB6LFxuICAgIF07XG4gIH07XG5cbiAgcHVibGljQVBJLnByb2plY3Rpb25Ub05vcm1hbGl6ZWRWaWV3cG9ydCA9ICh4LCB5LCB6KSA9PiBbXG4gICAgKHggKyAxLjApICogMC41LFxuICAgICh5ICsgMS4wKSAqIDAuNSxcbiAgICAoeiArIDEuMCkgKiAwLjUsXG4gIF07XG5cbiAgcHVibGljQVBJLlBpY2tQcm9wRnJvbSA9IG5vdEltcGxlbWVudGVkKCdQaWNrUHJvcEZyb20nKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIHZ0a1dpbmRvdzogbnVsbCxcbiAgYmFja2dyb3VuZDogWzAsIDAsIDBdLFxuICBiYWNrZ3JvdW5kMjogWzAuMiwgMC4yLCAwLjJdLFxuICBncmFkaWVudEJhY2tncm91bmQ6IGZhbHNlLFxuICB2aWV3cG9ydDogWzAsIDAsIDEsIDFdLFxuICBhc3BlY3Q6IFsxLCAxXSxcbiAgcGl4ZWxBc3BlY3Q6IFsxLCAxXSxcbiAgcHJvcHM6IFtdLFxuICBhY3RvcnMyRDogW10sXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBCdWlsZCBWVEsgQVBJXG4gIG1hY3JvLm9iaihwdWJsaWNBUEksIG1vZGVsKTtcbiAgbWFjcm8uZXZlbnQocHVibGljQVBJLCBtb2RlbCwgJ2V2ZW50Jyk7XG5cbiAgbWFjcm8uc2V0R2V0QXJyYXkocHVibGljQVBJLCBtb2RlbCwgWyd2aWV3cG9ydCddLCA0KTtcblxuICBtYWNyby5zZXRHZXRBcnJheShwdWJsaWNBUEksIG1vZGVsLCBbJ2JhY2tncm91bmQnLCAnYmFja2dyb3VuZDInXSwgMyk7XG5cbiAgdnRrVmlld3BvcnQocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrVmlld3BvcnQnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImV4cG9ydCBjb25zdCBCbGVuZE1vZGUgPSB7XG4gIENPTVBPU0lURV9CTEVORDogMCxcbiAgTUFYSU1VTV9JTlRFTlNJVFlfQkxFTkQ6IDEsXG4gIE1JTklNVU1fSU5URU5TSVRZX0JMRU5EOiAyLFxuICBBVkVSQUdFX0lOVEVOU0lUWV9CTEVORDogMyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgQmxlbmRNb2RlLFxufTtcbiIsImV4cG9ydCBjb25zdCBJbnRlcnBvbGF0aW9uVHlwZSA9IHtcbiAgTkVBUkVTVDogMCxcbiAgTElORUFSOiAxLFxuICBGQVNUX0xJTkVBUjogMixcbn07XG5cbmV4cG9ydCBjb25zdCBPcGFjaXR5TW9kZSA9IHtcbiAgRlJBQ1RJT05BTDogMCxcbiAgUFJPUE9SVElPTkFMOiAxLFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBJbnRlcnBvbGF0aW9uVHlwZSxcbiAgT3BhY2l0eU1vZGUsXG59O1xuIiwiaW1wb3J0IHsgbWF0MywgbWF0NCB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgdnRrVmlld05vZGUgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL1NjZW5lR3JhcGgvVmlld05vZGUnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtPcGVuR0xBY3RvciBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a09wZW5HTEFjdG9yKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrT3BlbkdMQWN0b3InKTtcblxuICAvLyBCdWlsZHMgbXlzZWxmLlxuICBwdWJsaWNBUEkuYnVpbGRQYXNzID0gKHByZXBhc3MpID0+IHtcbiAgICBpZiAocHJlcGFzcykge1xuICAgICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93ID0gcHVibGljQVBJLmdldEZpcnN0QW5jZXN0b3JPZlR5cGUoXG4gICAgICAgICd2dGtPcGVuR0xSZW5kZXJXaW5kb3cnXG4gICAgICApO1xuICAgICAgbW9kZWwub3BlbkdMUmVuZGVyZXIgPSBwdWJsaWNBUEkuZ2V0Rmlyc3RBbmNlc3Rvck9mVHlwZShcbiAgICAgICAgJ3Z0a09wZW5HTFJlbmRlcmVyJ1xuICAgICAgKTtcbiAgICAgIG1vZGVsLmNvbnRleHQgPSBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0Q29udGV4dCgpO1xuICAgICAgcHVibGljQVBJLnByZXBhcmVOb2RlcygpO1xuICAgICAgcHVibGljQVBJLmFkZE1pc3NpbmdOb2Rlcyhtb2RlbC5yZW5kZXJhYmxlLmdldFRleHR1cmVzKCkpO1xuICAgICAgcHVibGljQVBJLmFkZE1pc3NpbmdOb2RlKG1vZGVsLnJlbmRlcmFibGUuZ2V0TWFwcGVyKCkpO1xuICAgICAgcHVibGljQVBJLnJlbW92ZVVudXNlZE5vZGVzKCk7XG5cbiAgICAgIC8vIHdlIHN0b3JlIHRleHR1cmVzIGFuZCBtYXBwZXJcbiAgICAgIG1vZGVsLm9nbHRleHR1cmVzID0gbnVsbDtcbiAgICAgIG1vZGVsLmFjdGl2ZVRleHR1cmVzID0gbnVsbDtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtb2RlbC5jaGlsZHJlbi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBtb2RlbC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgIGlmIChjaGlsZC5pc0EoJ3Z0a09wZW5HTFRleHR1cmUnKSkge1xuICAgICAgICAgIGlmICghbW9kZWwub2dsdGV4dHVyZXMpIHtcbiAgICAgICAgICAgIG1vZGVsLm9nbHRleHR1cmVzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIG1vZGVsLm9nbHRleHR1cmVzLnB1c2goY2hpbGQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVsLm9nbG1hcHBlciA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS50cmF2ZXJzZU9wYXF1ZVpCdWZmZXJQYXNzID0gKHJlbmRlclBhc3MpID0+IHtcbiAgICBwdWJsaWNBUEkudHJhdmVyc2VPcGFxdWVQYXNzKHJlbmRlclBhc3MpO1xuICB9O1xuXG4gIC8vIHdlIGRyYXcgdGV4dHVyZXMsIHRoZW4gbWFwcGVyLCB0aGVuIHBvc3QgcGFzcyB0ZXh0dXJlc1xuICBwdWJsaWNBUEkudHJhdmVyc2VPcGFxdWVQYXNzID0gKHJlbmRlclBhc3MpID0+IHtcbiAgICBpZiAoXG4gICAgICAhbW9kZWwucmVuZGVyYWJsZSB8fFxuICAgICAgIW1vZGVsLnJlbmRlcmFibGUuZ2V0VmlzaWJpbGl0eSgpIHx8XG4gICAgICAhbW9kZWwucmVuZGVyYWJsZS5nZXRJc09wYXF1ZSgpIHx8XG4gICAgICAobW9kZWwub3BlbkdMUmVuZGVyZXIuZ2V0U2VsZWN0b3IoKSAmJiAhbW9kZWwucmVuZGVyYWJsZS5nZXRQaWNrYWJsZSgpKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHB1YmxpY0FQSS5hcHBseShyZW5kZXJQYXNzLCB0cnVlKTtcblxuICAgIG1vZGVsLm9nbG1hcHBlci50cmF2ZXJzZShyZW5kZXJQYXNzKTtcblxuICAgIHB1YmxpY0FQSS5hcHBseShyZW5kZXJQYXNzLCBmYWxzZSk7XG4gIH07XG5cbiAgLy8gd2UgZHJhdyB0ZXh0dXJlcywgdGhlbiBtYXBwZXIsIHRoZW4gcG9zdCBwYXNzIHRleHR1cmVzXG4gIHB1YmxpY0FQSS50cmF2ZXJzZVRyYW5zbHVjZW50UGFzcyA9IChyZW5kZXJQYXNzKSA9PiB7XG4gICAgaWYgKFxuICAgICAgIW1vZGVsLnJlbmRlcmFibGUgfHxcbiAgICAgICFtb2RlbC5yZW5kZXJhYmxlLmdldFZpc2liaWxpdHkoKSB8fFxuICAgICAgbW9kZWwucmVuZGVyYWJsZS5nZXRJc09wYXF1ZSgpIHx8XG4gICAgICAobW9kZWwub3BlbkdMUmVuZGVyZXIuZ2V0U2VsZWN0b3IoKSAmJiAhbW9kZWwucmVuZGVyYWJsZS5nZXRQaWNrYWJsZSgpKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHB1YmxpY0FQSS5hcHBseShyZW5kZXJQYXNzLCB0cnVlKTtcblxuICAgIG1vZGVsLm9nbG1hcHBlci50cmF2ZXJzZShyZW5kZXJQYXNzKTtcblxuICAgIHB1YmxpY0FQSS5hcHBseShyZW5kZXJQYXNzLCBmYWxzZSk7XG4gIH07XG5cbiAgcHVibGljQVBJLmFjdGl2YXRlVGV4dHVyZXMgPSAoKSA9PiB7XG4gICAgLy8gYWx3YXlzIHRyYXZlcnNlIHRleHR1cmVzIGZpcnN0LCB0aGVuIG1hcHBlclxuICAgIGlmICghbW9kZWwub2dsdGV4dHVyZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtb2RlbC5hY3RpdmVUZXh0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtb2RlbC5vZ2x0ZXh0dXJlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbW9kZWwub2dsdGV4dHVyZXNbaW5kZXhdO1xuICAgICAgY2hpbGQucmVuZGVyKCk7XG4gICAgICBpZiAoY2hpbGQuZ2V0SGFuZGxlKCkpIHtcbiAgICAgICAgbW9kZWwuYWN0aXZlVGV4dHVyZXMucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5xdWVyeVBhc3MgPSAocHJlcGFzcywgcmVuZGVyUGFzcykgPT4ge1xuICAgIGlmIChwcmVwYXNzKSB7XG4gICAgICBpZiAoIW1vZGVsLnJlbmRlcmFibGUgfHwgIW1vZGVsLnJlbmRlcmFibGUuZ2V0VmlzaWJpbGl0eSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbC5yZW5kZXJhYmxlLmdldElzT3BhcXVlKCkpIHtcbiAgICAgICAgcmVuZGVyUGFzcy5pbmNyZW1lbnRPcGFxdWVBY3RvckNvdW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJQYXNzLmluY3JlbWVudFRyYW5zbHVjZW50QWN0b3JDb3VudCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkub3BhcXVlWkJ1ZmZlclBhc3MgPSAocHJlcGFzcywgcmVuZGVyUGFzcykgPT5cbiAgICBwdWJsaWNBUEkub3BhcXVlUGFzcyhwcmVwYXNzLCByZW5kZXJQYXNzKTtcblxuICBwdWJsaWNBUEkub3BhcXVlUGFzcyA9IChwcmVwYXNzLCByZW5kZXJQYXNzKSA9PiB7XG4gICAgaWYgKHByZXBhc3MpIHtcbiAgICAgIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5lbmFibGVEZXB0aE1hc2soKTtcbiAgICAgIHB1YmxpY0FQSS5hY3RpdmF0ZVRleHR1cmVzKCk7XG4gICAgfSBlbHNlIGlmIChtb2RlbC5hY3RpdmVUZXh0dXJlcykge1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG1vZGVsLmFjdGl2ZVRleHR1cmVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBtb2RlbC5hY3RpdmVUZXh0dXJlc1tpbmRleF0uZGVhY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBSZW5kZXJzIG15c2VsZlxuICBwdWJsaWNBUEkudHJhbnNsdWNlbnRQYXNzID0gKHByZXBhc3MsIHJlbmRlclBhc3MpID0+IHtcbiAgICBpZiAocHJlcGFzcykge1xuICAgICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmRpc2FibGVEZXB0aE1hc2soKTtcbiAgICAgIHB1YmxpY0FQSS5hY3RpdmF0ZVRleHR1cmVzKCk7XG4gICAgfSBlbHNlIGlmIChtb2RlbC5hY3RpdmVUZXh0dXJlcykge1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG1vZGVsLmFjdGl2ZVRleHR1cmVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBtb2RlbC5hY3RpdmVUZXh0dXJlc1tpbmRleF0uZGVhY3RpdmF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0S2V5TWF0cmljZXMgPSAoKSA9PiB7XG4gICAgLy8gaGFzIHRoZSBhY3RvciBjaGFuZ2VkP1xuICAgIGlmIChtb2RlbC5yZW5kZXJhYmxlLmdldE1UaW1lKCkgPiBtb2RlbC5rZXlNYXRyaXhUaW1lLmdldE1UaW1lKCkpIHtcbiAgICAgIG1vZGVsLnJlbmRlcmFibGUuY29tcHV0ZU1hdHJpeCgpO1xuICAgICAgbWF0NC5jb3B5KG1vZGVsLmtleU1hdHJpY2VzLm1jd2MsIG1vZGVsLnJlbmRlcmFibGUuZ2V0TWF0cml4KCkpO1xuICAgICAgbWF0NC50cmFuc3Bvc2UobW9kZWwua2V5TWF0cmljZXMubWN3YywgbW9kZWwua2V5TWF0cmljZXMubWN3Yyk7XG5cbiAgICAgIGlmIChtb2RlbC5yZW5kZXJhYmxlLmdldElzSWRlbnRpdHkoKSkge1xuICAgICAgICBtYXQzLmlkZW50aXR5KG1vZGVsLmtleU1hdHJpY2VzLm5vcm1hbE1hdHJpeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXQzLmZyb21NYXQ0KG1vZGVsLmtleU1hdHJpY2VzLm5vcm1hbE1hdHJpeCwgbW9kZWwua2V5TWF0cmljZXMubWN3Yyk7XG4gICAgICAgIG1hdDMuaW52ZXJ0KFxuICAgICAgICAgIG1vZGVsLmtleU1hdHJpY2VzLm5vcm1hbE1hdHJpeCxcbiAgICAgICAgICBtb2RlbC5rZXlNYXRyaWNlcy5ub3JtYWxNYXRyaXhcbiAgICAgICAgKTtcbiAgICAgICAgbWF0My50cmFuc3Bvc2UoXG4gICAgICAgICAgbW9kZWwua2V5TWF0cmljZXMubm9ybWFsTWF0cml4LFxuICAgICAgICAgIG1vZGVsLmtleU1hdHJpY2VzLm5vcm1hbE1hdHJpeFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbW9kZWwua2V5TWF0cml4VGltZS5tb2RpZmllZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlbC5rZXlNYXRyaWNlcztcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIGNvbnRleHQ6IG51bGwsXG4gIGtleU1hdHJpeFRpbWU6IG51bGwsXG4gIGtleU1hdHJpY2VzOiBudWxsLFxuICBhY3RpdmVUZXh0dXJlczogbnVsbCxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEluaGVyaXRhbmNlXG4gIHZ0a1ZpZXdOb2RlLmV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzKTtcblxuICBtb2RlbC5rZXlNYXRyaXhUaW1lID0ge307XG4gIG1hY3JvLm9iaihtb2RlbC5rZXlNYXRyaXhUaW1lLCB7IG10aW1lOiAwIH0pO1xuICBtb2RlbC5rZXlNYXRyaWNlcyA9IHtcbiAgICBub3JtYWxNYXRyaXg6IG1hdDMuY3JlYXRlKCksXG4gICAgbWN3YzogbWF0NC5jcmVhdGUoKSxcbiAgfTtcblxuICAvLyBCdWlsZCBWVEsgQVBJXG4gIG1hY3JvLnNldEdldChwdWJsaWNBUEksIG1vZGVsLCBbJ2NvbnRleHQnXSk7XG5cbiAgbWFjcm8uZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsnYWN0aXZlVGV4dHVyZXMnXSk7XG5cbiAgLy8gT2JqZWN0IG1ldGhvZHNcbiAgdnRrT3BlbkdMQWN0b3IocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImltcG9ydCAqIGFzIG1hY3JvIGZyb20gJy4uLy4uLy4uL21hY3JvJztcbmltcG9ydCB2dGtWaWV3Tm9kZSBmcm9tICcuLi8uLi9TY2VuZUdyYXBoL1ZpZXdOb2RlJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrT3BlbkdMQWN0b3IgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtPcGVuR0xBY3RvcjJEKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrT3BlbkdMQWN0b3IyRCcpO1xuXG4gIC8vIEJ1aWxkcyBteXNlbGYuXG4gIHB1YmxpY0FQSS5idWlsZFBhc3MgPSAocHJlcGFzcykgPT4ge1xuICAgIGlmIChwcmVwYXNzKSB7XG4gICAgICBpZiAoIW1vZGVsLnJlbmRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbW9kZWwub3BlbkdMUmVuZGVyZXIgPSBwdWJsaWNBUEkuZ2V0Rmlyc3RBbmNlc3Rvck9mVHlwZShcbiAgICAgICAgJ3Z0a09wZW5HTFJlbmRlcmVyJ1xuICAgICAgKTtcbiAgICAgIHB1YmxpY0FQSS5wcmVwYXJlTm9kZXMoKTtcbiAgICAgIHB1YmxpY0FQSS5hZGRNaXNzaW5nTm9kZXMobW9kZWwucmVuZGVyYWJsZS5nZXRUZXh0dXJlcygpKTtcbiAgICAgIHB1YmxpY0FQSS5hZGRNaXNzaW5nTm9kZShtb2RlbC5yZW5kZXJhYmxlLmdldE1hcHBlcigpKTtcbiAgICAgIHB1YmxpY0FQSS5yZW1vdmVVbnVzZWROb2RlcygpO1xuICAgIH1cbiAgfTtcblxuICAvLyB3ZSBkcmF3IHRleHR1cmVzLCB0aGVuIG1hcHBlciwgdGhlbiBwb3N0IHBhc3MgdGV4dHVyZXNcbiAgcHVibGljQVBJLnRyYXZlcnNlT3BhcXVlUGFzcyA9IChyZW5kZXJQYXNzKSA9PiB7XG4gICAgaWYgKFxuICAgICAgIW1vZGVsLnJlbmRlcmFibGUgfHxcbiAgICAgICFtb2RlbC5yZW5kZXJhYmxlLmdldFZpc2liaWxpdHkoKSB8fFxuICAgICAgIW1vZGVsLnJlbmRlcmFibGUuZ2V0SXNPcGFxdWUoKSB8fFxuICAgICAgKG1vZGVsLm9wZW5HTFJlbmRlcmVyLmdldFNlbGVjdG9yKCkgJiYgIW1vZGVsLnJlbmRlcmFibGUuZ2V0UGlja2FibGUoKSlcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwdWJsaWNBUEkuYXBwbHkocmVuZGVyUGFzcywgdHJ1ZSk7XG4gICAgbW9kZWwuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQuaXNBKCd2dGtPcGVuR0xUZXh0dXJlJykpIHtcbiAgICAgICAgY2hpbGQudHJhdmVyc2UocmVuZGVyUGFzcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHVibGljQVBJLmFwcGx5KHJlbmRlclBhc3MsIGZhbHNlKTtcbiAgfTtcblxuICAvLyB3ZSBkcmF3IHRleHR1cmVzLCB0aGVuIG1hcHBlciwgdGhlbiBwb3N0IHBhc3MgdGV4dHVyZXNcbiAgcHVibGljQVBJLnRyYXZlcnNlVHJhbnNsdWNlbnRQYXNzID0gKHJlbmRlclBhc3MpID0+IHtcbiAgICBpZiAoXG4gICAgICAhbW9kZWwucmVuZGVyYWJsZSB8fFxuICAgICAgIW1vZGVsLnJlbmRlcmFibGUuZ2V0VmlzaWJpbGl0eSgpIHx8XG4gICAgICBtb2RlbC5yZW5kZXJhYmxlLmdldElzT3BhcXVlKCkgfHxcbiAgICAgIChtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRTZWxlY3RvcigpICYmICFtb2RlbC5yZW5kZXJhYmxlLmdldFBpY2thYmxlKCkpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHVibGljQVBJLmFwcGx5KHJlbmRlclBhc3MsIHRydWUpO1xuICAgIG1vZGVsLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBpZiAoIWNoaWxkLmlzQSgndnRrT3BlbkdMVGV4dHVyZScpKSB7XG4gICAgICAgIGNoaWxkLnRyYXZlcnNlKHJlbmRlclBhc3MpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHB1YmxpY0FQSS5hcHBseShyZW5kZXJQYXNzLCBmYWxzZSk7XG4gIH07XG5cbiAgcHVibGljQVBJLmFjdGl2YXRlVGV4dHVyZXMgPSAoKSA9PiB7XG4gICAgLy8gYWx3YXlzIHRyYXZlcnNlIHRleHR1cmVzIGZpcnN0LCB0aGVuIG1hcHBlclxuICAgIG1vZGVsLmFjdGl2ZVRleHR1cmVzID0gW107XG4gICAgbW9kZWwuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGlmIChjaGlsZC5pc0EoJ3Z0a09wZW5HTFRleHR1cmUnKSkge1xuICAgICAgICBjaGlsZC5yZW5kZXIoKTtcbiAgICAgICAgaWYgKGNoaWxkLmdldEhhbmRsZSgpKSB7XG4gICAgICAgICAgbW9kZWwuYWN0aXZlVGV4dHVyZXMucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvLyBSZW5kZXJzIG15c2VsZlxuICBwdWJsaWNBUEkub3BhcXVlUGFzcyA9IChwcmVwYXNzLCByZW5kZXJQYXNzKSA9PiB7XG4gICAgaWYgKHByZXBhc3MpIHtcbiAgICAgIG1vZGVsLmNvbnRleHQgPSBwdWJsaWNBUElcbiAgICAgICAgLmdldEZpcnN0QW5jZXN0b3JPZlR5cGUoJ3Z0a09wZW5HTFJlbmRlcldpbmRvdycpXG4gICAgICAgIC5nZXRDb250ZXh0KCk7XG4gICAgICBtb2RlbC5jb250ZXh0LmRlcHRoTWFzayh0cnVlKTtcbiAgICAgIHB1YmxpY0FQSS5hY3RpdmF0ZVRleHR1cmVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRlYWN0aXZhdGUgdGV4dHVyZXNcbiAgICAgIG1vZGVsLmFjdGl2ZVRleHR1cmVzLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIGNoaWxkLmRlYWN0aXZhdGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZW5kZXJzIG15c2VsZlxuICBwdWJsaWNBUEkudHJhbnNsdWNlbnRQYXNzID0gKHByZXBhc3MsIHJlbmRlclBhc3MpID0+IHtcbiAgICBpZiAocHJlcGFzcykge1xuICAgICAgbW9kZWwuY29udGV4dCA9IHB1YmxpY0FQSVxuICAgICAgICAuZ2V0Rmlyc3RBbmNlc3Rvck9mVHlwZSgndnRrT3BlbkdMUmVuZGVyV2luZG93JylcbiAgICAgICAgLmdldENvbnRleHQoKTtcbiAgICAgIG1vZGVsLmNvbnRleHQuZGVwdGhNYXNrKGZhbHNlKTtcbiAgICAgIHB1YmxpY0FQSS5hY3RpdmF0ZVRleHR1cmVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRlYWN0aXZhdGUgdGV4dHVyZXNcbiAgICAgIG1vZGVsLmFjdGl2ZVRleHR1cmVzLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIGNoaWxkLmRlYWN0aXZhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgbW9kZWwuY29udGV4dC5kZXB0aE1hc2sodHJ1ZSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgY29udGV4dDogbnVsbCxcbiAgYWN0aXZlVGV4dHVyZXM6IFtdLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gSW5oZXJpdGFuY2VcbiAgdnRrVmlld05vZGUuZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEJ1aWxkIFZUSyBBUElcbiAgbWFjcm8uc2V0R2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsnY29udGV4dCddKTtcblxuICBtYWNyby5nZXQocHVibGljQVBJLCBtb2RlbCwgWydhY3RpdmVUZXh0dXJlcyddKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICB2dGtPcGVuR0xBY3RvcjJEKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kIH07XG4iLCJleHBvcnQgY29uc3QgT2JqZWN0VHlwZSA9IHtcbiAgQVJSQVlfQlVGRkVSOiAwLFxuICBFTEVNRU5UX0FSUkFZX0JVRkZFUjogMSxcbiAgVEVYVFVSRV9CVUZGRVI6IDIsXG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIE9iamVjdFR5cGUsXG59O1xuIiwiaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCBDb25zdGFudHMgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9CdWZmZXJPYmplY3QvQ29uc3RhbnRzJztcblxuY29uc3QgeyBPYmplY3RUeXBlIH0gPSBDb25zdGFudHM7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEdsb2JhbCBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFN0YXRpYyBBUElcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IFNUQVRJQyA9IHt9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtPcGVuR0xCdWZmZXJPYmplY3QgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtPcGVuR0xCdWZmZXJPYmplY3QocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtPcGVuR0xCdWZmZXJPYmplY3QnKTtcblxuICAvLyBDbGFzcy1zcGVjaWZpYyBwcml2YXRlIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjb252ZXJ0VHlwZSh0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIE9iamVjdFR5cGUuRUxFTUVOVF9BUlJBWV9CVUZGRVI6XG4gICAgICAgIHJldHVybiBtb2RlbC5jb250ZXh0LkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xuICAgICAgY2FzZSBPYmplY3RUeXBlLlRFWFRVUkVfQlVGRkVSOlxuICAgICAgICBpZiAoJ1RFWFRVUkVfQlVGRkVSJyBpbiBtb2RlbC5jb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuVEVYVFVSRV9CVUZGRVI7XG4gICAgICAgIH1cbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWZhbGx0aHJvdWdoICovXG4gICAgICAvLyBJbnRlbnRpb25hbCBmYWxsdGhyb3VnaCBpbiBjYXNlIHRoZXJlIGlzIG5vIFRFWFRVUkVfQlVGRkVSIGluIFdlYkdMXG4gICAgICBkZWZhdWx0OlxuICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPYmplY3RUeXBlLkFSUkFZX0JVRkZFUjpcbiAgICAgICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuQVJSQVlfQlVGRkVSO1xuICAgIH1cbiAgfVxuXG4gIGxldCBpbnRlcm5hbFR5cGUgPSBudWxsO1xuICBsZXQgaW50ZXJuYWxIYW5kbGUgPSBudWxsO1xuICBsZXQgZGlydHkgPSB0cnVlO1xuICBsZXQgZXJyb3IgPSAnJztcblxuICAvLyBQdWJsaWMgQVBJIG1ldGhvZHNcbiAgcHVibGljQVBJLmdldFR5cGUgPSAoKSA9PiBpbnRlcm5hbFR5cGU7XG5cbiAgcHVibGljQVBJLnNldFR5cGUgPSAodmFsdWUpID0+IHtcbiAgICBpbnRlcm5hbFR5cGUgPSB2YWx1ZTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0SGFuZGxlID0gKCkgPT4gaW50ZXJuYWxIYW5kbGU7XG4gIHB1YmxpY0FQSS5pc1JlYWR5ID0gKCkgPT4gZGlydHkgPT09IGZhbHNlO1xuXG4gIHB1YmxpY0FQSS5nZW5lcmF0ZUJ1ZmZlciA9ICh0eXBlKSA9PiB7XG4gICAgY29uc3Qgb2JqZWN0VHlwZUdMID0gY29udmVydFR5cGUodHlwZSk7XG4gICAgaWYgKGludGVybmFsSGFuZGxlID09PSBudWxsKSB7XG4gICAgICBpbnRlcm5hbEhhbmRsZSA9IG1vZGVsLmNvbnRleHQuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBpbnRlcm5hbFR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydFR5cGUoaW50ZXJuYWxUeXBlKSA9PT0gb2JqZWN0VHlwZUdMO1xuICB9O1xuXG4gIHB1YmxpY0FQSS51cGxvYWQgPSAoZGF0YSwgdHlwZSkgPT4ge1xuICAgIC8vIGJ1ZmZlciwgc2l6ZSwgdHlwZVxuICAgIGNvbnN0IGFscmVhZHlHZW5lcmF0ZWQgPSBwdWJsaWNBUEkuZ2VuZXJhdGVCdWZmZXIodHlwZSk7XG4gICAgaWYgKCFhbHJlYWR5R2VuZXJhdGVkKSB7XG4gICAgICBlcnJvciA9ICdUcnlpbmcgdG8gdXBsb2FkIGFycmF5IGJ1ZmZlciB0byBpbmNvbXBhdGlibGUgYnVmZmVyLic7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vZGVsLmNvbnRleHQuYmluZEJ1ZmZlcihjb252ZXJ0VHlwZShpbnRlcm5hbFR5cGUpLCBpbnRlcm5hbEhhbmRsZSk7XG4gICAgbW9kZWwuY29udGV4dC5idWZmZXJEYXRhKFxuICAgICAgY29udmVydFR5cGUoaW50ZXJuYWxUeXBlKSxcbiAgICAgIGRhdGEsXG4gICAgICBtb2RlbC5jb250ZXh0LlNUQVRJQ19EUkFXXG4gICAgKTtcbiAgICBkaXJ0eSA9IGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5iaW5kID0gKCkgPT4ge1xuICAgIGlmICghaW50ZXJuYWxIYW5kbGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW9kZWwuY29udGV4dC5iaW5kQnVmZmVyKGNvbnZlcnRUeXBlKGludGVybmFsVHlwZSksIGludGVybmFsSGFuZGxlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBwdWJsaWNBUEkucmVsZWFzZSA9ICgpID0+IHtcbiAgICBpZiAoIWludGVybmFsSGFuZGxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vZGVsLmNvbnRleHQuYmluZEJ1ZmZlcihjb252ZXJ0VHlwZShpbnRlcm5hbFR5cGUpLCBudWxsKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBwdWJsaWNBUEkucmVsZWFzZUdyYXBoaWNzUmVzb3VyY2VzID0gKCkgPT4ge1xuICAgIGlmIChpbnRlcm5hbEhhbmRsZSAhPT0gbnVsbCkge1xuICAgICAgbW9kZWwuY29udGV4dC5iaW5kQnVmZmVyKGNvbnZlcnRUeXBlKGludGVybmFsVHlwZSksIG51bGwpO1xuICAgICAgbW9kZWwuY29udGV4dC5kZWxldGVCdWZmZXIoaW50ZXJuYWxIYW5kbGUpO1xuICAgICAgaW50ZXJuYWxIYW5kbGUgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0T3BlbkdMUmVuZGVyV2luZG93ID0gKHJ3KSA9PiB7XG4gICAgaWYgKG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyA9PT0gcncpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHVibGljQVBJLnJlbGVhc2VHcmFwaGljc1Jlc291cmNlcygpO1xuICAgIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyA9IHJ3O1xuICAgIG1vZGVsLmNvbnRleHQgPSBudWxsO1xuICAgIGlmIChydykge1xuICAgICAgbW9kZWwuY29udGV4dCA9IG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRDb250ZXh0KCk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRFcnJvciA9ICgpID0+IGVycm9yO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgb2JqZWN0VHlwZTogT2JqZWN0VHlwZS5BUlJBWV9CVUZGRVIsXG4gIG9wZW5HTFJlbmRlcldpbmRvdzogbnVsbCxcbiAgY29udGV4dDogbnVsbCxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIG1hY3JvLm9iaihwdWJsaWNBUEksIG1vZGVsKTtcblxuICBtYWNyby5nZXQocHVibGljQVBJLCBtb2RlbCwgWydvcGVuR0xSZW5kZXJXaW5kb3cnXSk7XG5cbiAgdnRrT3BlbkdMQnVmZmVyT2JqZWN0KHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kLCAuLi5TVEFUSUMsIC4uLkNvbnN0YW50cyB9O1xuIiwiaW1wb3J0IHsgbWF0MywgbWF0NCB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmltcG9ydCAqIGFzIG1hY3JvIGZyb20gJy4uLy4uLy4uL21hY3JvJztcbmltcG9ydCB2dGtWaWV3Tm9kZSBmcm9tICcuLi8uLi9TY2VuZUdyYXBoL1ZpZXdOb2RlJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrT3BlbkdMQ2FtZXJhIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrT3BlbkdMQ2FtZXJhKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrT3BlbkdMQ2FtZXJhJyk7XG5cbiAgcHVibGljQVBJLmJ1aWxkUGFzcyA9IChwcmVwYXNzKSA9PiB7XG4gICAgaWYgKHByZXBhc3MpIHtcbiAgICAgIG1vZGVsLm9wZW5HTFJlbmRlcmVyID0gcHVibGljQVBJLmdldEZpcnN0QW5jZXN0b3JPZlR5cGUoXG4gICAgICAgICd2dGtPcGVuR0xSZW5kZXJlcidcbiAgICAgICk7XG4gICAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cgPSBtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRQYXJlbnQoKTtcbiAgICAgIG1vZGVsLmNvbnRleHQgPSBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0Q29udGV4dCgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZW5kZXJzIG15c2VsZlxuICBwdWJsaWNBUEkub3BhcXVlUGFzcyA9IChwcmVwYXNzKSA9PiB7XG4gICAgaWYgKHByZXBhc3MpIHtcbiAgICAgIGNvbnN0IHRzaXplID0gbW9kZWwub3BlbkdMUmVuZGVyZXIuZ2V0VGlsZWRTaXplQW5kT3JpZ2luKCk7XG4gICAgICBtb2RlbC5jb250ZXh0LnZpZXdwb3J0KFxuICAgICAgICB0c2l6ZS5sb3dlckxlZnRVLFxuICAgICAgICB0c2l6ZS5sb3dlckxlZnRWLFxuICAgICAgICB0c2l6ZS51c2l6ZSxcbiAgICAgICAgdHNpemUudnNpemVcbiAgICAgICk7XG4gICAgICBtb2RlbC5jb250ZXh0LnNjaXNzb3IoXG4gICAgICAgIHRzaXplLmxvd2VyTGVmdFUsXG4gICAgICAgIHRzaXplLmxvd2VyTGVmdFYsXG4gICAgICAgIHRzaXplLnVzaXplLFxuICAgICAgICB0c2l6ZS52c2l6ZVxuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIHB1YmxpY0FQSS50cmFuc2x1Y2VudFBhc3MgPSBwdWJsaWNBUEkub3BhcXVlUGFzcztcbiAgcHVibGljQVBJLm9wYXF1ZVpCdWZmZXJQYXNzID0gcHVibGljQVBJLm9wYXF1ZVBhc3M7XG4gIHB1YmxpY0FQSS52b2x1bWVQYXNzID0gcHVibGljQVBJLm9wYXF1ZVBhc3M7XG5cbiAgcHVibGljQVBJLmdldEtleU1hdHJpY2VzID0gKHJlbikgPT4ge1xuICAgIC8vIGhhcyB0aGUgY2FtZXJhIGNoYW5nZWQ/XG4gICAgaWYgKFxuICAgICAgcmVuICE9PSBtb2RlbC5sYXN0UmVuZGVyZXIgfHxcbiAgICAgIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRNVGltZSgpID4gbW9kZWwua2V5TWF0cml4VGltZS5nZXRNVGltZSgpIHx8XG4gICAgICBwdWJsaWNBUEkuZ2V0TVRpbWUoKSA+IG1vZGVsLmtleU1hdHJpeFRpbWUuZ2V0TVRpbWUoKSB8fFxuICAgICAgcmVuLmdldE1UaW1lKCkgPiBtb2RlbC5rZXlNYXRyaXhUaW1lLmdldE1UaW1lKCkgfHxcbiAgICAgIG1vZGVsLnJlbmRlcmFibGUuZ2V0TVRpbWUoKSA+IG1vZGVsLmtleU1hdHJpeFRpbWUuZ2V0TVRpbWUoKVxuICAgICkge1xuICAgICAgbWF0NC5jb3B5KG1vZGVsLmtleU1hdHJpY2VzLndjdmMsIG1vZGVsLnJlbmRlcmFibGUuZ2V0Vmlld01hdHJpeCgpKTtcblxuICAgICAgbWF0My5mcm9tTWF0NChtb2RlbC5rZXlNYXRyaWNlcy5ub3JtYWxNYXRyaXgsIG1vZGVsLmtleU1hdHJpY2VzLndjdmMpO1xuICAgICAgbWF0My5pbnZlcnQoXG4gICAgICAgIG1vZGVsLmtleU1hdHJpY2VzLm5vcm1hbE1hdHJpeCxcbiAgICAgICAgbW9kZWwua2V5TWF0cmljZXMubm9ybWFsTWF0cml4XG4gICAgICApO1xuICAgICAgbWF0NC50cmFuc3Bvc2UobW9kZWwua2V5TWF0cmljZXMud2N2YywgbW9kZWwua2V5TWF0cmljZXMud2N2Yyk7XG5cbiAgICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gbW9kZWwub3BlbkdMUmVuZGVyZXIuZ2V0QXNwZWN0UmF0aW8oKTtcblxuICAgICAgbWF0NC5jb3B5KFxuICAgICAgICBtb2RlbC5rZXlNYXRyaWNlcy52Y3BjLFxuICAgICAgICBtb2RlbC5yZW5kZXJhYmxlLmdldFByb2plY3Rpb25NYXRyaXgoYXNwZWN0UmF0aW8sIC0xLCAxKVxuICAgICAgKTtcbiAgICAgIG1hdDQudHJhbnNwb3NlKG1vZGVsLmtleU1hdHJpY2VzLnZjcGMsIG1vZGVsLmtleU1hdHJpY2VzLnZjcGMpO1xuXG4gICAgICBtYXQ0Lm11bHRpcGx5KFxuICAgICAgICBtb2RlbC5rZXlNYXRyaWNlcy53Y3BjLFxuICAgICAgICBtb2RlbC5rZXlNYXRyaWNlcy52Y3BjLFxuICAgICAgICBtb2RlbC5rZXlNYXRyaWNlcy53Y3ZjXG4gICAgICApO1xuXG4gICAgICBtb2RlbC5rZXlNYXRyaXhUaW1lLm1vZGlmaWVkKCk7XG4gICAgICBtb2RlbC5sYXN0UmVuZGVyZXIgPSByZW47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGVsLmtleU1hdHJpY2VzO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgY29udGV4dDogbnVsbCxcbiAgbGFzdFJlbmRlcmVyOiBudWxsLFxuICBrZXlNYXRyaXhUaW1lOiBudWxsLFxuICBrZXlNYXRyaWNlczogbnVsbCxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEluaGVyaXRhbmNlXG4gIHZ0a1ZpZXdOb2RlLmV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzKTtcblxuICBtb2RlbC5rZXlNYXRyaXhUaW1lID0ge307XG4gIG1hY3JvLm9iaihtb2RlbC5rZXlNYXRyaXhUaW1lKTtcblxuICBtb2RlbC5rZXlNYXRyaWNlcyA9IHtcbiAgICBub3JtYWxNYXRyaXg6IG1hdDMuY3JlYXRlKCksXG4gICAgdmNwYzogbWF0NC5jcmVhdGUoKSxcbiAgICB3Y3ZjOiBtYXQ0LmNyZWF0ZSgpLFxuICAgIHdjcGM6IG1hdDQuY3JlYXRlKCksXG4gIH07XG5cbiAgLy8gQnVpbGQgVlRLIEFQSVxuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgWydjb250ZXh0JywgJ2tleU1hdHJpeFRpbWUnXSk7XG5cbiAgLy8gT2JqZWN0IG1ldGhvZHNcbiAgdnRrT3BlbkdMQ2FtZXJhKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kIH07XG4iLCJpbXBvcnQgeyBtYXQ0LCBxdWF0LCB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4JztcblxuaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB2dGtCdWZmZXJPYmplY3QgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9CdWZmZXJPYmplY3QnO1xuaW1wb3J0IHsgT2JqZWN0VHlwZSB9IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvQnVmZmVyT2JqZWN0L0NvbnN0YW50cyc7XG5pbXBvcnQgeyBSZXByZXNlbnRhdGlvbiB9IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL1Byb3BlcnR5L0NvbnN0YW50cyc7XG5cbmNvbnN0IHsgdnRrRGVidWdNYWNybywgdnRrRXJyb3JNYWNybyB9ID0gbWFjcm87XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFN0YXRpYyBmdW5jdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gY29tcHV0ZUludmVyc2VTaGlmdEFuZFNjYWxlTWF0cml4KGNvb3JkU2hpZnQsIGNvb3JkU2NhbGUpIHtcbiAgY29uc3QgaW52ZXJzZVNjYWxlID0gdmVjMy5jcmVhdGUoKTtcbiAgdmVjMy5pbnZlcnNlKGludmVyc2VTY2FsZSwgY29vcmRTY2FsZSk7XG5cbiAgY29uc3QgbWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgbWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlKFxuICAgIG1hdHJpeCxcbiAgICBxdWF0LmNyZWF0ZSgpLFxuICAgIGNvb3JkU2hpZnQsXG4gICAgaW52ZXJzZVNjYWxlXG4gICk7XG5cbiAgcmV0dXJuIG1hdHJpeDtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQXBwbHlDb29yZFNoaWZ0QW5kU2NhbGUoY29vcmRTaGlmdCwgY29vcmRTY2FsZSkge1xuICBpZiAoY29vcmRTaGlmdCA9PT0gbnVsbCB8fCBjb29yZFNjYWxlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuICEoXG4gICAgdmVjMy5leGFjdEVxdWFscyhjb29yZFNoaWZ0LCBbMCwgMCwgMF0pICYmXG4gICAgdmVjMy5leGFjdEVxdWFscyhjb29yZFNjYWxlLCBbMSwgMSwgMV0pXG4gICk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a09wZW5HTENlbGxBcnJheUJ1ZmZlck9iamVjdCBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a09wZW5HTENlbGxBcnJheUJ1ZmZlck9iamVjdChwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a09wZW5HTENlbGxBcnJheUJ1ZmZlck9iamVjdCcpO1xuXG4gIHB1YmxpY0FQSS5zZXRUeXBlKE9iamVjdFR5cGUuQVJSQVlfQlVGRkVSKTtcblxuICBwdWJsaWNBUEkuY3JlYXRlVkJPID0gKGNlbGxBcnJheSwgaW5SZXAsIG91dFJlcCwgb3B0aW9ucykgPT4ge1xuICAgIGlmICghY2VsbEFycmF5LmdldERhdGEoKSB8fCAhY2VsbEFycmF5LmdldERhdGEoKS5sZW5ndGgpIHtcbiAgICAgIG1vZGVsLmVsZW1lbnRDb3VudCA9IDA7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBGaWd1cmUgb3V0IGhvdyBiaWcgZWFjaCBibG9jayB3aWxsIGJlLCBjdXJyZW50bHkgNiBvciA3IGZsb2F0cy5cbiAgICBtb2RlbC5ibG9ja1NpemUgPSAzO1xuICAgIG1vZGVsLnZlcnRleE9mZnNldCA9IDA7XG4gICAgbW9kZWwubm9ybWFsT2Zmc2V0ID0gMDtcbiAgICBtb2RlbC50Q29vcmRPZmZzZXQgPSAwO1xuICAgIG1vZGVsLnRDb29yZENvbXBvbmVudHMgPSAwO1xuICAgIG1vZGVsLmNvbG9yQ29tcG9uZW50cyA9IDA7XG4gICAgbW9kZWwuY29sb3JPZmZzZXQgPSAwO1xuICAgIG1vZGVsLmN1c3RvbURhdGEgPSBbXTtcblxuICAgIGNvbnN0IHBvaW50RGF0YSA9IG9wdGlvbnMucG9pbnRzLmdldERhdGEoKTtcbiAgICBsZXQgbm9ybWFsRGF0YSA9IG51bGw7XG4gICAgbGV0IHRjb29yZERhdGEgPSBudWxsO1xuICAgIGxldCBjb2xvckRhdGEgPSBudWxsO1xuXG4gICAgY29uc3QgY29sb3JDb21wb25lbnRzID0gb3B0aW9ucy5jb2xvcnNcbiAgICAgID8gb3B0aW9ucy5jb2xvcnMuZ2V0TnVtYmVyT2ZDb21wb25lbnRzKClcbiAgICAgIDogMDtcbiAgICBjb25zdCB0ZXh0dXJlQ29tcG9uZW50cyA9IG9wdGlvbnMudGNvb3Jkc1xuICAgICAgPyBvcHRpb25zLnRjb29yZHMuZ2V0TnVtYmVyT2ZDb21wb25lbnRzKClcbiAgICAgIDogMDtcblxuICAgIC8vIHRoZSB2YWx1ZXMgb2YgNCBiZWxvdyBhcmUgYmVjYXVzZSBmbG9hdHMgYXJlIDQgYnl0ZXNcblxuICAgIGlmIChvcHRpb25zLm5vcm1hbHMpIHtcbiAgICAgIG1vZGVsLm5vcm1hbE9mZnNldCA9IDQgKiBtb2RlbC5ibG9ja1NpemU7XG4gICAgICBtb2RlbC5ibG9ja1NpemUgKz0gMztcbiAgICAgIG5vcm1hbERhdGEgPSBvcHRpb25zLm5vcm1hbHMuZ2V0RGF0YSgpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmN1c3RvbUF0dHJpYnV0ZXMpIHtcbiAgICAgIG9wdGlvbnMuY3VzdG9tQXR0cmlidXRlcy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgbW9kZWwuY3VzdG9tRGF0YS5wdXNoKHtcbiAgICAgICAgICAgIGRhdGE6IGEuZ2V0RGF0YSgpLFxuICAgICAgICAgICAgb2Zmc2V0OiA0ICogbW9kZWwuYmxvY2tTaXplLFxuICAgICAgICAgICAgY29tcG9uZW50czogYS5nZXROdW1iZXJPZkNvbXBvbmVudHMoKSxcbiAgICAgICAgICAgIG5hbWU6IGEuZ2V0TmFtZSgpLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1vZGVsLmJsb2NrU2l6ZSArPSBhLmdldE51bWJlck9mQ29tcG9uZW50cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50Y29vcmRzKSB7XG4gICAgICBtb2RlbC50Q29vcmRPZmZzZXQgPSA0ICogbW9kZWwuYmxvY2tTaXplO1xuICAgICAgbW9kZWwudENvb3JkQ29tcG9uZW50cyA9IHRleHR1cmVDb21wb25lbnRzO1xuICAgICAgbW9kZWwuYmxvY2tTaXplICs9IHRleHR1cmVDb21wb25lbnRzO1xuICAgICAgdGNvb3JkRGF0YSA9IG9wdGlvbnMudGNvb3Jkcy5nZXREYXRhKCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuY29sb3JzKSB7XG4gICAgICBtb2RlbC5jb2xvckNvbXBvbmVudHMgPSBvcHRpb25zLmNvbG9ycy5nZXROdW1iZXJPZkNvbXBvbmVudHMoKTtcbiAgICAgIG1vZGVsLmNvbG9yT2Zmc2V0ID0gMDtcbiAgICAgIGNvbG9yRGF0YSA9IG9wdGlvbnMuY29sb3JzLmdldERhdGEoKTtcbiAgICAgIGlmICghbW9kZWwuY29sb3JCTykge1xuICAgICAgICBtb2RlbC5jb2xvckJPID0gdnRrQnVmZmVyT2JqZWN0Lm5ld0luc3RhbmNlKCk7XG4gICAgICB9XG4gICAgICBtb2RlbC5jb2xvckJPLnNldE9wZW5HTFJlbmRlcldpbmRvdyhtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbC5jb2xvckJPID0gbnVsbDtcbiAgICB9XG4gICAgbW9kZWwuc3RyaWRlID0gNCAqIG1vZGVsLmJsb2NrU2l6ZTtcblxuICAgIGxldCBwb2ludElkeCA9IDA7XG4gICAgbGV0IG5vcm1hbElkeCA9IDA7XG4gICAgbGV0IHRjb29yZElkeCA9IDA7XG4gICAgbGV0IGNvbG9ySWR4ID0gMDtcbiAgICBsZXQgY3VzdElkeCA9IDA7XG4gICAgbGV0IGNlbGxDb3VudCA9IDA7XG4gICAgbGV0IGFkZEFQb2ludDtcblxuICAgIGNvbnN0IGNlbGxCdWlsZGVycyA9IHtcbiAgICAgIC8vIGVhc3ksIGV2ZXJ5IGlucHV0IHBvaW50IGJlY29tZXMgYW4gb3V0cHV0IHBvaW50XG4gICAgICBhbnl0aGluZ1RvUG9pbnRzKG51bVBvaW50cywgY2VsbFB0cywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzOyArK2kpIHtcbiAgICAgICAgICBhZGRBUG9pbnQoY2VsbFB0c1tvZmZzZXQgKyBpXSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBsaW5lc1RvV2lyZWZyYW1lKG51bVBvaW50cywgY2VsbFB0cywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIGZvciBsaW5lcyB3ZSBhZGQgYSBidW5jaCBvZiBzZWdtZW50c1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvaW50cyAtIDE7ICsraSkge1xuICAgICAgICAgIGFkZEFQb2ludChjZWxsUHRzW29mZnNldCArIGldKTtcbiAgICAgICAgICBhZGRBUG9pbnQoY2VsbFB0c1tvZmZzZXQgKyBpICsgMV0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcG9seXNUb1dpcmVmcmFtZShudW1Qb2ludHMsIGNlbGxQdHMsIG9mZnNldCkge1xuICAgICAgICAvLyBmb3IgcG9seXMgd2UgYWRkIGEgYnVuY2ggb2Ygc2VnbWVudHMgYW5kIGNsb3NlIGl0XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzOyArK2kpIHtcbiAgICAgICAgICBhZGRBUG9pbnQoY2VsbFB0c1tvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgYWRkQVBvaW50KGNlbGxQdHNbb2Zmc2V0ICsgKChpICsgMSkgJSBudW1Qb2ludHMpXSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdHJpcHNUb1dpcmVmcmFtZShudW1Qb2ludHMsIGNlbGxQdHMsIG9mZnNldCkge1xuICAgICAgICAvLyBmb3Igc3RyaXBzIHdlIGFkZCBhIGJ1bmNoIG9mIHNlZ21lbnRzIGFuZCBjbG9zZSBpdFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvaW50cyAtIDE7ICsraSkge1xuICAgICAgICAgIGFkZEFQb2ludChjZWxsUHRzW29mZnNldCArIGldKTtcbiAgICAgICAgICBhZGRBUG9pbnQoY2VsbFB0c1tvZmZzZXQgKyBpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzIC0gMjsgaSsrKSB7XG4gICAgICAgICAgYWRkQVBvaW50KGNlbGxQdHNbb2Zmc2V0ICsgaV0pO1xuICAgICAgICAgIGFkZEFQb2ludChjZWxsUHRzW29mZnNldCArIGkgKyAyXSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwb2x5c1RvU3VyZmFjZShucHRzLCBjZWxsUHRzLCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKG5wdHMgPCAzKSB7XG4gICAgICAgICAgLy8gaWdub3JlIGRlZ2VuZXJhdGUgdHJpYW5nbGVzXG4gICAgICAgICAgdnRrRGVidWdNYWNybygnc2tpcHBpbmcgZGVnZW5lcmF0ZSB0cmlhbmdsZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnB0cyAtIDI7IGkrKykge1xuICAgICAgICAgICAgYWRkQVBvaW50KGNlbGxQdHNbb2Zmc2V0ICsgMF0pO1xuICAgICAgICAgICAgYWRkQVBvaW50KGNlbGxQdHNbb2Zmc2V0ICsgaSArIDFdKTtcbiAgICAgICAgICAgIGFkZEFQb2ludChjZWxsUHRzW29mZnNldCArIGkgKyAyXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RyaXBzVG9TdXJmYWNlKG5wdHMsIGNlbGxQdHMsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5wdHMgLSAyOyBpKyspIHtcbiAgICAgICAgICBhZGRBUG9pbnQoY2VsbFB0c1tvZmZzZXQgKyBpXSk7XG4gICAgICAgICAgYWRkQVBvaW50KGNlbGxQdHNbb2Zmc2V0ICsgaSArIDEgKyAoaSAlIDIpXSk7XG4gICAgICAgICAgYWRkQVBvaW50KGNlbGxQdHNbb2Zmc2V0ICsgaSArIDEgKyAoKGkgKyAxKSAlIDIpXSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfTtcblxuICAgIGNvbnN0IGNlbGxDb3VudGVycyA9IHtcbiAgICAgIC8vIGVhc3ksIGV2ZXJ5IGlucHV0IHBvaW50IGJlY29tZXMgYW4gb3V0cHV0IHBvaW50XG4gICAgICBhbnl0aGluZ1RvUG9pbnRzKG51bVBvaW50cywgY2VsbFB0cykge1xuICAgICAgICByZXR1cm4gbnVtUG9pbnRzO1xuICAgICAgfSxcbiAgICAgIGxpbmVzVG9XaXJlZnJhbWUobnVtUG9pbnRzLCBjZWxsUHRzKSB7XG4gICAgICAgIHJldHVybiAobnVtUG9pbnRzIC0gMSkgKiAyO1xuICAgICAgfSxcbiAgICAgIHBvbHlzVG9XaXJlZnJhbWUobnVtUG9pbnRzLCBjZWxsUHRzKSB7XG4gICAgICAgIHJldHVybiBudW1Qb2ludHMgKiAyO1xuICAgICAgfSxcbiAgICAgIHN0cmlwc1RvV2lyZWZyYW1lKG51bVBvaW50cywgY2VsbFB0cykge1xuICAgICAgICByZXR1cm4gbnVtUG9pbnRzICogNCAtIDY7XG4gICAgICB9LFxuICAgICAgcG9seXNUb1N1cmZhY2UobnB0cywgY2VsbFB0cykge1xuICAgICAgICBpZiAobnB0cyA8IDMpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5wdHMgLSAyKSAqIDM7XG4gICAgICB9LFxuICAgICAgc3RyaXBzVG9TdXJmYWNlKG5wdHMsIGNlbGxQdHMsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gKG5wdHMgLSAyKSAqIDM7XG4gICAgICB9LFxuICAgIH07XG5cbiAgICBsZXQgZnVuYyA9IG51bGw7XG4gICAgbGV0IGNvdW50RnVuYyA9IG51bGw7XG4gICAgaWYgKG91dFJlcCA9PT0gUmVwcmVzZW50YXRpb24uUE9JTlRTIHx8IGluUmVwID09PSAndmVydHMnKSB7XG4gICAgICBmdW5jID0gY2VsbEJ1aWxkZXJzLmFueXRoaW5nVG9Qb2ludHM7XG4gICAgICBjb3VudEZ1bmMgPSBjZWxsQ291bnRlcnMuYW55dGhpbmdUb1BvaW50cztcbiAgICB9IGVsc2UgaWYgKG91dFJlcCA9PT0gUmVwcmVzZW50YXRpb24uV0lSRUZSQU1FIHx8IGluUmVwID09PSAnbGluZXMnKSB7XG4gICAgICBmdW5jID0gY2VsbEJ1aWxkZXJzW2Ake2luUmVwfVRvV2lyZWZyYW1lYF07XG4gICAgICBjb3VudEZ1bmMgPSBjZWxsQ291bnRlcnNbYCR7aW5SZXB9VG9XaXJlZnJhbWVgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnVuYyA9IGNlbGxCdWlsZGVyc1tgJHtpblJlcH1Ub1N1cmZhY2VgXTtcbiAgICAgIGNvdW50RnVuYyA9IGNlbGxDb3VudGVyc1tgJHtpblJlcH1Ub1N1cmZhY2VgXTtcbiAgICB9XG5cbiAgICBjb25zdCBhcnJheSA9IGNlbGxBcnJheS5nZXREYXRhKCk7XG4gICAgY29uc3Qgc2l6ZSA9IGFycmF5Lmxlbmd0aDtcbiAgICBsZXQgY2Fib0NvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc2l6ZTsgKSB7XG4gICAgICBjYWJvQ291bnQgKz0gY291bnRGdW5jKGFycmF5W2luZGV4XSwgYXJyYXkpO1xuICAgICAgaW5kZXggKz0gYXJyYXlbaW5kZXhdICsgMTtcbiAgICB9XG5cbiAgICBsZXQgcGFja2VkVUNWQk8gPSBudWxsO1xuICAgIGNvbnN0IHBhY2tlZFZCTyA9IG5ldyBGbG9hdDMyQXJyYXkoY2Fib0NvdW50ICogbW9kZWwuYmxvY2tTaXplKTtcbiAgICBpZiAoY29sb3JEYXRhKSB7XG4gICAgICBwYWNrZWRVQ1ZCTyA9IG5ldyBVaW50OEFycmF5KGNhYm9Db3VudCAqIDQpO1xuICAgIH1cbiAgICBsZXQgdmJvaWR4ID0gMDtcbiAgICBsZXQgdWNpZHggPSAwO1xuXG4gICAgLy8gRmluZCBvdXQgaWYgc2hpZnQgc2NhbGUgc2hvdWxkIGJlIHVzZWRcbiAgICAvLyBDb21wdXRlIHNxdWFyZXMgb2YgZGlhZ29uYWwgc2l6ZSBhbmQgZGlzdGFuY2UgZnJvbSB0aGUgb3JpZ2luXG4gICAgbGV0IGRpYWdTcSA9IDAuMDtcbiAgICBsZXQgZGlzdFNxID0gMC4wO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICBjb25zdCByYW5nZSA9IG9wdGlvbnMucG9pbnRzLmdldFJhbmdlKGkpO1xuXG4gICAgICBjb25zdCBkZWx0YSA9IHJhbmdlWzFdIC0gcmFuZ2VbMF07XG4gICAgICBkaWFnU3EgKz0gZGVsdGEgKiBkZWx0YTtcblxuICAgICAgY29uc3QgZGlzdFNoaWZ0ID0gMC41ICogKHJhbmdlWzFdICsgcmFuZ2VbMF0pO1xuICAgICAgZGlzdFNxICs9IGRpc3RTaGlmdCAqIGRpc3RTaGlmdDtcbiAgICB9XG5cbiAgICBjb25zdCB1c2VTaGlmdEFuZFNjYWxlID1cbiAgICAgIGRpYWdTcSA+IDAgJiZcbiAgICAgIChNYXRoLmFicyhkaXN0U3EpIC8gZGlhZ1NxID4gMS4wZTYgfHwgLy8gSWYgZGF0YSBpcyBmYXIgZnJvbSB0aGUgb3JpZ2luIHJlbGF0aXZlIHRvIGl0cyBzaXplXG4gICAgICAgIE1hdGguYWJzKE1hdGgubG9nMTAoZGlhZ1NxKSkgPiAzLjAgfHwgLy8gSWYgdGhlIHNpemUgaXMgaHVnZSB3aGVuIG5vdCBmYXIgZnJvbSB0aGUgb3JpZ2luXG4gICAgICAgIChkaWFnU3EgPT09IDAgJiYgZGlzdFNxID4gMS4wZTYpKTsgLy8gSWYgZGF0YSBpcyBhIHBvaW50LCBidXQgZmFyIGZyb20gdGhlIG9yaWdpblxuXG4gICAgaWYgKHVzZVNoaWZ0QW5kU2NhbGUpIHtcbiAgICAgIC8vIENvbXB1dGUgc2hpZnQgYW5kIHNjYWxlIHZlY3RvcnNcbiAgICAgIGNvbnN0IGNvb3JkU2hpZnQgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgICAgY29uc3QgY29vcmRTY2FsZSA9IHZlYzMuY3JlYXRlKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7ICsraSkge1xuICAgICAgICBjb25zdCByYW5nZSA9IG9wdGlvbnMucG9pbnRzLmdldFJhbmdlKGkpO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHJhbmdlWzFdIC0gcmFuZ2VbMF07XG5cbiAgICAgICAgY29vcmRTaGlmdFtpXSA9IDAuNSAqIChyYW5nZVsxXSArIHJhbmdlWzBdKTtcbiAgICAgICAgY29vcmRTY2FsZVtpXSA9IGRlbHRhID4gMCA/IDEuMCAvIGRlbHRhIDogMS4wO1xuICAgICAgfVxuICAgICAgcHVibGljQVBJLnNldENvb3JkU2hpZnRBbmRTY2FsZShjb29yZFNoaWZ0LCBjb29yZFNjYWxlKTtcbiAgICB9IGVsc2UgaWYgKG1vZGVsLmNvb3JkU2hpZnRBbmRTY2FsZUVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSB0byByZXNldFxuICAgICAgcHVibGljQVBJLnNldENvb3JkU2hpZnRBbmRTY2FsZShudWxsLCBudWxsKTtcbiAgICB9XG5cbiAgICBhZGRBUG9pbnQgPSBmdW5jdGlvbiBhZGRBUG9pbnRGdW5jKGkpIHtcbiAgICAgIC8vIFZlcnRpY2VzXG4gICAgICBwb2ludElkeCA9IGkgKiAzO1xuXG4gICAgICBpZiAoIW1vZGVsLmNvb3JkU2hpZnRBbmRTY2FsZUVuYWJsZWQpIHtcbiAgICAgICAgcGFja2VkVkJPW3Zib2lkeCsrXSA9IHBvaW50RGF0YVtwb2ludElkeCsrXTtcbiAgICAgICAgcGFja2VkVkJPW3Zib2lkeCsrXSA9IHBvaW50RGF0YVtwb2ludElkeCsrXTtcbiAgICAgICAgcGFja2VkVkJPW3Zib2lkeCsrXSA9IHBvaW50RGF0YVtwb2ludElkeCsrXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFwcGx5IHNoaWZ0IGFuZCBzY2FsZVxuICAgICAgICBwYWNrZWRWQk9bdmJvaWR4KytdID1cbiAgICAgICAgICAocG9pbnREYXRhW3BvaW50SWR4KytdIC0gbW9kZWwuY29vcmRTaGlmdFswXSkgKiBtb2RlbC5jb29yZFNjYWxlWzBdO1xuICAgICAgICBwYWNrZWRWQk9bdmJvaWR4KytdID1cbiAgICAgICAgICAocG9pbnREYXRhW3BvaW50SWR4KytdIC0gbW9kZWwuY29vcmRTaGlmdFsxXSkgKiBtb2RlbC5jb29yZFNjYWxlWzFdO1xuICAgICAgICBwYWNrZWRWQk9bdmJvaWR4KytdID1cbiAgICAgICAgICAocG9pbnREYXRhW3BvaW50SWR4KytdIC0gbW9kZWwuY29vcmRTaGlmdFsyXSkgKiBtb2RlbC5jb29yZFNjYWxlWzJdO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9ybWFsRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5oYXZlQ2VsbE5vcm1hbHMpIHtcbiAgICAgICAgICBub3JtYWxJZHggPSAoY2VsbENvdW50ICsgb3B0aW9ucy5jZWxsT2Zmc2V0KSAqIDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9ybWFsSWR4ID0gaSAqIDM7XG4gICAgICAgIH1cbiAgICAgICAgcGFja2VkVkJPW3Zib2lkeCsrXSA9IG5vcm1hbERhdGFbbm9ybWFsSWR4KytdO1xuICAgICAgICBwYWNrZWRWQk9bdmJvaWR4KytdID0gbm9ybWFsRGF0YVtub3JtYWxJZHgrK107XG4gICAgICAgIHBhY2tlZFZCT1t2Ym9pZHgrK10gPSBub3JtYWxEYXRhW25vcm1hbElkeCsrXTtcbiAgICAgIH1cblxuICAgICAgbW9kZWwuY3VzdG9tRGF0YS5mb3JFYWNoKChhdHRyKSA9PiB7XG4gICAgICAgIGN1c3RJZHggPSBpICogYXR0ci5jb21wb25lbnRzO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGF0dHIuY29tcG9uZW50czsgKytqKSB7XG4gICAgICAgICAgcGFja2VkVkJPW3Zib2lkeCsrXSA9IGF0dHIuZGF0YVtjdXN0SWR4KytdO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRjb29yZERhdGEgIT09IG51bGwpIHtcbiAgICAgICAgdGNvb3JkSWR4ID0gaSAqIHRleHR1cmVDb21wb25lbnRzO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRleHR1cmVDb21wb25lbnRzOyArK2opIHtcbiAgICAgICAgICBwYWNrZWRWQk9bdmJvaWR4KytdID0gdGNvb3JkRGF0YVt0Y29vcmRJZHgrK107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNvbG9yRGF0YSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0aW9ucy5oYXZlQ2VsbFNjYWxhcnMpIHtcbiAgICAgICAgICBjb2xvcklkeCA9IChjZWxsQ291bnQgKyBvcHRpb25zLmNlbGxPZmZzZXQpICogY29sb3JDb21wb25lbnRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbG9ySWR4ID0gaSAqIGNvbG9yQ29tcG9uZW50cztcbiAgICAgICAgfVxuICAgICAgICBwYWNrZWRVQ1ZCT1t1Y2lkeCsrXSA9IGNvbG9yRGF0YVtjb2xvcklkeCsrXTtcbiAgICAgICAgcGFja2VkVUNWQk9bdWNpZHgrK10gPSBjb2xvckRhdGFbY29sb3JJZHgrK107XG4gICAgICAgIHBhY2tlZFVDVkJPW3VjaWR4KytdID0gY29sb3JEYXRhW2NvbG9ySWR4KytdO1xuICAgICAgICBwYWNrZWRVQ1ZCT1t1Y2lkeCsrXSA9XG4gICAgICAgICAgY29sb3JDb21wb25lbnRzID09PSA0ID8gY29sb3JEYXRhW2NvbG9ySWR4KytdIDogMjU1O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc2l6ZTsgKSB7XG4gICAgICBmdW5jKGFycmF5W2luZGV4XSwgYXJyYXksIGluZGV4ICsgMSk7XG4gICAgICBpbmRleCArPSBhcnJheVtpbmRleF0gKyAxO1xuICAgICAgY2VsbENvdW50Kys7XG4gICAgfVxuICAgIG1vZGVsLmVsZW1lbnRDb3VudCA9IGNhYm9Db3VudDtcbiAgICBwdWJsaWNBUEkudXBsb2FkKHBhY2tlZFZCTywgT2JqZWN0VHlwZS5BUlJBWV9CVUZGRVIpO1xuICAgIGlmIChtb2RlbC5jb2xvckJPKSB7XG4gICAgICBtb2RlbC5jb2xvckJPU3RyaWRlID0gNDtcbiAgICAgIG1vZGVsLmNvbG9yQk8udXBsb2FkKHBhY2tlZFVDVkJPLCBPYmplY3RUeXBlLkFSUkFZX0JVRkZFUik7XG4gICAgfVxuICAgIHJldHVybiBjZWxsQ291bnQ7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldENvb3JkU2hpZnRBbmRTY2FsZSA9IChjb29yZFNoaWZ0LCBjb29yZFNjYWxlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgY29vcmRTaGlmdCAhPT0gbnVsbCAmJlxuICAgICAgKGNvb3JkU2hpZnQuY29uc3RydWN0b3IgIT09IEZsb2F0MzJBcnJheSB8fCBjb29yZFNoaWZ0Lmxlbmd0aCAhPT0gMylcbiAgICApIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oJ1dyb25nIHR5cGUgZm9yIGNvb3JkU2hpZnQsIGV4cGVjdGVkIHZlYzMgb3IgbnVsbCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGNvb3JkU2NhbGUgIT09IG51bGwgJiZcbiAgICAgIChjb29yZFNjYWxlLmNvbnN0cnVjdG9yICE9PSBGbG9hdDMyQXJyYXkgfHwgY29vcmRTY2FsZS5sZW5ndGggIT09IDMpXG4gICAgKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKCdXcm9uZyB0eXBlIGZvciBjb29yZFNjYWxlLCBleHBlY3RlZCB2ZWMzIG9yIG51bGwnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBtb2RlbC5jb29yZFNoaWZ0ID09PSBudWxsIHx8XG4gICAgICBjb29yZFNoaWZ0ID09PSBudWxsIHx8XG4gICAgICAhdmVjMy5lcXVhbHMoY29vcmRTaGlmdCwgbW9kZWwuY29vcmRTaGlmdClcbiAgICApIHtcbiAgICAgIG1vZGVsLmNvb3JkU2hpZnQgPSBjb29yZFNoaWZ0O1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG1vZGVsLmNvb3JkU2NhbGUgPT09IG51bGwgfHxcbiAgICAgIGNvb3JkU2NhbGUgPT09IG51bGwgfHxcbiAgICAgICF2ZWMzLmVxdWFscyhjb29yZFNjYWxlLCBtb2RlbC5jb29yZFNjYWxlKVxuICAgICkge1xuICAgICAgbW9kZWwuY29vcmRTY2FsZSA9IGNvb3JkU2NhbGU7XG4gICAgfVxuXG4gICAgbW9kZWwuY29vcmRTaGlmdEFuZFNjYWxlRW5hYmxlZCA9IHNob3VsZEFwcGx5Q29vcmRTaGlmdEFuZFNjYWxlKFxuICAgICAgbW9kZWwuY29vcmRTaGlmdCxcbiAgICAgIG1vZGVsLmNvb3JkU2NhbGVcbiAgICApO1xuXG4gICAgaWYgKG1vZGVsLmNvb3JkU2hpZnRBbmRTY2FsZUVuYWJsZWQpIHtcbiAgICAgIG1vZGVsLmludmVyc2VTaGlmdEFuZFNjYWxlTWF0cml4ID0gY29tcHV0ZUludmVyc2VTaGlmdEFuZFNjYWxlTWF0cml4KFxuICAgICAgICBtb2RlbC5jb29yZFNoaWZ0LFxuICAgICAgICBtb2RlbC5jb29yZFNjYWxlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbC5pbnZlcnNlU2hpZnRBbmRTY2FsZU1hdHJpeCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgZWxlbWVudENvdW50OiAwLFxuICBzdHJpZGU6IDAsXG4gIGNvbG9yQk9TdHJpZGU6IDAsXG4gIHZlcnRleE9mZnNldDogMCxcbiAgbm9ybWFsT2Zmc2V0OiAwLFxuICB0Q29vcmRPZmZzZXQ6IDAsXG4gIHRDb29yZENvbXBvbmVudHM6IDAsXG4gIGNvbG9yT2Zmc2V0OiAwLFxuICBjb2xvckNvbXBvbmVudHM6IDAsXG4gIHRjb29yZEJPOiBudWxsLFxuICBjdXN0b21EYXRhOiBbXSxcbiAgY29vcmRTaGlmdDogbnVsbCxcbiAgY29vcmRTY2FsZTogbnVsbCxcbiAgY29vcmRTaGlmdEFuZFNjYWxlRW5hYmxlZDogZmFsc2UsXG4gIGludmVyc2VTaGlmdEFuZFNjYWxlTWF0cml4OiBudWxsLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gSW5oZXJpdGFuY2VcbiAgdnRrQnVmZmVyT2JqZWN0LmV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzKTtcblxuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgW1xuICAgICdjb2xvckJPJyxcbiAgICAnZWxlbWVudENvdW50JyxcbiAgICAnc3RyaWRlJyxcbiAgICAnY29sb3JCT1N0cmlkZScsXG4gICAgJ3ZlcnRleE9mZnNldCcsXG4gICAgJ25vcm1hbE9mZnNldCcsXG4gICAgJ3RDb29yZE9mZnNldCcsXG4gICAgJ3RDb29yZENvbXBvbmVudHMnLFxuICAgICdjb2xvck9mZnNldCcsXG4gICAgJ2NvbG9yQ29tcG9uZW50cycsXG4gICAgJ2N1c3RvbURhdGEnLFxuICBdKTtcblxuICBtYWNyby5nZXQocHVibGljQVBJLCBtb2RlbCwgW1xuICAgICdjb29yZFNoaWZ0JyxcbiAgICAnY29vcmRTY2FsZScsXG4gICAgJ2Nvb3JkU2hpZnRBbmRTY2FsZUVuYWJsZWQnLFxuICAgICdpbnZlcnNlU2hpZnRBbmRTY2FsZU1hdHJpeCcsXG4gIF0pO1xuXG4gIC8vIE9iamVjdCBzcGVjaWZpYyBtZXRob2RzXG4gIHZ0a09wZW5HTENlbGxBcnJheUJ1ZmZlck9iamVjdChwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCB9O1xuIiwiaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB2dGtPcGVuR0xGcmFtZWJ1ZmZlciBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML0ZyYW1lYnVmZmVyJztcbmltcG9ydCB2dGtSZW5kZXJQYXNzIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9TY2VuZUdyYXBoL1JlbmRlclBhc3MnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a0ZvcndhcmRQYXNzKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrRm9yd2FyZFBhc3MnKTtcblxuICAvLyB0aGlzIHBhc3MgaW1wbGVtZW50cyBhIGZvcndhcmQgcmVuZGVyaW5nIHBpcGVsaW5lXG4gIC8vIGlmIGJvdGggdm9sdW1lcyBhbmQgb3BhcXVlIGdlb21ldHJ5IGFyZSBwcmVzZW50XG4gIC8vIGl0IHdpbGwgbWl4IHRoZSB0d28gdG9nZXRoZXIgYnkgY2FwdHVyaW5nIGEgemJ1ZmZlclxuICAvLyBmaXJzdFxuICBwdWJsaWNBUEkudHJhdmVyc2UgPSAodmlld05vZGUsIHBhcmVudCA9IG51bGwpID0+IHtcbiAgICBpZiAobW9kZWwuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHdlIGp1c3QgcmVuZGVyIG91ciBkZWxlZ2F0ZXMgaW4gb3JkZXJcbiAgICBtb2RlbC5jdXJyZW50UGFyZW50ID0gcGFyZW50O1xuXG4gICAgLy8gYnVpbGRcbiAgICBwdWJsaWNBUEkuc2V0Q3VycmVudE9wZXJhdGlvbignYnVpbGRQYXNzJyk7XG4gICAgdmlld05vZGUudHJhdmVyc2UocHVibGljQVBJKTtcblxuICAgIGNvbnN0IG51bWxheWVycyA9IHZpZXdOb2RlLmdldFJlbmRlcmFibGUoKS5nZXROdW1iZXJPZkxheWVycygpO1xuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIHJlbmRlcmVyc1xuICAgIGNvbnN0IHJlbmRlcmVycyA9IHZpZXdOb2RlLmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1sYXllcnM7IGkrKykge1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHJlbmRlcmVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgcmVuTm9kZSA9IHJlbmRlcmVyc1tpbmRleF07XG4gICAgICAgIGNvbnN0IHJlbiA9IHZpZXdOb2RlLmdldFJlbmRlcmFibGUoKS5nZXRSZW5kZXJlcnMoKVtpbmRleF07XG5cbiAgICAgICAgaWYgKHJlbi5nZXREcmF3KCkgJiYgcmVuLmdldExheWVyKCkgPT09IGkpIHtcbiAgICAgICAgICAvLyBjaGVjayBmb3IgYm90aCBvcGFxdWUgYW5kIHZvbHVtZSBhY3RvcnNcbiAgICAgICAgICBtb2RlbC5vcGFxdWVBY3RvckNvdW50ID0gMDtcbiAgICAgICAgICBtb2RlbC50cmFuc2x1Y2VudEFjdG9yQ291bnQgPSAwO1xuICAgICAgICAgIG1vZGVsLnZvbHVtZUNvdW50ID0gMDtcbiAgICAgICAgICBwdWJsaWNBUEkuc2V0Q3VycmVudE9wZXJhdGlvbigncXVlcnlQYXNzJyk7XG5cbiAgICAgICAgICByZW5Ob2RlLnRyYXZlcnNlKHB1YmxpY0FQSSk7XG5cbiAgICAgICAgICAvLyBkbyB3ZSBuZWVkIHRvIGNhcHR1cmUgYSB6YnVmZmVyP1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChtb2RlbC5vcGFxdWVBY3RvckNvdW50ID4gMCAmJiBtb2RlbC52b2x1bWVDb3VudCA+IDApIHx8XG4gICAgICAgICAgICBtb2RlbC5kZXB0aFJlcXVlc3RlZFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHZpZXdOb2RlLmdldEZyYW1lYnVmZmVyU2l6ZSgpO1xuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBmcmFtZWJ1ZmZlciBpcyBzZXR1cFxuICAgICAgICAgICAgaWYgKG1vZGVsLmZyYW1lYnVmZmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIG1vZGVsLmZyYW1lYnVmZmVyID0gdnRrT3BlbkdMRnJhbWVidWZmZXIubmV3SW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZGVsLmZyYW1lYnVmZmVyLnNldE9wZW5HTFJlbmRlcldpbmRvdyh2aWV3Tm9kZSk7XG4gICAgICAgICAgICBtb2RlbC5mcmFtZWJ1ZmZlci5zYXZlQ3VycmVudEJpbmRpbmdzQW5kQnVmZmVycygpO1xuICAgICAgICAgICAgY29uc3QgZmJTaXplID0gbW9kZWwuZnJhbWVidWZmZXIuZ2V0U2l6ZSgpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBmYlNpemUgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgZmJTaXplWzBdICE9PSBzaXplWzBdIHx8XG4gICAgICAgICAgICAgIGZiU2l6ZVsxXSAhPT0gc2l6ZVsxXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIG1vZGVsLmZyYW1lYnVmZmVyLmNyZWF0ZShzaXplWzBdLCBzaXplWzFdKTtcbiAgICAgICAgICAgICAgbW9kZWwuZnJhbWVidWZmZXIucG9wdWxhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW9kZWwuZnJhbWVidWZmZXIuYmluZCgpO1xuICAgICAgICAgICAgcHVibGljQVBJLnNldEN1cnJlbnRPcGVyYXRpb24oJ29wYXF1ZVpCdWZmZXJQYXNzJyk7XG4gICAgICAgICAgICByZW5Ob2RlLnRyYXZlcnNlKHB1YmxpY0FQSSk7XG4gICAgICAgICAgICBtb2RlbC5mcmFtZWJ1ZmZlci5yZXN0b3JlUHJldmlvdXNCaW5kaW5nc0FuZEJ1ZmZlcnMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwdWJsaWNBUEkuc2V0Q3VycmVudE9wZXJhdGlvbignY2FtZXJhUGFzcycpO1xuICAgICAgICAgIHJlbk5vZGUudHJhdmVyc2UocHVibGljQVBJKTtcbiAgICAgICAgICBpZiAobW9kZWwub3BhcXVlQWN0b3JDb3VudCA+IDApIHtcbiAgICAgICAgICAgIHB1YmxpY0FQSS5zZXRDdXJyZW50T3BlcmF0aW9uKCdvcGFxdWVQYXNzJyk7XG4gICAgICAgICAgICByZW5Ob2RlLnRyYXZlcnNlKHB1YmxpY0FQSSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RlbC50cmFuc2x1Y2VudEFjdG9yQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBwdWJsaWNBUEkuc2V0Q3VycmVudE9wZXJhdGlvbigndHJhbnNsdWNlbnRQYXNzJyk7XG4gICAgICAgICAgICByZW5Ob2RlLnRyYXZlcnNlKHB1YmxpY0FQSSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RlbC52b2x1bWVDb3VudCA+IDApIHtcbiAgICAgICAgICAgIHB1YmxpY0FQSS5zZXRDdXJyZW50T3BlcmF0aW9uKCd2b2x1bWVQYXNzJyk7XG4gICAgICAgICAgICByZW5Ob2RlLnRyYXZlcnNlKHB1YmxpY0FQSSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRaQnVmZmVyVGV4dHVyZSA9ICgpID0+IHtcbiAgICBpZiAobW9kZWwuZnJhbWVidWZmZXIpIHtcbiAgICAgIHJldHVybiBtb2RlbC5mcmFtZWJ1ZmZlci5nZXRDb2xvclRleHR1cmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgcHVibGljQVBJLmluY3JlbWVudE9wYXF1ZUFjdG9yQ291bnQgPSAoKSA9PiBtb2RlbC5vcGFxdWVBY3RvckNvdW50Kys7XG4gIHB1YmxpY0FQSS5pbmNyZW1lbnRUcmFuc2x1Y2VudEFjdG9yQ291bnQgPSAoKSA9PlxuICAgIG1vZGVsLnRyYW5zbHVjZW50QWN0b3JDb3VudCsrO1xuICBwdWJsaWNBUEkuaW5jcmVtZW50Vm9sdW1lQ291bnQgPSAoKSA9PiBtb2RlbC52b2x1bWVDb3VudCsrO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgb3BhcXVlQWN0b3JDb3VudDogMCxcbiAgdHJhbnNsdWNlbnRBY3RvckNvdW50OiAwLFxuICB2b2x1bWVDb3VudDogMCxcbiAgZnJhbWVidWZmZXI6IG51bGwsXG4gIGRlcHRoUmVxdWVzdGVkOiBmYWxzZSxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEJ1aWxkIFZUSyBBUElcbiAgdnRrUmVuZGVyUGFzcy5leHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyk7XG5cbiAgbWFjcm8uZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsnZnJhbWVidWZmZXInXSk7XG4gIG1hY3JvLnNldEdldChwdWJsaWNBUEksIG1vZGVsLCBbJ2RlcHRoUmVxdWVzdGVkJ10pO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIHZ0a0ZvcndhcmRQYXNzKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a0ZvcndhcmRQYXNzJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kIH07XG4iLCJpbXBvcnQgKiBhcyBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgdnRrT3BlbkdMVGV4dHVyZSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1RleHR1cmUnO1xuaW1wb3J0IHsgVnRrRGF0YVR5cGVzIH0gZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvRGF0YUFycmF5L0NvbnN0YW50cyc7XG5pbXBvcnQgeyBGaWx0ZXIgfSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1RleHR1cmUvQ29uc3RhbnRzJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrRnJhbWVidWZmZXIgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gdnRrRnJhbWVidWZmZXIocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtGcmFtZWJ1ZmZlcicpO1xuXG4gIHB1YmxpY0FQSS5nZXRCb3RoTW9kZSA9ICgpID0+IG1vZGVsLmNvbnRleHQuRlJBTUVCVUZGRVI7XG4gIC8vIHB1YmxpY0FQSS5nZXREcmF3TW9kZSA9ICgpID0+IG1vZGVsLmNvbnRleHQuRFJBV19GUkFNRUJVRkZFUjtcbiAgLy8gcHVibGljQVBJLmdldFJlYWRNb2RlID0gKCkgPT4gbW9kZWwuY29udGV4dC5SRUFEX0ZSQU1FQlVGRkVSO1xuXG4gIHB1YmxpY0FQSS5zYXZlQ3VycmVudEJpbmRpbmdzQW5kQnVmZmVycyA9IChtb2RlSW4pID0+IHtcbiAgICBjb25zdCBtb2RlID1cbiAgICAgIHR5cGVvZiBtb2RlSW4gIT09ICd1bmRlZmluZWQnID8gbW9kZUluIDogcHVibGljQVBJLmdldEJvdGhNb2RlKCk7XG4gICAgcHVibGljQVBJLnNhdmVDdXJyZW50QmluZGluZ3MobW9kZSk7XG4gICAgcHVibGljQVBJLnNhdmVDdXJyZW50QnVmZmVycyhtb2RlKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2F2ZUN1cnJlbnRCaW5kaW5ncyA9IChtb2RlSW4pID0+IHtcbiAgICBjb25zdCBnbCA9IG1vZGVsLmNvbnRleHQ7XG4gICAgbW9kZWwucHJldmlvdXNEcmF3QmluZGluZyA9IGdsLmdldFBhcmFtZXRlcihcbiAgICAgIG1vZGVsLmNvbnRleHQuRlJBTUVCVUZGRVJfQklORElOR1xuICAgICk7XG4gICAgbW9kZWwucHJldmlvdXNBY3RpdmVGcmFtZWJ1ZmZlciA9IG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRBY3RpdmVGcmFtZWJ1ZmZlcigpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zYXZlQ3VycmVudEJ1ZmZlcnMgPSAobW9kZUluKSA9PiB7XG4gICAgLy8gbm9vcCBvbiB3ZWJnbCAxXG4gIH07XG5cbiAgcHVibGljQVBJLnJlc3RvcmVQcmV2aW91c0JpbmRpbmdzQW5kQnVmZmVycyA9IChtb2RlSW4pID0+IHtcbiAgICBjb25zdCBtb2RlID1cbiAgICAgIHR5cGVvZiBtb2RlSW4gIT09ICd1bmRlZmluZWQnID8gbW9kZUluIDogcHVibGljQVBJLmdldEJvdGhNb2RlKCk7XG4gICAgcHVibGljQVBJLnJlc3RvcmVQcmV2aW91c0JpbmRpbmdzKG1vZGUpO1xuICAgIHB1YmxpY0FQSS5yZXN0b3JlUHJldmlvdXNCdWZmZXJzKG1vZGUpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZXN0b3JlUHJldmlvdXNCaW5kaW5ncyA9IChtb2RlSW4pID0+IHtcbiAgICBjb25zdCBnbCA9IG1vZGVsLmNvbnRleHQ7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBtb2RlbC5wcmV2aW91c0RyYXdCaW5kaW5nKTtcbiAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuc2V0QWN0aXZlRnJhbWVidWZmZXIoXG4gICAgICBtb2RlbC5wcmV2aW91c0FjdGl2ZUZyYW1lYnVmZmVyXG4gICAgKTtcbiAgfTtcblxuICBwdWJsaWNBUEkucmVzdG9yZVByZXZpb3VzQnVmZmVycyA9IChtb2RlSW4pID0+IHtcbiAgICAvLyBjdXJyZW50bHkgYSBub29wIG9uIHdlYmdsMVxuICB9O1xuXG4gIHB1YmxpY0FQSS5iaW5kID0gKCkgPT4ge1xuICAgIG1vZGVsLmNvbnRleHQuYmluZEZyYW1lYnVmZmVyKFxuICAgICAgbW9kZWwuY29udGV4dC5GUkFNRUJVRkZFUixcbiAgICAgIG1vZGVsLmdsRnJhbWVidWZmZXJcbiAgICApO1xuICAgIGlmIChtb2RlbC5jb2xvclRleHR1cmUpIHtcbiAgICAgIG1vZGVsLmNvbG9yVGV4dHVyZS5iaW5kKCk7XG4gICAgfVxuICAgIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5zZXRBY3RpdmVGcmFtZWJ1ZmZlcihwdWJsaWNBUEkpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5jcmVhdGUgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgIG1vZGVsLmdsRnJhbWVidWZmZXIgPSBtb2RlbC5jb250ZXh0LmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgbW9kZWwuZ2xGcmFtZWJ1ZmZlci53aWR0aCA9IHdpZHRoO1xuICAgIG1vZGVsLmdsRnJhbWVidWZmZXIuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRDb2xvckJ1ZmZlciA9ICh0ZXh0dXJlLCBhdHRhY2htZW50ID0gMCkgPT4ge1xuICAgIGNvbnN0IGdsID0gbW9kZWwuY29udGV4dDtcblxuICAgIGxldCBnbEF0dGFjaG1lbnQgPSBnbC5DT0xPUl9BVFRBQ0hNRU5UMDtcbiAgICBpZiAoYXR0YWNobWVudCA+IDApIHtcbiAgICAgIGlmIChtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0V2ViZ2wyKCkpIHtcbiAgICAgICAgZ2xBdHRhY2htZW50ICs9IGF0dGFjaG1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYWNyby52dGtFcnJvck1hY3JvKFxuICAgICAgICAgICdVc2luZyBtdWx0aXBsZSBmcmFtZWJ1ZmZlciBhdHRhY2htZW50cyByZXF1aXJlcyBXZWJHTCAyJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIG1vZGVsLmNvbG9yVGV4dHVyZSA9IHRleHR1cmU7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICBnbC5GUkFNRUJVRkZFUixcbiAgICAgIGdsQXR0YWNobWVudCxcbiAgICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgICB0ZXh0dXJlLmdldEhhbmRsZSgpLFxuICAgICAgMFxuICAgICk7XG4gIH07XG5cbiAgcHVibGljQVBJLnJlbW92ZUNvbG9yQnVmZmVyID0gKGF0dGFjaG1lbnQgPSAwKSA9PiB7XG4gICAgY29uc3QgZ2wgPSBtb2RlbC5jb250ZXh0O1xuXG4gICAgbGV0IGdsQXR0YWNobWVudCA9IGdsLkNPTE9SX0FUVEFDSE1FTlQwO1xuICAgIGlmIChhdHRhY2htZW50ID4gMCkge1xuICAgICAgaWYgKG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRXZWJnbDIoKSkge1xuICAgICAgICBnbEF0dGFjaG1lbnQgKz0gYXR0YWNobWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hY3JvLnZ0a0Vycm9yTWFjcm8oXG4gICAgICAgICAgJ1VzaW5nIG11bHRpcGxlIGZyYW1lYnVmZmVyIGF0dGFjaG1lbnRzIHJlcXVpcmVzIFdlYkdMIDInXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChcbiAgICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgICAgZ2xBdHRhY2htZW50LFxuICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgIG51bGwsXG4gICAgICAwXG4gICAgKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0RGVwdGhCdWZmZXIgPSAodGV4dHVyZSkgPT4ge1xuICAgIGlmIChtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0V2ViZ2wyKCkpIHtcbiAgICAgIGNvbnN0IGdsID0gbW9kZWwuY29udGV4dDtcbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgICAgICBnbC5GUkFNRUJVRkZFUixcbiAgICAgICAgZ2wuREVQVEhfQVRUQUNITUVOVCxcbiAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgdGV4dHVyZS5nZXRIYW5kbGUoKSxcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFjcm8udnRrRXJyb3JNYWNybyhcbiAgICAgICAgJ0F0dGFjaGluZyBkZXB0aCBidWZmZXIgdGV4dHVyZXMgdG8gZmJvIHJlcXVpcmVzIFdlYkdMIDInXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkucmVtb3ZlRGVwdGhCdWZmZXIgPSAoKSA9PiB7XG4gICAgaWYgKG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRXZWJnbDIoKSkge1xuICAgICAgY29uc3QgZ2wgPSBtb2RlbC5jb250ZXh0O1xuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgICAgICBnbC5ERVBUSF9BVFRBQ0hNRU5ULFxuICAgICAgICBnbC5URVhUVVJFXzJELFxuICAgICAgICBudWxsLFxuICAgICAgICAwXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYWNyby52dGtFcnJvck1hY3JvKFxuICAgICAgICAnQXR0YWNoaW5nIGRlcHRoIGJ1ZmZlciB0ZXh0dXJlcyB0byBmcmFtZWJ1ZmZlcnMgcmVxdWlyZXMgV2ViR0wgMidcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRHTEZyYW1lYnVmZmVyID0gKCkgPT4gbW9kZWwuZ2xGcmFtZWJ1ZmZlcjtcblxuICBwdWJsaWNBUEkuc2V0T3BlbkdMUmVuZGVyV2luZG93ID0gKHJ3KSA9PiB7XG4gICAgaWYgKG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyA9PT0gcncpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHVibGljQVBJLnJlbGVhc2VHcmFwaGljc1Jlc291cmNlcygpO1xuICAgIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyA9IHJ3O1xuICAgIG1vZGVsLmNvbnRleHQgPSBudWxsO1xuICAgIGlmIChydykge1xuICAgICAgbW9kZWwuY29udGV4dCA9IG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRDb250ZXh0KCk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5yZWxlYXNlR3JhcGhpY3NSZXNvdXJjZXMgPSAoKSA9PiB7XG4gICAgaWYgKG1vZGVsLmdsRnJhbWVidWZmZXIpIHtcbiAgICAgIG1vZGVsLmNvbnRleHQuZGVsZXRlRnJhbWVidWZmZXIobW9kZWwuZ2xGcmFtZWJ1ZmZlcik7XG4gICAgfVxuICAgIGlmIChtb2RlbC5jb2xvclRleHR1cmUpIHtcbiAgICAgIG1vZGVsLmNvbG9yVGV4dHVyZS5yZWxlYXNlR3JhcGhpY3NSZXNvdXJjZXMoKTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmdldFNpemUgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2l6ZSA9IFswLCAwXTtcbiAgICBpZiAobW9kZWwuZ2xGcmFtZWJ1ZmZlciAhPT0gbnVsbCkge1xuICAgICAgc2l6ZVswXSA9IG1vZGVsLmdsRnJhbWVidWZmZXIud2lkdGg7XG4gICAgICBzaXplWzFdID0gbW9kZWwuZ2xGcmFtZWJ1ZmZlci5oZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBzaXplO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5wb3B1bGF0ZUZyYW1lYnVmZmVyID0gKCkgPT4ge1xuICAgIHB1YmxpY0FQSS5iaW5kKCk7XG4gICAgY29uc3QgZ2wgPSBtb2RlbC5jb250ZXh0O1xuXG4gICAgY29uc3QgdGV4dHVyZSA9IHZ0a09wZW5HTFRleHR1cmUubmV3SW5zdGFuY2UoKTtcbiAgICB0ZXh0dXJlLnNldE9wZW5HTFJlbmRlcldpbmRvdyhtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cpO1xuICAgIHRleHR1cmUuc2V0TWluaWZpY2F0aW9uRmlsdGVyKEZpbHRlci5MSU5FQVIpO1xuICAgIHRleHR1cmUuc2V0TWFnbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTElORUFSKTtcbiAgICB0ZXh0dXJlLmNyZWF0ZTJERnJvbVJhdyhcbiAgICAgIG1vZGVsLmdsRnJhbWVidWZmZXIud2lkdGgsXG4gICAgICBtb2RlbC5nbEZyYW1lYnVmZmVyLmhlaWdodCxcbiAgICAgIDQsXG4gICAgICBWdGtEYXRhVHlwZXMuVU5TSUdORURfQ0hBUixcbiAgICAgIG51bGxcbiAgICApO1xuICAgIHB1YmxpY0FQSS5zZXRDb2xvckJ1ZmZlcih0ZXh0dXJlKTtcblxuICAgIC8vIGZvciBub3cgZG8gbm90IGNvdW50IG9uIGhhdmluZyBhIGRlcHRoIGJ1ZmZlciB0ZXh0dXJlXG4gICAgLy8gYXMgdGhleSBhcmUgbm90IHN0YW5kYXJkIHdlYmdsIDFcbiAgICBtb2RlbC5kZXB0aFRleHR1cmUgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbW9kZWwuZGVwdGhUZXh0dXJlKTtcbiAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKFxuICAgICAgZ2wuUkVOREVSQlVGRkVSLFxuICAgICAgZ2wuREVQVEhfQ09NUE9ORU5UMTYsXG4gICAgICBtb2RlbC5nbEZyYW1lYnVmZmVyLndpZHRoLFxuICAgICAgbW9kZWwuZ2xGcmFtZWJ1ZmZlci5oZWlnaHRcbiAgICApO1xuICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKFxuICAgICAgZ2wuRlJBTUVCVUZGRVIsXG4gICAgICBnbC5ERVBUSF9BVFRBQ0hNRU5ULFxuICAgICAgZ2wuUkVOREVSQlVGRkVSLFxuICAgICAgbW9kZWwuZGVwdGhUZXh0dXJlXG4gICAgKTtcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBvcGVuR0xSZW5kZXJXaW5kb3c6IG51bGwsXG4gIGdsRnJhbWVidWZmZXI6IG51bGwsXG4gIGNvbG9yVGV4dHVyZTogbnVsbCxcbiAgZGVwdGhUZXh0dXJlOiBudWxsLFxuICBwcmV2aW91c0RyYXdCaW5kaW5nOiAwLFxuICBwcmV2aW91c1JlYWRCaW5kaW5nOiAwLFxuICBwcmV2aW91c0RyYXdCdWZmZXI6IDAsXG4gIHByZXZpb3VzUmVhZEJ1ZmZlcjogMCxcbiAgcHJldmlvdXNBY3RpdmVGcmFtZWJ1ZmZlcjogbnVsbCxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBCdWlsZCBWVEsgQVBJXG4gIG1hY3JvLm9iaihwdWJsaWNBUEksIG1vZGVsKTtcblxuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgWydjb2xvclRleHR1cmUnXSk7XG5cbiAgLy8gRm9yIG1vcmUgbWFjcm8gbWV0aG9kcywgc2VlIFwiU291cmNlcy9tYWNyby5qc1wiXG4gIC8vIE9iamVjdCBzcGVjaWZpYyBtZXRob2RzXG4gIHZ0a0ZyYW1lYnVmZmVyKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQsICd2dGtGcmFtZWJ1ZmZlcicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImltcG9ydCB7IG1hdDMsIG1hdDQgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5pbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuXG5pbXBvcnQgdnRrQnVmZmVyT2JqZWN0IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvQnVmZmVyT2JqZWN0JztcbmltcG9ydCB2dGtIYXJkd2FyZVNlbGVjdG9yIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvSGFyZHdhcmVTZWxlY3Rvcic7XG5pbXBvcnQgdnRrUHJvcGVydHkgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvUHJvcGVydHknO1xuaW1wb3J0IHZ0a09wZW5HTFBvbHlEYXRhTWFwcGVyIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvUG9seURhdGFNYXBwZXInO1xuaW1wb3J0IHZ0a1NoYWRlclByb2dyYW0gZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9TaGFkZXJQcm9ncmFtJztcblxuY29uc3QgeyB2dGtFcnJvck1hY3JvIH0gPSBtYWNybztcbmNvbnN0IHsgUmVwcmVzZW50YXRpb24gfSA9IHZ0a1Byb3BlcnR5O1xuY29uc3QgeyBPYmplY3RUeXBlIH0gPSB2dGtCdWZmZXJPYmplY3Q7XG5jb25zdCB7IFBhc3NUeXBlcyB9ID0gdnRrSGFyZHdhcmVTZWxlY3RvcjtcblxuY29uc3QgU3RhcnRFdmVudCA9IHsgdHlwZTogJ1N0YXJ0RXZlbnQnIH07XG5jb25zdCBFbmRFdmVudCA9IHsgdHlwZTogJ0VuZEV2ZW50JyB9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtPcGVuR0xTcGhlcmVNYXBwZXIgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtPcGVuR0xHbHlwaDNETWFwcGVyKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrT3BlbkdMR2x5cGgzRE1hcHBlcicpO1xuXG4gIC8vIENhcHR1cmUgJ3BhcmVudENsYXNzJyBhcGkgZm9yIGludGVybmFsIHVzZVxuICBjb25zdCBzdXBlckNsYXNzID0geyAuLi5wdWJsaWNBUEkgfTtcblxuICBwdWJsaWNBUEkucmVuZGVyUGllY2UgPSAocmVuLCBhY3RvcikgPT4ge1xuICAgIHB1YmxpY0FQSS5pbnZva2VFdmVudChTdGFydEV2ZW50KTtcbiAgICBpZiAoIW1vZGVsLnJlbmRlcmFibGUuZ2V0U3RhdGljKCkpIHtcbiAgICAgIG1vZGVsLnJlbmRlcmFibGUudXBkYXRlKCk7XG4gICAgfVxuICAgIG1vZGVsLmN1cnJlbnRJbnB1dCA9IG1vZGVsLnJlbmRlcmFibGUuZ2V0SW5wdXREYXRhKDEpO1xuICAgIHB1YmxpY0FQSS5pbnZva2VFdmVudChFbmRFdmVudCk7XG5cbiAgICBpZiAoIW1vZGVsLmN1cnJlbnRJbnB1dCkge1xuICAgICAgdnRrRXJyb3JNYWNybygnTm8gaW5wdXQhJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyB0aGVuIHdlIGFyZSBkb25lXG4gICAgaWYgKFxuICAgICAgIW1vZGVsLmN1cnJlbnRJbnB1dC5nZXRQb2ludHMgfHxcbiAgICAgICFtb2RlbC5jdXJyZW50SW5wdXQuZ2V0UG9pbnRzKCkuZ2V0TnVtYmVyT2ZWYWx1ZXMoKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGZhY2VDdWxsaW5nXG4gICAgY29uc3QgZ2wgPSBtb2RlbC5jb250ZXh0O1xuICAgIGlmIChtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0V2ViZ2wyKCkpIHtcbiAgICAgIG1vZGVsLmhhcmR3YXJlU3VwcG9ydCA9IHRydWU7XG4gICAgICBtb2RlbC5leHRlbnNpb24gPSBudWxsO1xuICAgIH0gZWxzZSBpZiAoIW1vZGVsLmV4dGVuc2lvbikge1xuICAgICAgbW9kZWwuZXh0ZW5zaW9uID0gbW9kZWwuY29udGV4dC5nZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcbiAgICAgIG1vZGVsLmhhcmR3YXJlU3VwcG9ydCA9ICEhbW9kZWwuZXh0ZW5zaW9uO1xuICAgIH1cbiAgICAvLyB0byB0ZXN0IHdpdGhvdXQgZXh0ZW5zaW9uIHN1cHBvcnQgdW5jb21tZW50IHRoZSBuZXh0IHR3byBsaW5lc1xuICAgIC8vIG1vZGVsLmV4dGVuc2lvbiA9IG51bGw7XG4gICAgLy8gbW9kZWwuaGFyZHdhcmVTdXBwb3J0ID0gISFtb2RlbC5leHRlbnNpb247XG5cbiAgICBjb25zdCBiYWNrZmFjZUN1bGxpbmcgPSBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldEJhY2tmYWNlQ3VsbGluZygpO1xuICAgIGNvbnN0IGZyb250ZmFjZUN1bGxpbmcgPSBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldEZyb250ZmFjZUN1bGxpbmcoKTtcbiAgICBpZiAoIWJhY2tmYWNlQ3VsbGluZyAmJiAhZnJvbnRmYWNlQ3VsbGluZykge1xuICAgICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmRpc2FibGVDdWxsRmFjZSgpO1xuICAgIH0gZWxzZSBpZiAoZnJvbnRmYWNlQ3VsbGluZykge1xuICAgICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmVuYWJsZUN1bGxGYWNlKCk7XG4gICAgICBnbC5jdWxsRmFjZShnbC5GUk9OVCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5lbmFibGVDdWxsRmFjZSgpO1xuICAgICAgZ2wuY3VsbEZhY2UoZ2wuQkFDSyk7XG4gICAgfVxuXG4gICAgcHVibGljQVBJLnJlbmRlclBpZWNlU3RhcnQocmVuLCBhY3Rvcik7XG4gICAgcHVibGljQVBJLnJlbmRlclBpZWNlRHJhdyhyZW4sIGFjdG9yKTtcbiAgICBwdWJsaWNBUEkucmVuZGVyUGllY2VGaW5pc2gocmVuLCBhY3Rvcik7XG4gIH07XG5cbiAgcHVibGljQVBJLm11bHRpcGx5NHg0V2l0aE9mZnNldCA9IChvdXQsIGEsIGIsIG9mZikgPT4ge1xuICAgIGNvbnN0IGEwMCA9IGFbMF07XG4gICAgY29uc3QgYTAxID0gYVsxXTtcbiAgICBjb25zdCBhMDIgPSBhWzJdO1xuICAgIGNvbnN0IGEwMyA9IGFbM107XG4gICAgY29uc3QgYTEwID0gYVs0XTtcbiAgICBjb25zdCBhMTEgPSBhWzVdO1xuICAgIGNvbnN0IGExMiA9IGFbNl07XG4gICAgY29uc3QgYTEzID0gYVs3XTtcbiAgICBjb25zdCBhMjAgPSBhWzhdO1xuICAgIGNvbnN0IGEyMSA9IGFbOV07XG4gICAgY29uc3QgYTIyID0gYVsxMF07XG4gICAgY29uc3QgYTIzID0gYVsxMV07XG4gICAgY29uc3QgYTMwID0gYVsxMl07XG4gICAgY29uc3QgYTMxID0gYVsxM107XG4gICAgY29uc3QgYTMyID0gYVsxNF07XG4gICAgY29uc3QgYTMzID0gYVsxNV07XG5cbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgICBsZXQgYjAgPSBiW29mZl07XG4gICAgbGV0IGIxID0gYltvZmYgKyAxXTtcbiAgICBsZXQgYjIgPSBiW29mZiArIDJdO1xuICAgIGxldCBiMyA9IGJbb2ZmICsgM107XG4gICAgb3V0WzBdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gICAgb3V0WzFdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gICAgb3V0WzJdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gICAgb3V0WzNdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG5cbiAgICBiMCA9IGJbb2ZmICsgNF07XG4gICAgYjEgPSBiW29mZiArIDVdO1xuICAgIGIyID0gYltvZmYgKyA2XTtcbiAgICBiMyA9IGJbb2ZmICsgN107XG4gICAgb3V0WzRdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gICAgb3V0WzVdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gICAgb3V0WzZdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gICAgb3V0WzddID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG5cbiAgICBiMCA9IGJbb2ZmICsgOF07XG4gICAgYjEgPSBiW29mZiArIDldO1xuICAgIGIyID0gYltvZmYgKyAxMF07XG4gICAgYjMgPSBiW29mZiArIDExXTtcbiAgICBvdXRbOF0gPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDtcbiAgICBvdXRbOV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgICBvdXRbMTBdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gICAgb3V0WzExXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuXG4gICAgYjAgPSBiW29mZiArIDEyXTtcbiAgICBiMSA9IGJbb2ZmICsgMTNdO1xuICAgIGIyID0gYltvZmYgKyAxNF07XG4gICAgYjMgPSBiW29mZiArIDE1XTtcbiAgICBvdXRbMTJdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gICAgb3V0WzEzXSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICAgIG91dFsxNF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgICBvdXRbMTVdID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7XG4gIH07XG5cbiAgcHVibGljQVBJLnJlcGxhY2VTaGFkZXJOb3JtYWwgPSAoc2hhZGVycywgcmVuLCBhY3RvcikgPT4ge1xuICAgIGlmIChtb2RlbC5oYXJkd2FyZVN1cHBvcnQpIHtcbiAgICAgIGNvbnN0IGxhc3RMaWdodENvbXBsZXhpdHkgPSBtb2RlbC5sYXN0Qm91bmRCTy5nZXRSZWZlcmVuY2VCeU5hbWUoXG4gICAgICAgICdsYXN0TGlnaHRDb21wbGV4aXR5J1xuICAgICAgKTtcblxuICAgICAgaWYgKGxhc3RMaWdodENvbXBsZXhpdHkgPiAwKSB7XG4gICAgICAgIGxldCBWU1NvdXJjZSA9IHNoYWRlcnMuVmVydGV4O1xuXG4gICAgICAgIGlmIChtb2RlbC5sYXN0Qm91bmRCTy5nZXRDQUJPKCkuZ2V0Tm9ybWFsT2Zmc2V0KCkpIHtcbiAgICAgICAgICBWU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgIFZTU291cmNlLFxuICAgICAgICAgICAgJy8vVlRLOjpOb3JtYWw6OkRlYycsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMyBub3JtYWxNQzsnLFxuICAgICAgICAgICAgICAnYXR0cmlidXRlIG1hdDMgZ05vcm1hbDsnLFxuICAgICAgICAgICAgICAndW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDsnLFxuICAgICAgICAgICAgICAndmFyeWluZyB2ZWMzIG5vcm1hbFZDVlNPdXRwdXQ7JyxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApLnJlc3VsdDtcbiAgICAgICAgICBWU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgIFZTU291cmNlLFxuICAgICAgICAgICAgJy8vVlRLOjpOb3JtYWw6OkltcGwnLFxuICAgICAgICAgICAgWydub3JtYWxWQ1ZTT3V0cHV0ID0gbm9ybWFsTWF0cml4ICogZ05vcm1hbCAqIG5vcm1hbE1DOyddXG4gICAgICAgICAgKS5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgc2hhZGVycy5WZXJ0ZXggPSBWU1NvdXJjZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXJDbGFzcy5yZXBsYWNlU2hhZGVyTm9ybWFsKHNoYWRlcnMsIHJlbiwgYWN0b3IpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZXBsYWNlU2hhZGVyQ29sb3IgPSAoc2hhZGVycywgcmVuLCBhY3RvcikgPT4ge1xuICAgIGlmIChtb2RlbC5oYXJkd2FyZVN1cHBvcnQgJiYgbW9kZWwucmVuZGVyYWJsZS5nZXRDb2xvckFycmF5KCkpIHtcbiAgICAgIGxldCBWU1NvdXJjZSA9IHNoYWRlcnMuVmVydGV4O1xuICAgICAgbGV0IEdTU291cmNlID0gc2hhZGVycy5HZW9tZXRyeTtcbiAgICAgIGxldCBGU1NvdXJjZSA9IHNoYWRlcnMuRnJhZ21lbnQ7XG5cbiAgICAgIGNvbnN0IGxhc3RMaWdodENvbXBsZXhpdHkgPSBtb2RlbC5sYXN0Qm91bmRCTy5nZXRSZWZlcmVuY2VCeU5hbWUoXG4gICAgICAgICdsYXN0TGlnaHRDb21wbGV4aXR5J1xuICAgICAgKTtcblxuICAgICAgLy8gY3JlYXRlIHRoZSBtYXRlcmlhbC9jb2xvciBwcm9wZXJ0eSBkZWNsYXJhdGlvbnMsIGFuZCBWUyBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gdGhlc2UgYXJlIGFsd2F5cyBkZWZpbmVkXG4gICAgICBsZXQgY29sb3JEZWMgPSBbXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IGFtYmllbnQ7JyxcbiAgICAgICAgJ3VuaWZvcm0gZmxvYXQgZGlmZnVzZTsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBzcGVjdWxhcjsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBvcGFjaXR5VW5pZm9ybTsgLy8gdGhlIGZyYWdtZW50IG9wYWNpdHknLFxuICAgICAgXTtcbiAgICAgIC8vIGFkZCBtb3JlIGZvciBzcGVjdWxhclxuICAgICAgaWYgKGxhc3RMaWdodENvbXBsZXhpdHkpIHtcbiAgICAgICAgY29sb3JEZWMgPSBjb2xvckRlYy5jb25jYXQoW1xuICAgICAgICAgICd1bmlmb3JtIHZlYzMgc3BlY3VsYXJDb2xvclVuaWZvcm07JyxcbiAgICAgICAgICAndW5pZm9ybSBmbG9hdCBzcGVjdWxhclBvd2VyVW5pZm9ybTsnLFxuICAgICAgICBdKTtcbiAgICAgIH1cblxuICAgICAgLy8gbm93IGhhbmRsZSB0aGUgbW9yZSBjb21wbGV4IGZyYWdtZW50IHNoYWRlciBpbXBsZW1lbnRhdGlvblxuICAgICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgYWx3YXlzIGRlZmluZWQgdmFyaWFibGVzLiAgV2Ugc3RhcnRcbiAgICAgIC8vIGJ5IGFzc2lnbmluZyBhIGRlZmF1bHQgdmFsdWUgZnJvbSB0aGUgdW5pZm9ybVxuICAgICAgbGV0IGNvbG9ySW1wbCA9IFtcbiAgICAgICAgJ3ZlYzMgYW1iaWVudENvbG9yOycsXG4gICAgICAgICcgIHZlYzMgZGlmZnVzZUNvbG9yOycsXG4gICAgICAgICcgIGZsb2F0IG9wYWNpdHk7JyxcbiAgICAgIF07XG4gICAgICBpZiAobGFzdExpZ2h0Q29tcGxleGl0eSkge1xuICAgICAgICBjb2xvckltcGwgPSBjb2xvckltcGwuY29uY2F0KFtcbiAgICAgICAgICAnICB2ZWMzIHNwZWN1bGFyQ29sb3I7JyxcbiAgICAgICAgICAnICBmbG9hdCBzcGVjdWxhclBvd2VyOycsXG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgICAgY29sb3JJbXBsID0gY29sb3JJbXBsLmNvbmNhdChbJyAgb3BhY2l0eSA9IG9wYWNpdHlVbmlmb3JtOyddKTtcbiAgICAgIGlmIChsYXN0TGlnaHRDb21wbGV4aXR5KSB7XG4gICAgICAgIGNvbG9ySW1wbCA9IGNvbG9ySW1wbC5jb25jYXQoW1xuICAgICAgICAgICcgIHNwZWN1bGFyQ29sb3IgPSBzcGVjdWxhckNvbG9yVW5pZm9ybTsnLFxuICAgICAgICAgICcgIHNwZWN1bGFyUG93ZXIgPSBzcGVjdWxhclBvd2VyVW5pZm9ybTsnLFxuICAgICAgICBdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtb2RlbC5kcmF3aW5nRWRnZXMpIHtcbiAgICAgICAgY29sb3JEZWMgPSBjb2xvckRlYy5jb25jYXQoWyd2YXJ5aW5nIHZlYzQgdmVydGV4Q29sb3JWU091dHB1dDsnXSk7XG4gICAgICAgIFZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFZTU291cmNlLCAnLy9WVEs6OkNvbG9yOjpEZWMnLCBbXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWM0IGdDb2xvcjsnLFxuICAgICAgICAgICd2YXJ5aW5nIHZlYzQgdmVydGV4Q29sb3JWU091dHB1dDsnLFxuICAgICAgICBdKS5yZXN1bHQ7XG4gICAgICAgIFZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFZTU291cmNlLCAnLy9WVEs6OkNvbG9yOjpJbXBsJywgW1xuICAgICAgICAgICd2ZXJ0ZXhDb2xvclZTT3V0cHV0ID0gZ0NvbG9yOycsXG4gICAgICAgIF0pLnJlc3VsdDtcbiAgICAgICAgR1NTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoR1NTb3VyY2UsICcvL1ZUSzo6Q29sb3I6OkRlYycsIFtcbiAgICAgICAgICAnaW4gdmVjNCB2ZXJ0ZXhDb2xvclZTT3V0cHV0W107JyxcbiAgICAgICAgICAnb3V0IHZlYzQgdmVydGV4Q29sb3JHU091dHB1dDsnLFxuICAgICAgICBdKS5yZXN1bHQ7XG4gICAgICAgIEdTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKEdTU291cmNlLCAnLy9WVEs6OkNvbG9yOjpJbXBsJywgW1xuICAgICAgICAgICd2ZXJ0ZXhDb2xvckdTT3V0cHV0ID0gdmVydGV4Q29sb3JWU091dHB1dFtpXTsnLFxuICAgICAgICBdKS5yZXN1bHQ7XG5cbiAgICAgICAgY29sb3JJbXBsID0gY29sb3JJbXBsLmNvbmNhdChbXG4gICAgICAgICAgJyAgZGlmZnVzZUNvbG9yID0gdmVydGV4Q29sb3JWU091dHB1dC5yZ2I7JyxcbiAgICAgICAgICAnICBhbWJpZW50Q29sb3IgPSB2ZXJ0ZXhDb2xvclZTT3V0cHV0LnJnYjsnLFxuICAgICAgICAgICcgIG9wYWNpdHkgPSBvcGFjaXR5KnZlcnRleENvbG9yVlNPdXRwdXQuYTsnLFxuICAgICAgICBdKTtcbiAgICAgIH1cblxuICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgIEZTU291cmNlLFxuICAgICAgICAnLy9WVEs6OkNvbG9yOjpJbXBsJyxcbiAgICAgICAgY29sb3JJbXBsXG4gICAgICApLnJlc3VsdDtcblxuICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgIEZTU291cmNlLFxuICAgICAgICAnLy9WVEs6OkNvbG9yOjpEZWMnLFxuICAgICAgICBjb2xvckRlY1xuICAgICAgKS5yZXN1bHQ7XG5cbiAgICAgIHNoYWRlcnMuVmVydGV4ID0gVlNTb3VyY2U7XG4gICAgICBzaGFkZXJzLkdlb21ldHJ5ID0gR1NTb3VyY2U7XG4gICAgICBzaGFkZXJzLkZyYWdtZW50ID0gRlNTb3VyY2U7XG4gICAgfVxuICAgIHN1cGVyQ2xhc3MucmVwbGFjZVNoYWRlckNvbG9yKHNoYWRlcnMsIHJlbiwgYWN0b3IpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZXBsYWNlU2hhZGVyUG9zaXRpb25WQyA9IChzaGFkZXJzLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgaWYgKG1vZGVsLmhhcmR3YXJlU3VwcG9ydCkge1xuICAgICAgbGV0IFZTU291cmNlID0gc2hhZGVycy5WZXJ0ZXg7XG5cbiAgICAgIC8vIGRvIHdlIG5lZWQgdGhlIHZlcnRleCBpbiB0aGUgc2hhZGVyIGluIFZpZXcgQ29vcmRpbmF0ZXNcbiAgICAgIGNvbnN0IGxhc3RMaWdodENvbXBsZXhpdHkgPSBtb2RlbC5sYXN0Qm91bmRCTy5nZXRSZWZlcmVuY2VCeU5hbWUoXG4gICAgICAgICdsYXN0TGlnaHRDb21wbGV4aXR5J1xuICAgICAgKTtcbiAgICAgIGlmIChsYXN0TGlnaHRDb21wbGV4aXR5ID4gMCkge1xuICAgICAgICBWU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICBWU1NvdXJjZSxcbiAgICAgICAgICAnLy9WVEs6OlBvc2l0aW9uVkM6OkltcGwnLFxuICAgICAgICAgIFtcbiAgICAgICAgICAgICd2ZWM0IGdWZXJ0ZXhNQyA9IGdNYXRyaXggKiB2ZXJ0ZXhNQzsnLFxuICAgICAgICAgICAgJ3ZlcnRleFZDVlNPdXRwdXQgPSBNQ1ZDTWF0cml4ICogZ1ZlcnRleE1DOycsXG4gICAgICAgICAgICAnICBnbF9Qb3NpdGlvbiA9IE1DUENNYXRyaXggKiBnVmVydGV4TUM7JyxcbiAgICAgICAgICBdXG4gICAgICAgICkucmVzdWx0O1xuICAgICAgICBWU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShWU1NvdXJjZSwgJy8vVlRLOjpDYW1lcmE6OkRlYycsIFtcbiAgICAgICAgICAnYXR0cmlidXRlIG1hdDQgZ01hdHJpeDsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDQgTUNQQ01hdHJpeDsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDQgTUNWQ01hdHJpeDsnLFxuICAgICAgICBdKS5yZXN1bHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBWU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShWU1NvdXJjZSwgJy8vVlRLOjpDYW1lcmE6OkRlYycsIFtcbiAgICAgICAgICAnYXR0cmlidXRlIG1hdDQgZ01hdHJpeDsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDQgTUNQQ01hdHJpeDsnLFxuICAgICAgICBdKS5yZXN1bHQ7XG4gICAgICAgIFZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICAgIFZTU291cmNlLFxuICAgICAgICAgICcvL1ZUSzo6UG9zaXRpb25WQzo6SW1wbCcsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3ZlYzQgZ1ZlcnRleE1DID0gZ01hdHJpeCAqIHZlcnRleE1DOycsXG4gICAgICAgICAgICAnICBnbF9Qb3NpdGlvbiA9IE1DUENNYXRyaXggKiBnVmVydGV4TUM7JyxcbiAgICAgICAgICBdXG4gICAgICAgICkucmVzdWx0O1xuICAgICAgfVxuICAgICAgc2hhZGVycy5WZXJ0ZXggPSBWU1NvdXJjZTtcbiAgICB9XG4gICAgc3VwZXJDbGFzcy5yZXBsYWNlU2hhZGVyUG9zaXRpb25WQyhzaGFkZXJzLCByZW4sIGFjdG9yKTtcbiAgfTtcblxuICBwdWJsaWNBUEkucmVwbGFjZVNoYWRlclBpY2tpbmcgPSAoc2hhZGVycywgcmVuLCBhY3RvcikgPT4ge1xuICAgIGlmIChtb2RlbC5oYXJkd2FyZVN1cHBvcnQpIHtcbiAgICAgIGxldCBGU1NvdXJjZSA9IHNoYWRlcnMuRnJhZ21lbnQ7XG4gICAgICBsZXQgVlNTb3VyY2UgPSBzaGFkZXJzLlZlcnRleDtcbiAgICAgIFZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFZTU291cmNlLCAnLy9WVEs6OlBpY2tpbmc6OkRlYycsIFtcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMzIG1hcHBlckluZGV4VlM7JyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMyBtYXBwZXJJbmRleFZTT3V0cHV0OycsXG4gICAgICBdKS5yZXN1bHQ7XG4gICAgICBWU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgVlNTb3VyY2UsXG4gICAgICAgICcvL1ZUSzo6UGlja2luZzo6SW1wbCcsXG4gICAgICAgICcgIG1hcHBlckluZGV4VlNPdXRwdXQgPSBtYXBwZXJJbmRleFZTOydcbiAgICAgICkucmVzdWx0O1xuICAgICAgc2hhZGVycy5WZXJ0ZXggPSBWU1NvdXJjZTtcbiAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKEZTU291cmNlLCAnLy9WVEs6OlBpY2tpbmc6OkRlYycsIFtcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMyBtYXBwZXJJbmRleFZTT3V0cHV0OycsXG4gICAgICAgICd1bmlmb3JtIHZlYzMgbWFwcGVySW5kZXg7JyxcbiAgICAgICAgJ3VuaWZvcm0gaW50IHBpY2tpbmc7JyxcbiAgICAgIF0pLnJlc3VsdDtcbiAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKEZTU291cmNlLCAnLy9WVEs6OlBpY2tpbmc6OkltcGwnLCBbXG4gICAgICAgICcgIHZlYzQgcGlja0NvbG9yID0gcGlja2luZyA9PSAyID8gdmVjNChtYXBwZXJJbmRleFZTT3V0cHV0LDEuMCkgOiB2ZWM0KG1hcHBlckluZGV4LDEuMCk7JyxcbiAgICAgICAgJyAgZ2xfRnJhZ0RhdGFbMF0gPSBwaWNraW5nICE9IDAgPyBwaWNrQ29sb3IgOiBnbF9GcmFnRGF0YVswXTsnLFxuICAgICAgXSkucmVzdWx0O1xuICAgICAgc2hhZGVycy5GcmFnbWVudCA9IEZTU291cmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlckNsYXNzLnJlcGxhY2VTaGFkZXJQaWNraW5nKHNoYWRlcnMsIHJlbiwgYWN0b3IpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkudXBkYXRlR2x5cGhTaGFkZXJQYXJhbWV0ZXJzID0gKFxuICAgIG5vcm1hbE1hdHJpeFVzZWQsXG4gICAgbWN2Y01hdHJpeFVzZWQsXG4gICAgY2VsbEJPLFxuICAgIGNhcnJheSxcbiAgICBnYXJyYXksXG4gICAgbmFycmF5LFxuICAgIHAsXG4gICAgc2VsZWN0b3JcbiAgKSA9PiB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNlbGxCTy5nZXRQcm9ncmFtKCk7XG5cbiAgICBpZiAobm9ybWFsTWF0cml4VXNlZCkge1xuICAgICAgY29uc3QgYSA9IG1vZGVsLm5vcm1hbE1hdHJpeDtcbiAgICAgIGNvbnN0IGIgPSBuYXJyYXk7XG4gICAgICBjb25zdCBvZnMgPSBwICogOTtcbiAgICAgIGNvbnN0IG91dCA9IG1vZGVsLnRtcE1hdDM7XG5cbiAgICAgIGNvbnN0IGEwMCA9IGFbMF07XG4gICAgICBjb25zdCBhMDEgPSBhWzFdO1xuICAgICAgY29uc3QgYTAyID0gYVsyXTtcbiAgICAgIGNvbnN0IGExMCA9IGFbM107XG4gICAgICBjb25zdCBhMTEgPSBhWzRdO1xuICAgICAgY29uc3QgYTEyID0gYVs1XTtcbiAgICAgIGNvbnN0IGEyMCA9IGFbNl07XG4gICAgICBjb25zdCBhMjEgPSBhWzddO1xuICAgICAgY29uc3QgYTIyID0gYVs4XTtcblxuICAgICAgY29uc3QgYjAwID0gYltvZnNdO1xuICAgICAgY29uc3QgYjAxID0gYltvZnMgKyAxXTtcbiAgICAgIGNvbnN0IGIwMiA9IGJbb2ZzICsgMl07XG4gICAgICBjb25zdCBiMTAgPSBiW29mcyArIDNdO1xuICAgICAgY29uc3QgYjExID0gYltvZnMgKyA0XTtcbiAgICAgIGNvbnN0IGIxMiA9IGJbb2ZzICsgNV07XG4gICAgICBjb25zdCBiMjAgPSBiW29mcyArIDZdO1xuICAgICAgY29uc3QgYjIxID0gYltvZnMgKyA3XTtcbiAgICAgIGNvbnN0IGIyMiA9IGJbb2ZzICsgOF07XG5cbiAgICAgIG91dFswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcbiAgICAgIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgICAgIG91dFsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcblxuICAgICAgb3V0WzNdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwO1xuICAgICAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICAgICAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuXG4gICAgICBvdXRbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gICAgICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gICAgICBvdXRbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG5cbiAgICAgIHByb2dyYW0uc2V0VW5pZm9ybU1hdHJpeDN4Mygnbm9ybWFsTWF0cml4JywgbW9kZWwudG1wTWF0Myk7XG4gICAgfVxuICAgIHB1YmxpY0FQSS5tdWx0aXBseTR4NFdpdGhPZmZzZXQoXG4gICAgICBtb2RlbC50bXBNYXQ0LFxuICAgICAgbW9kZWwubWNwY01hdHJpeCxcbiAgICAgIGdhcnJheSxcbiAgICAgIHAgKiAxNlxuICAgICk7XG4gICAgcHJvZ3JhbS5zZXRVbmlmb3JtTWF0cml4KCdNQ1BDTWF0cml4JywgbW9kZWwudG1wTWF0NCk7XG4gICAgaWYgKG1jdmNNYXRyaXhVc2VkKSB7XG4gICAgICBwdWJsaWNBUEkubXVsdGlwbHk0eDRXaXRoT2Zmc2V0KFxuICAgICAgICBtb2RlbC50bXBNYXQ0LFxuICAgICAgICBtb2RlbC5tY3ZjTWF0cml4LFxuICAgICAgICBnYXJyYXksXG4gICAgICAgIHAgKiAxNlxuICAgICAgKTtcbiAgICAgIHByb2dyYW0uc2V0VW5pZm9ybU1hdHJpeCgnTUNWQ01hdHJpeCcsIG1vZGVsLnRtcE1hdDQpO1xuICAgIH1cblxuICAgIC8vIHNldCBjb2xvclxuICAgIGlmIChjYXJyYXkpIHtcbiAgICAgIGNvbnN0IGNkYXRhID0gY2FycmF5LmdldERhdGEoKTtcbiAgICAgIG1vZGVsLnRtcENvbG9yWzBdID0gY2RhdGFbcCAqIDRdIC8gMjU1LjA7XG4gICAgICBtb2RlbC50bXBDb2xvclsxXSA9IGNkYXRhW3AgKiA0ICsgMV0gLyAyNTUuMDtcbiAgICAgIG1vZGVsLnRtcENvbG9yWzJdID0gY2RhdGFbcCAqIDQgKyAyXSAvIDI1NS4wO1xuICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtM2ZBcnJheSgnYW1iaWVudENvbG9yVW5pZm9ybScsIG1vZGVsLnRtcENvbG9yKTtcbiAgICAgIHByb2dyYW0uc2V0VW5pZm9ybTNmQXJyYXkoJ2RpZmZ1c2VDb2xvclVuaWZvcm0nLCBtb2RlbC50bXBDb2xvcik7XG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBwcm9ncmFtLnNldFVuaWZvcm0zZkFycmF5KCdtYXBwZXJJbmRleCcsIHNlbGVjdG9yLmdldFByb3BDb2xvclZhbHVlKCkpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkucmVuZGVyUGllY2VEcmF3ID0gKHJlbiwgYWN0b3IpID0+IHtcbiAgICBjb25zdCByZXByZXNlbnRhdGlvbiA9IGFjdG9yLmdldFByb3BlcnR5KCkuZ2V0UmVwcmVzZW50YXRpb24oKTtcblxuICAgIGNvbnN0IGdsID0gbW9kZWwuY29udGV4dDtcblxuICAgIGNvbnN0IGRyYXdTdXJmYWNlV2l0aEVkZ2VzID1cbiAgICAgIGFjdG9yLmdldFByb3BlcnR5KCkuZ2V0RWRnZVZpc2liaWxpdHkoKSAmJlxuICAgICAgcmVwcmVzZW50YXRpb24gPT09IFJlcHJlc2VudGF0aW9uLlNVUkZBQ0U7XG5cbiAgICAvLyBbV01WUF1DID09IHt3b3JsZCwgbW9kZWwsIHZpZXcsIHByb2plY3Rpb259IGNvb3JkaW5hdGVzXG4gICAgLy8gRS5nLiwgV0NQQyA9PSB3b3JsZCB0byBwcm9qZWN0aW9uIGNvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb25cbiAgICBjb25zdCBrZXlNYXRzID0gbW9kZWwub3BlbkdMQ2FtZXJhLmdldEtleU1hdHJpY2VzKHJlbik7XG4gICAgY29uc3QgYWN0TWF0cyA9IG1vZGVsLm9wZW5HTEFjdG9yLmdldEtleU1hdHJpY2VzKCk7XG5cbiAgICAvLyBwcmVjb21wdXRlIHRoZSBhY3RvcitjYW1lcmEgbWF0cyBvbmNlXG4gICAgbWF0My5tdWx0aXBseShcbiAgICAgIG1vZGVsLm5vcm1hbE1hdHJpeCxcbiAgICAgIGtleU1hdHMubm9ybWFsTWF0cml4LFxuICAgICAgYWN0TWF0cy5ub3JtYWxNYXRyaXhcbiAgICApO1xuICAgIG1hdDQubXVsdGlwbHkobW9kZWwubWNwY01hdHJpeCwga2V5TWF0cy53Y3BjLCBhY3RNYXRzLm1jd2MpO1xuICAgIG1hdDQubXVsdGlwbHkobW9kZWwubWN2Y01hdHJpeCwga2V5TWF0cy53Y3ZjLCBhY3RNYXRzLm1jd2MpO1xuXG4gICAgY29uc3QgZ2FycmF5ID0gbW9kZWwucmVuZGVyYWJsZS5nZXRNYXRyaXhBcnJheSgpO1xuICAgIGNvbnN0IG5hcnJheSA9IG1vZGVsLnJlbmRlcmFibGUuZ2V0Tm9ybWFsQXJyYXkoKTtcbiAgICBjb25zdCBjYXJyYXkgPSBtb2RlbC5yZW5kZXJhYmxlLmdldENvbG9yQXJyYXkoKTtcbiAgICBjb25zdCBudW1QdHMgPSBnYXJyYXkubGVuZ3RoIC8gMTY7XG5cbiAgICBsZXQgY29tcG9zaXRlUGFzcyA9IGZhbHNlO1xuICAgIGlmIChtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRTZWxlY3RvcigpKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG1vZGVsLm9wZW5HTFJlbmRlcmVyLmdldFNlbGVjdG9yKCkuZ2V0Q3VycmVudFBhc3MoKSA9PT1cbiAgICAgICAgUGFzc1R5cGVzLkNPTVBPU0lURV9JTkRFWF9QQVNTXG4gICAgICApIHtcbiAgICAgICAgY29tcG9zaXRlUGFzcyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZm9yIGV2ZXJ5IHByaW1pdGl2ZSB0eXBlXG4gICAgZm9yIChsZXQgaSA9IG1vZGVsLnByaW1UeXBlcy5TdGFydDsgaSA8IG1vZGVsLnByaW1UeXBlcy5FbmQ7IGkrKykge1xuICAgICAgLy8gaWYgdGhlcmUgYXJlIGVudHJpZXNcbiAgICAgIGNvbnN0IGNhYm8gPSBtb2RlbC5wcmltaXRpdmVzW2ldLmdldENBQk8oKTtcbiAgICAgIGlmIChjYWJvLmdldEVsZW1lbnRDb3VudCgpKSB7XG4gICAgICAgIC8vIGFyZSB3ZSBkcmF3aW5nIGVkZ2VzXG4gICAgICAgIG1vZGVsLmRyYXdpbmdFZGdlcyA9XG4gICAgICAgICAgZHJhd1N1cmZhY2VXaXRoRWRnZXMgJiZcbiAgICAgICAgICAoaSA9PT0gbW9kZWwucHJpbVR5cGVzLlRyaXNFZGdlcyB8fFxuICAgICAgICAgICAgaSA9PT0gbW9kZWwucHJpbVR5cGVzLlRyaVN0cmlwc0VkZ2VzKTtcbiAgICAgICAgcHVibGljQVBJLnVwZGF0ZVNoYWRlcnMobW9kZWwucHJpbWl0aXZlc1tpXSwgcmVuLCBhY3Rvcik7XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBtb2RlbC5wcmltaXRpdmVzW2ldLmdldFByb2dyYW0oKTtcblxuICAgICAgICBjb25zdCBtb2RlID0gcHVibGljQVBJLmdldE9wZW5HTE1vZGUocmVwcmVzZW50YXRpb24sIGkpO1xuICAgICAgICBjb25zdCBub3JtYWxNYXRyaXhVc2VkID0gcHJvZ3JhbS5pc1VuaWZvcm1Vc2VkKCdub3JtYWxNYXRyaXgnKTtcbiAgICAgICAgY29uc3QgbWN2Y01hdHJpeFVzZWQgPSBwcm9ncmFtLmlzVW5pZm9ybVVzZWQoJ01DVkNNYXRyaXgnKTtcblxuICAgICAgICBpZiAobW9kZWwuaGFyZHdhcmVTdXBwb3J0KSB7XG4gICAgICAgICAgaWYgKG1vZGVsLmV4dGVuc2lvbikge1xuICAgICAgICAgICAgbW9kZWwuZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShcbiAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgY2Fiby5nZXRFbGVtZW50Q291bnQoKSxcbiAgICAgICAgICAgICAgbnVtUHRzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkKG1vZGUsIDAsIGNhYm8uZ2V0RWxlbWVudENvdW50KCksIG51bVB0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRyYXcgdGhlIGFycmF5IG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IGNhbSBtYXRyaXhcbiAgICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IG51bVB0czsgKytwKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9zaXRlUGFzcykge1xuICAgICAgICAgICAgICBtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRTZWxlY3RvcigpLnJlbmRlckNvbXBvc2l0ZUluZGV4KHApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHVibGljQVBJLnVwZGF0ZUdseXBoU2hhZGVyUGFyYW1ldGVycyhcbiAgICAgICAgICAgICAgbm9ybWFsTWF0cml4VXNlZCxcbiAgICAgICAgICAgICAgbWN2Y01hdHJpeFVzZWQsXG4gICAgICAgICAgICAgIG1vZGVsLnByaW1pdGl2ZXNbaV0sXG4gICAgICAgICAgICAgIGNhcnJheSxcbiAgICAgICAgICAgICAgZ2FycmF5LFxuICAgICAgICAgICAgICBuYXJyYXksXG4gICAgICAgICAgICAgIHAsXG4gICAgICAgICAgICAgIGNvbXBvc2l0ZVBhc3MgPyBtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRTZWxlY3RvcigpIDogbnVsbFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMobW9kZSwgMCwgY2Fiby5nZXRFbGVtZW50Q291bnQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRNYXBwZXJTaGFkZXJQYXJhbWV0ZXJzID0gKGNlbGxCTywgcmVuLCBhY3RvcikgPT4ge1xuICAgIGlmIChcbiAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0RWxlbWVudENvdW50KCkgJiZcbiAgICAgIChtb2RlbC5nbHlwaEJPQnVpbGRUaW1lLmdldE1UaW1lKCkgPlxuICAgICAgICBjZWxsQk8uZ2V0QXR0cmlidXRlVXBkYXRlVGltZSgpLmdldE1UaW1lKCkgfHxcbiAgICAgICAgY2VsbEJPLmdldFNoYWRlclNvdXJjZVRpbWUoKS5nZXRNVGltZSgpID5cbiAgICAgICAgICBjZWxsQk8uZ2V0QXR0cmlidXRlVXBkYXRlVGltZSgpLmdldE1UaW1lKCkpXG4gICAgKSB7XG4gICAgICBpZiAoY2VsbEJPLmdldFByb2dyYW0oKS5pc0F0dHJpYnV0ZVVzZWQoJ2dNYXRyaXgnKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWNlbGxCT1xuICAgICAgICAgICAgLmdldFZBTygpXG4gICAgICAgICAgICAuYWRkQXR0cmlidXRlTWF0cml4V2l0aERpdmlzb3IoXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCksXG4gICAgICAgICAgICAgIG1vZGVsLm1hdHJpeEJ1ZmZlcixcbiAgICAgICAgICAgICAgJ2dNYXRyaXgnLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICA2NCxcbiAgICAgICAgICAgICAgbW9kZWwuY29udGV4dC5GTE9BVCxcbiAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIDFcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgdnRrRXJyb3JNYWNybygnRXJyb3Igc2V0dGluZyBnTWF0cml4IGluIHNoYWRlciBWQU8uJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGxCTy5nZXRWQU8oKS5yZW1vdmVBdHRyaWJ1dGVBcnJheSgnZ01hdHJpeCcpO1xuICAgICAgfVxuICAgICAgaWYgKGNlbGxCTy5nZXRQcm9ncmFtKCkuaXNBdHRyaWJ1dGVVc2VkKCdnTm9ybWFsJykpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFjZWxsQk9cbiAgICAgICAgICAgIC5nZXRWQU8oKVxuICAgICAgICAgICAgLmFkZEF0dHJpYnV0ZU1hdHJpeFdpdGhEaXZpc29yKFxuICAgICAgICAgICAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpLFxuICAgICAgICAgICAgICBtb2RlbC5ub3JtYWxCdWZmZXIsXG4gICAgICAgICAgICAgICdnTm9ybWFsJyxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgMzYsXG4gICAgICAgICAgICAgIG1vZGVsLmNvbnRleHQuRkxPQVQsXG4gICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAxXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIHZ0a0Vycm9yTWFjcm8oJ0Vycm9yIHNldHRpbmcgZ05vcm1hbCBpbiBzaGFkZXIgVkFPLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZWxsQk8uZ2V0VkFPKCkucmVtb3ZlQXR0cmlidXRlQXJyYXkoJ2dOb3JtYWwnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjZWxsQk8uZ2V0UHJvZ3JhbSgpLmlzQXR0cmlidXRlVXNlZCgnZ0NvbG9yJykpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFjZWxsQk9cbiAgICAgICAgICAgIC5nZXRWQU8oKVxuICAgICAgICAgICAgLmFkZEF0dHJpYnV0ZUFycmF5V2l0aERpdmlzb3IoXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCksXG4gICAgICAgICAgICAgIG1vZGVsLmNvbG9yQnVmZmVyLFxuICAgICAgICAgICAgICAnZ0NvbG9yJyxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgbW9kZWwuY29udGV4dC5VTlNJR05FRF9CWVRFLFxuICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICB2dGtFcnJvck1hY3JvKCdFcnJvciBzZXR0aW5nIGdDb2xvciBpbiBzaGFkZXIgVkFPLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZWxsQk8uZ2V0VkFPKCkucmVtb3ZlQXR0cmlidXRlQXJyYXkoJ2dDb2xvcicpO1xuICAgICAgfVxuICAgICAgaWYgKGNlbGxCTy5nZXRQcm9ncmFtKCkuaXNBdHRyaWJ1dGVVc2VkKCdtYXBwZXJJbmRleFZTJykpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFjZWxsQk9cbiAgICAgICAgICAgIC5nZXRWQU8oKVxuICAgICAgICAgICAgLmFkZEF0dHJpYnV0ZUFycmF5V2l0aERpdmlzb3IoXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCksXG4gICAgICAgICAgICAgIG1vZGVsLnBpY2tCdWZmZXIsXG4gICAgICAgICAgICAgICdtYXBwZXJJbmRleFZTJyxcbiAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgNCxcbiAgICAgICAgICAgICAgbW9kZWwuY29udGV4dC5VTlNJR05FRF9CWVRFLFxuICAgICAgICAgICAgICA0LFxuICAgICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgICAxLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICB2dGtFcnJvck1hY3JvKCdFcnJvciBzZXR0aW5nIG1hcHBlckluZGV4VlMgaW4gc2hhZGVyIFZBTy4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2VsbEJPLmdldFZBTygpLnJlbW92ZUF0dHJpYnV0ZUFycmF5KCdtYXBwZXJJbmRleFZTJyk7XG4gICAgICB9XG4gICAgICBzdXBlckNsYXNzLnNldE1hcHBlclNoYWRlclBhcmFtZXRlcnMoY2VsbEJPLCByZW4sIGFjdG9yKTtcbiAgICAgIGNlbGxCTy5nZXRBdHRyaWJ1dGVVcGRhdGVUaW1lKCkubW9kaWZpZWQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdXBlckNsYXNzLnNldE1hcHBlclNoYWRlclBhcmFtZXRlcnMoY2VsbEJPLCByZW4sIGFjdG9yKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0TmVlZFRvUmVidWlsZEJ1ZmZlck9iamVjdHMgPSAocmVuLCBhY3RvcikgPT4ge1xuICAgIG1vZGVsLnJlbmRlcmFibGUuYnVpbGRBcnJheXMoKTtcblxuICAgIC8vIGZpcnN0IGRvIGEgY29hcnNlIGNoZWNrXG4gICAgLy8gTm90ZSB0aGF0IHRoZSBhY3RvcidzIG10aW1lIGluY2x1ZGVzIGl0J3MgcHJvcGVydGllcyBtdGltZVxuICAgIGNvbnN0IHZtdGltZSA9IG1vZGVsLlZCT0J1aWxkVGltZS5nZXRNVGltZSgpO1xuICAgIGlmICh2bXRpbWUgPCBtb2RlbC5yZW5kZXJhYmxlLmdldEJ1aWxkVGltZSgpLmdldE1UaW1lKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXJDbGFzcy5nZXROZWVkVG9SZWJ1aWxkQnVmZmVyT2JqZWN0cyhyZW4sIGFjdG9yKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuYnVpbGRCdWZmZXJPYmplY3RzID0gKHJlbiwgYWN0b3IpID0+IHtcbiAgICBpZiAobW9kZWwuaGFyZHdhcmVTdXBwb3J0KSB7XG4gICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBvYmplY3RzIGlmIG5lZWRlZFxuICAgICAgY29uc3QgZ2FycmF5ID0gbW9kZWwucmVuZGVyYWJsZS5nZXRNYXRyaXhBcnJheSgpO1xuICAgICAgY29uc3QgbmFycmF5ID0gbW9kZWwucmVuZGVyYWJsZS5nZXROb3JtYWxBcnJheSgpO1xuICAgICAgY29uc3QgY2FycmF5ID0gbW9kZWwucmVuZGVyYWJsZS5nZXRDb2xvckFycmF5KCk7XG4gICAgICBpZiAoIW1vZGVsLm1hdHJpeEJ1ZmZlcikge1xuICAgICAgICBtb2RlbC5tYXRyaXhCdWZmZXIgPSB2dGtCdWZmZXJPYmplY3QubmV3SW5zdGFuY2UoKTtcbiAgICAgICAgbW9kZWwubWF0cml4QnVmZmVyLnNldE9wZW5HTFJlbmRlcldpbmRvdyhtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cpO1xuICAgICAgICBtb2RlbC5ub3JtYWxCdWZmZXIgPSB2dGtCdWZmZXJPYmplY3QubmV3SW5zdGFuY2UoKTtcbiAgICAgICAgbW9kZWwubm9ybWFsQnVmZmVyLnNldE9wZW5HTFJlbmRlcldpbmRvdyhtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cpO1xuICAgICAgICBtb2RlbC5jb2xvckJ1ZmZlciA9IHZ0a0J1ZmZlck9iamVjdC5uZXdJbnN0YW5jZSgpO1xuICAgICAgICBtb2RlbC5jb2xvckJ1ZmZlci5zZXRPcGVuR0xSZW5kZXJXaW5kb3cobW9kZWwub3BlbkdMUmVuZGVyV2luZG93KTtcbiAgICAgICAgbW9kZWwucGlja0J1ZmZlciA9IHZ0a0J1ZmZlck9iamVjdC5uZXdJbnN0YW5jZSgpO1xuICAgICAgICBtb2RlbC5waWNrQnVmZmVyLnNldE9wZW5HTFJlbmRlcldpbmRvdyhtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cpO1xuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBtb2RlbC5yZW5kZXJhYmxlLmdldEJ1aWxkVGltZSgpLmdldE1UaW1lKCkgPlxuICAgICAgICBtb2RlbC5nbHlwaEJPQnVpbGRUaW1lLmdldE1UaW1lKClcbiAgICAgICkge1xuICAgICAgICBtb2RlbC5tYXRyaXhCdWZmZXIudXBsb2FkKGdhcnJheSwgT2JqZWN0VHlwZS5BUlJBWV9CVUZGRVIpO1xuICAgICAgICBtb2RlbC5ub3JtYWxCdWZmZXIudXBsb2FkKG5hcnJheSwgT2JqZWN0VHlwZS5BUlJBWV9CVUZGRVIpO1xuICAgICAgICBpZiAoY2FycmF5KSB7XG4gICAgICAgICAgbW9kZWwuY29sb3JCdWZmZXIudXBsb2FkKGNhcnJheS5nZXREYXRhKCksIE9iamVjdFR5cGUuQVJSQVlfQlVGRkVSKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlbC5jb2xvckJ1ZmZlci5yZWxlYXNlR3JhcGhpY3NSZXNvdXJjZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBudW1QdHMgPSBnYXJyYXkubGVuZ3RoIC8gMTY7XG4gICAgICAgIGNvbnN0IHBhcnJheSA9IG5ldyBVaW50OEFycmF5KDQgKiBudW1QdHMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVB0czsgKytpKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gaSArIDE7XG4gICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaSAqIDQ7XG4gICAgICAgICAgcGFycmF5W29mZnNldF0gPSB2YWx1ZSAlIDI1NjtcbiAgICAgICAgICB2YWx1ZSAtPSBwYXJyYXlbb2Zmc2V0XTtcbiAgICAgICAgICB2YWx1ZSAvPSAyNTY7XG4gICAgICAgICAgcGFycmF5W29mZnNldCArIDFdID0gdmFsdWUgJSAyNTY7XG4gICAgICAgICAgdmFsdWUgLT0gcGFycmF5W29mZnNldCArIDFdO1xuICAgICAgICAgIHZhbHVlIC89IDI1NjtcbiAgICAgICAgICBwYXJyYXlbb2Zmc2V0ICsgMl0gPSB2YWx1ZSAlIDI1NjtcbiAgICAgICAgICBwYXJyYXlbb2Zmc2V0ICsgM10gPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwucGlja0J1ZmZlci51cGxvYWQocGFycmF5LCBPYmplY3RUeXBlLkFSUkFZX0JVRkZFUik7XG4gICAgICAgIG1vZGVsLmdseXBoQk9CdWlsZFRpbWUubW9kaWZpZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyQ2xhc3MuYnVpbGRCdWZmZXJPYmplY3RzKHJlbiwgYWN0b3IpO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgbm9ybWFsTWF0cml4OiBudWxsLFxuICBtY3BjTWF0cml4OiBudWxsLFxuICBtY3djTWF0cml4OiBudWxsLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gSW5oZXJpdGFuY2VcbiAgdnRrT3BlbkdMUG9seURhdGFNYXBwZXIuZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIG1vZGVsLnRtcE1hdDMgPSBtYXQzLmNyZWF0ZSgpO1xuICBtb2RlbC5ub3JtYWxNYXRyaXggPSBtYXQzLmNyZWF0ZSgpO1xuICBtb2RlbC5tY3BjTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgbW9kZWwubWN2Y01hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gIG1vZGVsLnRtcENvbG9yID0gW107XG5cbiAgbW9kZWwuZ2x5cGhCT0J1aWxkVGltZSA9IHt9O1xuICBtYWNyby5vYmoobW9kZWwuZ2x5cGhCT0J1aWxkVGltZSwgeyBtdGltZTogMCB9KTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICB2dGtPcGVuR0xHbHlwaDNETWFwcGVyKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a09wZW5HTEdseXBoM0RNYXBwZXInKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImV4cG9ydCBjb25zdCBQYXNzVHlwZXMgPSB7XG4gIE1JTl9LTk9XTl9QQVNTOiAwLFxuICBBQ1RPUl9QQVNTOiAwLFxuICBDT01QT1NJVEVfSU5ERVhfUEFTUzogMSxcbiAgSURfTE9XMjQ6IDIsXG4gIE1BWF9LTk9XTl9QQVNTOiAyLFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBQYXNzVHlwZXMsXG59O1xuIiwiaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCBDb25zdGFudHMgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9IYXJkd2FyZVNlbGVjdG9yL0NvbnN0YW50cyc7XG5pbXBvcnQgdnRrT3BlbkdMRnJhbWVidWZmZXIgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9GcmFtZWJ1ZmZlcic7XG5pbXBvcnQgdnRrU2VsZWN0aW9uTm9kZSBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vRGF0YU1vZGVsL1NlbGVjdGlvbk5vZGUnO1xuaW1wb3J0IHZ0a0RhdGFTZXQgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9EYXRhU2V0JztcblxuY29uc3QgeyBQYXNzVHlwZXMgfSA9IENvbnN0YW50cztcbmNvbnN0IHsgU2VsZWN0aW9uQ29udGVudCwgU2VsZWN0aW9uRmllbGQgfSA9IHZ0a1NlbGVjdGlvbk5vZGU7XG5jb25zdCB7IEZpZWxkQXNzb2NpYXRpb25zIH0gPSB2dGtEYXRhU2V0O1xuY29uc3QgeyB2dGtFcnJvck1hY3JvIH0gPSBtYWNybztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrT3BlbkdMSGFyZHdhcmVTZWxlY3RvciBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a09wZW5HTEhhcmR3YXJlU2VsZWN0b3IocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtPcGVuR0xIYXJkd2FyZVNlbGVjdG9yJyk7XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5yZWxlYXNlUGl4QnVmZmVycyA9ICgpID0+IHtcbiAgICBtb2RlbC5waXhCdWZmZXIgPSBbXTtcbiAgICBtb2RlbC56QnVmZmVyID0gbnVsbDtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmJlZ2luU2VsZWN0aW9uID0gKCkgPT4ge1xuICAgIG1vZGVsLm9wZW5HTFJlbmRlcmVyID0gbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldFZpZXdOb2RlRm9yKFxuICAgICAgbW9kZWwucmVuZGVyZXJcbiAgICApO1xuICAgIG1vZGVsLm1heEF0dHJpYnV0ZUlkID0gMDtcblxuICAgIGNvbnN0IHNpemUgPSBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0U2l6ZSgpO1xuICAgIGlmICghbW9kZWwuZnJhbWVidWZmZXIpIHtcbiAgICAgIG1vZGVsLmZyYW1lYnVmZmVyID0gdnRrT3BlbkdMRnJhbWVidWZmZXIubmV3SW5zdGFuY2UoKTtcbiAgICAgIG1vZGVsLmZyYW1lYnVmZmVyLnNldE9wZW5HTFJlbmRlcldpbmRvdyhtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cpO1xuICAgICAgbW9kZWwuZnJhbWVidWZmZXIuc2F2ZUN1cnJlbnRCaW5kaW5nc0FuZEJ1ZmZlcnMoKTtcbiAgICAgIG1vZGVsLmZyYW1lYnVmZmVyLmNyZWF0ZShzaXplWzBdLCBzaXplWzFdKTtcbiAgICAgIC8vIHRoaXMgY2FsbHMgbW9kZWwuZnJhbWVidWZmZXIuYmluZCgpXG4gICAgICBtb2RlbC5mcmFtZWJ1ZmZlci5wb3B1bGF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsLmZyYW1lYnVmZmVyLnNldE9wZW5HTFJlbmRlcldpbmRvdyhtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cpO1xuICAgICAgbW9kZWwuZnJhbWVidWZmZXIuc2F2ZUN1cnJlbnRCaW5kaW5nc0FuZEJ1ZmZlcnMoKTtcbiAgICAgIGNvbnN0IGZiU2l6ZSA9IG1vZGVsLmZyYW1lYnVmZmVyLmdldFNpemUoKTtcbiAgICAgIGlmIChmYlNpemVbMF0gIT09IHNpemVbMF0gfHwgZmJTaXplWzFdICE9PSBzaXplWzFdKSB7XG4gICAgICAgIG1vZGVsLmZyYW1lYnVmZmVyLmNyZWF0ZShzaXplWzBdLCBzaXplWzFdKTtcbiAgICAgICAgLy8gdGhpcyBjYWxscyBtb2RlbC5mcmFtZWJ1ZmZlci5iaW5kKClcbiAgICAgICAgbW9kZWwuZnJhbWVidWZmZXIucG9wdWxhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWwuZnJhbWVidWZmZXIuYmluZCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1vZGVsLm9wZW5HTFJlbmRlcmVyLmNsZWFyKCk7XG4gICAgbW9kZWwub3BlbkdMUmVuZGVyZXIuc2V0U2VsZWN0b3IocHVibGljQVBJKTtcbiAgICBtb2RlbC5oaXRQcm9wcyA9IHt9O1xuICAgIG1vZGVsLnByb3BzID0gW107XG4gICAgcHVibGljQVBJLnJlbGVhc2VQaXhCdWZmZXJzKCk7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5lbmRTZWxlY3Rpb24gPSAoKSA9PiB7XG4gICAgbW9kZWwuaGl0UHJvcHMgPSB7fTtcbiAgICBtb2RlbC5vcGVuR0xSZW5kZXJlci5zZXRTZWxlY3RvcihudWxsKTtcbiAgICBtb2RlbC5mcmFtZWJ1ZmZlci5yZXN0b3JlUHJldmlvdXNCaW5kaW5nc0FuZEJ1ZmZlcnMoKTtcbiAgfTtcblxuICBwdWJsaWNBUEkucHJlQ2FwdHVyZVBhc3MgPSAoKSA9PiB7fTtcblxuICBwdWJsaWNBUEkucG9zdENhcHR1cmVQYXNzID0gKCkgPT4ge307XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5zZWxlY3QgPSAoKSA9PiB7XG4gICAgbGV0IHNlbCA9IG51bGw7XG4gICAgaWYgKHB1YmxpY0FQSS5jYXB0dXJlQnVmZmVycygpKSB7XG4gICAgICBzZWwgPSBwdWJsaWNBUEkuZ2VuZXJhdGVTZWxlY3Rpb24oXG4gICAgICAgIG1vZGVsLmFyZWFbMF0sXG4gICAgICAgIG1vZGVsLmFyZWFbMV0sXG4gICAgICAgIG1vZGVsLmFyZWFbMl0sXG4gICAgICAgIG1vZGVsLmFyZWFbM11cbiAgICAgICk7XG4gICAgICBwdWJsaWNBUEkucmVsZWFzZVBpeEJ1ZmZlcnMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbDtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmNhcHR1cmVCdWZmZXJzID0gKCkgPT4ge1xuICAgIGlmICghbW9kZWwucmVuZGVyZXIgfHwgIW1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdykge1xuICAgICAgdnRrRXJyb3JNYWNybygnUmVuZGVyZXIgYW5kIHZpZXcgbXVzdCBiZSBzZXQgYmVmb3JlIGNhbGxpbmcgU2VsZWN0LicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1vZGVsLm9wZW5HTFJlbmRlcmVyID0gbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldFZpZXdOb2RlRm9yKFxuICAgICAgbW9kZWwucmVuZGVyZXJcbiAgICApO1xuXG4gICAgLy8gaW50IHJnYmFbNF07XG4gICAgLy8gcndpbi5nZXRDb2xvckJ1ZmZlclNpemVzKHJnYmEpO1xuICAgIC8vIGlmIChyZ2JhWzBdIDwgOCB8fCByZ2JhWzFdIDwgOCB8fCByZ2JhWzJdIDwgOCkge1xuICAgIC8vICAgdnRrRXJyb3JNYWNybyhcIkNvbG9yIGJ1ZmZlciBkZXB0aCBtdXN0IGJlIGF0IGxlYXN0IDggYml0LiBcIlxuICAgIC8vICAgICBcIkN1cnJlbnRseTogXCIgPDwgcmdiYVswXSA8PCBcIiwgXCIgPDwgcmdiYVsxXSA8PCBcIiwgXCIgPDxyZ2JhWzJdKTtcbiAgICAvLyAgIHJldHVybiBmYWxzZTtcbiAgICAvLyB9XG4gICAgcHVibGljQVBJLmludm9rZUV2ZW50KHsgdHlwZTogJ1N0YXJ0RXZlbnQnIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSByZW5kZXJlciBmb3Igc2VsZWN0aW9uLlxuICAgIC8vIGNoYW5nZSB0aGUgcmVuZGVyZXIncyBiYWNrZ3JvdW5kIHRvIGJsYWNrLCB3aGljaCB3aWxsIGluZGljYXRlIGEgbWlzc1xuICAgIG1vZGVsLm9yaWdpbmFsQmFja2dyb3VuZCA9IG1vZGVsLnJlbmRlcmVyLmdldEJhY2tncm91bmRCeVJlZmVyZW5jZSgpO1xuICAgIG1vZGVsLnJlbmRlcmVyLnNldEJhY2tncm91bmQoMC4wLCAwLjAsIDAuMCk7XG4gICAgY29uc3QgcnBhc3NlcyA9IG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRSZW5kZXJQYXNzZXMoKTtcblxuICAgIHB1YmxpY0FQSS5iZWdpblNlbGVjdGlvbigpO1xuICAgIGZvciAoXG4gICAgICBtb2RlbC5jdXJyZW50UGFzcyA9IFBhc3NUeXBlcy5NSU5fS05PV05fUEFTUztcbiAgICAgIG1vZGVsLmN1cnJlbnRQYXNzIDw9IFBhc3NUeXBlcy5DT01QT1NJVEVfSU5ERVhfUEFTUztcbiAgICAgIG1vZGVsLmN1cnJlbnRQYXNzKytcbiAgICApIHtcbiAgICAgIGlmIChwdWJsaWNBUEkucGFzc1JlcXVpcmVkKG1vZGVsLmN1cnJlbnRQYXNzKSkge1xuICAgICAgICBwdWJsaWNBUEkucHJlQ2FwdHVyZVBhc3MobW9kZWwuY3VycmVudFBhc3MpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgbW9kZWwuY2FwdHVyZVpWYWx1ZXMgJiZcbiAgICAgICAgICBtb2RlbC5jdXJyZW50UGFzcyA9PT0gUGFzc1R5cGVzLkFDVE9SX1BBU1MgJiZcbiAgICAgICAgICB0eXBlb2YgcnBhc3Nlc1swXS5zZXREZXB0aFJlcXVlc3RlZCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgIHR5cGVvZiBycGFzc2VzWzBdLmdldEZyYW1lYnVmZmVyID09PSAnZnVuY3Rpb24nXG4gICAgICAgICkge1xuICAgICAgICAgIHJwYXNzZXNbMF0uc2V0RGVwdGhSZXF1ZXN0ZWQodHJ1ZSk7XG4gICAgICAgICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LnRyYXZlcnNlQWxsUGFzc2VzKCk7XG4gICAgICAgICAgcnBhc3Nlc1swXS5zZXREZXB0aFJlcXVlc3RlZChmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LnRyYXZlcnNlQWxsUGFzc2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcHVibGljQVBJLnBvc3RDYXB0dXJlUGFzcyhtb2RlbC5jdXJyZW50UGFzcyk7XG5cbiAgICAgICAgcHVibGljQVBJLnNhdmVQaXhlbEJ1ZmZlcihtb2RlbC5jdXJyZW50UGFzcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHB1YmxpY0FQSS5lbmRTZWxlY3Rpb24oKTtcblxuICAgIC8vIHJlc3RvcmUgb3JpZ2luYWwgYmFja2dyb3VuZFxuICAgIG1vZGVsLnJlbmRlcmVyLnNldEJhY2tncm91bmQobW9kZWwub3JpZ2luYWxCYWNrZ3JvdW5kKTtcbiAgICBwdWJsaWNBUEkuaW52b2tlRXZlbnQoeyB0eXBlOiAnRW5kRXZlbnQnIH0pO1xuXG4gICAgLy8gcmVzdG9yZSBpbWFnZSwgbm90IG5lZWRlZD9cbiAgICAvLyBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cudHJhdmVyc2VBbGxQYXNzZXMoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLnBhc3NSZXF1aXJlZCA9IChwYXNzKSA9PiB0cnVlO1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuc2F2ZVBpeGVsQnVmZmVyID0gKHBhc3NObykgPT4ge1xuICAgIG1vZGVsLnBpeEJ1ZmZlcltwYXNzTm9dID0gbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldFBpeGVsRGF0YShcbiAgICAgIG1vZGVsLmFyZWFbMF0sXG4gICAgICBtb2RlbC5hcmVhWzFdLFxuICAgICAgbW9kZWwuYXJlYVsyXSxcbiAgICAgIG1vZGVsLmFyZWFbM11cbiAgICApO1xuICAgIGlmIChwYXNzTm8gPT09IFBhc3NUeXBlcy5BQ1RPUl9QQVNTKSB7XG4gICAgICBpZiAobW9kZWwuY2FwdHVyZVpWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgcnBhc3NlcyA9IG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRSZW5kZXJQYXNzZXMoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHR5cGVvZiBycGFzc2VzWzBdLnNldERlcHRoUmVxdWVzdGVkID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgdHlwZW9mIHJwYXNzZXNbMF0uZ2V0RnJhbWVidWZmZXIgPT09ICdmdW5jdGlvbidcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3QgZmIgPSBycGFzc2VzWzBdLmdldEZyYW1lYnVmZmVyKCk7XG4gICAgICAgICAgZmIuc2F2ZUN1cnJlbnRCaW5kaW5nc0FuZEJ1ZmZlcnMoKTtcbiAgICAgICAgICBmYi5iaW5kKCk7XG4gICAgICAgICAgbW9kZWwuekJ1ZmZlciA9IG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRQaXhlbERhdGEoXG4gICAgICAgICAgICBtb2RlbC5hcmVhWzBdLFxuICAgICAgICAgICAgbW9kZWwuYXJlYVsxXSxcbiAgICAgICAgICAgIG1vZGVsLmFyZWFbMl0sXG4gICAgICAgICAgICBtb2RlbC5hcmVhWzNdXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmYi5yZXN0b3JlUHJldmlvdXNCaW5kaW5nc0FuZEJ1ZmZlcnMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHVibGljQVBJLmJ1aWxkUHJvcEhpdExpc3QobW9kZWwucGl4QnVmZmVyW3Bhc3NOb10pO1xuICAgIH1cbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmJ1aWxkUHJvcEhpdExpc3QgPSAocGl4ZWxidWZmZXIpID0+IHtcbiAgICBmb3IgKGxldCB5eSA9IDA7IHl5IDw9IG1vZGVsLmFyZWFbM10gLSBtb2RlbC5hcmVhWzFdOyB5eSsrKSB7XG4gICAgICBmb3IgKGxldCB4eCA9IDA7IHh4IDw9IG1vZGVsLmFyZWFbMl0gLSBtb2RlbC5hcmVhWzBdOyB4eCsrKSB7XG4gICAgICAgIGxldCB2YWwgPSBwdWJsaWNBUEkuY29udmVydCh4eCwgeXksIHBpeGVsYnVmZmVyKTtcbiAgICAgICAgaWYgKHZhbCA+IDApIHtcbiAgICAgICAgICB2YWwtLTtcbiAgICAgICAgICBpZiAoISh2YWwgaW4gbW9kZWwuaGl0UHJvcHMpKSB7XG4gICAgICAgICAgICBtb2RlbC5oaXRQcm9wc1t2YWxdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5yZW5kZXJQcm9wID0gKHByb3ApID0+IHtcbiAgICBpZiAobW9kZWwuY3VycmVudFBhc3MgPT09IFBhc3NUeXBlcy5BQ1RPUl9QQVNTKSB7XG4gICAgICBwdWJsaWNBUEkuc2V0UHJvcENvbG9yVmFsdWVGcm9tSW50KG1vZGVsLnByb3BzLmxlbmd0aCArIG1vZGVsLmlkT2Zmc2V0KTtcbiAgICAgIG1vZGVsLnByb3BzLnB1c2gocHJvcCk7XG4gICAgfVxuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkucmVuZGVyQ29tcG9zaXRlSW5kZXggPSAoaW5kZXgpID0+IHtcbiAgICBpZiAobW9kZWwuY3VycmVudFBhc3MgPT09IFBhc3NUeXBlcy5DT01QT1NJVEVfSU5ERVhfUEFTUykge1xuICAgICAgcHVibGljQVBJLnNldFByb3BDb2xvclZhbHVlRnJvbUludChpbmRleCArIG1vZGVsLmlkT2Zmc2V0KTtcbiAgICB9XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFRPRE86IG1ha2UgaW5saW5lXG4gIHB1YmxpY0FQSS5yZW5kZXJBdHRyaWJ1dGVJZCA9IChhdHRyaWJpZCkgPT4ge1xuICAgIGlmIChhdHRyaWJpZCA8IDApIHtcbiAgICAgIC8vIG5lZ2F0aXZlIGF0dHJpYmlkIGlzIHZhbGlkLiBJdCBoYXBwZW5zIHdoZW4gcmVuZGVyaW5nIGhpZ2hlciBvcmRlclxuICAgICAgLy8gZWxlbWVudHMgd2hlcmUgbmV3IHBvaW50cyBhcmUgYWRkZWQgZm9yIHJlbmRlcmluZyBzbW9vdGggc3VyZmFjZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbW9kZWwubWF4QXR0cmlidXRlSWQgPVxuICAgICAgYXR0cmliaWQgPiBtb2RlbC5tYXhBdHRyaWJ1dGVJZCA/IGF0dHJpYmlkIDogbW9kZWwubWF4QXR0cmlidXRlSWQ7XG5cbiAgICAvLyBpZiAobW9kZWwuY3VycmVudFBhc3MgPCBQYXNzVHlwZXMuSURfTE9XMjQpIHtcbiAgICAvLyAgIHJldHVybjsgLy8gdXNlbGVzcy4uLlxuICAgIC8vIH1cbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmdldFByb3BGcm9tSUQgPSAoaWQpID0+IHtcbiAgICBpZiAoaWQgPj0gMCAmJiBpZCA8IG1vZGVsLnByb3BzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG1vZGVsLnByb3BzW2lkXTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5wYXNzVHlwZVRvU3RyaW5nID0gKHR5cGUpID0+IG1hY3JvLmVudW1Ub1N0cmluZyhQYXNzVHlwZXMsIHR5cGUpO1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuaXNQcm9wSGl0ID0gKGlkKSA9PiBCb29sZWFuKG1vZGVsLmhpdFByb3BzW2lkXSk7XG5cbiAgcHVibGljQVBJLmNvbnZlcnQgPSAoeHgsIHl5LCBwYikgPT4ge1xuICAgIGlmICghcGIpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCBvZmZzZXQgPSAoeXkgKiAobW9kZWwuYXJlYVsyXSAtIG1vZGVsLmFyZWFbMF0gKyAxKSArIHh4KSAqIDQ7XG4gICAgY29uc3QgcmdiID0gW107XG4gICAgcmdiWzBdID0gcGJbb2Zmc2V0XTtcbiAgICByZ2JbMV0gPSBwYltvZmZzZXQgKyAxXTtcbiAgICByZ2JbMl0gPSBwYltvZmZzZXQgKyAyXTtcbiAgICBsZXQgdmFsID0gcmdiWzJdO1xuICAgIHZhbCAqPSAyNTY7XG4gICAgdmFsICs9IHJnYlsxXTtcbiAgICB2YWwgKj0gMjU2O1xuICAgIHZhbCArPSByZ2JbMF07XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0UHJvcENvbG9yVmFsdWVGcm9tSW50ID0gKHZhbCkgPT4ge1xuICAgIG1vZGVsLnByb3BDb2xvclZhbHVlWzBdID0gKHZhbCAlIDI1NikgLyAyNTUuMDtcbiAgICBtb2RlbC5wcm9wQ29sb3JWYWx1ZVsxXSA9IChNYXRoLmZsb29yKHZhbCAvIDI1NikgJSAyNTYpIC8gMjU1LjA7XG4gICAgbW9kZWwucHJvcENvbG9yVmFsdWVbMl0gPSAoTWF0aC5mbG9vcih2YWwgLyA2NTUzNikgJSAyNTYpIC8gMjU1LjA7XG4gIH07XG5cbiAgLy8gaW5mbyBoYXNcbiAgLy8gICB2YWxpZFxuICAvLyAgIHByb3BJZFxuICAvLyAgIHByb3BcbiAgLy8gICBjb21wb3NpdGVJRFxuICAvLyAgIGF0dHJpYnV0ZUlEXG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5nZXRQaXhlbEluZm9ybWF0aW9uID0gKFxuICAgIGluRGlzcGxheVBvc2l0aW9uLFxuICAgIG1heERpc3RhbmNlLFxuICAgIG91dFNlbGVjdGVkUG9zaXRpb25cbiAgKSA9PiB7XG4gICAgLy8gQmFzZSBjYXNlXG4gICAgY29uc3QgbWF4RGlzdCA9IG1heERpc3RhbmNlIDwgMCA/IDAgOiBtYXhEaXN0YW5jZTtcbiAgICBpZiAobWF4RGlzdCA9PT0gMCkge1xuICAgICAgb3V0U2VsZWN0ZWRQb3NpdGlvblswXSA9IGluRGlzcGxheVBvc2l0aW9uWzBdO1xuICAgICAgb3V0U2VsZWN0ZWRQb3NpdGlvblsxXSA9IGluRGlzcGxheVBvc2l0aW9uWzFdO1xuICAgICAgaWYgKFxuICAgICAgICBpbkRpc3BsYXlQb3NpdGlvblswXSA8IG1vZGVsLmFyZWFbMF0gfHxcbiAgICAgICAgaW5EaXNwbGF5UG9zaXRpb25bMF0gPiBtb2RlbC5hcmVhWzJdIHx8XG4gICAgICAgIGluRGlzcGxheVBvc2l0aW9uWzFdIDwgbW9kZWwuYXJlYVsxXSB8fFxuICAgICAgICBpbkRpc3BsYXlQb3NpdGlvblsxXSA+IG1vZGVsLmFyZWFbM11cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gb2Zmc2V0IGluRGlzcGxheVBvc2l0aW9uIGJhc2VkIG9uIHRoZSBsb3dlci1sZWZ0LWNvcm5lciBvZiB0aGUgQXJlYS5cbiAgICAgIGNvbnN0IGRpc3BsYXlQb3NpdGlvbiA9IFtcbiAgICAgICAgaW5EaXNwbGF5UG9zaXRpb25bMF0gLSBtb2RlbC5hcmVhWzBdLFxuICAgICAgICBpbkRpc3BsYXlQb3NpdGlvblsxXSAtIG1vZGVsLmFyZWFbMV0sXG4gICAgICBdO1xuXG4gICAgICBjb25zdCBhY3RvcmlkID0gcHVibGljQVBJLmNvbnZlcnQoXG4gICAgICAgIGRpc3BsYXlQb3NpdGlvblswXSxcbiAgICAgICAgZGlzcGxheVBvc2l0aW9uWzFdLFxuICAgICAgICBtb2RlbC5waXhCdWZmZXJbUGFzc1R5cGVzLkFDVE9SX1BBU1NdXG4gICAgICApO1xuICAgICAgaWYgKGFjdG9yaWQgPD0gMCkge1xuICAgICAgICAvLyB0aGUgcGl4ZWwgZGlkIG5vdCBoaXQgYW55IGFjdG9yLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5mbyA9IHt9O1xuICAgICAgaW5mby52YWxpZCA9IHRydWU7XG5cbiAgICAgIGluZm8ucHJvcElEID0gYWN0b3JpZCAtIG1vZGVsLmlkT2Zmc2V0O1xuICAgICAgaW5mby5wcm9wID0gcHVibGljQVBJLmdldFByb3BGcm9tSUQoaW5mby5wcm9wSUQpO1xuXG4gICAgICBsZXQgY29tcG9zaXRlSUQgPSBwdWJsaWNBUEkuY29udmVydChcbiAgICAgICAgZGlzcGxheVBvc2l0aW9uWzBdLFxuICAgICAgICBkaXNwbGF5UG9zaXRpb25bMV0sXG4gICAgICAgIG1vZGVsLnBpeEJ1ZmZlcltQYXNzVHlwZXMuQ09NUE9TSVRFX0lOREVYX1BBU1NdXG4gICAgICApO1xuICAgICAgaWYgKGNvbXBvc2l0ZUlEIDwgMCB8fCBjb21wb3NpdGVJRCA+IDB4ZmZmZmZmKSB7XG4gICAgICAgIGNvbXBvc2l0ZUlEID0gMDtcbiAgICAgIH1cbiAgICAgIGluZm8uY29tcG9zaXRlSUQgPSBjb21wb3NpdGVJRCAtIG1vZGVsLmlkT2Zmc2V0O1xuICAgICAgaWYgKG1vZGVsLmNhcHR1cmVaVmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9XG4gICAgICAgICAgKGRpc3BsYXlQb3NpdGlvblsxXSAqIChtb2RlbC5hcmVhWzJdIC0gbW9kZWwuYXJlYVswXSArIDEpICtcbiAgICAgICAgICAgIGRpc3BsYXlQb3NpdGlvblswXSkgKlxuICAgICAgICAgIDQ7XG4gICAgICAgIGluZm8uelZhbHVlID1cbiAgICAgICAgICAoMjU2ICogbW9kZWwuekJ1ZmZlcltvZmZzZXRdICsgbW9kZWwuekJ1ZmZlcltvZmZzZXQgKyAxXSkgLyA2NTUzNS4wO1xuICAgICAgICBpbmZvLmRpc3BsYXlQb3NpdGlvbiA9IGluRGlzcGxheVBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zdCBsb3cyNCA9IHB1YmxpY0FQSS5jb252ZXJ0KFxuICAgICAgLy8gICBkaXNwbGF5UG9zaXRpb25bMF0sIGRpc3BsYXlQb3NpdGlvblsxXSwgbW9kZWwucGl4QnVmZmVyW1Bhc3NUeXBlcy5JRF9MT1cyNF0pO1xuXG4gICAgICAvLyAvLyBpZCAwIGlzIHJlc2VydmVkIGZvciBub3RoaW5nIHByZXNlbnQuXG4gICAgICAvLyBpbmZvLmF0dHJpYnV0ZUlEID0gbG93MjQgLSBtb2RlbC5pZE9mZnNldDtcbiAgICAgIC8vIGlmIChpbmZvLmF0dHJpYnV0ZUlEIDwgMCkge1xuICAgICAgLy8gICAvLyB0aGUgcGl4ZWwgZGlkIG5vdCBoaXQgYW55IGNlbGwuXG4gICAgICAvLyAgIHJldHVybiBudWxsO1xuICAgICAgLy8gfVxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHN1Y2Nlc3NpdmVseSBncm93aW5nIGJveGVzLlxuICAgIC8vIFRoZXkgcmVjdXJzaXZlbHkgY2FsbCB0aGUgYmFzZSBjYXNlIHRvIGhhbmRsZSBzaW5nbGUgcGl4ZWxzLlxuICAgIGNvbnN0IGRpc3BQb3MgPSBbaW5EaXNwbGF5UG9zaXRpb25bMF0sIGluRGlzcGxheVBvc2l0aW9uWzFdXTtcbiAgICBjb25zdCBjdXJQb3MgPSBbMCwgMF07XG4gICAgbGV0IGluZm8gPSBwdWJsaWNBUEkuZ2V0UGl4ZWxJbmZvcm1hdGlvbihcbiAgICAgIGluRGlzcGxheVBvc2l0aW9uLFxuICAgICAgMCxcbiAgICAgIG91dFNlbGVjdGVkUG9zaXRpb25cbiAgICApO1xuICAgIGlmIChpbmZvICYmIGluZm8udmFsaWQpIHtcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cbiAgICBmb3IgKGxldCBkaXN0ID0gMTsgZGlzdCA8IG1heERpc3Q7ICsrZGlzdCkge1xuICAgICAgLy8gVmVydGljYWwgc2lkZXMgb2YgYm94LlxuICAgICAgZm9yIChcbiAgICAgICAgbGV0IHkgPSBkaXNwUG9zWzFdID4gZGlzdCA/IGRpc3BQb3NbMV0gLSBkaXN0IDogMDtcbiAgICAgICAgeSA8PSBkaXNwUG9zWzFdICsgZGlzdDtcbiAgICAgICAgKyt5XG4gICAgICApIHtcbiAgICAgICAgY3VyUG9zWzFdID0geTtcbiAgICAgICAgaWYgKGRpc3BQb3NbMF0gPj0gZGlzdCkge1xuICAgICAgICAgIGN1clBvc1swXSA9IGRpc3BQb3NbMF0gLSBkaXN0O1xuICAgICAgICAgIGluZm8gPSBwdWJsaWNBUEkuZ2V0UGl4ZWxJbmZvcm1hdGlvbihjdXJQb3MsIDAsIG91dFNlbGVjdGVkUG9zaXRpb24pO1xuICAgICAgICAgIGlmIChpbmZvICYmIGluZm8udmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJQb3NbMF0gPSBkaXNwUG9zWzBdICsgZGlzdDtcbiAgICAgICAgaW5mbyA9IHB1YmxpY0FQSS5nZXRQaXhlbEluZm9ybWF0aW9uKGN1clBvcywgMCwgb3V0U2VsZWN0ZWRQb3NpdGlvbik7XG4gICAgICAgIGlmIChpbmZvICYmIGluZm8udmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gSG9yaXpvbnRhbCBzaWRlcyBvZiBib3guXG4gICAgICBmb3IgKFxuICAgICAgICBsZXQgeCA9IGRpc3BQb3NbMF0gPj0gZGlzdCA/IGRpc3BQb3NbMF0gLSAoZGlzdCAtIDEpIDogMDtcbiAgICAgICAgeCA8PSBkaXNwUG9zWzBdICsgKGRpc3QgLSAxKTtcbiAgICAgICAgKyt4XG4gICAgICApIHtcbiAgICAgICAgY3VyUG9zWzBdID0geDtcbiAgICAgICAgaWYgKGRpc3BQb3NbMV0gPj0gZGlzdCkge1xuICAgICAgICAgIGN1clBvc1sxXSA9IGRpc3BQb3NbMV0gLSBkaXN0O1xuICAgICAgICAgIGluZm8gPSBwdWJsaWNBUEkuZ2V0UGl4ZWxJbmZvcm1hdGlvbihjdXJQb3MsIDAsIG91dFNlbGVjdGVkUG9zaXRpb24pO1xuICAgICAgICAgIGlmIChpbmZvICYmIGluZm8udmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJQb3NbMV0gPSBkaXNwUG9zWzFdICsgZGlzdDtcbiAgICAgICAgaW5mbyA9IHB1YmxpY0FQSS5nZXRQaXhlbEluZm9ybWF0aW9uKGN1clBvcywgMCwgb3V0U2VsZWN0ZWRQb3NpdGlvbik7XG4gICAgICAgIGlmIChpbmZvICYmIGluZm8udmFsaWQpIHtcbiAgICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vdGhpbmcgaGl0LlxuICAgIG91dFNlbGVjdGVkUG9zaXRpb25bMF0gPSBpbkRpc3BsYXlQb3NpdGlvblswXTtcbiAgICBvdXRTZWxlY3RlZFBvc2l0aW9uWzFdID0gaW5EaXNwbGF5UG9zaXRpb25bMV07XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuY29udmVydFNlbGVjdGlvbiA9IChmaWVsZGFzc29jaWF0aW9uLCBkYXRhTWFwKSA9PiB7XG4gICAgY29uc3Qgc2VsID0gW107XG5cbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGRhdGFNYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgY29uc3QgY2hpbGQgPSB2dGtTZWxlY3Rpb25Ob2RlLm5ld0luc3RhbmNlKCk7XG4gICAgICBjaGlsZC5zZXRDb250ZW50VHlwZShTZWxlY3Rpb25Db250ZW50LklORElDRVMpO1xuICAgICAgc3dpdGNoIChmaWVsZGFzc29jaWF0aW9uKSB7XG4gICAgICAgIGNhc2UgRmllbGRBc3NvY2lhdGlvbnMuRklFTERfQVNTT0NJQVRJT05fQ0VMTFM6XG4gICAgICAgICAgY2hpbGQuc2V0RmllbGRUeXBlKFNlbGVjdGlvbkZpZWxkLkNFTEwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEZpZWxkQXNzb2NpYXRpb25zLkZJRUxEX0FTU09DSUFUSU9OX1BPSU5UUzpcbiAgICAgICAgICBjaGlsZC5zZXRGaWVsZFR5cGUoU2VsZWN0aW9uRmllbGQuUE9JTlQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZ0a0Vycm9yTWFjcm8oJ1Vua25vd24gZmllbGQgYXNzb2NpYXRpb24nKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkLmdldFByb3BlcnRpZXMoKS5wcm9wSUQgPSB2YWx1ZS5pbmZvLnByb3BJRDtcbiAgICAgIGNoaWxkLmdldFByb3BlcnRpZXMoKS5wcm9wID0gdmFsdWUuaW5mby5wcm9wO1xuICAgICAgY2hpbGQuZ2V0UHJvcGVydGllcygpLmNvbXBvc2l0ZUlEID0gdmFsdWUuaW5mby5jb21wb3NpdGVJRDtcbiAgICAgIGNoaWxkLmdldFByb3BlcnRpZXMoKS5waXhlbENvdW50ID0gdmFsdWUucGl4ZWxDb3VudDtcbiAgICAgIGlmIChtb2RlbC5jYXB0dXJlWlZhbHVlcykge1xuICAgICAgICBjaGlsZC5nZXRQcm9wZXJ0aWVzKCkuZGlzcGxheVBvc2l0aW9uID0gW1xuICAgICAgICAgIHZhbHVlLmluZm8uZGlzcGxheVBvc2l0aW9uWzBdLFxuICAgICAgICAgIHZhbHVlLmluZm8uZGlzcGxheVBvc2l0aW9uWzFdLFxuICAgICAgICAgIHZhbHVlLmluZm8uelZhbHVlLFxuICAgICAgICBdO1xuICAgICAgICBjaGlsZC5nZXRQcm9wZXJ0aWVzKCkud29ybGRQb3NpdGlvbiA9IG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5kaXNwbGF5VG9Xb3JsZChcbiAgICAgICAgICB2YWx1ZS5pbmZvLmRpc3BsYXlQb3NpdGlvblswXSxcbiAgICAgICAgICB2YWx1ZS5pbmZvLmRpc3BsYXlQb3NpdGlvblsxXSxcbiAgICAgICAgICB2YWx1ZS5pbmZvLnpWYWx1ZSxcbiAgICAgICAgICBtb2RlbC5yZW5kZXJlclxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjaGlsZC5zZXRTZWxlY3Rpb25MaXN0KHZhbHVlLmF0dHJpYnV0ZUlEcyk7XG4gICAgICBzZWxbY291bnRdID0gY2hpbGQ7XG4gICAgICBjb3VudCsrO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlbDtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0SW5mb0hhc2ggPSAoaW5mbykgPT4gYCR7aW5mby5wcm9wSUR9ICR7aW5mby5jb21wb3NpdGVJRH1gO1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuZ2VuZXJhdGVTZWxlY3Rpb24gPSAoZngxLCBmeTEsIGZ4MiwgZnkyKSA9PiB7XG4gICAgY29uc3QgeDEgPSBNYXRoLmZsb29yKGZ4MSk7XG4gICAgY29uc3QgeTEgPSBNYXRoLmZsb29yKGZ5MSk7XG4gICAgY29uc3QgeDIgPSBNYXRoLmZsb29yKGZ4Mik7XG4gICAgY29uc3QgeTIgPSBNYXRoLmZsb29yKGZ5Mik7XG5cbiAgICBjb25zdCBkYXRhTWFwID0gbmV3IE1hcCgpO1xuXG4gICAgY29uc3Qgb3V0U2VsZWN0ZWRQb3NpdGlvbiA9IFswLCAwXTtcblxuICAgIGZvciAobGV0IHl5ID0geTE7IHl5IDw9IHkyOyB5eSsrKSB7XG4gICAgICBmb3IgKGxldCB4eCA9IHgxOyB4eCA8PSB4MjsgeHgrKykge1xuICAgICAgICBjb25zdCBwb3MgPSBbeHgsIHl5XTtcbiAgICAgICAgY29uc3QgaW5mbyA9IHB1YmxpY0FQSS5nZXRQaXhlbEluZm9ybWF0aW9uKHBvcywgMCwgb3V0U2VsZWN0ZWRQb3NpdGlvbik7XG4gICAgICAgIGlmIChpbmZvICYmIGluZm8udmFsaWQpIHtcbiAgICAgICAgICBjb25zdCBoYXNoID0gcHVibGljQVBJLmdldEluZm9IYXNoKGluZm8pO1xuICAgICAgICAgIGlmICghZGF0YU1hcC5oYXMoaGFzaCkpIHtcbiAgICAgICAgICAgIGRhdGFNYXAuc2V0KGhhc2gsIHtcbiAgICAgICAgICAgICAgaW5mbyxcbiAgICAgICAgICAgICAgcGl4ZWxDb3VudDogMSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlSURzOiBbaW5mby5hdHRyaWJ1dGVJRF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZG12ID0gZGF0YU1hcC5nZXQoaGFzaCk7XG4gICAgICAgICAgICBkbXYucGl4ZWxDb3VudCsrO1xuICAgICAgICAgICAgaWYgKG1vZGVsLmNhcHR1cmVaVmFsdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpbmZvLnpWYWx1ZSA8IGRtdi5pbmZvLnpWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGRtdi5pbmZvID0gaW5mbztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRtdi5hdHRyaWJ1dGVJRHMuaW5kZXhPZihpbmZvLmF0dHJpYnV0ZUlEKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgZG12LmF0dHJpYnV0ZUlEcy5wdXNoKGluZm8uYXR0cmlidXRlSUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHVibGljQVBJLmNvbnZlcnRTZWxlY3Rpb24obW9kZWwuZmllbGRBc3NvY2lhdGlvbiwgZGF0YU1hcCk7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgcHVibGljQVBJLmF0dGFjaCA9ICh3LCByKSA9PiB7XG4gICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93ID0gdztcbiAgICBtb2RlbC5yZW5kZXJlciA9IHI7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gb3ZlcnJpZGVcbiAgY29uc3Qgc3VwZXJTZXRBcmVhID0gcHVibGljQVBJLnNldEFyZWE7XG4gIHB1YmxpY0FQSS5zZXRBcmVhID0gKC4uLmFyZ3MpID0+IHtcbiAgICBpZiAoc3VwZXJTZXRBcmVhKC4uLmFyZ3MpKSB7XG4gICAgICBtb2RlbC5hcmVhWzBdID0gTWF0aC5mbG9vcihtb2RlbC5hcmVhWzBdKTtcbiAgICAgIG1vZGVsLmFyZWFbMV0gPSBNYXRoLmZsb29yKG1vZGVsLmFyZWFbMV0pO1xuICAgICAgbW9kZWwuYXJlYVsyXSA9IE1hdGguZmxvb3IobW9kZWwuYXJlYVsyXSk7XG4gICAgICBtb2RlbC5hcmVhWzNdID0gTWF0aC5mbG9vcihtb2RlbC5hcmVhWzNdKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBmaWVsZEFzc29jaWF0aW9uOiBGaWVsZEFzc29jaWF0aW9ucy5GSUVMRF9BU1NPQ0lBVElPTl9DRUxMUyxcbiAgcmVuZGVyZXI6IG51bGwsXG4gIGFyZWE6IG51bGwsXG4gIG9wZW5HTFJlbmRlcldpbmRvdzogbnVsbCxcbiAgb3BlbkdMUmVuZGVyZXI6IG51bGwsXG4gIGN1cnJlbnRQYXNzOiAtMSxcbiAgcHJvcENvbG9yVmFsdWU6IG51bGwsXG4gIHByb3BzOiBudWxsLFxuICBpZE9mZnNldDogMSxcbiAgY2FwdHVyZVpWYWx1ZXM6IGZhbHNlLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gQnVpbGQgVlRLIEFQSVxuICBtYWNyby5vYmoocHVibGljQVBJLCBtb2RlbCk7XG5cbiAgbW9kZWwuYXJlYSA9IFswLCAwLCAwLCAwXTtcbiAgbW9kZWwucHJvcENvbG9yVmFsdWUgPSBbMCwgMCwgMF07XG4gIG1vZGVsLnByb3BzID0gW107XG5cbiAgbWFjcm8uc2V0R2V0KHB1YmxpY0FQSSwgbW9kZWwsIFtcbiAgICAnZmllbGRBc3NvY2lhdGlvbicsXG4gICAgJ3JlbmRlcmVyJyxcbiAgICAnY3VycmVudFBhc3MnLFxuICAgICdjYXB0dXJlWlZhbHVlcycsXG4gIF0pO1xuXG4gIG1hY3JvLnNldEdldEFycmF5KHB1YmxpY0FQSSwgbW9kZWwsIFsnYXJlYSddLCA0KTtcbiAgbWFjcm8uc2V0R2V0QXJyYXkocHVibGljQVBJLCBtb2RlbCwgWydwcm9wQ29sb3JWYWx1ZSddLCAzKTtcbiAgbWFjcm8uZXZlbnQocHVibGljQVBJLCBtb2RlbCwgJ2V2ZW50Jyk7XG5cbiAgLy8gT2JqZWN0IG1ldGhvZHNcbiAgdnRrT3BlbkdMSGFyZHdhcmVTZWxlY3RvcihwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShcbiAgZXh0ZW5kLFxuICAndnRrT3BlbkdMSGFyZHdhcmVTZWxlY3Rvcidcbik7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kLCAuLi5Db25zdGFudHMgfTtcbiIsImltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgdnRrQ2VsbEFycmF5QnVmZmVyT2JqZWN0IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvQ2VsbEFycmF5QnVmZmVyT2JqZWN0JztcbmltcG9ydCB2dGtTaGFkZXJQcm9ncmFtIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvU2hhZGVyUHJvZ3JhbSc7XG5pbXBvcnQgdnRrVmVydGV4QXJyYXlPYmplY3QgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9WZXJ0ZXhBcnJheU9iamVjdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a09wZW5HTEhlbHBlciBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a09wZW5HTEhlbHBlcihwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a09wZW5HTEhlbHBlcicpO1xuXG4gIHB1YmxpY0FQSS5zZXRPcGVuR0xSZW5kZXJXaW5kb3cgPSAod2luKSA9PiB7XG4gICAgbW9kZWwucHJvZ3JhbS5zZXRDb250ZXh0KHdpbi5nZXRDb250ZXh0KCkpO1xuICAgIG1vZGVsLlZBTy5zZXRPcGVuR0xSZW5kZXJXaW5kb3cod2luKTtcbiAgICBtb2RlbC5DQUJPLnNldE9wZW5HTFJlbmRlcldpbmRvdyh3aW4pO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZWxlYXNlR3JhcGhpY3NSZXNvdXJjZXMgPSAob2dsd2luKSA9PiB7XG4gICAgbW9kZWwuVkFPLnJlbGVhc2VHcmFwaGljc1Jlc291cmNlcygpO1xuICAgIG1vZGVsLkNBQk8ucmVsZWFzZUdyYXBoaWNzUmVzb3VyY2VzKCk7XG4gICAgbW9kZWwuQ0FCTy5zZXRFbGVtZW50Q291bnQoMCk7XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBwcm9ncmFtOiBudWxsLFxuICBzaGFkZXJTb3VyY2VUaW1lOiBudWxsLFxuICBWQU86IG51bGwsXG4gIGF0dHJpYnV0ZVVwZGF0ZVRpbWU6IG51bGwsXG4gIENBQk86IG51bGwsXG4gIHByaW1pdGl2ZVR5cGU6IDAsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBCdWlsZCBWVEsgQVBJXG4gIG1hY3JvLm9iaihwdWJsaWNBUEksIG1vZGVsKTtcblxuICBtb2RlbC5zaGFkZXJTb3VyY2VUaW1lID0ge307XG4gIG1hY3JvLm9iaihtb2RlbC5zaGFkZXJTb3VyY2VUaW1lKTtcblxuICBtb2RlbC5hdHRyaWJ1dGVVcGRhdGVUaW1lID0ge307XG4gIG1hY3JvLm9iaihtb2RlbC5hdHRyaWJ1dGVVcGRhdGVUaW1lKTtcblxuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgW1xuICAgICdwcm9ncmFtJyxcbiAgICAnc2hhZGVyU291cmNlVGltZScsXG4gICAgJ1ZBTycsXG4gICAgJ2F0dHJpYnV0ZVVwZGF0ZVRpbWUnLFxuICAgICdDQUJPJyxcbiAgICAncHJpbWl0aXZlVHlwZScsXG4gIF0pO1xuXG4gIG1vZGVsLnByb2dyYW0gPSB2dGtTaGFkZXJQcm9ncmFtLm5ld0luc3RhbmNlKCk7XG4gIG1vZGVsLlZBTyA9IHZ0a1ZlcnRleEFycmF5T2JqZWN0Lm5ld0luc3RhbmNlKCk7XG4gIG1vZGVsLkNBQk8gPSB2dGtDZWxsQXJyYXlCdWZmZXJPYmplY3QubmV3SW5zdGFuY2UoKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICB2dGtPcGVuR0xIZWxwZXIocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImltcG9ydCB7IG1hdDQgfSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IENvbnN0YW50cyBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9JbWFnZU1hcHBlci9Db25zdGFudHMnO1xuaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB2dGtEYXRhQXJyYXkgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvRGF0YUFycmF5JztcbmltcG9ydCB7IFZ0a0RhdGFUeXBlcyB9IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL0RhdGFBcnJheS9Db25zdGFudHMnO1xuaW1wb3J0IHZ0a0hlbHBlciBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML0hlbHBlcic7XG5pbXBvcnQgKiBhcyB2dGtNYXRoIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL01hdGgnO1xuaW1wb3J0IHZ0a09wZW5HTFRleHR1cmUgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9UZXh0dXJlJztcbmltcG9ydCB2dGtTaGFkZXJQcm9ncmFtIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvU2hhZGVyUHJvZ3JhbSc7XG5pbXBvcnQgdnRrVmlld05vZGUgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL1NjZW5lR3JhcGgvVmlld05vZGUnO1xuaW1wb3J0IHsgUmVwcmVzZW50YXRpb24gfSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9Qcm9wZXJ0eS9Db25zdGFudHMnO1xuaW1wb3J0IHtcbiAgV3JhcCxcbiAgRmlsdGVyLFxufSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1RleHR1cmUvQ29uc3RhbnRzJztcbmltcG9ydCB7IEludGVycG9sYXRpb25UeXBlIH0gZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvSW1hZ2VQcm9wZXJ0eS9Db25zdGFudHMnO1xuXG5pbXBvcnQgdnRrUG9seURhdGFWUyBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML2dsc2wvdnRrUG9seURhdGFWUy5nbHNsJztcbmltcG9ydCB2dGtQb2x5RGF0YUZTIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvZ2xzbC92dGtQb2x5RGF0YUZTLmdsc2wnO1xuaW1wb3J0IHZ0a1JlcGxhY2VtZW50U2hhZGVyTWFwcGVyIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvUmVwbGFjZW1lbnRTaGFkZXJNYXBwZXInO1xuXG5jb25zdCB7IHZ0a0Vycm9yTWFjcm8gfSA9IG1hY3JvO1xuXG5jb25zdCB7IFNsaWNpbmdNb2RlIH0gPSBDb25zdGFudHM7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGhlbHBlciBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGNvbXB1dGVGblRvU3RyaW5nKHByb3BlcnR5LCBmbiwgbnVtYmVyT2ZDb21wb25lbnRzKSB7XG4gIGNvbnN0IHB3ZnVuID0gZm4uYXBwbHkocHJvcGVydHkpO1xuICBpZiAocHdmdW4pIHtcbiAgICBjb25zdCBpQ29tcHMgPSBwcm9wZXJ0eS5nZXRJbmRlcGVuZGVudENvbXBvbmVudHMoKTtcbiAgICByZXR1cm4gYCR7cHJvcGVydHkuZ2V0TVRpbWUoKX0tJHtpQ29tcHN9LSR7bnVtYmVyT2ZDb21wb25lbnRzfWA7XG4gIH1cbiAgcmV0dXJuICcwJztcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrT3BlbkdMSW1hZ2VNYXBwZXIgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtPcGVuR0xJbWFnZU1hcHBlcihwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a09wZW5HTEltYWdlTWFwcGVyJyk7XG5cbiAgcHVibGljQVBJLmJ1aWxkUGFzcyA9IChwcmVwYXNzKSA9PiB7XG4gICAgaWYgKHByZXBhc3MpIHtcbiAgICAgIG1vZGVsLm9wZW5HTEltYWdlU2xpY2UgPSBwdWJsaWNBUEkuZ2V0Rmlyc3RBbmNlc3Rvck9mVHlwZShcbiAgICAgICAgJ3Z0a09wZW5HTEltYWdlU2xpY2UnXG4gICAgICApO1xuICAgICAgbW9kZWwub3BlbkdMUmVuZGVyZXIgPSBwdWJsaWNBUEkuZ2V0Rmlyc3RBbmNlc3Rvck9mVHlwZShcbiAgICAgICAgJ3Z0a09wZW5HTFJlbmRlcmVyJ1xuICAgICAgKTtcbiAgICAgIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyA9IG1vZGVsLm9wZW5HTFJlbmRlcmVyLmdldFBhcmVudCgpO1xuICAgICAgbW9kZWwuY29udGV4dCA9IG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRDb250ZXh0KCk7XG4gICAgICBtb2RlbC50cmlzLnNldE9wZW5HTFJlbmRlcldpbmRvdyhtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cpO1xuICAgICAgbW9kZWwub3BlbkdMVGV4dHVyZS5zZXRPcGVuR0xSZW5kZXJXaW5kb3cobW9kZWwub3BlbkdMUmVuZGVyV2luZG93KTtcbiAgICAgIG1vZGVsLmNvbG9yVGV4dHVyZS5zZXRPcGVuR0xSZW5kZXJXaW5kb3cobW9kZWwub3BlbkdMUmVuZGVyV2luZG93KTtcbiAgICAgIG1vZGVsLnB3ZlRleHR1cmUuc2V0T3BlbkdMUmVuZGVyV2luZG93KG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyk7XG4gICAgICBjb25zdCByZW4gPSBtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRSZW5kZXJhYmxlKCk7XG4gICAgICBtb2RlbC5vcGVuR0xDYW1lcmEgPSBtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRWaWV3Tm9kZUZvcihcbiAgICAgICAgcmVuLmdldEFjdGl2ZUNhbWVyYSgpXG4gICAgICApO1xuICAgICAgLy8gaXMgc2xpY2Ugc2V0IGJ5IHRoZSBjYW1lcmFcbiAgICAgIGlmIChtb2RlbC5yZW5kZXJhYmxlLmdldFNsaWNlQXRGb2NhbFBvaW50KCkpIHtcbiAgICAgICAgbW9kZWwucmVuZGVyYWJsZS5zZXRTbGljZUZyb21DYW1lcmEocmVuLmdldEFjdGl2ZUNhbWVyYSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLnRyYW5zbHVjZW50UGFzcyA9IChwcmVwYXNzKSA9PiB7XG4gICAgaWYgKHByZXBhc3MpIHtcbiAgICAgIHB1YmxpY0FQSS5yZW5kZXIoKTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLm9wYXF1ZVpCdWZmZXJQYXNzID0gKHByZXBhc3MpID0+IHtcbiAgICBpZiAocHJlcGFzcykge1xuICAgICAgbW9kZWwuaGF2ZVNlZW5EZXB0aFJlcXVlc3QgPSB0cnVlO1xuICAgICAgbW9kZWwucmVuZGVyRGVwdGggPSB0cnVlO1xuICAgICAgcHVibGljQVBJLnJlbmRlcigpO1xuICAgICAgbW9kZWwucmVuZGVyRGVwdGggPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLm9wYXF1ZVBhc3MgPSAocHJlcGFzcykgPT4ge1xuICAgIGlmIChwcmVwYXNzKSB7XG4gICAgICBwdWJsaWNBUEkucmVuZGVyKCk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRDb2luY2lkZW50UGFyYW1ldGVycyA9IChyZW4sIGFjdG9yKSA9PiB7XG4gICAgaWYgKG1vZGVsLnJlbmRlcmFibGUuZ2V0UmVzb2x2ZUNvaW5jaWRlbnRUb3BvbG9neSgpKSB7XG4gICAgICByZXR1cm4gbW9kZWwucmVuZGVyYWJsZS5nZXRDb2luY2lkZW50VG9wb2xvZ3lQb2x5Z29uT2Zmc2V0UGFyYW1ldGVycygpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvLyBSZW5kZXJzIG15c2VsZlxuICBwdWJsaWNBUEkucmVuZGVyID0gKCkgPT4ge1xuICAgIGNvbnN0IGFjdG9yID0gbW9kZWwub3BlbkdMSW1hZ2VTbGljZS5nZXRSZW5kZXJhYmxlKCk7XG4gICAgY29uc3QgcmVuID0gbW9kZWwub3BlbkdMUmVuZGVyZXIuZ2V0UmVuZGVyYWJsZSgpO1xuICAgIHB1YmxpY0FQSS5yZW5kZXJQaWVjZShyZW4sIGFjdG9yKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuYnVpbGRTaGFkZXJzID0gKHNoYWRlcnMsIHJlbiwgYWN0b3IpID0+IHtcbiAgICBwdWJsaWNBUEkuZ2V0U2hhZGVyVGVtcGxhdGUoc2hhZGVycywgcmVuLCBhY3Rvcik7XG4gICAgcHVibGljQVBJLnJlcGxhY2VTaGFkZXJWYWx1ZXMoc2hhZGVycywgcmVuLCBhY3Rvcik7XG4gIH07XG5cbiAgcHVibGljQVBJLmdldFNoYWRlclRlbXBsYXRlID0gKHNoYWRlcnMsIHJlbiwgYWN0b3IpID0+IHtcbiAgICBzaGFkZXJzLlZlcnRleCA9IHZ0a1BvbHlEYXRhVlM7XG4gICAgc2hhZGVycy5GcmFnbWVudCA9IHZ0a1BvbHlEYXRhRlM7XG4gICAgc2hhZGVycy5HZW9tZXRyeSA9ICcnO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZXBsYWNlU2hhZGVyVmFsdWVzID0gKHNoYWRlcnMsIHJlbiwgYWN0b3IpID0+IHtcbiAgICBsZXQgVlNTb3VyY2UgPSBzaGFkZXJzLlZlcnRleDtcbiAgICBsZXQgRlNTb3VyY2UgPSBzaGFkZXJzLkZyYWdtZW50O1xuXG4gICAgVlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoVlNTb3VyY2UsICcvL1ZUSzo6Q2FtZXJhOjpEZWMnLCBbXG4gICAgICAndW5pZm9ybSBtYXQ0IE1DUENNYXRyaXg7JyxcbiAgICBdKS5yZXN1bHQ7XG4gICAgVlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICBWU1NvdXJjZSxcbiAgICAgICcvL1ZUSzo6UG9zaXRpb25WQzo6SW1wbCcsXG4gICAgICBbJyAgZ2xfUG9zaXRpb24gPSBNQ1BDTWF0cml4ICogdmVydGV4TUM7J11cbiAgICApLnJlc3VsdDtcblxuICAgIFZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgVlNTb3VyY2UsXG4gICAgICAnLy9WVEs6OlRDb29yZDo6SW1wbCcsXG4gICAgICAndGNvb3JkVkNWU091dHB1dCA9IHRjb29yZE1DOydcbiAgICApLnJlc3VsdDtcblxuICAgIFZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgVlNTb3VyY2UsXG4gICAgICAnLy9WVEs6OlRDb29yZDo6RGVjJyxcbiAgICAgICdhdHRyaWJ1dGUgdmVjMiB0Y29vcmRNQzsgdmFyeWluZyB2ZWMyIHRjb29yZFZDVlNPdXRwdXQ7J1xuICAgICkucmVzdWx0O1xuXG4gICAgY29uc3QgdE51bUNvbXAgPSBtb2RlbC5vcGVuR0xUZXh0dXJlLmdldENvbXBvbmVudHMoKTtcbiAgICBjb25zdCBpQ29tcHMgPSBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldEluZGVwZW5kZW50Q29tcG9uZW50cygpO1xuXG4gICAgbGV0IHRjb29yZERlYyA9IFtcbiAgICAgICd2YXJ5aW5nIHZlYzIgdGNvb3JkVkNWU091dHB1dDsnLFxuICAgICAgLy8gY29sb3Igc2hpZnQgYW5kIHNjYWxlXG4gICAgICAndW5pZm9ybSBmbG9hdCBjc2hpZnQwOycsXG4gICAgICAndW5pZm9ybSBmbG9hdCBjc2NhbGUwOycsXG4gICAgICAvLyBwd2Ygc2hpZnQgYW5kIHNjYWxlXG4gICAgICAndW5pZm9ybSBmbG9hdCBwd2ZzaGlmdDA7JyxcbiAgICAgICd1bmlmb3JtIGZsb2F0IHB3ZnNjYWxlMDsnLFxuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmUxOycsXG4gICAgICAndW5pZm9ybSBzYW1wbGVyMkQgY29sb3JUZXh0dXJlMTsnLFxuICAgICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHB3ZlRleHR1cmUxOycsXG4gICAgICAndW5pZm9ybSBmbG9hdCBvcGFjaXR5OycsXG4gICAgXTtcbiAgICBpZiAoaUNvbXBzKSB7XG4gICAgICBmb3IgKGxldCBjb21wID0gMTsgY29tcCA8IHROdW1Db21wOyBjb21wKyspIHtcbiAgICAgICAgdGNvb3JkRGVjID0gdGNvb3JkRGVjLmNvbmNhdChbXG4gICAgICAgICAgLy8gY29sb3Igc2hpZnQgYW5kIHNjYWxlXG4gICAgICAgICAgYHVuaWZvcm0gZmxvYXQgY3NoaWZ0JHtjb21wfTtgLFxuICAgICAgICAgIGB1bmlmb3JtIGZsb2F0IGNzY2FsZSR7Y29tcH07YCxcbiAgICAgICAgICAvLyB3ZWlnaHRpbmcgc2hpZnQgYW5kIHNjYWxlXG4gICAgICAgICAgYHVuaWZvcm0gZmxvYXQgcHdmc2hpZnQke2NvbXB9O2AsXG4gICAgICAgICAgYHVuaWZvcm0gZmxvYXQgcHdmc2NhbGUke2NvbXB9O2AsXG4gICAgICAgIF0pO1xuICAgICAgfVxuICAgICAgLy8gdGhlIGhlaWdodHMgZGVmaW5lZCBiZWxvdyBhcmUgdGhlIGxvY2F0aW9uc1xuICAgICAgLy8gZm9yIHRoZSB1cCB0byBmb3VyIGNvbXBvbmVudHMgb2YgdGhlIHRmdW5zXG4gICAgICAvLyB0aGUgdGZ1bnMgaGF2ZSBhIGhlaWdodCBvZiAyWG51bUNvbXBzIHBpeGVscyBzbyB0aGVcbiAgICAgIC8vIHZhbHVlcyBhcmUgY29tcHV0ZWQgdG8gaGl0IHRoZSBtaWRkbGUgb2YgdGhlIHR3byByb3dzXG4gICAgICAvLyBmb3IgdGhhdCBjb21wb25lbnRcbiAgICAgIHN3aXRjaCAodE51bUNvbXApIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRjb29yZERlYyA9IHRjb29yZERlYy5jb25jYXQoW1xuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgbWl4MDsnLFxuICAgICAgICAgICAgJyNkZWZpbmUgaGVpZ2h0MCAwLjUnLFxuICAgICAgICAgIF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGNvb3JkRGVjID0gdGNvb3JkRGVjLmNvbmNhdChbXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBtaXgwOycsXG4gICAgICAgICAgICAndW5pZm9ybSBmbG9hdCBtaXgxOycsXG4gICAgICAgICAgICAnI2RlZmluZSBoZWlnaHQwIDAuMjUnLFxuICAgICAgICAgICAgJyNkZWZpbmUgaGVpZ2h0MSAwLjc1JyxcbiAgICAgICAgICBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRjb29yZERlYyA9IHRjb29yZERlYy5jb25jYXQoW1xuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgbWl4MDsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgbWl4MTsnLFxuICAgICAgICAgICAgJ3VuaWZvcm0gZmxvYXQgbWl4MjsnLFxuICAgICAgICAgICAgJyNkZWZpbmUgaGVpZ2h0MCAwLjE3JyxcbiAgICAgICAgICAgICcjZGVmaW5lIGhlaWdodDEgMC41JyxcbiAgICAgICAgICAgICcjZGVmaW5lIGhlaWdodDIgMC44MycsXG4gICAgICAgICAgXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICB0Y29vcmREZWMgPSB0Y29vcmREZWMuY29uY2F0KFtcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IG1peDA7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IG1peDE7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IG1peDI7JyxcbiAgICAgICAgICAgICd1bmlmb3JtIGZsb2F0IG1peDM7JyxcbiAgICAgICAgICAgICcjZGVmaW5lIGhlaWdodDAgMC4xMjUnLFxuICAgICAgICAgICAgJyNkZWZpbmUgaGVpZ2h0MSAwLjM3NScsXG4gICAgICAgICAgICAnI2RlZmluZSBoZWlnaHQyIDAuNjI1JyxcbiAgICAgICAgICAgICcjZGVmaW5lIGhlaWdodDMgMC44NzUnLFxuICAgICAgICAgIF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZ0a0Vycm9yTWFjcm8oJ1Vuc3VwcG9ydGVkIG51bWJlciBvZiBpbmRlcGVuZGVudCBjb29yZGluYXRlcy4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICBGU1NvdXJjZSxcbiAgICAgICcvL1ZUSzo6VENvb3JkOjpEZWMnLFxuICAgICAgdGNvb3JkRGVjXG4gICAgKS5yZXN1bHQ7XG5cbiAgICBpZiAoaUNvbXBzKSB7XG4gICAgICBjb25zdCByZ2JhID0gWydyJywgJ2cnLCAnYicsICdhJ107XG4gICAgICBsZXQgdGNvb3JkSW1wbCA9IFsndmVjNCB0dmFsdWUgPSB0ZXh0dXJlMkQodGV4dHVyZTEsIHRjb29yZFZDVlNPdXRwdXQpOyddO1xuICAgICAgZm9yIChsZXQgY29tcCA9IDA7IGNvbXAgPCB0TnVtQ29tcDsgY29tcCsrKSB7XG4gICAgICAgIHRjb29yZEltcGwgPSB0Y29vcmRJbXBsLmNvbmNhdChbXG4gICAgICAgICAgYHZlYzMgdGNvbG9yJHtjb21wfSA9IG1peCR7Y29tcH0gKiB0ZXh0dXJlMkQoY29sb3JUZXh0dXJlMSwgdmVjMih0dmFsdWUuJHtyZ2JhW2NvbXBdfSAqIGNzY2FsZSR7Y29tcH0gKyBjc2hpZnQke2NvbXB9LCBoZWlnaHQke2NvbXB9KSkucmdiO2AsXG4gICAgICAgICAgYGZsb2F0IGNvbXBXZWlnaHQke2NvbXB9ID0gbWl4JHtjb21wfSAqIHRleHR1cmUyRChwd2ZUZXh0dXJlMSwgdmVjMih0dmFsdWUuJHtyZ2JhW2NvbXBdfSAqIHB3ZnNjYWxlJHtjb21wfSArIHB3ZnNoaWZ0JHtjb21wfSwgaGVpZ2h0JHtjb21wfSkpLnI7YCxcbiAgICAgICAgXSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHROdW1Db21wKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0Y29vcmRJbXBsID0gdGNvb3JkSW1wbC5jb25jYXQoW1xuICAgICAgICAgICAgJ2dsX0ZyYWdEYXRhWzBdID0gdmVjNCh0Y29sb3IwLnJnYiwgb3BhY2l0eSk7JyxcbiAgICAgICAgICBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRjb29yZEltcGwgPSB0Y29vcmRJbXBsLmNvbmNhdChbXG4gICAgICAgICAgICAnZmxvYXQgd2VpZ2h0U3VtID0gY29tcFdlaWdodDAgKyBjb21wV2VpZ2h0MTsnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdEYXRhWzBdID0gdmVjNCh2ZWMzKCh0Y29sb3IwLnJnYiAqIChjb21wV2VpZ2h0MCAvIHdlaWdodFN1bSkpICsgKHRjb2xvcjEucmdiICogKGNvbXBXZWlnaHQxIC8gd2VpZ2h0U3VtKSkpLCBvcGFjaXR5KTsnLFxuICAgICAgICAgIF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgdGNvb3JkSW1wbCA9IHRjb29yZEltcGwuY29uY2F0KFtcbiAgICAgICAgICAgICdmbG9hdCB3ZWlnaHRTdW0gPSBjb21wV2VpZ2h0MCArIGNvbXBXZWlnaHQxICsgY29tcFdlaWdodDI7JyxcbiAgICAgICAgICAgICdnbF9GcmFnRGF0YVswXSA9IHZlYzQodmVjMygodGNvbG9yMC5yZ2IgKiAoY29tcFdlaWdodDAgLyB3ZWlnaHRTdW0pKSArICh0Y29sb3IxLnJnYiAqIChjb21wV2VpZ2h0MSAvIHdlaWdodFN1bSkpICsgKHRjb2xvcjIucmdiICogKGNvbXBXZWlnaHQyIC8gd2VpZ2h0U3VtKSkpLCBvcGFjaXR5KTsnLFxuICAgICAgICAgIF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgdGNvb3JkSW1wbCA9IHRjb29yZEltcGwuY29uY2F0KFtcbiAgICAgICAgICAgICdmbG9hdCB3ZWlnaHRTdW0gPSBjb21wV2VpZ2h0MCArIGNvbXBXZWlnaHQxICsgY29tcFdlaWdodDIgKyBjb21wV2VpZ2h0MzsnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdEYXRhWzBdID0gdmVjNCh2ZWMzKCh0Y29sb3IwLnJnYiAqIChjb21wV2VpZ2h0MCAvIHdlaWdodFN1bSkpICsgKHRjb2xvcjEucmdiICogKGNvbXBXZWlnaHQxIC8gd2VpZ2h0U3VtKSkgKyAodGNvbG9yMi5yZ2IgKiAoY29tcFdlaWdodDIgLyB3ZWlnaHRTdW0pKSArICh0Y29sb3IzLnJnYiAqIChjb21wV2VpZ2h0MyAvIHdlaWdodFN1bSkpKSwgb3BhY2l0eSk7JyxcbiAgICAgICAgICBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB2dGtFcnJvck1hY3JvKCdVbnN1cHBvcnRlZCBudW1iZXIgb2YgaW5kZXBlbmRlbnQgY29vcmRpbmF0ZXMuJyk7XG4gICAgICB9XG4gICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgRlNTb3VyY2UsXG4gICAgICAgICcvL1ZUSzo6VENvb3JkOjpJbXBsJyxcbiAgICAgICAgdGNvb3JkSW1wbFxuICAgICAgKS5yZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRlcGVuZGVudCBjb21wb25lbnRzXG4gICAgICBzd2l0Y2ggKHROdW1Db21wKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgIEZTU291cmNlLFxuICAgICAgICAgICAgJy8vVlRLOjpUQ29vcmQ6OkltcGwnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnZmxvYXQgaW50ZW5zaXR5ID0gdGV4dHVyZTJEKHRleHR1cmUxLCB0Y29vcmRWQ1ZTT3V0cHV0KS5yOycsXG4gICAgICAgICAgICAgICd2ZWMzIHRjb2xvciA9IHRleHR1cmUyRChjb2xvclRleHR1cmUxLCB2ZWMyKGludGVuc2l0eSAqIGNzY2FsZTAgKyBjc2hpZnQwLCAwLjUpKS5yZ2I7JyxcbiAgICAgICAgICAgICAgJ2Zsb2F0IHNjYWxhck9wYWNpdHkgPSB0ZXh0dXJlMkQocHdmVGV4dHVyZTEsIHZlYzIoaW50ZW5zaXR5ICogcHdmc2NhbGUwICsgcHdmc2hpZnQwLCAwLjUpKS5yOycsXG4gICAgICAgICAgICAgICdnbF9GcmFnRGF0YVswXSA9IHZlYzQodGNvbG9yLCBzY2FsYXJPcGFjaXR5ICogb3BhY2l0eSk7JyxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApLnJlc3VsdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICAgICAgRlNTb3VyY2UsXG4gICAgICAgICAgICAnLy9WVEs6OlRDb29yZDo6SW1wbCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICd2ZWM0IHRjb2xvciA9IHRleHR1cmUyRCh0ZXh0dXJlMSwgdGNvb3JkVkNWU091dHB1dCk7JyxcbiAgICAgICAgICAgICAgJ2Zsb2F0IGludGVuc2l0eSA9IHRjb2xvci5yKmNzY2FsZTAgKyBjc2hpZnQwOycsXG4gICAgICAgICAgICAgICdnbF9GcmFnRGF0YVswXSA9IHZlYzQodGV4dHVyZTJEKGNvbG9yVGV4dHVyZTEsIHZlYzIoaW50ZW5zaXR5LCAwLjUpKS5yZ2IsIHB3ZnNjYWxlMCp0Y29sb3IuZyArIHB3ZnNoaWZ0MCk7JyxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICApLnJlc3VsdDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgIEZTU291cmNlLFxuICAgICAgICAgICAgJy8vVlRLOjpUQ29vcmQ6OkltcGwnLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAndmVjNCB0Y29sb3IgPSBjc2NhbGUwKnRleHR1cmUyRCh0ZXh0dXJlMSwgdGNvb3JkVkNWU091dHB1dC5zdCkgKyBjc2hpZnQwOycsXG4gICAgICAgICAgICAgICdnbF9GcmFnRGF0YVswXSA9IHZlYzQodGV4dHVyZTJEKGNvbG9yVGV4dHVyZTEsIHZlYzIodGNvbG9yLnIsMC41KSkuciwnLFxuICAgICAgICAgICAgICAnICB0ZXh0dXJlMkQoY29sb3JUZXh0dXJlMSwgdmVjMih0Y29sb3IuZywwLjUpKS5yLCcsXG4gICAgICAgICAgICAgICcgIHRleHR1cmUyRChjb2xvclRleHR1cmUxLCB2ZWMyKHRjb2xvci5iLDAuNSkpLnIsIHRjb2xvci5hKTsnLFxuICAgICAgICAgICAgXVxuICAgICAgICAgICkucmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2RlbC5oYXZlU2VlbkRlcHRoUmVxdWVzdCkge1xuICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgIEZTU291cmNlLFxuICAgICAgICAnLy9WVEs6OlpCdWZmZXI6OkRlYycsXG4gICAgICAgICd1bmlmb3JtIGludCBkZXB0aFJlcXVlc3Q7J1xuICAgICAgKS5yZXN1bHQ7XG4gICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShGU1NvdXJjZSwgJy8vVlRLOjpaQnVmZmVyOjpJbXBsJywgW1xuICAgICAgICAnaWYgKGRlcHRoUmVxdWVzdCA9PSAxKSB7JyxcbiAgICAgICAgJ2Zsb2F0IGl6ID0gZmxvb3IoZ2xfRnJhZ0Nvb3JkLnoqNjU1MzUuMCArIDAuMSk7JyxcbiAgICAgICAgJ2Zsb2F0IHJmID0gZmxvb3IoaXovMjU2LjApLzI1NS4wOycsXG4gICAgICAgICdmbG9hdCBnZiA9IG1vZChpeiwyNTYuMCkvMjU1LjA7JyxcbiAgICAgICAgJ2dsX0ZyYWdEYXRhWzBdID0gdmVjNChyZiwgZ2YsIDAuMCwgMS4wKTsgfScsXG4gICAgICBdKS5yZXN1bHQ7XG4gICAgfVxuXG4gICAgc2hhZGVycy5WZXJ0ZXggPSBWU1NvdXJjZTtcbiAgICBzaGFkZXJzLkZyYWdtZW50ID0gRlNTb3VyY2U7XG5cbiAgICBwdWJsaWNBUEkucmVwbGFjZVNoYWRlckNvaW5jaWRlbnRPZmZzZXQoc2hhZGVycywgcmVuLCBhY3Rvcik7XG4gIH07XG5cbiAgcHVibGljQVBJLmdldE5lZWRUb1JlYnVpbGRTaGFkZXJzID0gKGNlbGxCTywgcmVuLCBhY3RvcikgPT4ge1xuICAgIC8vIGhhcyBzb21ldGhpbmcgY2hhbmdlZCB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgdG8gcmVjcmVhdGUgdGhlIHNoYWRlcj9cbiAgICAvLyBjYW5kaWRhdGVzIGFyZVxuICAgIC8vIHByb3BlcnR5IG1vZGlmaWVkIChyZXByZXNlbnRhdGlvbiBpbnRlcnBvbGF0aW9uIGFuZCBsaWdodGluZylcbiAgICAvLyBpbnB1dCBtb2RpZmllZFxuICAgIC8vIGxpZ2h0IGNvbXBsZXhpdHkgY2hhbmdlZFxuXG4gICAgY29uc3QgdE51bUNvbXAgPSBtb2RlbC5vcGVuR0xUZXh0dXJlLmdldENvbXBvbmVudHMoKTtcbiAgICBjb25zdCBpQ29tcCA9IGFjdG9yLmdldFByb3BlcnR5KCkuZ2V0SW5kZXBlbmRlbnRDb21wb25lbnRzKCk7XG5cbiAgICBpZiAoXG4gICAgICBtb2RlbC5sYXN0SGF2ZVNlZW5EZXB0aFJlcXVlc3QgIT09IG1vZGVsLmhhdmVTZWVuRGVwdGhSZXF1ZXN0IHx8XG4gICAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpID09PSAwIHx8XG4gICAgICBtb2RlbC5sYXN0VGV4dHVyZUNvbXBvbmVudHMgIT09IHROdW1Db21wIHx8XG4gICAgICBtb2RlbC5sYXN0SW5kZXBlbmRlbnRDb21wb25lbnRzICE9PSBpQ29tcFxuICAgICkge1xuICAgICAgbW9kZWwubGFzdEhhdmVTZWVuRGVwdGhSZXF1ZXN0ID0gbW9kZWwuaGF2ZVNlZW5EZXB0aFJlcXVlc3Q7XG4gICAgICBtb2RlbC5sYXN0VGV4dHVyZUNvbXBvbmVudHMgPSB0TnVtQ29tcDtcbiAgICAgIG1vZGVsLmxhc3RJbmRlcGVuZGVudENvbXBvbmVudHMgPSBpQ29tcDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBwdWJsaWNBUEkudXBkYXRlU2hhZGVycyA9IChjZWxsQk8sIHJlbiwgYWN0b3IpID0+IHtcbiAgICBtb2RlbC5sYXN0Qm91bmRCTyA9IGNlbGxCTztcblxuICAgIC8vIGhhcyBzb21ldGhpbmcgY2hhbmdlZCB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgdG8gcmVjcmVhdGUgdGhlIHNoYWRlcj9cbiAgICBpZiAocHVibGljQVBJLmdldE5lZWRUb1JlYnVpbGRTaGFkZXJzKGNlbGxCTywgcmVuLCBhY3RvcikpIHtcbiAgICAgIGNvbnN0IHNoYWRlcnMgPSB7IFZlcnRleDogbnVsbCwgRnJhZ21lbnQ6IG51bGwsIEdlb21ldHJ5OiBudWxsIH07XG5cbiAgICAgIHB1YmxpY0FQSS5idWlsZFNoYWRlcnMoc2hhZGVycywgcmVuLCBhY3Rvcik7XG5cbiAgICAgIC8vIGNvbXBpbGUgYW5kIGJpbmQgdGhlIHByb2dyYW0gaWYgbmVlZGVkXG4gICAgICBjb25zdCBuZXdTaGFkZXIgPSBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3dcbiAgICAgICAgLmdldFNoYWRlckNhY2hlKClcbiAgICAgICAgLnJlYWR5U2hhZGVyUHJvZ3JhbUFycmF5KFxuICAgICAgICAgIHNoYWRlcnMuVmVydGV4LFxuICAgICAgICAgIHNoYWRlcnMuRnJhZ21lbnQsXG4gICAgICAgICAgc2hhZGVycy5HZW9tZXRyeVxuICAgICAgICApO1xuXG4gICAgICAvLyBpZiB0aGUgc2hhZGVyIGNoYW5nZWQgcmVpbml0aWFsaXplIHRoZSBWQU9cbiAgICAgIGlmIChuZXdTaGFkZXIgIT09IGNlbGxCTy5nZXRQcm9ncmFtKCkpIHtcbiAgICAgICAgY2VsbEJPLnNldFByb2dyYW0obmV3U2hhZGVyKTtcbiAgICAgICAgLy8gcmVzZXQgdGhlIFZBTyBhcyB0aGUgc2hhZGVyIGhhcyBjaGFuZ2VkXG4gICAgICAgIGNlbGxCTy5nZXRWQU8oKS5yZWxlYXNlR3JhcGhpY3NSZXNvdXJjZXMoKTtcbiAgICAgIH1cblxuICAgICAgY2VsbEJPLmdldFNoYWRlclNvdXJjZVRpbWUoKS5tb2RpZmllZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3dcbiAgICAgICAgLmdldFNoYWRlckNhY2hlKClcbiAgICAgICAgLnJlYWR5U2hhZGVyUHJvZ3JhbShjZWxsQk8uZ2V0UHJvZ3JhbSgpKTtcbiAgICB9XG5cbiAgICBjZWxsQk8uZ2V0VkFPKCkuYmluZCgpO1xuICAgIHB1YmxpY0FQSS5zZXRNYXBwZXJTaGFkZXJQYXJhbWV0ZXJzKGNlbGxCTywgcmVuLCBhY3Rvcik7XG4gICAgcHVibGljQVBJLnNldENhbWVyYVNoYWRlclBhcmFtZXRlcnMoY2VsbEJPLCByZW4sIGFjdG9yKTtcbiAgICBwdWJsaWNBUEkuc2V0UHJvcGVydHlTaGFkZXJQYXJhbWV0ZXJzKGNlbGxCTywgcmVuLCBhY3Rvcik7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldE1hcHBlclNoYWRlclBhcmFtZXRlcnMgPSAoY2VsbEJPLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgLy8gTm93IHRvIHVwZGF0ZSB0aGUgVkFPIHRvbywgaWYgbmVjZXNzYXJ5LlxuXG4gICAgaWYgKFxuICAgICAgY2VsbEJPLmdldENBQk8oKS5nZXRFbGVtZW50Q291bnQoKSAmJlxuICAgICAgKG1vZGVsLlZCT0J1aWxkVGltZSA+IGNlbGxCTy5nZXRBdHRyaWJ1dGVVcGRhdGVUaW1lKCkuZ2V0TVRpbWUoKSB8fFxuICAgICAgICBjZWxsQk8uZ2V0U2hhZGVyU291cmNlVGltZSgpLmdldE1UaW1lKCkgPlxuICAgICAgICAgIGNlbGxCTy5nZXRBdHRyaWJ1dGVVcGRhdGVUaW1lKCkuZ2V0TVRpbWUoKSlcbiAgICApIHtcbiAgICAgIGlmIChjZWxsQk8uZ2V0UHJvZ3JhbSgpLmlzQXR0cmlidXRlVXNlZCgndmVydGV4TUMnKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWNlbGxCT1xuICAgICAgICAgICAgLmdldFZBTygpXG4gICAgICAgICAgICAuYWRkQXR0cmlidXRlQXJyYXkoXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCksXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCksXG4gICAgICAgICAgICAgICd2ZXJ0ZXhNQycsXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0VmVydGV4T2Zmc2V0KCksXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0U3RyaWRlKCksXG4gICAgICAgICAgICAgIG1vZGVsLmNvbnRleHQuRkxPQVQsXG4gICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgIG1vZGVsLmNvbnRleHQuRkFMU0VcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgdnRrRXJyb3JNYWNybygnRXJyb3Igc2V0dGluZyB2ZXJ0ZXhNQyBpbiBzaGFkZXIgVkFPLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCkuaXNBdHRyaWJ1dGVVc2VkKCd0Y29vcmRNQycpICYmXG4gICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0VENvb3JkT2Zmc2V0KClcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWNlbGxCT1xuICAgICAgICAgICAgLmdldFZBTygpXG4gICAgICAgICAgICAuYWRkQXR0cmlidXRlQXJyYXkoXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCksXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCksXG4gICAgICAgICAgICAgICd0Y29vcmRNQycsXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0VENvb3JkT2Zmc2V0KCksXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0U3RyaWRlKCksXG4gICAgICAgICAgICAgIG1vZGVsLmNvbnRleHQuRkxPQVQsXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0VENvb3JkQ29tcG9uZW50cygpLFxuICAgICAgICAgICAgICBtb2RlbC5jb250ZXh0LkZBTFNFXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIHZ0a0Vycm9yTWFjcm8oJ0Vycm9yIHNldHRpbmcgdGNvb3JkTUMgaW4gc2hhZGVyIFZBTy4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2VsbEJPLmdldEF0dHJpYnV0ZVVwZGF0ZVRpbWUoKS5tb2RpZmllZCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHRleFVuaXQgPSBtb2RlbC5vcGVuR0xUZXh0dXJlLmdldFRleHR1cmVVbml0KCk7XG4gICAgY2VsbEJPLmdldFByb2dyYW0oKS5zZXRVbmlmb3JtaSgndGV4dHVyZTEnLCB0ZXhVbml0KTtcblxuICAgIGNvbnN0IG51bUNvbXAgPSBtb2RlbC5vcGVuR0xUZXh0dXJlLmdldENvbXBvbmVudHMoKTtcbiAgICBjb25zdCBpQ29tcHMgPSBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldEluZGVwZW5kZW50Q29tcG9uZW50cygpO1xuICAgIGlmIChpQ29tcHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29tcDsgaSsrKSB7XG4gICAgICAgIGNlbGxCT1xuICAgICAgICAgIC5nZXRQcm9ncmFtKClcbiAgICAgICAgICAuc2V0VW5pZm9ybWYoYG1peCR7aX1gLCBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldENvbXBvbmVudFdlaWdodChpKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgb2dsU2hpZnRTY2FsZSA9IG1vZGVsLm9wZW5HTFRleHR1cmUuZ2V0U2hpZnRBbmRTY2FsZSgpO1xuXG4gICAgLy8gdGhyZWUgbGV2ZWxzIG9mIHNoaWZ0IHNjYWxlIGNvbWJpbmVkIGludG8gb25lXG4gICAgLy8gZm9yIHBlcmZvcm1hbmNlIGluIHRoZSBmcmFnbWVudCBzaGFkZXJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUNvbXA7IGkrKykge1xuICAgICAgbGV0IGN3ID0gYWN0b3IuZ2V0UHJvcGVydHkoKS5nZXRDb2xvcldpbmRvdygpO1xuICAgICAgbGV0IGNsID0gYWN0b3IuZ2V0UHJvcGVydHkoKS5nZXRDb2xvckxldmVsKCk7XG4gICAgICBjb25zdCB0YXJnZXQgPSBpQ29tcHMgPyBpIDogMDtcbiAgICAgIGNvbnN0IGNmdW4gPSBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldFJHQlRyYW5zZmVyRnVuY3Rpb24odGFyZ2V0KTtcbiAgICAgIGlmIChjZnVuKSB7XG4gICAgICAgIGNvbnN0IGNSYW5nZSA9IGNmdW4uZ2V0UmFuZ2UoKTtcbiAgICAgICAgY3cgPSBjUmFuZ2VbMV0gLSBjUmFuZ2VbMF07XG4gICAgICAgIGNsID0gMC41ICogKGNSYW5nZVsxXSArIGNSYW5nZVswXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNjYWxlID0gb2dsU2hpZnRTY2FsZS5zY2FsZSAvIGN3O1xuICAgICAgY29uc3Qgc2hpZnQgPSAob2dsU2hpZnRTY2FsZS5zaGlmdCAtIGNsKSAvIGN3ICsgMC41O1xuICAgICAgY2VsbEJPLmdldFByb2dyYW0oKS5zZXRVbmlmb3JtZihgY3NoaWZ0JHtpfWAsIHNoaWZ0KTtcbiAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCkuc2V0VW5pZm9ybWYoYGNzY2FsZSR7aX1gLCBzY2FsZSk7XG4gICAgfVxuXG4gICAgLy8gcHdmIHNoaWZ0L3NjYWxlXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db21wOyBpKyspIHtcbiAgICAgIGxldCBwd2ZTY2FsZSA9IDEuMDtcbiAgICAgIGxldCBwd2ZTaGlmdCA9IDAuMDtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGlDb21wcyA/IGkgOiAwO1xuICAgICAgY29uc3QgcHdmdW4gPSBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldFBpZWNld2lzZUZ1bmN0aW9uKHRhcmdldCk7XG4gICAgICBpZiAocHdmdW4pIHtcbiAgICAgICAgY29uc3QgcHdmUmFuZ2UgPSBwd2Z1bi5nZXRSYW5nZSgpO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBwd2ZSYW5nZVsxXSAtIHB3ZlJhbmdlWzBdO1xuICAgICAgICBjb25zdCBtaWQgPSAwLjUgKiAocHdmUmFuZ2VbMF0gKyBwd2ZSYW5nZVsxXSk7XG4gICAgICAgIHB3ZlNjYWxlID0gb2dsU2hpZnRTY2FsZS5zY2FsZSAvIGxlbmd0aDtcbiAgICAgICAgcHdmU2hpZnQgPSAob2dsU2hpZnRTY2FsZS5zaGlmdCAtIG1pZCkgLyBsZW5ndGggKyAwLjU7XG4gICAgICB9XG4gICAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpLnNldFVuaWZvcm1mKGBwd2ZzaGlmdCR7aX1gLCBwd2ZTaGlmdCk7XG4gICAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpLnNldFVuaWZvcm1mKGBwd2ZzY2FsZSR7aX1gLCBwd2ZTY2FsZSk7XG4gICAgfVxuXG4gICAgaWYgKG1vZGVsLmhhdmVTZWVuRGVwdGhSZXF1ZXN0KSB7XG4gICAgICBjZWxsQk9cbiAgICAgICAgLmdldFByb2dyYW0oKVxuICAgICAgICAuc2V0VW5pZm9ybWkoJ2RlcHRoUmVxdWVzdCcsIG1vZGVsLnJlbmRlckRlcHRoID8gMSA6IDApO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBjb2luY2lkZW50XG4gICAgaWYgKGNlbGxCTy5nZXRQcm9ncmFtKCkuaXNVbmlmb3JtVXNlZCgnY29mZnNldCcpKSB7XG4gICAgICBjb25zdCBjcCA9IHB1YmxpY0FQSS5nZXRDb2luY2lkZW50UGFyYW1ldGVycyhyZW4sIGFjdG9yKTtcbiAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCkuc2V0VW5pZm9ybWYoJ2NvZmZzZXQnLCBjcC5vZmZzZXQpO1xuICAgICAgLy8gY2ZhY3RvciBpc24ndCBhbHdheXMgdXNlZCB3aGVuIGNvZmZzZXQgaXMuXG4gICAgICBpZiAoY2VsbEJPLmdldFByb2dyYW0oKS5pc1VuaWZvcm1Vc2VkKCdjZmFjdG9yJykpIHtcbiAgICAgICAgY2VsbEJPLmdldFByb2dyYW0oKS5zZXRVbmlmb3JtZignY2ZhY3RvcicsIGNwLmZhY3Rvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGV4Q29sb3JVbml0ID0gbW9kZWwuY29sb3JUZXh0dXJlLmdldFRleHR1cmVVbml0KCk7XG4gICAgY2VsbEJPLmdldFByb2dyYW0oKS5zZXRVbmlmb3JtaSgnY29sb3JUZXh0dXJlMScsIHRleENvbG9yVW5pdCk7XG5cbiAgICBjb25zdCB0ZXhPcGFjaXR5VW5pdCA9IG1vZGVsLnB3ZlRleHR1cmUuZ2V0VGV4dHVyZVVuaXQoKTtcbiAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpLnNldFVuaWZvcm1pKCdwd2ZUZXh0dXJlMScsIHRleE9wYWNpdHlVbml0KTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0Q2FtZXJhU2hhZGVyUGFyYW1ldGVycyA9IChjZWxsQk8sIHJlbiwgYWN0b3IpID0+IHtcbiAgICBjb25zdCBwcm9ncmFtID0gY2VsbEJPLmdldFByb2dyYW0oKTtcblxuICAgIGNvbnN0IGFjdE1hdHMgPSBtb2RlbC5vcGVuR0xJbWFnZVNsaWNlLmdldEtleU1hdHJpY2VzKCk7XG4gICAgY29uc3QgaW1hZ2UgPSBtb2RlbC5jdXJyZW50SW5wdXQ7XG4gICAgY29uc3QgaTJ3bWF0NCA9IGltYWdlLmdldEluZGV4VG9Xb3JsZCgpO1xuICAgIG1hdDQubXVsdGlwbHkobW9kZWwuaW1hZ2VtYXQsIGFjdE1hdHMubWN3YywgaTJ3bWF0NCk7XG5cbiAgICBjb25zdCBrZXlNYXRzID0gbW9kZWwub3BlbkdMQ2FtZXJhLmdldEtleU1hdHJpY2VzKHJlbik7XG4gICAgbWF0NC5tdWx0aXBseShtb2RlbC5pbWFnZW1hdCwga2V5TWF0cy53Y3BjLCBtb2RlbC5pbWFnZW1hdCk7XG5cbiAgICBpZiAoY2VsbEJPLmdldENBQk8oKS5nZXRDb29yZFNoaWZ0QW5kU2NhbGVFbmFibGVkKCkpIHtcbiAgICAgIGNvbnN0IGludmVyc2VTaGlmdFNjYWxlTWF0ID0gY2VsbEJPXG4gICAgICAgIC5nZXRDQUJPKClcbiAgICAgICAgLmdldEludmVyc2VTaGlmdEFuZFNjYWxlTWF0cml4KCk7XG4gICAgICBtYXQ0Lm11bHRpcGx5KG1vZGVsLmltYWdlbWF0LCBtb2RlbC5pbWFnZW1hdCwgaW52ZXJzZVNoaWZ0U2NhbGVNYXQpO1xuICAgIH1cblxuICAgIHByb2dyYW0uc2V0VW5pZm9ybU1hdHJpeCgnTUNQQ01hdHJpeCcsIG1vZGVsLmltYWdlbWF0KTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0UHJvcGVydHlTaGFkZXJQYXJhbWV0ZXJzID0gKGNlbGxCTywgcmVuLCBhY3RvcikgPT4ge1xuICAgIGNvbnN0IHByb2dyYW0gPSBjZWxsQk8uZ2V0UHJvZ3JhbSgpO1xuXG4gICAgY29uc3QgcHB0eSA9IGFjdG9yLmdldFByb3BlcnR5KCk7XG5cbiAgICBjb25zdCBvcGFjaXR5ID0gcHB0eS5nZXRPcGFjaXR5KCk7XG4gICAgcHJvZ3JhbS5zZXRVbmlmb3JtZignb3BhY2l0eScsIG9wYWNpdHkpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZW5kZXJQaWVjZVN0YXJ0ID0gKHJlbiwgYWN0b3IpID0+IHtcbiAgICAvLyBtYWtlIHN1cmUgdGhlIEJPcyBhcmUgdXAgdG8gZGF0ZVxuICAgIHB1YmxpY0FQSS51cGRhdGVCdWZmZXJPYmplY3RzKHJlbiwgYWN0b3IpO1xuXG4gICAgLy8gQmluZCB0aGUgT3BlbkdMLCB0aGlzIGlzIHNoYXJlZCBiZXR3ZWVuIHRoZSBkaWZmZXJlbnQgcHJpbWl0aXZlL2NlbGwgdHlwZXMuXG4gICAgbW9kZWwubGFzdEJvdW5kQk8gPSBudWxsO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZW5kZXJQaWVjZURyYXcgPSAocmVuLCBhY3RvcikgPT4ge1xuICAgIGNvbnN0IGdsID0gbW9kZWwuY29udGV4dDtcblxuICAgIC8vIGFjdGl2YXRlIHRoZSB0ZXh0dXJlXG4gICAgbW9kZWwub3BlbkdMVGV4dHVyZS5hY3RpdmF0ZSgpO1xuICAgIG1vZGVsLmNvbG9yVGV4dHVyZS5hY3RpdmF0ZSgpO1xuICAgIG1vZGVsLnB3ZlRleHR1cmUuYWN0aXZhdGUoKTtcblxuICAgIC8vIGRyYXcgcG9seWdvbnNcbiAgICBpZiAobW9kZWwudHJpcy5nZXRDQUJPKCkuZ2V0RWxlbWVudENvdW50KCkpIHtcbiAgICAgIC8vIEZpcnN0IHdlIGRvIHRoZSB0cmlhbmdsZXMsIHVwZGF0ZSB0aGUgc2hhZGVyLCBzZXQgdW5pZm9ybXMsIGV0Yy5cbiAgICAgIHB1YmxpY0FQSS51cGRhdGVTaGFkZXJzKG1vZGVsLnRyaXMsIHJlbiwgYWN0b3IpO1xuICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIG1vZGVsLnRyaXMuZ2V0Q0FCTygpLmdldEVsZW1lbnRDb3VudCgpKTtcbiAgICAgIG1vZGVsLnRyaXMuZ2V0VkFPKCkucmVsZWFzZSgpO1xuICAgIH1cblxuICAgIG1vZGVsLm9wZW5HTFRleHR1cmUuZGVhY3RpdmF0ZSgpO1xuICAgIG1vZGVsLmNvbG9yVGV4dHVyZS5kZWFjdGl2YXRlKCk7XG4gICAgbW9kZWwucHdmVGV4dHVyZS5kZWFjdGl2YXRlKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLnJlbmRlclBpZWNlRmluaXNoID0gKHJlbiwgYWN0b3IpID0+IHt9O1xuXG4gIHB1YmxpY0FQSS5yZW5kZXJQaWVjZSA9IChyZW4sIGFjdG9yKSA9PiB7XG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBiZWVuIHByb3Blcmx5IGluaXRpYWxpemVkLlxuICAgIC8vIGlmIChyZW4uZ2V0UmVuZGVyV2luZG93KCkuY2hlY2tBYm9ydFN0YXR1cygpKSB7XG4gICAgLy8gICByZXR1cm47XG4gICAgLy8gfVxuXG4gICAgcHVibGljQVBJLmludm9rZUV2ZW50KHsgdHlwZTogJ1N0YXJ0RXZlbnQnIH0pO1xuICAgIG1vZGVsLnJlbmRlcmFibGUudXBkYXRlKCk7XG4gICAgbW9kZWwuY3VycmVudElucHV0ID0gbW9kZWwucmVuZGVyYWJsZS5nZXRJbnB1dERhdGEoKTtcbiAgICBwdWJsaWNBUEkuaW52b2tlRXZlbnQoeyB0eXBlOiAnRW5kRXZlbnQnIH0pO1xuXG4gICAgaWYgKCFtb2RlbC5jdXJyZW50SW5wdXQpIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oJ05vIGlucHV0IScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHB1YmxpY0FQSS5yZW5kZXJQaWVjZVN0YXJ0KHJlbiwgYWN0b3IpO1xuICAgIHB1YmxpY0FQSS5yZW5kZXJQaWVjZURyYXcocmVuLCBhY3Rvcik7XG4gICAgcHVibGljQVBJLnJlbmRlclBpZWNlRmluaXNoKHJlbiwgYWN0b3IpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5jb21wdXRlQm91bmRzID0gKHJlbiwgYWN0b3IpID0+IHtcbiAgICBpZiAoIXB1YmxpY0FQSS5nZXRJbnB1dCgpKSB7XG4gICAgICB2dGtNYXRoLnVuaW5pdGlhbGl6ZUJvdW5kcyhtb2RlbC5ib3VuZHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtb2RlbC5ib3VuZHMgPSBwdWJsaWNBUEkuZ2V0SW5wdXQoKS5nZXRCb3VuZHMoKTtcbiAgfTtcblxuICBwdWJsaWNBUEkudXBkYXRlQnVmZmVyT2JqZWN0cyA9IChyZW4sIGFjdG9yKSA9PiB7XG4gICAgLy8gUmVidWlsZCBidWZmZXJzIGlmIG5lZWRlZFxuICAgIGlmIChwdWJsaWNBUEkuZ2V0TmVlZFRvUmVidWlsZEJ1ZmZlck9iamVjdHMocmVuLCBhY3RvcikpIHtcbiAgICAgIHB1YmxpY0FQSS5idWlsZEJ1ZmZlck9iamVjdHMocmVuLCBhY3Rvcik7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXROZWVkVG9SZWJ1aWxkQnVmZmVyT2JqZWN0cyA9IChyZW4sIGFjdG9yKSA9PiB7XG4gICAgLy8gZmlyc3QgZG8gYSBjb2Fyc2UgY2hlY2tcbiAgICBpZiAoXG4gICAgICBtb2RlbC5WQk9CdWlsZFRpbWUuZ2V0TVRpbWUoKSA8IHB1YmxpY0FQSS5nZXRNVGltZSgpIHx8XG4gICAgICBtb2RlbC5WQk9CdWlsZFRpbWUuZ2V0TVRpbWUoKSA8IGFjdG9yLmdldE1UaW1lKCkgfHxcbiAgICAgIG1vZGVsLlZCT0J1aWxkVGltZS5nZXRNVGltZSgpIDwgbW9kZWwucmVuZGVyYWJsZS5nZXRNVGltZSgpIHx8XG4gICAgICBtb2RlbC5WQk9CdWlsZFRpbWUuZ2V0TVRpbWUoKSA8IGFjdG9yLmdldFByb3BlcnR5KCkuZ2V0TVRpbWUoKSB8fFxuICAgICAgbW9kZWwuVkJPQnVpbGRUaW1lLmdldE1UaW1lKCkgPCBtb2RlbC5jdXJyZW50SW5wdXQuZ2V0TVRpbWUoKVxuICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBwdWJsaWNBUEkuYnVpbGRCdWZmZXJPYmplY3RzID0gKHJlbiwgYWN0b3IpID0+IHtcbiAgICBjb25zdCBpbWFnZSA9IG1vZGVsLmN1cnJlbnRJbnB1dDtcblxuICAgIGlmIChpbWFnZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdG9yUHJvcGVydHkgPSBhY3Rvci5nZXRQcm9wZXJ0eSgpO1xuXG4gICAgLy8gc2V0IGludGVycG9sYXRpb24gb24gdGhlIHRleHR1cmUgYmFzZWQgb24gcHJvcGVydHkgc2V0dGluZ1xuICAgIGNvbnN0IGlUeXBlID0gYWN0b3JQcm9wZXJ0eS5nZXRJbnRlcnBvbGF0aW9uVHlwZSgpO1xuICAgIGlmIChpVHlwZSA9PT0gSW50ZXJwb2xhdGlvblR5cGUuTkVBUkVTVCkge1xuICAgICAgbW9kZWwuY29sb3JUZXh0dXJlLnNldE1pbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTkVBUkVTVCk7XG4gICAgICBtb2RlbC5jb2xvclRleHR1cmUuc2V0TWFnbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTkVBUkVTVCk7XG4gICAgICBtb2RlbC5wd2ZUZXh0dXJlLnNldE1pbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTkVBUkVTVCk7XG4gICAgICBtb2RlbC5wd2ZUZXh0dXJlLnNldE1hZ25pZmljYXRpb25GaWx0ZXIoRmlsdGVyLk5FQVJFU1QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbC5jb2xvclRleHR1cmUuc2V0TWluaWZpY2F0aW9uRmlsdGVyKEZpbHRlci5MSU5FQVIpO1xuICAgICAgbW9kZWwuY29sb3JUZXh0dXJlLnNldE1hZ25pZmljYXRpb25GaWx0ZXIoRmlsdGVyLkxJTkVBUik7XG4gICAgICBtb2RlbC5wd2ZUZXh0dXJlLnNldE1pbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTElORUFSKTtcbiAgICAgIG1vZGVsLnB3ZlRleHR1cmUuc2V0TWFnbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTElORUFSKTtcbiAgICB9XG5cbiAgICBjb25zdCBudW1Db21wID0gaW1hZ2UuZ2V0UG9pbnREYXRhKCkuZ2V0U2NhbGFycygpLmdldE51bWJlck9mQ29tcG9uZW50cygpO1xuICAgIGNvbnN0IGlDb21wcyA9IGFjdG9yUHJvcGVydHkuZ2V0SW5kZXBlbmRlbnRDb21wb25lbnRzKCk7XG4gICAgY29uc3QgbnVtSUNvbXBzID0gaUNvbXBzID8gbnVtQ29tcCA6IDE7XG4gICAgY29uc3QgdGV4dHVyZUhlaWdodCA9IGlDb21wcyA/IDIgKiBudW1JQ29tcHMgOiAxO1xuXG4gICAgY29uc3QgY2Z1blRvU3RyaW5nID0gY29tcHV0ZUZuVG9TdHJpbmcoXG4gICAgICBhY3RvclByb3BlcnR5LFxuICAgICAgYWN0b3JQcm9wZXJ0eS5nZXRSR0JUcmFuc2ZlckZ1bmN0aW9uLFxuICAgICAgbnVtSUNvbXBzXG4gICAgKTtcblxuICAgIGlmIChtb2RlbC5jb2xvclRleHR1cmVTdHJpbmcgIT09IGNmdW5Ub1N0cmluZykge1xuICAgICAgY29uc3QgY1dpZHRoID0gMTAyNDtcbiAgICAgIGNvbnN0IGNTaXplID0gY1dpZHRoICogdGV4dHVyZUhlaWdodCAqIDM7XG4gICAgICBjb25zdCBjVGFibGUgPSBuZXcgVWludDhBcnJheShjU2l6ZSk7XG4gICAgICBsZXQgY2Z1biA9IGFjdG9yUHJvcGVydHkuZ2V0UkdCVHJhbnNmZXJGdW5jdGlvbigpO1xuICAgICAgaWYgKGNmdW4pIHtcbiAgICAgICAgY29uc3QgdG1wVGFibGUgPSBuZXcgRmxvYXQzMkFycmF5KGNXaWR0aCAqIDMpO1xuXG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgbnVtSUNvbXBzOyBjKyspIHtcbiAgICAgICAgICBjZnVuID0gYWN0b3JQcm9wZXJ0eS5nZXRSR0JUcmFuc2ZlckZ1bmN0aW9uKGMpO1xuICAgICAgICAgIGNvbnN0IGNSYW5nZSA9IGNmdW4uZ2V0UmFuZ2UoKTtcbiAgICAgICAgICBjZnVuLmdldFRhYmxlKGNSYW5nZVswXSwgY1JhbmdlWzFdLCBjV2lkdGgsIHRtcFRhYmxlLCAxKTtcbiAgICAgICAgICBpZiAoaUNvbXBzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNXaWR0aCAqIDM7IGkrKykge1xuICAgICAgICAgICAgICBjVGFibGVbYyAqIGNXaWR0aCAqIDYgKyBpXSA9IDI1NS4wICogdG1wVGFibGVbaV07XG4gICAgICAgICAgICAgIGNUYWJsZVtjICogY1dpZHRoICogNiArIGkgKyBjV2lkdGggKiAzXSA9IDI1NS4wICogdG1wVGFibGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY1dpZHRoICogMzsgaSsrKSB7XG4gICAgICAgICAgICAgIGNUYWJsZVtjICogY1dpZHRoICogNiArIGldID0gMjU1LjAgKiB0bXBUYWJsZVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuY29sb3JUZXh0dXJlLmNyZWF0ZTJERnJvbVJhdyhcbiAgICAgICAgICBjV2lkdGgsXG4gICAgICAgICAgdGV4dHVyZUhlaWdodCxcbiAgICAgICAgICAzLFxuICAgICAgICAgIFZ0a0RhdGFUeXBlcy5VTlNJR05FRF9DSEFSLFxuICAgICAgICAgIGNUYWJsZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjV2lkdGggKiAzOyArK2kpIHtcbiAgICAgICAgICBjVGFibGVbaV0gPSAoMjU1LjAgKiBpKSAvICgoY1dpZHRoIC0gMSkgKiAzKTtcbiAgICAgICAgICBjVGFibGVbaSArIDFdID0gKDI1NS4wICogaSkgLyAoKGNXaWR0aCAtIDEpICogMyk7XG4gICAgICAgICAgY1RhYmxlW2kgKyAyXSA9ICgyNTUuMCAqIGkpIC8gKChjV2lkdGggLSAxKSAqIDMpO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLmNvbG9yVGV4dHVyZS5jcmVhdGUyREZyb21SYXcoXG4gICAgICAgICAgY1dpZHRoLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMyxcbiAgICAgICAgICBWdGtEYXRhVHlwZXMuVU5TSUdORURfQ0hBUixcbiAgICAgICAgICBjVGFibGVcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgbW9kZWwuY29sb3JUZXh0dXJlU3RyaW5nID0gY2Z1blRvU3RyaW5nO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHBpZWNld2lzZSBmdW5jdGlvbiBidWZmZXIuICBUaGlzIGJ1ZmZlciBpcyB1c2VkIGVpdGhlclxuICAgIC8vIGZvciBjb21wb25lbnQgd2VpZ2h0aW5nIG9yIG9wYWNpdHksIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlXG4gICAgLy8gcmVuZGVyaW5nIGNvbXBvbmVudHMgaW5kZXBlbmRlbnRseSBvciBub3QuXG4gICAgY29uc3QgcHdmdW5Ub1N0cmluZyA9IGNvbXB1dGVGblRvU3RyaW5nKFxuICAgICAgYWN0b3JQcm9wZXJ0eSxcbiAgICAgIGFjdG9yUHJvcGVydHkuZ2V0UGllY2V3aXNlRnVuY3Rpb24sXG4gICAgICBudW1JQ29tcHNcbiAgICApO1xuXG4gICAgaWYgKG1vZGVsLnB3ZlRleHR1cmVTdHJpbmcgIT09IHB3ZnVuVG9TdHJpbmcpIHtcbiAgICAgIGNvbnN0IHB3ZldpZHRoID0gMTAyNDtcbiAgICAgIGNvbnN0IHB3ZlNpemUgPSBwd2ZXaWR0aCAqIHRleHR1cmVIZWlnaHQ7XG4gICAgICBjb25zdCBwd2ZUYWJsZSA9IG5ldyBVaW50OEFycmF5KHB3ZlNpemUpO1xuICAgICAgbGV0IHB3ZnVuID0gYWN0b3JQcm9wZXJ0eS5nZXRQaWVjZXdpc2VGdW5jdGlvbigpO1xuICAgICAgLy8gc3VwcG9ydCBjYXNlIHdoZXJlIHB3ZnVuIGlzIGFkZGVkL3JlbW92ZWRcbiAgICAgIG1vZGVsLnB3ZlRleHR1cmUucmVzZXRGb3JtYXRBbmRUeXBlKCk7XG4gICAgICBpZiAocHdmdW4pIHtcbiAgICAgICAgY29uc3QgcHdmRmxvYXRUYWJsZSA9IG5ldyBGbG9hdDMyQXJyYXkocHdmU2l6ZSk7XG4gICAgICAgIGNvbnN0IHRtcFRhYmxlID0gbmV3IEZsb2F0MzJBcnJheShwd2ZXaWR0aCk7XG5cbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBudW1JQ29tcHM7ICsrYykge1xuICAgICAgICAgIHB3ZnVuID0gYWN0b3JQcm9wZXJ0eS5nZXRQaWVjZXdpc2VGdW5jdGlvbihjKTtcbiAgICAgICAgICBpZiAocHdmdW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFBpZWNld2lzZSBjb25zdGFudCBtYXggaWYgbm8gZnVuY3Rpb24gc3VwcGxpZWQgZm9yIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAgICBwd2ZGbG9hdFRhYmxlLmZpbGwoMS4wKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcHdmUmFuZ2UgPSBwd2Z1bi5nZXRSYW5nZSgpO1xuICAgICAgICAgICAgcHdmdW4uZ2V0VGFibGUocHdmUmFuZ2VbMF0sIHB3ZlJhbmdlWzFdLCBwd2ZXaWR0aCwgdG1wVGFibGUsIDEpO1xuICAgICAgICAgICAgLy8gYWRqdXN0IGZvciBzYW1wbGUgZGlzdGFuY2UgZXRjXG4gICAgICAgICAgICBpZiAoaUNvbXBzKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHdmV2lkdGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHB3ZkZsb2F0VGFibGVbYyAqIHB3ZldpZHRoICogMiArIGldID0gdG1wVGFibGVbaV07XG4gICAgICAgICAgICAgICAgcHdmRmxvYXRUYWJsZVtjICogcHdmV2lkdGggKiAyICsgaSArIHB3ZldpZHRoXSA9IHRtcFRhYmxlW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB3ZldpZHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwd2ZGbG9hdFRhYmxlW2MgKiBwd2ZXaWR0aCAqIDIgKyBpXSA9IHRtcFRhYmxlW2ldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1vZGVsLnB3ZlRleHR1cmUuY3JlYXRlMkRGcm9tUmF3KFxuICAgICAgICAgIHB3ZldpZHRoLFxuICAgICAgICAgIHRleHR1cmVIZWlnaHQsXG4gICAgICAgICAgMSxcbiAgICAgICAgICBWdGtEYXRhVHlwZXMuRkxPQVQsXG4gICAgICAgICAgcHdmRmxvYXRUYWJsZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVmYXVsdCBpcyBvcGFxdWVcbiAgICAgICAgcHdmVGFibGUuZmlsbCgyNTUuMCk7XG4gICAgICAgIG1vZGVsLnB3ZlRleHR1cmUuY3JlYXRlMkRGcm9tUmF3KFxuICAgICAgICAgIHB3ZldpZHRoLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgMSxcbiAgICAgICAgICBWdGtEYXRhVHlwZXMuVU5TSUdORURfQ0hBUixcbiAgICAgICAgICBwd2ZUYWJsZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBtb2RlbC5wd2ZUZXh0dXJlU3RyaW5nID0gcHdmdW5Ub1N0cmluZztcbiAgICB9XG5cbiAgICAvLyBGaW5kIHdoYXQgSUpLIGF4aXMgYW5kIHdoYXQgZGlyZWN0aW9uIHRvIHNsaWNlIGFsb25nXG4gICAgY29uc3QgeyBpamtNb2RlIH0gPSBtb2RlbC5yZW5kZXJhYmxlLmdldENsb3Nlc3RJSktBeGlzKCk7XG5cbiAgICAvLyBGaW5kIHRoZSBJSksgc2xpY2VcbiAgICBsZXQgblNsaWNlID0gbW9kZWwucmVuZGVyYWJsZS5nZXRTbGljZSgpO1xuICAgIGlmIChpamtNb2RlICE9PSBtb2RlbC5yZW5kZXJhYmxlLmdldFNsaWNpbmdNb2RlKCkpIHtcbiAgICAgIC8vIElmIG5vdCBJSksgc2xpY2luZywgZ2V0IHRoZSBJSksgc2xpY2UgZnJvbSB0aGUgWFlaIHBvc2l0aW9uL3NsaWNlXG4gICAgICBuU2xpY2UgPSBtb2RlbC5yZW5kZXJhYmxlLmdldFNsaWNlQXRQb3NpdGlvbihuU2xpY2UpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgc2xpY2VPZmZzZXRcbiAgICBjb25zdCBleHQgPSBpbWFnZS5nZXRFeHRlbnQoKTtcbiAgICBsZXQgc2xpY2VPZmZzZXQ7XG4gICAgaWYgKGlqa01vZGUgPT09IFNsaWNpbmdNb2RlLkkpIHtcbiAgICAgIHNsaWNlT2Zmc2V0ID0gblNsaWNlIC0gZXh0WzBdO1xuICAgIH1cbiAgICBpZiAoaWprTW9kZSA9PT0gU2xpY2luZ01vZGUuSikge1xuICAgICAgc2xpY2VPZmZzZXQgPSBuU2xpY2UgLSBleHRbMl07XG4gICAgfVxuICAgIGlmIChpamtNb2RlID09PSBTbGljaW5nTW9kZS5LIHx8IGlqa01vZGUgPT09IFNsaWNpbmdNb2RlLk5PTkUpIHtcbiAgICAgIHNsaWNlT2Zmc2V0ID0gblNsaWNlIC0gZXh0WzRdO1xuICAgIH1cblxuICAgIC8vIHJlYnVpbGQgdGhlIFZCTyBpZiB0aGUgZGF0YSBoYXMgY2hhbmdlZFxuICAgIGNvbnN0IHRvU3RyaW5nID0gYCR7blNsaWNlfUEke2ltYWdlLmdldE1UaW1lKCl9QSR7aW1hZ2VcbiAgICAgIC5nZXRQb2ludERhdGEoKVxuICAgICAgLmdldFNjYWxhcnMoKVxuICAgICAgLmdldE1UaW1lKCl9QiR7cHVibGljQVBJLmdldE1UaW1lKCl9QyR7bW9kZWwucmVuZGVyYWJsZS5nZXRTbGljaW5nTW9kZSgpfUQke2FjdG9yXG4gICAgICAuZ2V0UHJvcGVydHkoKVxuICAgICAgLmdldE1UaW1lKCl9YDtcbiAgICBpZiAobW9kZWwuVkJPQnVpbGRTdHJpbmcgIT09IHRvU3RyaW5nKSB7XG4gICAgICAvLyBCdWlsZCB0aGUgVkJPc1xuICAgICAgY29uc3QgZGltcyA9IGltYWdlLmdldERpbWVuc2lvbnMoKTtcbiAgICAgIGlmIChpVHlwZSA9PT0gSW50ZXJwb2xhdGlvblR5cGUuTkVBUkVTVCkge1xuICAgICAgICBpZiAobnVtQ29tcCA9PT0gNCkge1xuICAgICAgICAgIG1vZGVsLm9wZW5HTFRleHR1cmUuc2V0R2VuZXJhdGVNaXBtYXAodHJ1ZSk7XG4gICAgICAgICAgbW9kZWwub3BlbkdMVGV4dHVyZS5zZXRNaW5pZmljYXRpb25GaWx0ZXIoRmlsdGVyLk5FQVJFU1QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGVsLm9wZW5HTFRleHR1cmUuc2V0TWluaWZpY2F0aW9uRmlsdGVyKEZpbHRlci5ORUFSRVNUKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5vcGVuR0xUZXh0dXJlLnNldE1hZ25pZmljYXRpb25GaWx0ZXIoRmlsdGVyLk5FQVJFU1QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG51bUNvbXAgPT09IDQpIHtcbiAgICAgICAgICBtb2RlbC5vcGVuR0xUZXh0dXJlLnNldEdlbmVyYXRlTWlwbWFwKHRydWUpO1xuICAgICAgICAgIG1vZGVsLm9wZW5HTFRleHR1cmUuc2V0TWluaWZpY2F0aW9uRmlsdGVyKFxuICAgICAgICAgICAgRmlsdGVyLkxJTkVBUl9NSVBNQVBfTElORUFSXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlbC5vcGVuR0xUZXh0dXJlLnNldE1pbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTElORUFSKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5vcGVuR0xUZXh0dXJlLnNldE1hZ25pZmljYXRpb25GaWx0ZXIoRmlsdGVyLkxJTkVBUik7XG4gICAgICB9XG4gICAgICBtb2RlbC5vcGVuR0xUZXh0dXJlLnNldFdyYXBTKFdyYXAuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBtb2RlbC5vcGVuR0xUZXh0dXJlLnNldFdyYXBUKFdyYXAuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBjb25zdCBzbGljZVNpemUgPSBkaW1zWzBdICogZGltc1sxXSAqIG51bUNvbXA7XG5cbiAgICAgIGNvbnN0IHB0c0FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSgxMik7XG4gICAgICBjb25zdCB0Y29vcmRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICB0Y29vcmRBcnJheVtpICogMl0gPSBpICUgMiA/IDEuMCA6IDAuMDtcbiAgICAgICAgdGNvb3JkQXJyYXlbaSAqIDIgKyAxXSA9IGkgPiAxID8gMS4wIDogMC4wO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBiYXNpY1NjYWxhcnMgPSBpbWFnZS5nZXRQb2ludERhdGEoKS5nZXRTY2FsYXJzKCkuZ2V0RGF0YSgpO1xuICAgICAgbGV0IHNjYWxhcnMgPSBudWxsO1xuICAgICAgLy8gR2V0IHJpZ2h0IHNjYWxhcnMgYWNjb3JkaW5nIHRvIHNsaWNpbmcgbW9kZVxuICAgICAgaWYgKGlqa01vZGUgPT09IFNsaWNpbmdNb2RlLkkpIHtcbiAgICAgICAgc2NhbGFycyA9IG5ldyBiYXNpY1NjYWxhcnMuY29uc3RydWN0b3IoZGltc1syXSAqIGRpbXNbMV0gKiBudW1Db21wKTtcbiAgICAgICAgbGV0IGlkID0gMDtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkaW1zWzJdOyBrKyspIHtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGRpbXNbMV07IGorKykge1xuICAgICAgICAgICAgY29uc3QgYnNJZHggPVxuICAgICAgICAgICAgICAoc2xpY2VPZmZzZXQgKyBqICogZGltc1swXSArIGsgKiBkaW1zWzBdICogZGltc1sxXSkgKiBudW1Db21wO1xuICAgICAgICAgICAgaWQgPSAoayAqIGRpbXNbMV0gKyBqKSAqIG51bUNvbXA7XG4gICAgICAgICAgICBzY2FsYXJzLnNldChiYXNpY1NjYWxhcnMuc3ViYXJyYXkoYnNJZHgsIGJzSWR4ICsgbnVtQ29tcCksIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGltc1swXSA9IGRpbXNbMV07XG4gICAgICAgIGRpbXNbMV0gPSBkaW1zWzJdO1xuICAgICAgICBwdHNBcnJheVswXSA9IG5TbGljZTtcbiAgICAgICAgcHRzQXJyYXlbMV0gPSBleHRbMl07XG4gICAgICAgIHB0c0FycmF5WzJdID0gZXh0WzRdO1xuICAgICAgICBwdHNBcnJheVszXSA9IG5TbGljZTtcbiAgICAgICAgcHRzQXJyYXlbNF0gPSBleHRbM107XG4gICAgICAgIHB0c0FycmF5WzVdID0gZXh0WzRdO1xuICAgICAgICBwdHNBcnJheVs2XSA9IG5TbGljZTtcbiAgICAgICAgcHRzQXJyYXlbN10gPSBleHRbMl07XG4gICAgICAgIHB0c0FycmF5WzhdID0gZXh0WzVdO1xuICAgICAgICBwdHNBcnJheVs5XSA9IG5TbGljZTtcbiAgICAgICAgcHRzQXJyYXlbMTBdID0gZXh0WzNdO1xuICAgICAgICBwdHNBcnJheVsxMV0gPSBleHRbNV07XG4gICAgICB9IGVsc2UgaWYgKGlqa01vZGUgPT09IFNsaWNpbmdNb2RlLkopIHtcbiAgICAgICAgc2NhbGFycyA9IG5ldyBiYXNpY1NjYWxhcnMuY29uc3RydWN0b3IoZGltc1syXSAqIGRpbXNbMF0gKiBudW1Db21wKTtcbiAgICAgICAgbGV0IGlkID0gMDtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBkaW1zWzJdOyBrKyspIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpbXNbMF07IGkrKykge1xuICAgICAgICAgICAgY29uc3QgYnNJZHggPVxuICAgICAgICAgICAgICAoaSArIHNsaWNlT2Zmc2V0ICogZGltc1swXSArIGsgKiBkaW1zWzBdICogZGltc1sxXSkgKiBudW1Db21wO1xuICAgICAgICAgICAgaWQgPSAoayAqIGRpbXNbMF0gKyBpKSAqIG51bUNvbXA7XG4gICAgICAgICAgICBzY2FsYXJzLnNldChiYXNpY1NjYWxhcnMuc3ViYXJyYXkoYnNJZHgsIGJzSWR4ICsgbnVtQ29tcCksIGlkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGltc1sxXSA9IGRpbXNbMl07XG4gICAgICAgIHB0c0FycmF5WzBdID0gZXh0WzBdO1xuICAgICAgICBwdHNBcnJheVsxXSA9IG5TbGljZTtcbiAgICAgICAgcHRzQXJyYXlbMl0gPSBleHRbNF07XG4gICAgICAgIHB0c0FycmF5WzNdID0gZXh0WzFdO1xuICAgICAgICBwdHNBcnJheVs0XSA9IG5TbGljZTtcbiAgICAgICAgcHRzQXJyYXlbNV0gPSBleHRbNF07XG4gICAgICAgIHB0c0FycmF5WzZdID0gZXh0WzBdO1xuICAgICAgICBwdHNBcnJheVs3XSA9IG5TbGljZTtcbiAgICAgICAgcHRzQXJyYXlbOF0gPSBleHRbNV07XG4gICAgICAgIHB0c0FycmF5WzldID0gZXh0WzFdO1xuICAgICAgICBwdHNBcnJheVsxMF0gPSBuU2xpY2U7XG4gICAgICAgIHB0c0FycmF5WzExXSA9IGV4dFs1XTtcbiAgICAgIH0gZWxzZSBpZiAoaWprTW9kZSA9PT0gU2xpY2luZ01vZGUuSyB8fCBpamtNb2RlID09PSBTbGljaW5nTW9kZS5OT05FKSB7XG4gICAgICAgIHNjYWxhcnMgPSBiYXNpY1NjYWxhcnMuc3ViYXJyYXkoXG4gICAgICAgICAgc2xpY2VPZmZzZXQgKiBzbGljZVNpemUsXG4gICAgICAgICAgKHNsaWNlT2Zmc2V0ICsgMSkgKiBzbGljZVNpemVcbiAgICAgICAgKTtcbiAgICAgICAgcHRzQXJyYXlbMF0gPSBleHRbMF07XG4gICAgICAgIHB0c0FycmF5WzFdID0gZXh0WzJdO1xuICAgICAgICBwdHNBcnJheVsyXSA9IG5TbGljZTtcbiAgICAgICAgcHRzQXJyYXlbM10gPSBleHRbMV07XG4gICAgICAgIHB0c0FycmF5WzRdID0gZXh0WzJdO1xuICAgICAgICBwdHNBcnJheVs1XSA9IG5TbGljZTtcbiAgICAgICAgcHRzQXJyYXlbNl0gPSBleHRbMF07XG4gICAgICAgIHB0c0FycmF5WzddID0gZXh0WzNdO1xuICAgICAgICBwdHNBcnJheVs4XSA9IG5TbGljZTtcbiAgICAgICAgcHRzQXJyYXlbOV0gPSBleHRbMV07XG4gICAgICAgIHB0c0FycmF5WzEwXSA9IGV4dFszXTtcbiAgICAgICAgcHRzQXJyYXlbMTFdID0gblNsaWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdnRrRXJyb3JNYWNybygnUmVmb3JtYXQgc2xpY2luZyBub3QgeWV0IHN1cHBvcnRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgbW9kZWwub3BlbkdMVGV4dHVyZS5jcmVhdGUyREZyb21SYXcoXG4gICAgICAgIGRpbXNbMF0sXG4gICAgICAgIGRpbXNbMV0sXG4gICAgICAgIG51bUNvbXAsXG4gICAgICAgIGltYWdlLmdldFBvaW50RGF0YSgpLmdldFNjYWxhcnMoKS5nZXREYXRhVHlwZSgpLFxuICAgICAgICBzY2FsYXJzXG4gICAgICApO1xuICAgICAgbW9kZWwub3BlbkdMVGV4dHVyZS5hY3RpdmF0ZSgpO1xuICAgICAgbW9kZWwub3BlbkdMVGV4dHVyZS5zZW5kUGFyYW1ldGVycygpO1xuICAgICAgbW9kZWwub3BlbkdMVGV4dHVyZS5kZWFjdGl2YXRlKCk7XG5cbiAgICAgIGNvbnN0IHBvaW50cyA9IHZ0a0RhdGFBcnJheS5uZXdJbnN0YW5jZSh7XG4gICAgICAgIG51bWJlck9mQ29tcG9uZW50czogMyxcbiAgICAgICAgdmFsdWVzOiBwdHNBcnJheSxcbiAgICAgIH0pO1xuICAgICAgcG9pbnRzLnNldE5hbWUoJ3BvaW50cycpO1xuICAgICAgY29uc3QgdGNvb3JkcyA9IHZ0a0RhdGFBcnJheS5uZXdJbnN0YW5jZSh7XG4gICAgICAgIG51bWJlck9mQ29tcG9uZW50czogMixcbiAgICAgICAgdmFsdWVzOiB0Y29vcmRBcnJheSxcbiAgICAgIH0pO1xuICAgICAgdGNvb3Jkcy5zZXROYW1lKCd0Y29vcmRzJyk7XG5cbiAgICAgIGNvbnN0IGNlbGxBcnJheSA9IG5ldyBVaW50MTZBcnJheSg4KTtcbiAgICAgIGNlbGxBcnJheVswXSA9IDM7XG4gICAgICBjZWxsQXJyYXlbMV0gPSAwO1xuICAgICAgY2VsbEFycmF5WzJdID0gMTtcbiAgICAgIGNlbGxBcnJheVszXSA9IDM7XG4gICAgICBjZWxsQXJyYXlbNF0gPSAzO1xuICAgICAgY2VsbEFycmF5WzVdID0gMDtcbiAgICAgIGNlbGxBcnJheVs2XSA9IDM7XG4gICAgICBjZWxsQXJyYXlbN10gPSAyO1xuICAgICAgY29uc3QgY2VsbHMgPSB2dGtEYXRhQXJyYXkubmV3SW5zdGFuY2Uoe1xuICAgICAgICBudW1iZXJPZkNvbXBvbmVudHM6IDEsXG4gICAgICAgIHZhbHVlczogY2VsbEFycmF5LFxuICAgICAgfSk7XG5cbiAgICAgIG1vZGVsLnRyaXMuZ2V0Q0FCTygpLmNyZWF0ZVZCTyhjZWxscywgJ3BvbHlzJywgUmVwcmVzZW50YXRpb24uU1VSRkFDRSwge1xuICAgICAgICBwb2ludHMsXG4gICAgICAgIHRjb29yZHMsXG4gICAgICAgIGNlbGxPZmZzZXQ6IDAsXG4gICAgICB9KTtcbiAgICAgIG1vZGVsLlZCT0J1aWxkVGltZS5tb2RpZmllZCgpO1xuICAgICAgbW9kZWwuVkJPQnVpbGRTdHJpbmcgPSB0b1N0cmluZztcbiAgICB9XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBWQk9CdWlsZFRpbWU6IDAsXG4gIFZCT0J1aWxkU3RyaW5nOiBudWxsLFxuICBvcGVuR0xUZXh0dXJlOiBudWxsLFxuICB0cmlzOiBudWxsLFxuICBpbWFnZW1hdDogbnVsbCxcbiAgY29sb3JUZXh0dXJlOiBudWxsLFxuICBwd2ZUZXh0dXJlOiBudWxsLFxuICBsYXN0SGF2ZVNlZW5EZXB0aFJlcXVlc3Q6IGZhbHNlLFxuICBoYXZlU2VlbkRlcHRoUmVxdWVzdDogZmFsc2UsXG4gIGxhc3RUZXh0dXJlQ29tcG9uZW50czogMCxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEluaGVyaXRhbmNlXG4gIHZ0a1ZpZXdOb2RlLmV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzKTtcbiAgdnRrUmVwbGFjZW1lbnRTaGFkZXJNYXBwZXIuaW1wbGVtZW50UmVwbGFjZVNoYWRlckNvaW5jaWRlbnRPZmZzZXQoXG4gICAgcHVibGljQVBJLFxuICAgIG1vZGVsLFxuICAgIGluaXRpYWxWYWx1ZXNcbiAgKTtcblxuICBtb2RlbC50cmlzID0gdnRrSGVscGVyLm5ld0luc3RhbmNlKCk7XG4gIG1vZGVsLm9wZW5HTFRleHR1cmUgPSB2dGtPcGVuR0xUZXh0dXJlLm5ld0luc3RhbmNlKCk7XG4gIG1vZGVsLmNvbG9yVGV4dHVyZSA9IHZ0a09wZW5HTFRleHR1cmUubmV3SW5zdGFuY2UoKTtcbiAgbW9kZWwucHdmVGV4dHVyZSA9IHZ0a09wZW5HTFRleHR1cmUubmV3SW5zdGFuY2UoKTtcblxuICBtb2RlbC5pbWFnZW1hdCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgLy8gQnVpbGQgVlRLIEFQSVxuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgW10pO1xuXG4gIG1vZGVsLlZCT0J1aWxkVGltZSA9IHt9O1xuICBtYWNyby5vYmoobW9kZWwuVkJPQnVpbGRUaW1lKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICB2dGtPcGVuR0xJbWFnZU1hcHBlcihwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQsICd2dGtPcGVuR0xJbWFnZU1hcHBlcicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCB9O1xuIiwiaW1wb3J0IHsgbWF0NCB9IGZyb20gJ2dsLW1hdHJpeCc7XG5cbmltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgdnRrVmlld05vZGUgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL1NjZW5lR3JhcGgvVmlld05vZGUnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtPcGVuR0xJbWFnZVNsaWNlIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrT3BlbkdMSW1hZ2VTbGljZShwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a09wZW5HTEltYWdlU2xpY2UnKTtcblxuICAvLyBCdWlsZHMgbXlzZWxmLlxuICBwdWJsaWNBUEkuYnVpbGRQYXNzID0gKHByZXBhc3MpID0+IHtcbiAgICBpZiAoIW1vZGVsLnJlbmRlcmFibGUgfHwgIW1vZGVsLnJlbmRlcmFibGUuZ2V0VmlzaWJpbGl0eSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcmVwYXNzKSB7XG4gICAgICBpZiAoIW1vZGVsLnJlbmRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtb2RlbC5vcGVuR0xSZW5kZXJlciA9IHB1YmxpY0FQSS5nZXRGaXJzdEFuY2VzdG9yT2ZUeXBlKFxuICAgICAgICAndnRrT3BlbkdMUmVuZGVyZXInXG4gICAgICApO1xuICAgICAgcHVibGljQVBJLnByZXBhcmVOb2RlcygpO1xuICAgICAgcHVibGljQVBJLmFkZE1pc3NpbmdOb2RlKG1vZGVsLnJlbmRlcmFibGUuZ2V0TWFwcGVyKCkpO1xuICAgICAgcHVibGljQVBJLnJlbW92ZVVudXNlZE5vZGVzKCk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS50cmF2ZXJzZU9wYXF1ZVpCdWZmZXJQYXNzID0gKHJlbmRlclBhc3MpID0+IHtcbiAgICBwdWJsaWNBUEkudHJhdmVyc2VPcGFxdWVQYXNzKHJlbmRlclBhc3MpO1xuICB9O1xuXG4gIC8vIHdlIGRyYXcgdGV4dHVyZXMsIHRoZW4gbWFwcGVyLCB0aGVuIHBvc3QgcGFzcyB0ZXh0dXJlc1xuICBwdWJsaWNBUEkudHJhdmVyc2VPcGFxdWVQYXNzID0gKHJlbmRlclBhc3MpID0+IHtcbiAgICBpZiAoXG4gICAgICAhbW9kZWwucmVuZGVyYWJsZSB8fFxuICAgICAgIW1vZGVsLnJlbmRlcmFibGUuZ2V0VmlzaWJpbGl0eSgpIHx8XG4gICAgICAhbW9kZWwucmVuZGVyYWJsZS5nZXRJc09wYXF1ZSgpIHx8XG4gICAgICAobW9kZWwub3BlbkdMUmVuZGVyZXIuZ2V0U2VsZWN0b3IoKSAmJiAhbW9kZWwucmVuZGVyYWJsZS5nZXRQaWNrYWJsZSgpKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHB1YmxpY0FQSS5hcHBseShyZW5kZXJQYXNzLCB0cnVlKTtcbiAgICBtb2RlbC5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgY2hpbGQudHJhdmVyc2UocmVuZGVyUGFzcyk7XG4gICAgfSk7XG4gICAgcHVibGljQVBJLmFwcGx5KHJlbmRlclBhc3MsIGZhbHNlKTtcbiAgfTtcblxuICAvLyB3ZSBkcmF3IHRleHR1cmVzLCB0aGVuIG1hcHBlciwgdGhlbiBwb3N0IHBhc3MgdGV4dHVyZXNcbiAgcHVibGljQVBJLnRyYXZlcnNlVHJhbnNsdWNlbnRQYXNzID0gKHJlbmRlclBhc3MpID0+IHtcbiAgICBpZiAoXG4gICAgICAhbW9kZWwucmVuZGVyYWJsZSB8fFxuICAgICAgIW1vZGVsLnJlbmRlcmFibGUuZ2V0VmlzaWJpbGl0eSgpIHx8XG4gICAgICBtb2RlbC5yZW5kZXJhYmxlLmdldElzT3BhcXVlKCkgfHxcbiAgICAgIChtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRTZWxlY3RvcigpICYmICFtb2RlbC5yZW5kZXJhYmxlLmdldFBpY2thYmxlKCkpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHVibGljQVBJLmFwcGx5KHJlbmRlclBhc3MsIHRydWUpO1xuICAgIG1vZGVsLmNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBjaGlsZC50cmF2ZXJzZShyZW5kZXJQYXNzKTtcbiAgICB9KTtcbiAgICBwdWJsaWNBUEkuYXBwbHkocmVuZGVyUGFzcywgZmFsc2UpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5xdWVyeVBhc3MgPSAocHJlcGFzcywgcmVuZGVyUGFzcykgPT4ge1xuICAgIGlmIChwcmVwYXNzKSB7XG4gICAgICBpZiAoIW1vZGVsLnJlbmRlcmFibGUgfHwgIW1vZGVsLnJlbmRlcmFibGUuZ2V0VmlzaWJpbGl0eSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbC5yZW5kZXJhYmxlLmdldElzT3BhcXVlKCkpIHtcbiAgICAgICAgcmVuZGVyUGFzcy5pbmNyZW1lbnRPcGFxdWVBY3RvckNvdW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJQYXNzLmluY3JlbWVudFRyYW5zbHVjZW50QWN0b3JDb3VudCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkub3BhcXVlWkJ1ZmZlclBhc3MgPSAocHJlcGFzcywgcmVuZGVyUGFzcykgPT5cbiAgICBwdWJsaWNBUEkub3BhcXVlUGFzcyhwcmVwYXNzLCByZW5kZXJQYXNzKTtcblxuICAvLyBSZW5kZXJzIG15c2VsZlxuICBwdWJsaWNBUEkub3BhcXVlUGFzcyA9IChwcmVwYXNzLCByZW5kZXJQYXNzKSA9PiB7XG4gICAgaWYgKHByZXBhc3MpIHtcbiAgICAgIG1vZGVsLmNvbnRleHQgPSBwdWJsaWNBUElcbiAgICAgICAgLmdldEZpcnN0QW5jZXN0b3JPZlR5cGUoJ3Z0a09wZW5HTFJlbmRlcldpbmRvdycpXG4gICAgICAgIC5nZXRDb250ZXh0KCk7XG4gICAgICBtb2RlbC5jb250ZXh0LmRlcHRoTWFzayh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVuZGVycyBteXNlbGZcbiAgcHVibGljQVBJLnRyYW5zbHVjZW50UGFzcyA9IChwcmVwYXNzLCByZW5kZXJQYXNzKSA9PiB7XG4gICAgaWYgKHByZXBhc3MpIHtcbiAgICAgIG1vZGVsLmNvbnRleHQgPSBwdWJsaWNBUElcbiAgICAgICAgLmdldEZpcnN0QW5jZXN0b3JPZlR5cGUoJ3Z0a09wZW5HTFJlbmRlcldpbmRvdycpXG4gICAgICAgIC5nZXRDb250ZXh0KCk7XG4gICAgICBtb2RlbC5jb250ZXh0LmRlcHRoTWFzayhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsLmNvbnRleHQuZGVwdGhNYXNrKHRydWUpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0S2V5TWF0cmljZXMgPSAoKSA9PiB7XG4gICAgLy8gaGFzIHRoZSBhY3RvciBjaGFuZ2VkP1xuICAgIGlmIChtb2RlbC5yZW5kZXJhYmxlLmdldE1UaW1lKCkgPiBtb2RlbC5rZXlNYXRyaXhUaW1lLmdldE1UaW1lKCkpIHtcbiAgICAgIG1hdDQuY29weShtb2RlbC5rZXlNYXRyaWNlcy5tY3djLCBtb2RlbC5yZW5kZXJhYmxlLmdldE1hdHJpeCgpKTtcbiAgICAgIG1hdDQudHJhbnNwb3NlKG1vZGVsLmtleU1hdHJpY2VzLm1jd2MsIG1vZGVsLmtleU1hdHJpY2VzLm1jd2MpO1xuICAgICAgbW9kZWwua2V5TWF0cml4VGltZS5tb2RpZmllZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlbC5rZXlNYXRyaWNlcztcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIGNvbnRleHQ6IG51bGwsXG4gIGtleU1hdHJpeFRpbWU6IG51bGwsXG4gIGtleU1hdHJpY2VzOiBudWxsLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gSW5oZXJpdGFuY2VcbiAgdnRrVmlld05vZGUuZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIG1vZGVsLmtleU1hdHJpeFRpbWUgPSB7fTtcbiAgbWFjcm8ub2JqKG1vZGVsLmtleU1hdHJpeFRpbWUsIHsgbXRpbWU6IDAgfSk7XG4gIG1vZGVsLmtleU1hdHJpY2VzID0ge1xuICAgIG1jd2M6IG1hdDQuY3JlYXRlKCksXG4gIH07XG5cbiAgLy8gQnVpbGQgVlRLIEFQSVxuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgWydjb250ZXh0J10pO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIHZ0a09wZW5HTEltYWdlU2xpY2UocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrT3BlbkdMSW1hZ2VTbGljZScpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCB9O1xuIiwiLy8gaW1wb3J0IHsgbWF0NCwgdmVjMyB9ICAgICBmcm9tICdnbC1tYXRyaXgnO1xuXG5pbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0IHZ0a1ZpZXdOb2RlIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9TY2VuZUdyYXBoL1ZpZXdOb2RlJztcblxuY29uc3QgeyB2dGtEZWJ1Z01hY3JvIH0gPSBtYWNybztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrT3BlbkdMUGl4ZWxTcGFjZUNhbGxiYWNrTWFwcGVyIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrT3BlbkdMUGl4ZWxTcGFjZUNhbGxiYWNrTWFwcGVyKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrT3BlbkdMUGl4ZWxTcGFjZUNhbGxiYWNrTWFwcGVyJyk7XG5cbiAgcHVibGljQVBJLm9wYXF1ZVBhc3MgPSAocHJlcGFzcywgcmVuZGVyUGFzcykgPT4ge1xuICAgIG1vZGVsLm9wZW5HTFJlbmRlcmVyID0gcHVibGljQVBJLmdldEZpcnN0QW5jZXN0b3JPZlR5cGUoXG4gICAgICAndnRrT3BlbkdMUmVuZGVyZXInXG4gICAgKTtcbiAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cgPSBtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRQYXJlbnQoKTtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IG1vZGVsLm9wZW5HTFJlbmRlcmVyLmdldEFzcGVjdFJhdGlvKCk7XG4gICAgY29uc3QgY2FtZXJhID0gbW9kZWwub3BlbkdMUmVuZGVyZXJcbiAgICAgID8gbW9kZWwub3BlbkdMUmVuZGVyZXIuZ2V0UmVuZGVyYWJsZSgpLmdldEFjdGl2ZUNhbWVyYSgpXG4gICAgICA6IG51bGw7XG4gICAgY29uc3QgdHNpemUgPSBtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRUaWxlZFNpemVBbmRPcmlnaW4oKTtcbiAgICBsZXQgdGV4ZWxzID0gbnVsbDtcblxuICAgIGlmIChtb2RlbC5yZW5kZXJhYmxlLmdldFVzZVpWYWx1ZXMoKSkge1xuICAgICAgY29uc3QgemJ0ID0gcmVuZGVyUGFzcy5nZXRaQnVmZmVyVGV4dHVyZSgpO1xuICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmZsb29yKHpidC5nZXRXaWR0aCgpKTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguZmxvb3IoemJ0LmdldEhlaWdodCgpKTtcblxuICAgICAgY29uc3QgZ2wgPSBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0Q29udGV4dCgpO1xuICAgICAgemJ0LmJpbmQoKTtcblxuICAgICAgLy8gSGVyZSB3ZSBuZWVkIHRvIHVzZSB2dGtGcmFtZWJ1ZmZlciB0byBzYXZlIGN1cnJlbnQgc2V0dGluZ3MgKGJpbmRpbmdzL2J1ZmZlcnMpXG4gICAgICBjb25zdCBmYiA9IHJlbmRlclBhc3MuZ2V0RnJhbWVidWZmZXIoKTtcbiAgICAgIGlmICghZmIpIHtcbiAgICAgICAgdnRrRGVidWdNYWNybygnTm8gZnJhbWVidWZmZXIgdG8gc2F2ZS9yZXN0b3JlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBzYXZlIGZyYW1lYnVmZmVyIHNldHRpbmdzXG4gICAgICAgIGZiLnNhdmVDdXJyZW50QmluZGluZ3NBbmRCdWZmZXJzKCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoXG4gICAgICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCxcbiAgICAgICAgZ2wuVEVYVFVSRV8yRCxcbiAgICAgICAgemJ0LmdldEhhbmRsZSgpLFxuICAgICAgICAwXG4gICAgICApO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpID09PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURVxuICAgICAgKSB7XG4gICAgICAgIHRleGVscyA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRleGVscyk7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyB3ZSBuZWVkIHRvIHJlc3RvcmUgZnJhbWVidWZmZXIgYmluZGluZ3MvYnVmZmVyc1xuICAgICAgaWYgKGZiKSB7XG4gICAgICAgIGZiLnJlc3RvcmVQcmV2aW91c0JpbmRpbmdzQW5kQnVmZmVycygpO1xuICAgICAgfVxuXG4gICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgfVxuXG4gICAgbW9kZWwucmVuZGVyYWJsZS5pbnZva2VDYWxsYmFjayhcbiAgICAgIG1vZGVsLnJlbmRlcmFibGUuZ2V0SW5wdXREYXRhKCksXG4gICAgICBjYW1lcmEsXG4gICAgICBhc3BlY3RSYXRpbyxcbiAgICAgIHRzaXplLFxuICAgICAgdGV4ZWxzXG4gICAgKTtcbiAgfTtcblxuICBwdWJsaWNBUEkucXVlcnlQYXNzID0gKHByZXBhc3MsIHJlbmRlclBhc3MpID0+IHtcbiAgICBpZiAocHJlcGFzcykge1xuICAgICAgaWYgKG1vZGVsLnJlbmRlcmFibGUuZ2V0VXNlWlZhbHVlcygpKSB7XG4gICAgICAgIHJlbmRlclBhc3Muc2V0RGVwdGhSZXF1ZXN0ZWQodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJQYXNzLnNldERlcHRoUmVxdWVzdGVkKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7fTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gSW5oZXJpdGFuY2VcbiAgdnRrVmlld05vZGUuZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIHZ0a09wZW5HTFBpeGVsU3BhY2VDYWxsYmFja01hcHBlcihwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShcbiAgZXh0ZW5kLFxuICAndnRrT3BlbkdMUGl4ZWxTcGFjZUNhbGxiYWNrTWFwcGVyJ1xuKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImltcG9ydCB7IG1hdDMsIG1hdDQsIHZlYzMgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5pbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0IHZ0a0hlbHBlciBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML0hlbHBlcic7XG5pbXBvcnQgdnRrTWFwcGVyIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL01hcHBlcic7XG5pbXBvcnQgKiBhcyB2dGtNYXRoIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL01hdGgnO1xuaW1wb3J0IHZ0a09wZW5HTFRleHR1cmUgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9UZXh0dXJlJztcbmltcG9ydCB2dGtQcm9wZXJ0eSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9Qcm9wZXJ0eSc7XG5pbXBvcnQgdnRrU2hhZGVyUHJvZ3JhbSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1NoYWRlclByb2dyYW0nO1xuaW1wb3J0IHZ0a1ZpZXdOb2RlIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9TY2VuZUdyYXBoL1ZpZXdOb2RlJztcbmltcG9ydCB2dGtQb2x5RGF0YVZTIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvZ2xzbC92dGtQb2x5RGF0YVZTLmdsc2wnO1xuaW1wb3J0IHZ0a1BvbHlEYXRhRlMgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9nbHNsL3Z0a1BvbHlEYXRhRlMuZ2xzbCc7XG5cbmltcG9ydCB2dGtSZXBsYWNlbWVudFNoYWRlck1hcHBlciBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1JlcGxhY2VtZW50U2hhZGVyTWFwcGVyJztcblxuLyogZXNsaW50LWRpc2FibGUgbm8tbG9uZWx5LWlmICovXG5cbmNvbnN0IHByaW1UeXBlcyA9IHtcbiAgU3RhcnQ6IDAsXG4gIFBvaW50czogMCxcbiAgTGluZXM6IDEsXG4gIFRyaXM6IDIsXG4gIFRyaVN0cmlwczogMyxcbiAgVHJpc0VkZ2VzOiA0LFxuICBUcmlTdHJpcHNFZGdlczogNSxcbiAgRW5kOiA2LFxufTtcblxuY29uc3QgeyBSZXByZXNlbnRhdGlvbiwgU2hhZGluZyB9ID0gdnRrUHJvcGVydHk7XG5jb25zdCB7IFNjYWxhck1vZGUgfSA9IHZ0a01hcHBlcjtcbmNvbnN0IHsgRmlsdGVyLCBXcmFwIH0gPSB2dGtPcGVuR0xUZXh0dXJlO1xuY29uc3QgeyB2dGtFcnJvck1hY3JvIH0gPSBtYWNybztcbmNvbnN0IFN0YXJ0RXZlbnQgPSB7IHR5cGU6ICdTdGFydEV2ZW50JyB9O1xuY29uc3QgRW5kRXZlbnQgPSB7IHR5cGU6ICdFbmRFdmVudCcgfTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrT3BlbkdMUG9seURhdGFNYXBwZXIgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtPcGVuR0xQb2x5RGF0YU1hcHBlcihwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a09wZW5HTFBvbHlEYXRhTWFwcGVyJyk7XG5cbiAgcHVibGljQVBJLmJ1aWxkUGFzcyA9IChwcmVwYXNzKSA9PiB7XG4gICAgaWYgKHByZXBhc3MpIHtcbiAgICAgIG1vZGVsLm9wZW5HTEFjdG9yID0gcHVibGljQVBJLmdldEZpcnN0QW5jZXN0b3JPZlR5cGUoJ3Z0a09wZW5HTEFjdG9yJyk7XG4gICAgICBtb2RlbC5vcGVuR0xSZW5kZXJlciA9IG1vZGVsLm9wZW5HTEFjdG9yLmdldEZpcnN0QW5jZXN0b3JPZlR5cGUoXG4gICAgICAgICd2dGtPcGVuR0xSZW5kZXJlcidcbiAgICAgICk7XG4gICAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cgPSBtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRQYXJlbnQoKTtcbiAgICAgIG1vZGVsLm9wZW5HTENhbWVyYSA9IG1vZGVsLm9wZW5HTFJlbmRlcmVyLmdldFZpZXdOb2RlRm9yKFxuICAgICAgICBtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRSZW5kZXJhYmxlKCkuZ2V0QWN0aXZlQ2FtZXJhKClcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlbmRlcnMgbXlzZWxmXG4gIHB1YmxpY0FQSS50cmFuc2x1Y2VudFBhc3MgPSAocHJlcGFzcykgPT4ge1xuICAgIGlmIChwcmVwYXNzKSB7XG4gICAgICBwdWJsaWNBUEkucmVuZGVyKCk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5vcGFxdWVaQnVmZmVyUGFzcyA9IChwcmVwYXNzKSA9PiB7XG4gICAgaWYgKHByZXBhc3MpIHtcbiAgICAgIG1vZGVsLmhhdmVTZWVuRGVwdGhSZXF1ZXN0ID0gdHJ1ZTtcbiAgICAgIG1vZGVsLnJlbmRlckRlcHRoID0gdHJ1ZTtcbiAgICAgIHB1YmxpY0FQSS5yZW5kZXIoKTtcbiAgICAgIG1vZGVsLnJlbmRlckRlcHRoID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5vcGFxdWVQYXNzID0gKHByZXBhc3MpID0+IHtcbiAgICBpZiAocHJlcGFzcykge1xuICAgICAgcHVibGljQVBJLnJlbmRlcigpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkucmVuZGVyID0gKCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRDb250ZXh0KCk7XG4gICAgaWYgKG1vZGVsLmNvbnRleHQgIT09IGN0eCkge1xuICAgICAgbW9kZWwuY29udGV4dCA9IGN0eDtcbiAgICAgIGZvciAobGV0IGkgPSBwcmltVHlwZXMuU3RhcnQ7IGkgPCBwcmltVHlwZXMuRW5kOyBpKyspIHtcbiAgICAgICAgbW9kZWwucHJpbWl0aXZlc1tpXS5zZXRPcGVuR0xSZW5kZXJXaW5kb3cobW9kZWwub3BlbkdMUmVuZGVyV2luZG93KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYWN0b3IgPSBtb2RlbC5vcGVuR0xBY3Rvci5nZXRSZW5kZXJhYmxlKCk7XG4gICAgY29uc3QgcmVuID0gbW9kZWwub3BlbkdMUmVuZGVyZXIuZ2V0UmVuZGVyYWJsZSgpO1xuICAgIHB1YmxpY0FQSS5yZW5kZXJQaWVjZShyZW4sIGFjdG9yKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuYnVpbGRTaGFkZXJzID0gKHNoYWRlcnMsIHJlbiwgYWN0b3IpID0+IHtcbiAgICBwdWJsaWNBUEkuZ2V0U2hhZGVyVGVtcGxhdGUoc2hhZGVycywgcmVuLCBhY3Rvcik7XG5cbiAgICAvLyB1c2VyIHNwZWNpZmllZCBwcmUgcmVwbGFjZW1lbnRzXG4gICAgY29uc3Qgb3BlbkdMU3BlYyA9IG1vZGVsLnJlbmRlcmFibGUuZ2V0Vmlld1NwZWNpZmljUHJvcGVydGllcygpLk9wZW5HTDtcbiAgICBsZXQgc2hhZGVyUmVwbGFjZW1lbnRzID0gbnVsbDtcbiAgICBpZiAob3BlbkdMU3BlYykge1xuICAgICAgc2hhZGVyUmVwbGFjZW1lbnRzID0gb3BlbkdMU3BlYy5TaGFkZXJSZXBsYWNlbWVudHM7XG4gICAgfVxuXG4gICAgaWYgKHNoYWRlclJlcGxhY2VtZW50cykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFkZXJSZXBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VyclJlcGxhY2VtZW50ID0gc2hhZGVyUmVwbGFjZW1lbnRzW2ldO1xuICAgICAgICBpZiAoY3VyclJlcGxhY2VtZW50LnJlcGxhY2VGaXJzdCkge1xuICAgICAgICAgIGNvbnN0IHNoYWRlclR5cGUgPSBjdXJyUmVwbGFjZW1lbnQuc2hhZGVyVHlwZTtcbiAgICAgICAgICBjb25zdCBzc3JjID0gc2hhZGVyc1tzaGFkZXJUeXBlXTtcbiAgICAgICAgICBjb25zdCBzdWJzdGl0dXRlUmVzID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICAgICAgc3NyYyxcbiAgICAgICAgICAgIGN1cnJSZXBsYWNlbWVudC5vcmlnaW5hbFZhbHVlLFxuICAgICAgICAgICAgY3VyclJlcGxhY2VtZW50LnJlcGxhY2VtZW50VmFsdWUsXG4gICAgICAgICAgICBjdXJyUmVwbGFjZW1lbnQucmVwbGFjZUFsbFxuICAgICAgICAgICk7XG4gICAgICAgICAgc2hhZGVyc1tzaGFkZXJUeXBlXSA9IHN1YnN0aXR1dGVSZXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljQVBJLnJlcGxhY2VTaGFkZXJWYWx1ZXMoc2hhZGVycywgcmVuLCBhY3Rvcik7XG5cbiAgICAvLyB1c2VyIHNwZWNpZmllZCBwb3N0IHJlcGxhY2VtZW50c1xuICAgIGlmIChzaGFkZXJSZXBsYWNlbWVudHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhZGVyUmVwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJSZXBsYWNlbWVudCA9IHNoYWRlclJlcGxhY2VtZW50c1tpXTtcbiAgICAgICAgaWYgKCFjdXJyUmVwbGFjZW1lbnQucmVwbGFjZUZpcnN0KSB7XG4gICAgICAgICAgY29uc3Qgc2hhZGVyVHlwZSA9IGN1cnJSZXBsYWNlbWVudC5zaGFkZXJUeXBlO1xuICAgICAgICAgIGNvbnN0IHNzcmMgPSBzaGFkZXJzW3NoYWRlclR5cGVdO1xuICAgICAgICAgIGNvbnN0IHN1YnN0aXR1dGVSZXMgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgICAgICBzc3JjLFxuICAgICAgICAgICAgY3VyclJlcGxhY2VtZW50Lm9yaWdpbmFsVmFsdWUsXG4gICAgICAgICAgICBjdXJyUmVwbGFjZW1lbnQucmVwbGFjZW1lbnRWYWx1ZSxcbiAgICAgICAgICAgIGN1cnJSZXBsYWNlbWVudC5yZXBsYWNlQWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzaGFkZXJzW3NoYWRlclR5cGVdID0gc3Vic3RpdHV0ZVJlcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmdldFNoYWRlclRlbXBsYXRlID0gKHNoYWRlcnMsIHJlbiwgYWN0b3IpID0+IHtcbiAgICBjb25zdCBvcGVuR0xTcGVjUHJvcCA9IG1vZGVsLnJlbmRlcmFibGUuZ2V0Vmlld1NwZWNpZmljUHJvcGVydGllcygpLk9wZW5HTDtcblxuICAgIGxldCB2ZXJ0ZXhTaGFkZXJDb2RlID0gdnRrUG9seURhdGFWUztcbiAgICBpZiAob3BlbkdMU3BlY1Byb3ApIHtcbiAgICAgIGNvbnN0IHZlcnRleFNwZWNQcm9wID0gb3BlbkdMU3BlY1Byb3AuVmVydGV4U2hhZGVyQ29kZTtcbiAgICAgIGlmICh2ZXJ0ZXhTcGVjUHJvcCAhPT0gdW5kZWZpbmVkICYmIHZlcnRleFNwZWNQcm9wICE9PSAnJykge1xuICAgICAgICB2ZXJ0ZXhTaGFkZXJDb2RlID0gdmVydGV4U3BlY1Byb3A7XG4gICAgICB9XG4gICAgfVxuICAgIHNoYWRlcnMuVmVydGV4ID0gdmVydGV4U2hhZGVyQ29kZTtcblxuICAgIGxldCBmcmFnbWVudFNoYWRlckNvZGUgPSB2dGtQb2x5RGF0YUZTO1xuICAgIGlmIChvcGVuR0xTcGVjUHJvcCkge1xuICAgICAgY29uc3QgZnJhZ21lbnRTcGVjUHJvcCA9IG9wZW5HTFNwZWNQcm9wLkZyYWdtZW50U2hhZGVyQ29kZTtcbiAgICAgIGlmIChmcmFnbWVudFNwZWNQcm9wICE9PSB1bmRlZmluZWQgJiYgZnJhZ21lbnRTcGVjUHJvcCAhPT0gJycpIHtcbiAgICAgICAgZnJhZ21lbnRTaGFkZXJDb2RlID0gZnJhZ21lbnRTcGVjUHJvcDtcbiAgICAgIH1cbiAgICB9XG4gICAgc2hhZGVycy5GcmFnbWVudCA9IGZyYWdtZW50U2hhZGVyQ29kZTtcblxuICAgIGxldCBnZW9tZXRyeVNoYWRlckNvZGUgPSAnJztcbiAgICBpZiAob3BlbkdMU3BlY1Byb3ApIHtcbiAgICAgIGNvbnN0IGdlb21ldHJ5U3BlY1Byb3AgPSBvcGVuR0xTcGVjUHJvcC5HZW9tZXRyeVNoYWRlckNvZGU7XG4gICAgICBpZiAoZ2VvbWV0cnlTcGVjUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdlb21ldHJ5U2hhZGVyQ29kZSA9IGdlb21ldHJ5U3BlY1Byb3A7XG4gICAgICB9XG4gICAgfVxuICAgIHNoYWRlcnMuR2VvbWV0cnkgPSBnZW9tZXRyeVNoYWRlckNvZGU7XG4gIH07XG5cbiAgcHVibGljQVBJLnJlcGxhY2VTaGFkZXJDb2xvciA9IChzaGFkZXJzLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgbGV0IFZTU291cmNlID0gc2hhZGVycy5WZXJ0ZXg7XG4gICAgbGV0IEdTU291cmNlID0gc2hhZGVycy5HZW9tZXRyeTtcbiAgICBsZXQgRlNTb3VyY2UgPSBzaGFkZXJzLkZyYWdtZW50O1xuXG4gICAgY29uc3QgbGFzdExpZ2h0Q29tcGxleGl0eSA9IG1vZGVsLmxhc3RCb3VuZEJPLmdldFJlZmVyZW5jZUJ5TmFtZShcbiAgICAgICdsYXN0TGlnaHRDb21wbGV4aXR5J1xuICAgICk7XG5cbiAgICAvLyBjcmVhdGUgdGhlIG1hdGVyaWFsL2NvbG9yIHByb3BlcnR5IGRlY2xhcmF0aW9ucywgYW5kIFZTIGltcGxlbWVudGF0aW9uXG4gICAgLy8gdGhlc2UgYXJlIGFsd2F5cyBkZWZpbmVkXG4gICAgbGV0IGNvbG9yRGVjID0gW1xuICAgICAgJ3VuaWZvcm0gZmxvYXQgYW1iaWVudDsnLFxuICAgICAgJ3VuaWZvcm0gZmxvYXQgZGlmZnVzZTsnLFxuICAgICAgJ3VuaWZvcm0gZmxvYXQgc3BlY3VsYXI7JyxcbiAgICAgICd1bmlmb3JtIGZsb2F0IG9wYWNpdHlVbmlmb3JtOyAvLyB0aGUgZnJhZ21lbnQgb3BhY2l0eScsXG4gICAgICAndW5pZm9ybSB2ZWMzIGFtYmllbnRDb2xvclVuaWZvcm07JyxcbiAgICAgICd1bmlmb3JtIHZlYzMgZGlmZnVzZUNvbG9yVW5pZm9ybTsnLFxuICAgIF07XG4gICAgLy8gYWRkIG1vcmUgZm9yIHNwZWN1bGFyXG4gICAgaWYgKGxhc3RMaWdodENvbXBsZXhpdHkpIHtcbiAgICAgIGNvbG9yRGVjID0gY29sb3JEZWMuY29uY2F0KFtcbiAgICAgICAgJ3VuaWZvcm0gdmVjMyBzcGVjdWxhckNvbG9yVW5pZm9ybTsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCBzcGVjdWxhclBvd2VyVW5pZm9ybTsnLFxuICAgICAgXSk7XG4gICAgfVxuXG4gICAgLy8gbm93IGhhbmRsZSB0aGUgbW9yZSBjb21wbGV4IGZyYWdtZW50IHNoYWRlciBpbXBsZW1lbnRhdGlvblxuICAgIC8vIHRoZSBmb2xsb3dpbmcgYXJlIGFsd2F5cyBkZWZpbmVkIHZhcmlhYmxlcy4gIFdlIHN0YXJ0XG4gICAgLy8gYnkgYXNzaWduaW5nIGEgZGVmYXVsdCB2YWx1ZSBmcm9tIHRoZSB1bmlmb3JtXG4gICAgbGV0IGNvbG9ySW1wbCA9IFtcbiAgICAgICd2ZWMzIGFtYmllbnRDb2xvcjsnLFxuICAgICAgJyAgdmVjMyBkaWZmdXNlQ29sb3I7JyxcbiAgICAgICcgIGZsb2F0IG9wYWNpdHk7JyxcbiAgICBdO1xuICAgIGlmIChsYXN0TGlnaHRDb21wbGV4aXR5KSB7XG4gICAgICBjb2xvckltcGwgPSBjb2xvckltcGwuY29uY2F0KFtcbiAgICAgICAgJyAgdmVjMyBzcGVjdWxhckNvbG9yOycsXG4gICAgICAgICcgIGZsb2F0IHNwZWN1bGFyUG93ZXI7JyxcbiAgICAgIF0pO1xuICAgIH1cbiAgICBjb2xvckltcGwgPSBjb2xvckltcGwuY29uY2F0KFtcbiAgICAgICcgIGFtYmllbnRDb2xvciA9IGFtYmllbnRDb2xvclVuaWZvcm07JyxcbiAgICAgICcgIGRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvclVuaWZvcm07JyxcbiAgICAgICcgIG9wYWNpdHkgPSBvcGFjaXR5VW5pZm9ybTsnLFxuICAgIF0pO1xuICAgIGlmIChsYXN0TGlnaHRDb21wbGV4aXR5KSB7XG4gICAgICBjb2xvckltcGwgPSBjb2xvckltcGwuY29uY2F0KFtcbiAgICAgICAgJyAgc3BlY3VsYXJDb2xvciA9IHNwZWN1bGFyQ29sb3JVbmlmb3JtOycsXG4gICAgICAgICcgIHNwZWN1bGFyUG93ZXIgPSBzcGVjdWxhclBvd2VyVW5pZm9ybTsnLFxuICAgICAgXSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIHNjYWxhciB2ZXJ0ZXggY29sb3JpbmdcbiAgICBpZiAoXG4gICAgICBtb2RlbC5sYXN0Qm91bmRCTy5nZXRDQUJPKCkuZ2V0Q29sb3JDb21wb25lbnRzKCkgIT09IDAgJiZcbiAgICAgICFtb2RlbC5kcmF3aW5nRWRnZXNcbiAgICApIHtcbiAgICAgIGNvbG9yRGVjID0gY29sb3JEZWMuY29uY2F0KFsndmFyeWluZyB2ZWM0IHZlcnRleENvbG9yVlNPdXRwdXQ7J10pO1xuICAgICAgVlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoVlNTb3VyY2UsICcvL1ZUSzo6Q29sb3I6OkRlYycsIFtcbiAgICAgICAgJ2F0dHJpYnV0ZSB2ZWM0IHNjYWxhckNvbG9yOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzQgdmVydGV4Q29sb3JWU091dHB1dDsnLFxuICAgICAgXSkucmVzdWx0O1xuICAgICAgVlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoVlNTb3VyY2UsICcvL1ZUSzo6Q29sb3I6OkltcGwnLCBbXG4gICAgICAgICd2ZXJ0ZXhDb2xvclZTT3V0cHV0ID0gIHNjYWxhckNvbG9yOycsXG4gICAgICBdKS5yZXN1bHQ7XG4gICAgICBHU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShHU1NvdXJjZSwgJy8vVlRLOjpDb2xvcjo6RGVjJywgW1xuICAgICAgICAnaW4gdmVjNCB2ZXJ0ZXhDb2xvclZTT3V0cHV0W107JyxcbiAgICAgICAgJ291dCB2ZWM0IHZlcnRleENvbG9yR1NPdXRwdXQ7JyxcbiAgICAgIF0pLnJlc3VsdDtcbiAgICAgIEdTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKEdTU291cmNlLCAnLy9WVEs6OkNvbG9yOjpJbXBsJywgW1xuICAgICAgICAndmVydGV4Q29sb3JHU091dHB1dCA9IHZlcnRleENvbG9yVlNPdXRwdXRbaV07JyxcbiAgICAgIF0pLnJlc3VsdDtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBtb2RlbC5sYXN0Qm91bmRCTy5nZXRDQUJPKCkuZ2V0Q29sb3JDb21wb25lbnRzKCkgIT09IDAgJiZcbiAgICAgICFtb2RlbC5kcmF3aW5nRWRnZXNcbiAgICApIHtcbiAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgJy8vVlRLOjpDb2xvcjo6SW1wbCcsXG4gICAgICAgIGNvbG9ySW1wbC5jb25jYXQoW1xuICAgICAgICAgICcgIGRpZmZ1c2VDb2xvciA9IHZlcnRleENvbG9yVlNPdXRwdXQucmdiOycsXG4gICAgICAgICAgJyAgYW1iaWVudENvbG9yID0gdmVydGV4Q29sb3JWU091dHB1dC5yZ2I7JyxcbiAgICAgICAgICAnICBvcGFjaXR5ID0gb3BhY2l0eSp2ZXJ0ZXhDb2xvclZTT3V0cHV0LmE7JyxcbiAgICAgICAgXSlcbiAgICAgICkucmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoXG4gICAgICAgIG1vZGVsLnJlbmRlcmFibGUuZ2V0SW50ZXJwb2xhdGVTY2FsYXJzQmVmb3JlTWFwcGluZygpICYmXG4gICAgICAgIG1vZGVsLnJlbmRlcmFibGUuZ2V0Q29sb3JDb29yZGluYXRlcygpICYmXG4gICAgICAgICFtb2RlbC5kcmF3aW5nRWRnZXNcbiAgICAgICkge1xuICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgICAnLy9WVEs6OkNvbG9yOjpJbXBsJyxcbiAgICAgICAgICBjb2xvckltcGwuY29uY2F0KFtcbiAgICAgICAgICAgICcgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodGV4dHVyZTEsIHRjb29yZFZDVlNPdXRwdXQuc3QpOycsXG4gICAgICAgICAgICAnICBkaWZmdXNlQ29sb3IgPSB0ZXhDb2xvci5yZ2I7JyxcbiAgICAgICAgICAgICcgIGFtYmllbnRDb2xvciA9IHRleENvbG9yLnJnYjsnLFxuICAgICAgICAgICAgJyAgb3BhY2l0eSA9IG9wYWNpdHkqdGV4Q29sb3IuYTsnLFxuICAgICAgICAgIF0pXG4gICAgICAgICkucmVzdWx0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgICAgRlNTb3VyY2UsXG4gICAgICAgICAgJy8vVlRLOjpDb2xvcjo6SW1wbCcsXG4gICAgICAgICAgY29sb3JJbXBsXG4gICAgICAgICkucmVzdWx0O1xuICAgICAgfVxuICAgIH1cblxuICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgRlNTb3VyY2UsXG4gICAgICAnLy9WVEs6OkNvbG9yOjpEZWMnLFxuICAgICAgY29sb3JEZWNcbiAgICApLnJlc3VsdDtcblxuICAgIHNoYWRlcnMuVmVydGV4ID0gVlNTb3VyY2U7XG4gICAgc2hhZGVycy5HZW9tZXRyeSA9IEdTU291cmNlO1xuICAgIHNoYWRlcnMuRnJhZ21lbnQgPSBGU1NvdXJjZTtcbiAgfTtcblxuICBwdWJsaWNBUEkucmVwbGFjZVNoYWRlckxpZ2h0ID0gKHNoYWRlcnMsIHJlbiwgYWN0b3IpID0+IHtcbiAgICBsZXQgRlNTb3VyY2UgPSBzaGFkZXJzLkZyYWdtZW50O1xuXG4gICAgLy8gY2hlY2sgZm9yIHNoYWRvdyBtYXBzXG4gICAgY29uc3Qgc2hhZG93RmFjdG9yID0gJyc7XG5cbiAgICBjb25zdCBsYXN0TGlnaHRDb21wbGV4aXR5ID0gbW9kZWwubGFzdEJvdW5kQk8uZ2V0UmVmZXJlbmNlQnlOYW1lKFxuICAgICAgJ2xhc3RMaWdodENvbXBsZXhpdHknXG4gICAgKTtcblxuICAgIGNvbnN0IGxhc3RMaWdodENvdW50ID0gbW9kZWwubGFzdEJvdW5kQk8uZ2V0UmVmZXJlbmNlQnlOYW1lKFxuICAgICAgJ2xhc3RMaWdodENvdW50J1xuICAgICk7XG5cbiAgICBsZXQgc3N0cmluZyA9IFtdO1xuXG4gICAgc3dpdGNoIChsYXN0TGlnaHRDb21wbGV4aXR5KSB7XG4gICAgICBjYXNlIDA6IC8vIG5vIGxpZ2h0aW5nIG9yIFJFTkRFUl9WQUxVRVNcbiAgICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgICAgRlNTb3VyY2UsXG4gICAgICAgICAgJy8vVlRLOjpMaWdodDo6SW1wbCcsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJyAgZ2xfRnJhZ0RhdGFbMF0gPSB2ZWM0KGFtYmllbnRDb2xvciAqIGFtYmllbnQgKyBkaWZmdXNlQ29sb3IgKiBkaWZmdXNlLCBvcGFjaXR5KTsnLFxuICAgICAgICAgICAgJyAgLy9WVEs6OkxpZ2h0OjpJbXBsJyxcbiAgICAgICAgICBdLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICkucmVzdWx0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxOiAvLyBoZWFkbGlnaHRcbiAgICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgICAgRlNTb3VyY2UsXG4gICAgICAgICAgJy8vVlRLOjpMaWdodDo6SW1wbCcsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJyAgZmxvYXQgZGYgPSBtYXgoMC4wLCBub3JtYWxWQ1ZTT3V0cHV0LnopOycsXG4gICAgICAgICAgICAnICBmbG9hdCBzZiA9IHBvdyhkZiwgc3BlY3VsYXJQb3dlcik7JyxcbiAgICAgICAgICAgICcgIHZlYzMgZGlmZnVzZUwgPSBkZiAqIGRpZmZ1c2VDb2xvcjsnLFxuICAgICAgICAgICAgJyAgdmVjMyBzcGVjdWxhckwgPSBzZiAqIHNwZWN1bGFyQ29sb3I7JyxcbiAgICAgICAgICAgICcgIGdsX0ZyYWdEYXRhWzBdID0gdmVjNChhbWJpZW50Q29sb3IgKiBhbWJpZW50ICsgZGlmZnVzZUwgKiBkaWZmdXNlICsgc3BlY3VsYXJMICogc3BlY3VsYXIsIG9wYWNpdHkpOycsXG4gICAgICAgICAgICAnICAvL1ZUSzo6TGlnaHQ6OkltcGwnLFxuICAgICAgICAgIF0sXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKS5yZXN1bHQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI6IC8vIGxpZ2h0IGtpdFxuICAgICAgICBmb3IgKGxldCBsYyA9IDA7IGxjIDwgbGFzdExpZ2h0Q291bnQ7ICsrbGMpIHtcbiAgICAgICAgICBzc3RyaW5nID0gc3N0cmluZy5jb25jYXQoW1xuICAgICAgICAgICAgYHVuaWZvcm0gdmVjMyBsaWdodENvbG9yJHtsY307YCxcbiAgICAgICAgICAgIGB1bmlmb3JtIHZlYzMgbGlnaHREaXJlY3Rpb25WQyR7bGN9OyAvLyBub3JtYWxpemVkYCxcbiAgICAgICAgICAgIGB1bmlmb3JtIHZlYzMgbGlnaHRIYWxmQW5nbGVWQyR7bGN9OyAvLyBub3JtYWxpemVkYCxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgICAnLy9WVEs6OkxpZ2h0OjpEZWMnLFxuICAgICAgICAgIHNzdHJpbmdcbiAgICAgICAgKS5yZXN1bHQ7XG5cbiAgICAgICAgc3N0cmluZyA9IFtcbiAgICAgICAgICAndmVjMyBkaWZmdXNlTCA9IHZlYzMoMCwwLDApOycsXG4gICAgICAgICAgJyAgdmVjMyBzcGVjdWxhckwgPSB2ZWMzKDAsMCwwKTsnLFxuICAgICAgICAgICcgIGZsb2F0IGRmOycsXG4gICAgICAgIF07XG4gICAgICAgIGZvciAobGV0IGxjID0gMDsgbGMgPCBsYXN0TGlnaHRDb3VudDsgKytsYykge1xuICAgICAgICAgIHNzdHJpbmcgPSBzc3RyaW5nLmNvbmNhdChbXG4gICAgICAgICAgICBgICBkZiA9IG1heCgwLjAsIGRvdChub3JtYWxWQ1ZTT3V0cHV0LCAtbGlnaHREaXJlY3Rpb25WQyR7bGN9KSk7YCxcbiAgICAgICAgICAgIGAgIGRpZmZ1c2VMICs9ICgoZGYke3NoYWRvd0ZhY3Rvcn0pICogbGlnaHRDb2xvciR7bGN9KTtgLFxuICAgICAgICAgICAgYCAgaWYgKGRvdChub3JtYWxWQ1ZTT3V0cHV0LCBsaWdodERpcmVjdGlvblZDJHtsY30pIDwgMC4wKWAsXG4gICAgICAgICAgICAnICAgIHsnLFxuICAgICAgICAgICAgYCAgICBmbG9hdCBzZiA9IHBvdyggbWF4KDAuMCwgZG90KGxpZ2h0SGFsZkFuZ2xlVkMke2xjfSxub3JtYWxWQ1ZTT3V0cHV0KSksIHNwZWN1bGFyUG93ZXIpO2AsXG4gICAgICAgICAgICBgICAgIHNwZWN1bGFyTCArPSAoKHNmJHtzaGFkb3dGYWN0b3J9KSAqIGxpZ2h0Q29sb3Ike2xjfSk7YCxcbiAgICAgICAgICAgICcgICAgfScsXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgc3N0cmluZyA9IHNzdHJpbmcuY29uY2F0KFtcbiAgICAgICAgICAnICBkaWZmdXNlTCA9IGRpZmZ1c2VMICogZGlmZnVzZUNvbG9yOycsXG4gICAgICAgICAgJyAgc3BlY3VsYXJMID0gc3BlY3VsYXJMICogc3BlY3VsYXJDb2xvcjsnLFxuICAgICAgICAgICcgIGdsX0ZyYWdEYXRhWzBdID0gdmVjNChhbWJpZW50Q29sb3IgKiBhbWJpZW50ICsgZGlmZnVzZUwgKiBkaWZmdXNlICsgc3BlY3VsYXJMICogc3BlY3VsYXIsIG9wYWNpdHkpOycsXG4gICAgICAgICAgJyAgLy9WVEs6OkxpZ2h0OjpJbXBsJyxcbiAgICAgICAgXSk7XG4gICAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICAgIEZTU291cmNlLFxuICAgICAgICAgICcvL1ZUSzo6TGlnaHQ6OkltcGwnLFxuICAgICAgICAgIHNzdHJpbmcsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKS5yZXN1bHQ7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6IC8vIHBvc2l0aW9uYWxcbiAgICAgICAgZm9yIChsZXQgbGMgPSAwOyBsYyA8IGxhc3RMaWdodENvdW50OyArK2xjKSB7XG4gICAgICAgICAgc3N0cmluZyA9IHNzdHJpbmcuY29uY2F0KFtcbiAgICAgICAgICAgIGB1bmlmb3JtIHZlYzMgbGlnaHRDb2xvciR7bGN9O2AsXG4gICAgICAgICAgICBgdW5pZm9ybSB2ZWMzIGxpZ2h0RGlyZWN0aW9uVkMke2xjfTsgLy8gbm9ybWFsaXplZGAsXG4gICAgICAgICAgICBgdW5pZm9ybSB2ZWMzIGxpZ2h0SGFsZkFuZ2xlVkMke2xjfTsgLy8gbm9ybWFsaXplZGAsXG4gICAgICAgICAgICBgdW5pZm9ybSB2ZWMzIGxpZ2h0UG9zaXRpb25WQyR7bGN9O2AsXG4gICAgICAgICAgICBgdW5pZm9ybSB2ZWMzIGxpZ2h0QXR0ZW51YXRpb24ke2xjfTtgLFxuICAgICAgICAgICAgYHVuaWZvcm0gZmxvYXQgbGlnaHRDb25lQW5nbGUke2xjfTtgLFxuICAgICAgICAgICAgYHVuaWZvcm0gZmxvYXQgbGlnaHRFeHBvbmVudCR7bGN9O2AsXG4gICAgICAgICAgICBgdW5pZm9ybSBpbnQgbGlnaHRQb3NpdGlvbmFsJHtsY307YCxcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgICAnLy9WVEs6OkxpZ2h0OjpEZWMnLFxuICAgICAgICAgIHNzdHJpbmdcbiAgICAgICAgKS5yZXN1bHQ7XG5cbiAgICAgICAgc3N0cmluZyA9IFtcbiAgICAgICAgICAndmVjMyBkaWZmdXNlTCA9IHZlYzMoMCwwLDApOycsXG4gICAgICAgICAgJyAgdmVjMyBzcGVjdWxhckwgPSB2ZWMzKDAsMCwwKTsnLFxuICAgICAgICAgICcgIHZlYzMgdmVydExpZ2h0RGlyZWN0aW9uVkM7JyxcbiAgICAgICAgICAnICBmbG9hdCBhdHRlbnVhdGlvbjsnLFxuICAgICAgICAgICcgIGZsb2F0IGRmOycsXG4gICAgICAgIF07XG4gICAgICAgIGZvciAobGV0IGxjID0gMDsgbGMgPCBsYXN0TGlnaHRDb3VudDsgKytsYykge1xuICAgICAgICAgIHNzdHJpbmcgPSBzc3RyaW5nLmNvbmNhdChbXG4gICAgICAgICAgICAnICBhdHRlbnVhdGlvbiA9IDEuMDsnLFxuICAgICAgICAgICAgYCAgaWYgKGxpZ2h0UG9zaXRpb25hbCR7bGN9ID09IDApYCxcbiAgICAgICAgICAgICcgICAgeycsXG4gICAgICAgICAgICBgICAgICAgdmVydExpZ2h0RGlyZWN0aW9uVkMgPSBsaWdodERpcmVjdGlvblZDJHtsY307YCxcbiAgICAgICAgICAgICcgICAgfScsXG4gICAgICAgICAgICAnICBlbHNlJyxcbiAgICAgICAgICAgICcgICAgeycsXG4gICAgICAgICAgICBgICAgIHZlcnRMaWdodERpcmVjdGlvblZDID0gdmVydGV4VkMueHl6IC0gbGlnaHRQb3NpdGlvblZDJHtsY307YCxcbiAgICAgICAgICAgICcgICAgZmxvYXQgZGlzdGFuY2VWQyA9IGxlbmd0aCh2ZXJ0TGlnaHREaXJlY3Rpb25WQyk7JyxcbiAgICAgICAgICAgICcgICAgdmVydExpZ2h0RGlyZWN0aW9uVkMgPSBub3JtYWxpemUodmVydExpZ2h0RGlyZWN0aW9uVkMpOycsXG4gICAgICAgICAgICAnICAgIGF0dGVudWF0aW9uID0gMS4wIC8nLFxuICAgICAgICAgICAgYCAgICAgIChsaWdodEF0dGVudWF0aW9uJHtsY30ueGAsXG4gICAgICAgICAgICBgICAgICAgICsgbGlnaHRBdHRlbnVhdGlvbiR7bGN9LnkgKiBkaXN0YW5jZVZDYCxcbiAgICAgICAgICAgIGAgICAgICAgKyBsaWdodEF0dGVudWF0aW9uJHtsY30ueiAqIGRpc3RhbmNlVkMgKiBkaXN0YW5jZVZDKTtgLFxuICAgICAgICAgICAgJyAgICAvLyBwZXIgT3BlbkdMIHN0YW5kYXJkIGNvbmUgYW5nbGUgaXMgOTAgb3IgbGVzcyBmb3IgYSBzcG90IGxpZ2h0JyxcbiAgICAgICAgICAgIGAgICAgaWYgKGxpZ2h0Q29uZUFuZ2xlJHtsY30gPD0gOTAuMClgLFxuICAgICAgICAgICAgJyAgICAgIHsnLFxuICAgICAgICAgICAgYCAgICAgIGZsb2F0IGNvbmVEb3QgPSBkb3QodmVydExpZ2h0RGlyZWN0aW9uVkMsIGxpZ2h0RGlyZWN0aW9uVkMke2xjfSk7YCxcbiAgICAgICAgICAgICcgICAgICAvLyBpZiBpbnNpZGUgdGhlIGNvbmUnLFxuICAgICAgICAgICAgYCAgICAgIGlmIChjb25lRG90ID49IGNvcyhyYWRpYW5zKGxpZ2h0Q29uZUFuZ2xlJHtsY30pKSlgLFxuICAgICAgICAgICAgJyAgICAgICAgeycsXG4gICAgICAgICAgICBgICAgICAgICBhdHRlbnVhdGlvbiA9IGF0dGVudWF0aW9uICogcG93KGNvbmVEb3QsIGxpZ2h0RXhwb25lbnQke2xjfSk7YCxcbiAgICAgICAgICAgICcgICAgICAgIH0nLFxuICAgICAgICAgICAgJyAgICAgIGVsc2UnLFxuICAgICAgICAgICAgJyAgICAgICAgeycsXG4gICAgICAgICAgICAnICAgICAgICBhdHRlbnVhdGlvbiA9IDAuMDsnLFxuICAgICAgICAgICAgJyAgICAgICAgfScsXG4gICAgICAgICAgICAnICAgICAgfScsXG4gICAgICAgICAgICAnICAgIH0nLFxuICAgICAgICAgICAgJyAgICBkZiA9IG1heCgwLjAsIGF0dGVudWF0aW9uKmRvdChub3JtYWxWQ1ZTT3V0cHV0LCAtdmVydExpZ2h0RGlyZWN0aW9uVkMpKTsnLFxuICAgICAgICAgICAgYCAgICBkaWZmdXNlTCArPSAoKGRmJHtzaGFkb3dGYWN0b3J9KSAqIGxpZ2h0Q29sb3Ike2xjfSk7YCxcbiAgICAgICAgICAgICcgICAgaWYgKGRvdChub3JtYWxWQ1ZTT3V0cHV0LCB2ZXJ0TGlnaHREaXJlY3Rpb25WQykgPCAwLjApJyxcbiAgICAgICAgICAgICcgICAgICB7JyxcbiAgICAgICAgICAgIGAgICAgICBmbG9hdCBzZiA9IGF0dGVudWF0aW9uKnBvdyggbWF4KDAuMCwgZG90KGxpZ2h0SGFsZkFuZ2xlVkMke2xjfSxub3JtYWxWQ1ZTT3V0cHV0KSksIHNwZWN1bGFyUG93ZXIpO2AsXG4gICAgICAgICAgICBgICAgIHNwZWN1bGFyTCArPSAoKHNmJHtzaGFkb3dGYWN0b3J9KSAqIGxpZ2h0Q29sb3Ike2xjfSk7YCxcbiAgICAgICAgICAgICcgICAgfScsXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgc3N0cmluZyA9IHNzdHJpbmcuY29uY2F0KFtcbiAgICAgICAgICAnICBkaWZmdXNlTCA9IGRpZmZ1c2VMICogZGlmZnVzZUNvbG9yOycsXG4gICAgICAgICAgJyAgc3BlY3VsYXJMID0gc3BlY3VsYXJMICogc3BlY3VsYXJDb2xvcjsnLFxuICAgICAgICAgICcgIGdsX0ZyYWdEYXRhWzBdID0gdmVjNChhbWJpZW50Q29sb3IgKiBhbWJpZW50ICsgZGlmZnVzZUwgKiBkaWZmdXNlICsgc3BlY3VsYXJMICogc3BlY3VsYXIsIG9wYWNpdHkpOycsXG4gICAgICAgICAgJyAgLy9WVEs6OkxpZ2h0OjpJbXBsJyxcbiAgICAgICAgXSk7XG4gICAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICAgIEZTU291cmNlLFxuICAgICAgICAgICcvL1ZUSzo6TGlnaHQ6OkltcGwnLFxuICAgICAgICAgIHNzdHJpbmcsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKS5yZXN1bHQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdnRrRXJyb3JNYWNybygnYmFkIGxpZ2h0IGNvbXBsZXhpdHknKTtcbiAgICB9XG5cbiAgICBzaGFkZXJzLkZyYWdtZW50ID0gRlNTb3VyY2U7XG4gIH07XG5cbiAgcHVibGljQVBJLnJlcGxhY2VTaGFkZXJOb3JtYWwgPSAoc2hhZGVycywgcmVuLCBhY3RvcikgPT4ge1xuICAgIGNvbnN0IGxhc3RMaWdodENvbXBsZXhpdHkgPSBtb2RlbC5sYXN0Qm91bmRCTy5nZXRSZWZlcmVuY2VCeU5hbWUoXG4gICAgICAnbGFzdExpZ2h0Q29tcGxleGl0eSdcbiAgICApO1xuXG4gICAgaWYgKGxhc3RMaWdodENvbXBsZXhpdHkgPiAwKSB7XG4gICAgICBsZXQgVlNTb3VyY2UgPSBzaGFkZXJzLlZlcnRleDtcbiAgICAgIGxldCBHU1NvdXJjZSA9IHNoYWRlcnMuR2VvbWV0cnk7XG4gICAgICBsZXQgRlNTb3VyY2UgPSBzaGFkZXJzLkZyYWdtZW50O1xuXG4gICAgICBpZiAobW9kZWwubGFzdEJvdW5kQk8uZ2V0Q0FCTygpLmdldE5vcm1hbE9mZnNldCgpKSB7XG4gICAgICAgIFZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFZTU291cmNlLCAnLy9WVEs6Ok5vcm1hbDo6RGVjJywgW1xuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMyBub3JtYWxNQzsnLFxuICAgICAgICAgICd1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4OycsXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjMyBub3JtYWxWQ1ZTT3V0cHV0OycsXG4gICAgICAgIF0pLnJlc3VsdDtcbiAgICAgICAgVlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgICAgVlNTb3VyY2UsXG4gICAgICAgICAgJy8vVlRLOjpOb3JtYWw6OkltcGwnLFxuICAgICAgICAgIFsnbm9ybWFsVkNWU091dHB1dCA9IG5vcm1hbE1hdHJpeCAqIG5vcm1hbE1DOyddXG4gICAgICAgICkucmVzdWx0O1xuICAgICAgICBHU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShHU1NvdXJjZSwgJy8vVlRLOjpOb3JtYWw6OkRlYycsIFtcbiAgICAgICAgICAnaW4gdmVjMyBub3JtYWxWQ1ZTT3V0cHV0W107JyxcbiAgICAgICAgICAnb3V0IHZlYzMgbm9ybWFsVkNHU091dHB1dDsnLFxuICAgICAgICBdKS5yZXN1bHQ7XG4gICAgICAgIEdTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICAgIEdTU291cmNlLFxuICAgICAgICAgICcvL1ZUSzo6Tm9ybWFsOjpJbXBsJyxcbiAgICAgICAgICBbJ25vcm1hbFZDR1NPdXRwdXQgPSBub3JtYWxWQ1ZTT3V0cHV0W2ldOyddXG4gICAgICAgICkucmVzdWx0O1xuICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShGU1NvdXJjZSwgJy8vVlRLOjpOb3JtYWw6OkRlYycsIFtcbiAgICAgICAgICAndmFyeWluZyB2ZWMzIG5vcm1hbFZDVlNPdXRwdXQ7JyxcbiAgICAgICAgXSkucmVzdWx0O1xuICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgICAnLy9WVEs6Ok5vcm1hbDo6SW1wbCcsXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3ZlYzMgbm9ybWFsVkNWU091dHB1dCA9IG5vcm1hbGl6ZShub3JtYWxWQ1ZTT3V0cHV0KTsnLFxuICAgICAgICAgICAgLy8gIGlmICghZ2xfRnJvbnRGYWNpbmcpIGRvZXMgbm90IHdvcmsgaW4gaW50ZWwgaGQ0MDAwIG1hY1xuICAgICAgICAgICAgLy8gIGlmIChpbnQoZ2xfRnJvbnRGYWNpbmcpID09IDApIGRvZXMgbm90IHdvcmsgb24gbWVzYVxuICAgICAgICAgICAgJyAgaWYgKGdsX0Zyb250RmFjaW5nID09IGZhbHNlKSB7IG5vcm1hbFZDVlNPdXRwdXQgPSAtbm9ybWFsVkNWU091dHB1dDsgfScsXG4gICAgICAgICAgXVxuICAgICAgICApLnJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChtb2RlbC5oYXZlQ2VsbE5vcm1hbHMpIHtcbiAgICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgIEZTU291cmNlLFxuICAgICAgICAgICAgJy8vVlRLOjpOb3JtYWw6OkRlYycsXG4gICAgICAgICAgICBbJ3VuaWZvcm0gbWF0MyBub3JtYWxNYXRyaXg7JywgJ3VuaWZvcm0gc2FtcGxlckJ1ZmZlciB0ZXh0dXJlTjsnXVxuICAgICAgICAgICkucmVzdWx0O1xuICAgICAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICAgICAgRlNTb3VyY2UsXG4gICAgICAgICAgICAnLy9WVEs6Ok5vcm1hbDo6SW1wbCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICd2ZWMzIG5vcm1hbFZDVlNPdXRwdXQgPSBub3JtYWxpemUobm9ybWFsTWF0cml4IConLFxuICAgICAgICAgICAgICAnICAgIHRleGVsRmV0Y2hCdWZmZXIodGV4dHVyZU4sIGdsX1ByaW1pdGl2ZUlEICsgUHJpbWl0aXZlSURPZmZzZXQpLnh5eik7JyxcbiAgICAgICAgICAgICAgJyAgaWYgKGdsX0Zyb250RmFjaW5nID09IGZhbHNlKSB7IG5vcm1hbFZDVlNPdXRwdXQgPSAtbm9ybWFsVkNWU091dHB1dDsgfScsXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKS5yZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcHVibGljQVBJLmdldE9wZW5HTE1vZGUoXG4gICAgICAgICAgICAgIGFjdG9yLmdldFByb3BlcnR5KCkuZ2V0UmVwcmVzZW50YXRpb24oKSxcbiAgICAgICAgICAgICAgbW9kZWwubGFzdEJvdW5kQk8uZ2V0UHJpbWl0aXZlVHlwZSgpXG4gICAgICAgICAgICApID09PSBtb2RlbC5jb250ZXh0LkxJTkVTXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBnZW5lcmF0ZSBhIG5vcm1hbCBmb3IgbGluZXMsIGl0IHdpbGwgYmUgcGVycGVuZGljdWxhciB0byB0aGUgbGluZVxuICAgICAgICAgICAgLy8gYW5kIG1heGltYWxseSBhbGlnbmVkIHdpdGggdGhlIGNhbWVyYSB2aWV3IGRpcmVjdGlvblxuICAgICAgICAgICAgLy8gbm8gY2x1ZSBpZiB0aGlzIGlzIHRoZSBiZXN0IHdheSB0byBkbyB0aGlzLlxuICAgICAgICAgICAgLy8gdGhlIGNvZGUgYmVsb3cgaGFzIGJlZW4gb3B0aW1pemVkIGEgYml0IHNvIHdoYXQgZm9sbG93cyBpc1xuICAgICAgICAgICAgLy8gYW4gZXhwbGFuYXRpb24gb2YgdGhlIGJhc2ljIGFwcHJvYWNoLiBDb21wdXRlIHRoZSBncmFkaWVudCBvZiB0aGUgbGluZVxuICAgICAgICAgICAgLy8gd2l0aCByZXNwZWN0IHRvIHggYW5kIHksIHRoZSB0aGUgbGFyZ2VyIG9mIHRoZSB0d29cbiAgICAgICAgICAgIC8vIGNyb3NzIHRoYXQgd2l0aCB0aGUgY2FtZXJhIHZpZXcgZGlyZWN0aW9uLiBUaGF0IGdpdmVzIGEgdmVjdG9yXG4gICAgICAgICAgICAvLyBvcnRob2dvbmFsIHRvIHRoZSBjYW1lcmEgdmlldyBhbmQgdGhlIGxpbmUuIE5vdGUgdGhhdCB0aGUgbGluZSBhbmQgdGhlIGNhbWVyYVxuICAgICAgICAgICAgLy8gdmlldyBhcmUgcHJvYmFibHkgbm90IG9ydGhvZ29uYWwuIFdoaWNoIGlzIHdoeSB3aGVuIHdlIGNyb3NzIHJlc3VsdCB0aGF0IHdpdGhcbiAgICAgICAgICAgIC8vIHRoZSBsaW5lIGdyYWRpZW50IGFnYWluIHdlIGdldCBhIHJlYXNvbmFibGUgbm9ybWFsLiBJdCB3aWxsIGJlIG90aG9nb25hbCB0b1xuICAgICAgICAgICAgLy8gdGhlIGxpbmUgKHdoaWNoIGlzIGEgcGxhbmUgYnV0IG1heGltYWxseSBhbGlnbmVkIHdpdGggdGhlIGNhbWVyYSB2aWV3LlxuICAgICAgICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgICAgICAgIEZTU291cmNlLFxuICAgICAgICAgICAgICAnLy9WVEs6OlVuaWZvcm1GbG93OjpJbXBsJyxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICcgIHZlYzMgZmR4ID0gdmVjMyhkRmR4KHZlcnRleFZDLngpLGRGZHgodmVydGV4VkMueSksZEZkeCh2ZXJ0ZXhWQy56KSk7JyxcbiAgICAgICAgICAgICAgICAnICB2ZWMzIGZkeSA9IHZlYzMoZEZkeSh2ZXJ0ZXhWQy54KSxkRmR5KHZlcnRleFZDLnkpLGRGZHkodmVydGV4VkMueikpOycsXG4gICAgICAgICAgICAgICAgJyAgLy9WVEs6OlVuaWZvcm1GbG93OjpJbXBsJyxcbiAgICAgICAgICAgICAgXSAvLyBGb3IgZnVydGhlciByZXBsYWNlbWVudHNcbiAgICAgICAgICAgICkucmVzdWx0O1xuICAgICAgICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgICAgICAgIEZTU291cmNlLFxuICAgICAgICAgICAgICAnLy9WVEs6Ok5vcm1hbDo6SW1wbCcsXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAndmVjMyBub3JtYWxWQ1ZTT3V0cHV0OycsXG4gICAgICAgICAgICAgICAgJyAgZmR4ID0gbm9ybWFsaXplKGZkeCk7JyxcbiAgICAgICAgICAgICAgICAnICBmZHkgPSBub3JtYWxpemUoZmR5KTsnLFxuICAgICAgICAgICAgICAgICcgIGlmIChhYnMoZmR4LngpID4gMC4wKScsXG4gICAgICAgICAgICAgICAgJyAgICB7IG5vcm1hbFZDVlNPdXRwdXQgPSBub3JtYWxpemUoY3Jvc3ModmVjMyhmZHgueSwgLWZkeC54LCAwLjApLCBmZHgpKTsgfScsXG4gICAgICAgICAgICAgICAgJyAgZWxzZSB7IG5vcm1hbFZDVlNPdXRwdXQgPSBub3JtYWxpemUoY3Jvc3ModmVjMyhmZHkueSwgLWZkeS54LCAwLjApLCBmZHkpKTt9JyxcbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgKS5yZXN1bHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgICAgICAgJy8vVlRLOjpOb3JtYWw6OkRlYycsXG4gICAgICAgICAgICAgIFsndW5pZm9ybSBpbnQgY2FtZXJhUGFyYWxsZWw7J11cbiAgICAgICAgICAgICkucmVzdWx0O1xuXG4gICAgICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgICAgRlNTb3VyY2UsXG4gICAgICAgICAgICAgICcvL1ZUSzo6VW5pZm9ybUZsb3c6OkltcGwnLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLy8gJyAgdmVjMyBmZHggPSB2ZWMzKGRGZHgodmVydGV4VkMueCksZEZkeCh2ZXJ0ZXhWQy55KSxkRmR4KHZlcnRleFZDLnopKTsnLFxuICAgICAgICAgICAgICAgIC8vICcgIHZlYzMgZmR5ID0gdmVjMyhkRmR5KHZlcnRleFZDLngpLGRGZHkodmVydGV4VkMueSksZEZkeSh2ZXJ0ZXhWQy56KSk7JyxcbiAgICAgICAgICAgICAgICAnICB2ZWMzIGZkeCA9IGRGZHgodmVydGV4VkMueHl6KTsnLFxuICAgICAgICAgICAgICAgICcgIHZlYzMgZmR5ID0gZEZkeSh2ZXJ0ZXhWQy54eXopOycsXG4gICAgICAgICAgICAgICAgJyAgLy9WVEs6OlVuaWZvcm1GbG93OjpJbXBsJyxcbiAgICAgICAgICAgICAgXSAvLyBGb3IgZnVydGhlciByZXBsYWNlbWVudHNcbiAgICAgICAgICAgICkucmVzdWx0O1xuICAgICAgICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgICAgICAgIEZTU291cmNlLFxuICAgICAgICAgICAgICAnLy9WVEs6Ok5vcm1hbDo6SW1wbCcsXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAnICBmZHggPSBub3JtYWxpemUoZmR4KTsnLFxuICAgICAgICAgICAgICAgICcgIGZkeSA9IG5vcm1hbGl6ZShmZHkpOycsXG4gICAgICAgICAgICAgICAgJyAgdmVjMyBub3JtYWxWQ1ZTT3V0cHV0ID0gbm9ybWFsaXplKGNyb3NzKGZkeCxmZHkpKTsnLFxuICAgICAgICAgICAgICAgIC8vIHRoZSBjb2RlIGJlbG93IGlzIGZhc3RlciwgYnV0IGRvZXMgbm90IHdvcmsgb24gc29tZSBkZXZpY2VzXG4gICAgICAgICAgICAgICAgLy8gJ3ZlYzMgbm9ybWFsVkMgPSBub3JtYWxpemUoY3Jvc3MoZEZkeCh2ZXJ0ZXhWQy54eXopLCBkRmR5KHZlcnRleFZDLnh5eikpKTsnLFxuICAgICAgICAgICAgICAgICcgIGlmIChjYW1lcmFQYXJhbGxlbCA9PSAxICYmIG5vcm1hbFZDVlNPdXRwdXQueiA8IDAuMCkgeyBub3JtYWxWQ1ZTT3V0cHV0ID0gLTEuMCpub3JtYWxWQ1ZTT3V0cHV0OyB9JyxcbiAgICAgICAgICAgICAgICAnICBpZiAoY2FtZXJhUGFyYWxsZWwgPT0gMCAmJiBkb3Qobm9ybWFsVkNWU091dHB1dCx2ZXJ0ZXhWQy54eXopID4gMC4wKSB7IG5vcm1hbFZDVlNPdXRwdXQgPSAtMS4wKm5vcm1hbFZDVlNPdXRwdXQ7IH0nLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNoYWRlcnMuVmVydGV4ID0gVlNTb3VyY2U7XG4gICAgICBzaGFkZXJzLkdlb21ldHJ5ID0gR1NTb3VyY2U7XG4gICAgICBzaGFkZXJzLkZyYWdtZW50ID0gRlNTb3VyY2U7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5yZXBsYWNlU2hhZGVyUG9zaXRpb25WQyA9IChzaGFkZXJzLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgbGV0IFZTU291cmNlID0gc2hhZGVycy5WZXJ0ZXg7XG4gICAgbGV0IEdTU291cmNlID0gc2hhZGVycy5HZW9tZXRyeTtcbiAgICBsZXQgRlNTb3VyY2UgPSBzaGFkZXJzLkZyYWdtZW50O1xuXG4gICAgLy8gZm9yIHBvaW50cyBtYWtlIHN1cmUgdG8gYWRkIGluIHRoZSBwb2ludCBzaXplXG4gICAgaWYgKFxuICAgICAgYWN0b3IuZ2V0UHJvcGVydHkoKS5nZXRSZXByZXNlbnRhdGlvbigpID09PSBSZXByZXNlbnRhdGlvbi5QT0lOVFMgfHxcbiAgICAgIG1vZGVsLmxhc3RCb3VuZEJPLmdldFByaW1pdGl2ZVR5cGUoKSA9PT0gcHJpbVR5cGVzLlBvaW50c1xuICAgICkge1xuICAgICAgVlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgIFZTU291cmNlLFxuICAgICAgICAnLy9WVEs6OlBvc2l0aW9uVkM6OkltcGwnLFxuICAgICAgICBbXG4gICAgICAgICAgJy8vVlRLOjpQb3NpdGlvblZDOjpJbXBsJyxcbiAgICAgICAgICBgICBnbF9Qb2ludFNpemUgPSAke2FjdG9yLmdldFByb3BlcnR5KCkuZ2V0UG9pbnRTaXplKCl9LjA7YCxcbiAgICAgICAgXSxcbiAgICAgICAgZmFsc2VcbiAgICAgICkucmVzdWx0O1xuICAgIH1cblxuICAgIC8vIGRvIHdlIG5lZWQgdGhlIHZlcnRleCBpbiB0aGUgc2hhZGVyIGluIFZpZXcgQ29vcmRpbmF0ZXNcbiAgICBjb25zdCBsYXN0TGlnaHRDb21wbGV4aXR5ID0gbW9kZWwubGFzdEJvdW5kQk8uZ2V0UmVmZXJlbmNlQnlOYW1lKFxuICAgICAgJ2xhc3RMaWdodENvbXBsZXhpdHknXG4gICAgKTtcbiAgICBpZiAobGFzdExpZ2h0Q29tcGxleGl0eSA+IDApIHtcbiAgICAgIFZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICBWU1NvdXJjZSxcbiAgICAgICAgJy8vVlRLOjpQb3NpdGlvblZDOjpEZWMnLFxuICAgICAgICBbJ3ZhcnlpbmcgdmVjNCB2ZXJ0ZXhWQ1ZTT3V0cHV0OyddXG4gICAgICApLnJlc3VsdDtcbiAgICAgIFZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICBWU1NvdXJjZSxcbiAgICAgICAgJy8vVlRLOjpQb3NpdGlvblZDOjpJbXBsJyxcbiAgICAgICAgW1xuICAgICAgICAgICd2ZXJ0ZXhWQ1ZTT3V0cHV0ID0gTUNWQ01hdHJpeCAqIHZlcnRleE1DOycsXG4gICAgICAgICAgJyAgZ2xfUG9zaXRpb24gPSBNQ1BDTWF0cml4ICogdmVydGV4TUM7JyxcbiAgICAgICAgXVxuICAgICAgKS5yZXN1bHQ7XG4gICAgICBWU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShWU1NvdXJjZSwgJy8vVlRLOjpDYW1lcmE6OkRlYycsIFtcbiAgICAgICAgJ3VuaWZvcm0gbWF0NCBNQ1BDTWF0cml4OycsXG4gICAgICAgICd1bmlmb3JtIG1hdDQgTUNWQ01hdHJpeDsnLFxuICAgICAgXSkucmVzdWx0O1xuICAgICAgR1NTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgIEdTU291cmNlLFxuICAgICAgICAnLy9WVEs6OlBvc2l0aW9uVkM6OkRlYycsXG4gICAgICAgIFsnaW4gdmVjNCB2ZXJ0ZXhWQ1ZTT3V0cHV0W107JywgJ291dCB2ZWM0IHZlcnRleFZDR1NPdXRwdXQ7J11cbiAgICAgICkucmVzdWx0O1xuICAgICAgR1NTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgIEdTU291cmNlLFxuICAgICAgICAnLy9WVEs6OlBvc2l0aW9uVkM6OkltcGwnLFxuICAgICAgICBbJ3ZlcnRleFZDR1NPdXRwdXQgPSB2ZXJ0ZXhWQ1ZTT3V0cHV0W2ldOyddXG4gICAgICApLnJlc3VsdDtcbiAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgJy8vVlRLOjpQb3NpdGlvblZDOjpEZWMnLFxuICAgICAgICBbJ3ZhcnlpbmcgdmVjNCB2ZXJ0ZXhWQ1ZTT3V0cHV0OyddXG4gICAgICApLnJlc3VsdDtcbiAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgJy8vVlRLOjpQb3NpdGlvblZDOjpJbXBsJyxcbiAgICAgICAgWyd2ZWM0IHZlcnRleFZDID0gdmVydGV4VkNWU091dHB1dDsnXVxuICAgICAgKS5yZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIFZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFZTU291cmNlLCAnLy9WVEs6OkNhbWVyYTo6RGVjJywgW1xuICAgICAgICAndW5pZm9ybSBtYXQ0IE1DUENNYXRyaXg7JyxcbiAgICAgIF0pLnJlc3VsdDtcbiAgICAgIFZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICBWU1NvdXJjZSxcbiAgICAgICAgJy8vVlRLOjpQb3NpdGlvblZDOjpJbXBsJyxcbiAgICAgICAgWycgIGdsX1Bvc2l0aW9uID0gTUNQQ01hdHJpeCAqIHZlcnRleE1DOyddXG4gICAgICApLnJlc3VsdDtcbiAgICB9XG4gICAgc2hhZGVycy5WZXJ0ZXggPSBWU1NvdXJjZTtcbiAgICBzaGFkZXJzLkdlb21ldHJ5ID0gR1NTb3VyY2U7XG4gICAgc2hhZGVycy5GcmFnbWVudCA9IEZTU291cmNlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZXBsYWNlU2hhZGVyVENvb3JkID0gKHNoYWRlcnMsIHJlbiwgYWN0b3IpID0+IHtcbiAgICBpZiAobW9kZWwubGFzdEJvdW5kQk8uZ2V0Q0FCTygpLmdldFRDb29yZE9mZnNldCgpKSB7XG4gICAgICBsZXQgVlNTb3VyY2UgPSBzaGFkZXJzLlZlcnRleDtcbiAgICAgIGxldCBHU1NvdXJjZSA9IHNoYWRlcnMuR2VvbWV0cnk7XG4gICAgICBsZXQgRlNTb3VyY2UgPSBzaGFkZXJzLkZyYWdtZW50O1xuXG4gICAgICBpZiAobW9kZWwuZHJhd2luZ0VkZ2VzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgVlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgIFZTU291cmNlLFxuICAgICAgICAnLy9WVEs6OlRDb29yZDo6SW1wbCcsXG4gICAgICAgICd0Y29vcmRWQ1ZTT3V0cHV0ID0gdGNvb3JkTUM7J1xuICAgICAgKS5yZXN1bHQ7XG5cbiAgICAgIC8vIHdlIG9ubHkgaGFuZGxlIHRoZSBmaXJzdCB0ZXh0dXJlIGJ5IGRlZmF1bHRcbiAgICAgIC8vIGFkZGl0aW9uYWwgdGV4dHVyZXMgYXJlIGFjdGl2YXRlZCBhbmQgd2Ugc2V0IHRoZSB1bmlmb3JtXG4gICAgICAvLyBmb3IgdGhlIHRleHR1cmUgdW5pdCB0aGV5IGFyZSBhc3NpZ25lZCB0bywgYnV0IHlvdSBoYXZlIHRvXG4gICAgICAvLyBhZGQgaW4gdGhlIHNoYWRlciBjb2RlIHRvIGRvIHNvbWV0aGluZyB3aXRoIHRoZW1cbiAgICAgIGNvbnN0IHR1cyA9IG1vZGVsLm9wZW5HTEFjdG9yLmdldEFjdGl2ZVRleHR1cmVzKCk7XG4gICAgICBsZXQgdE51bUNvbXAgPSAyO1xuICAgICAgbGV0IHRjZGltID0gMjtcbiAgICAgIGlmICh0dXMgJiYgdHVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdE51bUNvbXAgPSB0dXNbMF0uZ2V0Q29tcG9uZW50cygpO1xuICAgICAgICBpZiAodHVzWzBdLmdldFRhcmdldCgpID09PSBtb2RlbC5jb250ZXh0LlRFWFRVUkVfQ1VCRV9NQVApIHtcbiAgICAgICAgICB0Y2RpbSA9IDM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbC5yZW5kZXJhYmxlLmdldENvbG9yVGV4dHVyZU1hcCgpKSB7XG4gICAgICAgIHROdW1Db21wID0gbW9kZWwucmVuZGVyYWJsZVxuICAgICAgICAgIC5nZXRDb2xvclRleHR1cmVNYXAoKVxuICAgICAgICAgIC5nZXRQb2ludERhdGEoKVxuICAgICAgICAgIC5nZXRTY2FsYXJzKClcbiAgICAgICAgICAuZ2V0TnVtYmVyT2ZDb21wb25lbnRzKCk7XG4gICAgICAgIHRjZGltID0gMjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRjZGltID09PSAyKSB7XG4gICAgICAgIFZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICAgIFZTU291cmNlLFxuICAgICAgICAgICcvL1ZUSzo6VENvb3JkOjpEZWMnLFxuICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiB0Y29vcmRNQzsgdmFyeWluZyB2ZWMyIHRjb29yZFZDVlNPdXRwdXQ7J1xuICAgICAgICApLnJlc3VsdDtcbiAgICAgICAgR1NTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoR1NTb3VyY2UsICcvL1ZUSzo6VENvb3JkOjpEZWMnLCBbXG4gICAgICAgICAgJ2luIHZlYzIgdGNvb3JkVkNWU091dHB1dFtdOycsXG4gICAgICAgICAgJ291dCB2ZWMyIHRjb29yZFZDR1NPdXRwdXQ7JyxcbiAgICAgICAgXSkucmVzdWx0O1xuICAgICAgICBHU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICBHU1NvdXJjZSxcbiAgICAgICAgICAnLy9WVEs6OlRDb29yZDo6SW1wbCcsXG4gICAgICAgICAgJ3Rjb29yZFZDR1NPdXRwdXQgPSB0Y29vcmRWQ1ZTT3V0cHV0W2ldOydcbiAgICAgICAgKS5yZXN1bHQ7XG4gICAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKEZTU291cmNlLCAnLy9WVEs6OlRDb29yZDo6RGVjJywgW1xuICAgICAgICAgICd2YXJ5aW5nIHZlYzIgdGNvb3JkVkNWU091dHB1dDsnLFxuICAgICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlMTsnLFxuICAgICAgICBdKS5yZXN1bHQ7XG4gICAgICAgIGlmICh0dXMgJiYgdHVzLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgc3dpdGNoICh0TnVtQ29tcCkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgICAgICAgICAnLy9WVEs6OlRDb29yZDo6SW1wbCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3ZlYzQgdGNvbG9yID0gdGV4dHVyZTJEKHRleHR1cmUxLCB0Y29vcmRWQ1ZTT3V0cHV0KTsnLFxuICAgICAgICAgICAgICAgICAgJ2dsX0ZyYWdEYXRhWzBdID0gY2xhbXAoZ2xfRnJhZ0RhdGFbMF0sMC4wLDEuMCkqJyxcbiAgICAgICAgICAgICAgICAgICcgIHZlYzQodGNvbG9yLnIsdGNvbG9yLnIsdGNvbG9yLnIsMS4wKTsnLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgKS5yZXN1bHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgICAgICAgICAnLy9WVEs6OlRDb29yZDo6SW1wbCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgJ3ZlYzQgdGNvbG9yID0gdGV4dHVyZTJEKHRleHR1cmUxLCB0Y29vcmRWQ1ZTT3V0cHV0KTsnLFxuICAgICAgICAgICAgICAgICAgJ2dsX0ZyYWdEYXRhWzBdID0gY2xhbXAoZ2xfRnJhZ0RhdGFbMF0sMC4wLDEuMCkqJyxcbiAgICAgICAgICAgICAgICAgICcgIHZlYzQodGNvbG9yLnIsdGNvbG9yLnIsdGNvbG9yLnIsdGNvbG9yLmcpOycsXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICApLnJlc3VsdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgICAgICAgICAnLy9WVEs6OlRDb29yZDo6SW1wbCcsXG4gICAgICAgICAgICAgICAgJ2dsX0ZyYWdEYXRhWzBdID0gY2xhbXAoZ2xfRnJhZ0RhdGFbMF0sMC4wLDEuMCkqdGV4dHVyZTJEKHRleHR1cmUxLCB0Y29vcmRWQ1ZTT3V0cHV0LnN0KTsnXG4gICAgICAgICAgICAgICkucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgICAgVlNTb3VyY2UsXG4gICAgICAgICAgJy8vVlRLOjpUQ29vcmQ6OkRlYycsXG4gICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMzIHRjb29yZE1DOyB2YXJ5aW5nIHZlYzMgdGNvb3JkVkNWU091dHB1dDsnXG4gICAgICAgICkucmVzdWx0O1xuICAgICAgICBHU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShHU1NvdXJjZSwgJy8vVlRLOjpUQ29vcmQ6OkRlYycsIFtcbiAgICAgICAgICAnaW4gdmVjMyB0Y29vcmRWQ1ZTT3V0cHV0W107JyxcbiAgICAgICAgICAnb3V0IHZlYzMgdGNvb3JkVkNHU091dHB1dDsnLFxuICAgICAgICBdKS5yZXN1bHQ7XG4gICAgICAgIEdTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICAgIEdTU291cmNlLFxuICAgICAgICAgICcvL1ZUSzo6VENvb3JkOjpJbXBsJyxcbiAgICAgICAgICAndGNvb3JkVkNHU091dHB1dCA9IHRjb29yZFZDVlNPdXRwdXRbaV07J1xuICAgICAgICApLnJlc3VsdDtcbiAgICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoRlNTb3VyY2UsICcvL1ZUSzo6VENvb3JkOjpEZWMnLCBbXG4gICAgICAgICAgJ3ZhcnlpbmcgdmVjMyB0Y29vcmRWQ1ZTT3V0cHV0OycsXG4gICAgICAgICAgJ3VuaWZvcm0gc2FtcGxlckN1YmUgdGV4dHVyZTE7JyxcbiAgICAgICAgXSkucmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKHROdW1Db21wKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgICAgICAgIEZTU291cmNlLFxuICAgICAgICAgICAgICAnLy9WVEs6OlRDb29yZDo6SW1wbCcsXG4gICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAndmVjNCB0Y29sb3IgPSB0ZXh0dXJlQ3ViZSh0ZXh0dXJlMSwgdGNvb3JkVkNWU091dHB1dCk7JyxcbiAgICAgICAgICAgICAgICAnZ2xfRnJhZ0RhdGFbMF0gPSBjbGFtcChnbF9GcmFnRGF0YVswXSwwLjAsMS4wKSonLFxuICAgICAgICAgICAgICAgICcgIHZlYzQodGNvbG9yLnIsdGNvbG9yLnIsdGNvbG9yLnIsMS4wKTsnLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApLnJlc3VsdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgICAgICAgJy8vVlRLOjpUQ29vcmQ6OkltcGwnLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ3ZlYzQgdGNvbG9yID0gdGV4dHVyZUN1YmUodGV4dHVyZTEsIHRjb29yZFZDVlNPdXRwdXQpOycsXG4gICAgICAgICAgICAgICAgJ2dsX0ZyYWdEYXRhWzBdID0gY2xhbXAoZ2xfRnJhZ0RhdGFbMF0sMC4wLDEuMCkqJyxcbiAgICAgICAgICAgICAgICAnICB2ZWM0KHRjb2xvci5yLHRjb2xvci5yLHRjb2xvci5yLHRjb2xvci5nKTsnLFxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApLnJlc3VsdDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgICAgRlNTb3VyY2UsXG4gICAgICAgICAgICAgICcvL1ZUSzo6VENvb3JkOjpJbXBsJyxcbiAgICAgICAgICAgICAgJ2dsX0ZyYWdEYXRhWzBdID0gY2xhbXAoZ2xfRnJhZ0RhdGFbMF0sMC4wLDEuMCkqdGV4dHVyZUN1YmUodGV4dHVyZTEsIHRjb29yZFZDVlNPdXRwdXQpOydcbiAgICAgICAgICAgICkucmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzaGFkZXJzLlZlcnRleCA9IFZTU291cmNlO1xuICAgICAgc2hhZGVycy5HZW9tZXRyeSA9IEdTU291cmNlO1xuICAgICAgc2hhZGVycy5GcmFnbWVudCA9IEZTU291cmNlO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkucmVwbGFjZVNoYWRlckNsaXAgPSAoc2hhZGVycywgcmVuLCBhY3RvcikgPT4ge1xuICAgIGxldCBWU1NvdXJjZSA9IHNoYWRlcnMuVmVydGV4O1xuICAgIGxldCBGU1NvdXJjZSA9IHNoYWRlcnMuRnJhZ21lbnQ7XG5cbiAgICBpZiAobW9kZWwucmVuZGVyYWJsZS5nZXROdW1iZXJPZkNsaXBwaW5nUGxhbmVzKCkpIHtcbiAgICAgIGxldCBudW1DbGlwUGxhbmVzID0gbW9kZWwucmVuZGVyYWJsZS5nZXROdW1iZXJPZkNsaXBwaW5nUGxhbmVzKCk7XG4gICAgICBpZiAobnVtQ2xpcFBsYW5lcyA+IDYpIHtcbiAgICAgICAgbWFjcm8udnRrRXJyb3JNYWNybygnT3BlbkdMIGhhcyBhIGxpbWl0IG9mIDYgY2xpcHBpbmcgcGxhbmVzJyk7XG4gICAgICAgIG51bUNsaXBQbGFuZXMgPSA2O1xuICAgICAgfVxuICAgICAgVlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoVlNTb3VyY2UsICcvL1ZUSzo6Q2xpcDo6RGVjJywgW1xuICAgICAgICAndW5pZm9ybSBpbnQgbnVtQ2xpcFBsYW5lczsnLFxuICAgICAgICAndW5pZm9ybSB2ZWM0IGNsaXBQbGFuZXNbNl07JyxcbiAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgY2xpcERpc3RhbmNlc1ZTT3V0cHV0WzZdOycsXG4gICAgICBdKS5yZXN1bHQ7XG5cbiAgICAgIFZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFZTU291cmNlLCAnLy9WVEs6OkNsaXA6OkltcGwnLCBbXG4gICAgICAgICdmb3IgKGludCBwbGFuZU51bSA9IDA7IHBsYW5lTnVtIDwgNjsgcGxhbmVOdW0rKyknLFxuICAgICAgICAnICAgIHsnLFxuICAgICAgICAnICAgIGlmIChwbGFuZU51bSA+PSBudW1DbGlwUGxhbmVzKScsXG4gICAgICAgICcgICAgICAgIHsnLFxuICAgICAgICAnICAgICAgICBicmVhazsnLFxuICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgJyAgICBjbGlwRGlzdGFuY2VzVlNPdXRwdXRbcGxhbmVOdW1dID0gZG90KGNsaXBQbGFuZXNbcGxhbmVOdW1dLCB2ZXJ0ZXhNQyk7JyxcbiAgICAgICAgJyAgICB9JyxcbiAgICAgIF0pLnJlc3VsdDtcbiAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKEZTU291cmNlLCAnLy9WVEs6OkNsaXA6OkRlYycsIFtcbiAgICAgICAgJ3VuaWZvcm0gaW50IG51bUNsaXBQbGFuZXM7JyxcbiAgICAgICAgJ3ZhcnlpbmcgZmxvYXQgY2xpcERpc3RhbmNlc1ZTT3V0cHV0WzZdOycsXG4gICAgICBdKS5yZXN1bHQ7XG5cbiAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKEZTU291cmNlLCAnLy9WVEs6OkNsaXA6OkltcGwnLCBbXG4gICAgICAgICdmb3IgKGludCBwbGFuZU51bSA9IDA7IHBsYW5lTnVtIDwgNjsgcGxhbmVOdW0rKyknLFxuICAgICAgICAnICAgIHsnLFxuICAgICAgICAnICAgIGlmIChwbGFuZU51bSA+PSBudW1DbGlwUGxhbmVzKScsXG4gICAgICAgICcgICAgICAgIHsnLFxuICAgICAgICAnICAgICAgICBicmVhazsnLFxuICAgICAgICAnICAgICAgICB9JyxcbiAgICAgICAgJyAgICBpZiAoY2xpcERpc3RhbmNlc1ZTT3V0cHV0W3BsYW5lTnVtXSA8IDAuMCkgZGlzY2FyZDsnLFxuICAgICAgICAnICAgIH0nLFxuICAgICAgXSkucmVzdWx0O1xuICAgIH1cbiAgICBzaGFkZXJzLlZlcnRleCA9IFZTU291cmNlO1xuICAgIHNoYWRlcnMuRnJhZ21lbnQgPSBGU1NvdXJjZTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0Q29pbmNpZGVudFBhcmFtZXRlcnMgPSAocmVuLCBhY3RvcikgPT4ge1xuICAgIC8vIDEuIFJlc29sdmVDb2luY2lkZW50VG9wb2xvZ3kgaXMgT24gYW5kIG5vbiB6ZXJvIGZvciB0aGlzIHByaW1pdGl2ZVxuICAgIC8vIHR5cGVcbiAgICBsZXQgY3AgPSBudWxsO1xuICAgIGNvbnN0IHByb3AgPSBhY3Rvci5nZXRQcm9wZXJ0eSgpO1xuICAgIGlmIChcbiAgICAgIG1vZGVsLnJlbmRlcmFibGUuZ2V0UmVzb2x2ZUNvaW5jaWRlbnRUb3BvbG9neSgpIHx8XG4gICAgICAocHJvcC5nZXRFZGdlVmlzaWJpbGl0eSgpICYmXG4gICAgICAgIHByb3AuZ2V0UmVwcmVzZW50YXRpb24oKSA9PT0gUmVwcmVzZW50YXRpb24uU1VSRkFDRSlcbiAgICApIHtcbiAgICAgIGNvbnN0IHByaW1UeXBlID0gbW9kZWwubGFzdEJvdW5kQk8uZ2V0UHJpbWl0aXZlVHlwZSgpO1xuICAgICAgaWYgKFxuICAgICAgICBwcmltVHlwZSA9PT0gcHJpbVR5cGVzLlBvaW50cyB8fFxuICAgICAgICBwcm9wLmdldFJlcHJlc2VudGF0aW9uKCkgPT09IFJlcHJlc2VudGF0aW9uLlBPSU5UU1xuICAgICAgKSB7XG4gICAgICAgIGNwID0gbW9kZWwucmVuZGVyYWJsZS5nZXRDb2luY2lkZW50VG9wb2xvZ3lQb2ludE9mZnNldFBhcmFtZXRlcigpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgcHJpbVR5cGUgPT09IHByaW1UeXBlcy5MaW5lcyB8fFxuICAgICAgICBwcm9wLmdldFJlcHJlc2VudGF0aW9uKCkgPT09IFJlcHJlc2VudGF0aW9uLldJUkVGUkFNRVxuICAgICAgKSB7XG4gICAgICAgIGNwID0gbW9kZWwucmVuZGVyYWJsZS5nZXRDb2luY2lkZW50VG9wb2xvZ3lMaW5lT2Zmc2V0UGFyYW1ldGVycygpO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgcHJpbVR5cGUgPT09IHByaW1UeXBlcy5UcmlzIHx8XG4gICAgICAgIHByaW1UeXBlID09PSBwcmltVHlwZXMuVHJpU3RyaXBzXG4gICAgICApIHtcbiAgICAgICAgY3AgPSBtb2RlbC5yZW5kZXJhYmxlLmdldENvaW5jaWRlbnRUb3BvbG9neVBvbHlnb25PZmZzZXRQYXJhbWV0ZXJzKCk7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIHByaW1UeXBlID09PSBwcmltVHlwZXMuVHJpc0VkZ2VzIHx8XG4gICAgICAgIHByaW1UeXBlID09PSBwcmltVHlwZXMuVHJpU3RyaXBzRWRnZXNcbiAgICAgICkge1xuICAgICAgICBjcCA9IG1vZGVsLnJlbmRlcmFibGUuZ2V0Q29pbmNpZGVudFRvcG9sb2d5UG9seWdvbk9mZnNldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgY3AuZmFjdG9yIC89IDIuMDtcbiAgICAgICAgY3Aub2Zmc2V0IC89IDIuMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBoYXJkd2FyZSBwaWNraW5nIGFsd2F5cyBvZmZzZXQgZHVlIHRvIHNhdmVkIHpidWZmZXJcbiAgICAvLyBUaGlzIGdldHMgeW91IGFib3ZlIHRoZSBzYXZlZCBzdXJmYWNlIGRlcHRoIGJ1ZmZlci5cbiAgICAvLyB2dGtIYXJkd2FyZVNlbGVjdG9yKiBzZWxlY3RvciA9IHJlbi0+R2V0U2VsZWN0b3IoKTtcbiAgICAvLyBpZiAoc2VsZWN0b3IgJiZcbiAgICAvLyAgICAgc2VsZWN0b3ItPkdldEZpZWxkQXNzb2NpYXRpb24oKSA9PSB2dGtEYXRhT2JqZWN0OjpGSUVMRF9BU1NPQ0lBVElPTl9QT0lOVFMpXG4gICAgLy8ge1xuICAgIC8vICAgb2Zmc2V0IC09IDIuMDtcbiAgICAvLyAgIHJldHVybjtcbiAgICAvLyB9XG4gICAgcmV0dXJuIGNwO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZXBsYWNlU2hhZGVyUGlja2luZyA9IChzaGFkZXJzLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgbGV0IEZTU291cmNlID0gc2hhZGVycy5GcmFnbWVudDtcbiAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShGU1NvdXJjZSwgJy8vVlRLOjpQaWNraW5nOjpEZWMnLCBbXG4gICAgICAndW5pZm9ybSB2ZWMzIG1hcHBlckluZGV4OycsXG4gICAgICAndW5pZm9ybSBpbnQgcGlja2luZzsnLFxuICAgIF0pLnJlc3VsdDtcbiAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgIEZTU291cmNlLFxuICAgICAgJy8vVlRLOjpQaWNraW5nOjpJbXBsJyxcbiAgICAgICcgIGdsX0ZyYWdEYXRhWzBdID0gcGlja2luZyAhPSAwID8gdmVjNChtYXBwZXJJbmRleCwxLjApIDogZ2xfRnJhZ0RhdGFbMF07J1xuICAgICkucmVzdWx0O1xuICAgIHNoYWRlcnMuRnJhZ21lbnQgPSBGU1NvdXJjZTtcbiAgfTtcblxuICBwdWJsaWNBUEkucmVwbGFjZVNoYWRlclZhbHVlcyA9IChzaGFkZXJzLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgcHVibGljQVBJLnJlcGxhY2VTaGFkZXJDb2xvcihzaGFkZXJzLCByZW4sIGFjdG9yKTtcbiAgICBwdWJsaWNBUEkucmVwbGFjZVNoYWRlck5vcm1hbChzaGFkZXJzLCByZW4sIGFjdG9yKTtcbiAgICBwdWJsaWNBUEkucmVwbGFjZVNoYWRlckxpZ2h0KHNoYWRlcnMsIHJlbiwgYWN0b3IpO1xuICAgIHB1YmxpY0FQSS5yZXBsYWNlU2hhZGVyVENvb3JkKHNoYWRlcnMsIHJlbiwgYWN0b3IpO1xuICAgIHB1YmxpY0FQSS5yZXBsYWNlU2hhZGVyUGlja2luZyhzaGFkZXJzLCByZW4sIGFjdG9yKTtcbiAgICBwdWJsaWNBUEkucmVwbGFjZVNoYWRlckNsaXAoc2hhZGVycywgcmVuLCBhY3Rvcik7XG4gICAgcHVibGljQVBJLnJlcGxhY2VTaGFkZXJDb2luY2lkZW50T2Zmc2V0KHNoYWRlcnMsIHJlbiwgYWN0b3IpO1xuICAgIHB1YmxpY0FQSS5yZXBsYWNlU2hhZGVyUG9zaXRpb25WQyhzaGFkZXJzLCByZW4sIGFjdG9yKTtcblxuICAgIGlmIChtb2RlbC5oYXZlU2VlbkRlcHRoUmVxdWVzdCkge1xuICAgICAgbGV0IEZTU291cmNlID0gc2hhZGVycy5GcmFnbWVudDtcbiAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgJy8vVlRLOjpaQnVmZmVyOjpEZWMnLFxuICAgICAgICAndW5pZm9ybSBpbnQgZGVwdGhSZXF1ZXN0OydcbiAgICAgICkucmVzdWx0O1xuICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoRlNTb3VyY2UsICcvL1ZUSzo6WkJ1ZmZlcjo6SW1wbCcsIFtcbiAgICAgICAgJ2lmIChkZXB0aFJlcXVlc3QgPT0gMSkgeycsXG4gICAgICAgICdmbG9hdCBpeiA9IGZsb29yKGdsX0ZyYWdDb29yZC56KjY1NTM1LjAgKyAwLjEpOycsXG4gICAgICAgICdmbG9hdCByZiA9IGZsb29yKGl6LzI1Ni4wKS8yNTUuMDsnLFxuICAgICAgICAnZmxvYXQgZ2YgPSBtb2QoaXosMjU2LjApLzI1NS4wOycsXG4gICAgICAgICdnbF9GcmFnRGF0YVswXSA9IHZlYzQocmYsIGdmLCAwLjAsIDEuMCk7IH0nLFxuICAgICAgXSkucmVzdWx0O1xuICAgICAgc2hhZGVycy5GcmFnbWVudCA9IEZTU291cmNlO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0TmVlZFRvUmVidWlsZFNoYWRlcnMgPSAoY2VsbEJPLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgbGV0IGxpZ2h0Q29tcGxleGl0eSA9IDA7XG4gICAgbGV0IG51bWJlck9mTGlnaHRzID0gMDtcblxuICAgIGNvbnN0IHByaW1UeXBlID0gY2VsbEJPLmdldFByaW1pdGl2ZVR5cGUoKTtcbiAgICBjb25zdCBwb2x5ID0gbW9kZWwuY3VycmVudElucHV0O1xuXG4gICAgLy8gZGlmZmVyZW50IGFsZ28gZnJvbSBDKysgYXMgb2YgNS8yMDE5XG4gICAgbGV0IG5lZWRMaWdodGluZyA9IGZhbHNlO1xuICAgIGNvbnN0IHBvaW50Tm9ybWFscyA9IHBvbHkuZ2V0UG9pbnREYXRhKCkuZ2V0Tm9ybWFscygpO1xuICAgIGNvbnN0IGNlbGxOb3JtYWxzID0gcG9seS5nZXRDZWxsRGF0YSgpLmdldE5vcm1hbHMoKTtcbiAgICBjb25zdCBmbGF0ID0gYWN0b3IuZ2V0UHJvcGVydHkoKS5nZXRJbnRlcnBvbGF0aW9uKCkgPT09IFNoYWRpbmcuRkxBVDtcbiAgICBjb25zdCByZXByZXNlbnRhdGlvbiA9IGFjdG9yLmdldFByb3BlcnR5KCkuZ2V0UmVwcmVzZW50YXRpb24oKTtcbiAgICBjb25zdCBtb2RlID0gcHVibGljQVBJLmdldE9wZW5HTE1vZGUocmVwcmVzZW50YXRpb24sIHByaW1UeXBlKTtcbiAgICAvLyAxKSBhbGwgc3VyZmFjZXMgbmVlZCBsaWdodGluZ1xuICAgIGlmIChtb2RlID09PSBtb2RlbC5jb250ZXh0LlRSSUFOR0xFUykge1xuICAgICAgbmVlZExpZ2h0aW5nID0gdHJ1ZTtcbiAgICAgIC8vIDIpIGFsbCBjZWxsIG5vcm1hbHMgd2l0aG91dCBwb2ludCBub3JtYWxzIG5lZWQgbGlnaHRpbmdcbiAgICB9IGVsc2UgaWYgKGNlbGxOb3JtYWxzICYmICFwb2ludE5vcm1hbHMpIHtcbiAgICAgIG5lZWRMaWdodGluZyA9IHRydWU7XG4gICAgICAvLyAzKSBQaG9uZyArIHBvaW50Tm9ybWFscyBuZWVkIGxpZ2h0aW5nXG4gICAgfSBlbHNlIGlmICghZmxhdCAmJiBwb2ludE5vcm1hbHMpIHtcbiAgICAgIG5lZWRMaWdodGluZyA9IHRydWU7XG4gICAgICAvLyA0KSBQaG9uZyBMaW5lcyBuZWVkIGxpZ2h0aW5nXG4gICAgfSBlbHNlIGlmICghZmxhdCAmJiBtb2RlID09PSBtb2RlbC5jb250ZXh0LkxJTkVTKSB7XG4gICAgICBuZWVkTGlnaHRpbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvLyA1KSBldmVyeXRoaW5nIGVsc2UgaXMgdW5saXRcblxuICAgIC8vIGRvIHdlIG5lZWQgbGlnaHRpbmc/XG4gICAgaWYgKGFjdG9yLmdldFByb3BlcnR5KCkuZ2V0TGlnaHRpbmcoKSAmJiBuZWVkTGlnaHRpbmcpIHtcbiAgICAgIC8vIGNvbnNpZGVyIHRoZSBsaWdodGluZyBjb21wbGV4aXR5IHRvIGRldGVybWluZSB3aGljaCBjYXNlIGFwcGxpZXNcbiAgICAgIC8vIHNpbXBsZSBoZWFkbGlnaHQsIExpZ2h0IEtpdCwgdGhlIHdob2xlIGZlYXR1cmUgc2V0IG9mIFZUS1xuICAgICAgbGlnaHRDb21wbGV4aXR5ID0gMDtcbiAgICAgIGNvbnN0IGxpZ2h0cyA9IHJlbi5nZXRMaWdodHNCeVJlZmVyZW5jZSgpO1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxpZ2h0cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgY29uc3QgbGlnaHQgPSBsaWdodHNbaW5kZXhdO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBsaWdodC5nZXRTd2l0Y2goKTtcbiAgICAgICAgaWYgKHN0YXR1cyA+IDApIHtcbiAgICAgICAgICBudW1iZXJPZkxpZ2h0cysrO1xuICAgICAgICAgIGlmIChsaWdodENvbXBsZXhpdHkgPT09IDApIHtcbiAgICAgICAgICAgIGxpZ2h0Q29tcGxleGl0eSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIGxpZ2h0Q29tcGxleGl0eSA9PT0gMSAmJlxuICAgICAgICAgIChudW1iZXJPZkxpZ2h0cyA+IDEgfHxcbiAgICAgICAgICAgIGxpZ2h0LmdldEludGVuc2l0eSgpICE9PSAxLjAgfHxcbiAgICAgICAgICAgICFsaWdodC5saWdodFR5cGVJc0hlYWRMaWdodCgpKVxuICAgICAgICApIHtcbiAgICAgICAgICBsaWdodENvbXBsZXhpdHkgPSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaWdodENvbXBsZXhpdHkgPCAzICYmIGxpZ2h0LmdldFBvc2l0aW9uYWwoKSkge1xuICAgICAgICAgIGxpZ2h0Q29tcGxleGl0eSA9IDM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbmVlZFJlYnVpbGQgPSBmYWxzZTtcbiAgICBjb25zdCBsYXN0TGlnaHRDb21wbGV4aXR5ID0gbW9kZWwubGFzdEJvdW5kQk8uZ2V0UmVmZXJlbmNlQnlOYW1lKFxuICAgICAgJ2xhc3RMaWdodENvbXBsZXhpdHknXG4gICAgKTtcbiAgICBjb25zdCBsYXN0TGlnaHRDb3VudCA9IG1vZGVsLmxhc3RCb3VuZEJPLmdldFJlZmVyZW5jZUJ5TmFtZShcbiAgICAgICdsYXN0TGlnaHRDb3VudCdcbiAgICApO1xuICAgIGlmIChcbiAgICAgIGxhc3RMaWdodENvbXBsZXhpdHkgIT09IGxpZ2h0Q29tcGxleGl0eSB8fFxuICAgICAgbGFzdExpZ2h0Q291bnQgIT09IG51bWJlck9mTGlnaHRzXG4gICAgKSB7XG4gICAgICBtb2RlbC5sYXN0Qm91bmRCTy5zZXQoeyBsYXN0TGlnaHRDb21wbGV4aXR5OiBsaWdodENvbXBsZXhpdHkgfSwgdHJ1ZSk7XG4gICAgICBtb2RlbC5sYXN0Qm91bmRCTy5zZXQoeyBsYXN0TGlnaHRDb3VudDogbnVtYmVyT2ZMaWdodHMgfSwgdHJ1ZSk7XG4gICAgICBuZWVkUmVidWlsZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gaGFzIHNvbWV0aGluZyBjaGFuZ2VkIHRoYXQgd291bGQgcmVxdWlyZSB1cyB0byByZWNyZWF0ZSB0aGUgc2hhZGVyP1xuICAgIC8vIGNhbmRpZGF0ZXMgYXJlXG4gICAgLy8gcHJvcGVydHkgbW9kaWZpZWQgKHJlcHJlc2VudGF0aW9uIGludGVycG9sYXRpb24gYW5kIGxpZ2h0aW5nKVxuICAgIC8vIGlucHV0IG1vZGlmaWVkXG4gICAgLy8gbGlnaHQgY29tcGxleGl0eSBjaGFuZ2VkXG4gICAgaWYgKFxuICAgICAgbW9kZWwubGFzdEhhdmVTZWVuRGVwdGhSZXF1ZXN0ICE9PSBtb2RlbC5oYXZlU2VlbkRlcHRoUmVxdWVzdCB8fFxuICAgICAgY2VsbEJPLmdldFByb2dyYW0oKSA9PT0gMCB8fFxuICAgICAgY2VsbEJPLmdldFNoYWRlclNvdXJjZVRpbWUoKS5nZXRNVGltZSgpIDwgcHVibGljQVBJLmdldE1UaW1lKCkgfHxcbiAgICAgIGNlbGxCTy5nZXRTaGFkZXJTb3VyY2VUaW1lKCkuZ2V0TVRpbWUoKSA8IGFjdG9yLmdldE1UaW1lKCkgfHxcbiAgICAgIGNlbGxCTy5nZXRTaGFkZXJTb3VyY2VUaW1lKCkuZ2V0TVRpbWUoKSA8IG1vZGVsLnJlbmRlcmFibGUuZ2V0TVRpbWUoKSB8fFxuICAgICAgY2VsbEJPLmdldFNoYWRlclNvdXJjZVRpbWUoKS5nZXRNVGltZSgpIDwgbW9kZWwuY3VycmVudElucHV0LmdldE1UaW1lKCkgfHxcbiAgICAgIG5lZWRSZWJ1aWxkXG4gICAgKSB7XG4gICAgICBtb2RlbC5sYXN0SGF2ZVNlZW5EZXB0aFJlcXVlc3QgPSBtb2RlbC5oYXZlU2VlbkRlcHRoUmVxdWVzdDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBwdWJsaWNBUEkudXBkYXRlU2hhZGVycyA9IChjZWxsQk8sIHJlbiwgYWN0b3IpID0+IHtcbiAgICBtb2RlbC5sYXN0Qm91bmRCTyA9IGNlbGxCTztcblxuICAgIC8vIGhhcyBzb21ldGhpbmcgY2hhbmdlZCB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgdG8gcmVjcmVhdGUgdGhlIHNoYWRlcj9cbiAgICBpZiAocHVibGljQVBJLmdldE5lZWRUb1JlYnVpbGRTaGFkZXJzKGNlbGxCTywgcmVuLCBhY3RvcikpIHtcbiAgICAgIGNvbnN0IHNoYWRlcnMgPSB7IFZlcnRleDogbnVsbCwgRnJhZ21lbnQ6IG51bGwsIEdlb21ldHJ5OiBudWxsIH07XG4gICAgICBwdWJsaWNBUEkuYnVpbGRTaGFkZXJzKHNoYWRlcnMsIHJlbiwgYWN0b3IpO1xuXG4gICAgICAvLyBjb21waWxlIGFuZCBiaW5kIHRoZSBwcm9ncmFtIGlmIG5lZWRlZFxuICAgICAgY29uc3QgbmV3U2hhZGVyID0gbW9kZWwub3BlbkdMUmVuZGVyV2luZG93XG4gICAgICAgIC5nZXRTaGFkZXJDYWNoZSgpXG4gICAgICAgIC5yZWFkeVNoYWRlclByb2dyYW1BcnJheShcbiAgICAgICAgICBzaGFkZXJzLlZlcnRleCxcbiAgICAgICAgICBzaGFkZXJzLkZyYWdtZW50LFxuICAgICAgICAgIHNoYWRlcnMuR2VvbWV0cnlcbiAgICAgICAgKTtcblxuICAgICAgLy8gaWYgdGhlIHNoYWRlciBjaGFuZ2VkIHJlaW5pdGlhbGl6ZSB0aGUgVkFPXG4gICAgICBpZiAobmV3U2hhZGVyICE9PSBjZWxsQk8uZ2V0UHJvZ3JhbSgpKSB7XG4gICAgICAgIGNlbGxCTy5zZXRQcm9ncmFtKG5ld1NoYWRlcik7XG4gICAgICAgIC8vIHJlc2V0IHRoZSBWQU8gYXMgdGhlIHNoYWRlciBoYXMgY2hhbmdlZFxuICAgICAgICBjZWxsQk8uZ2V0VkFPKCkucmVsZWFzZUdyYXBoaWNzUmVzb3VyY2VzKCk7XG4gICAgICB9XG5cbiAgICAgIGNlbGxCTy5nZXRTaGFkZXJTb3VyY2VUaW1lKCkubW9kaWZpZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93XG4gICAgICAgIC5nZXRTaGFkZXJDYWNoZSgpXG4gICAgICAgIC5yZWFkeVNoYWRlclByb2dyYW0oY2VsbEJPLmdldFByb2dyYW0oKSk7XG4gICAgfVxuXG4gICAgY2VsbEJPLmdldFZBTygpLmJpbmQoKTtcblxuICAgIHB1YmxpY0FQSS5zZXRNYXBwZXJTaGFkZXJQYXJhbWV0ZXJzKGNlbGxCTywgcmVuLCBhY3Rvcik7XG4gICAgcHVibGljQVBJLnNldFByb3BlcnR5U2hhZGVyUGFyYW1ldGVycyhjZWxsQk8sIHJlbiwgYWN0b3IpO1xuICAgIHB1YmxpY0FQSS5zZXRDYW1lcmFTaGFkZXJQYXJhbWV0ZXJzKGNlbGxCTywgcmVuLCBhY3Rvcik7XG4gICAgcHVibGljQVBJLnNldExpZ2h0aW5nU2hhZGVyUGFyYW1ldGVycyhjZWxsQk8sIHJlbiwgYWN0b3IpO1xuXG4gICAgY29uc3QgbGlzdENhbGxiYWNrcyA9IG1vZGVsLnJlbmRlcmFibGUuZ2V0Vmlld1NwZWNpZmljUHJvcGVydGllcygpXG4gICAgICAuU2hhZGVyc0NhbGxiYWNrcztcbiAgICBpZiAobGlzdENhbGxiYWNrcykge1xuICAgICAgbGlzdENhbGxiYWNrcy5mb3JFYWNoKChvYmplY3QpID0+IHtcbiAgICAgICAgb2JqZWN0LmNhbGxiYWNrKG9iamVjdC51c2VyRGF0YSwgY2VsbEJPLCByZW4sIGFjdG9yKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0TWFwcGVyU2hhZGVyUGFyYW1ldGVycyA9IChjZWxsQk8sIHJlbiwgYWN0b3IpID0+IHtcbiAgICAvLyBOb3cgdG8gdXBkYXRlIHRoZSBWQU8gdG9vLCBpZiBuZWNlc3NhcnkuXG4gICAgaWYgKGNlbGxCTy5nZXRQcm9ncmFtKCkuaXNVbmlmb3JtVXNlZCgnUHJpbWl0aXZlSURPZmZzZXQnKSkge1xuICAgICAgY2VsbEJPXG4gICAgICAgIC5nZXRQcm9ncmFtKClcbiAgICAgICAgLnNldFVuaWZvcm1pKCdQcmltaXRpdmVJRE9mZnNldCcsIG1vZGVsLnByaW1pdGl2ZUlET2Zmc2V0KTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBjZWxsQk8uZ2V0Q0FCTygpLmdldEVsZW1lbnRDb3VudCgpICYmXG4gICAgICAobW9kZWwuVkJPQnVpbGRUaW1lLmdldE1UaW1lKCkgPlxuICAgICAgICBjZWxsQk8uZ2V0QXR0cmlidXRlVXBkYXRlVGltZSgpLmdldE1UaW1lKCkgfHxcbiAgICAgICAgY2VsbEJPLmdldFNoYWRlclNvdXJjZVRpbWUoKS5nZXRNVGltZSgpID5cbiAgICAgICAgICBjZWxsQk8uZ2V0QXR0cmlidXRlVXBkYXRlVGltZSgpLmdldE1UaW1lKCkpXG4gICAgKSB7XG4gICAgICBjb25zdCBsYXN0TGlnaHRDb21wbGV4aXR5ID0gbW9kZWwubGFzdEJvdW5kQk8uZ2V0UmVmZXJlbmNlQnlOYW1lKFxuICAgICAgICAnbGFzdExpZ2h0Q29tcGxleGl0eSdcbiAgICAgICk7XG5cbiAgICAgIGlmIChjZWxsQk8uZ2V0UHJvZ3JhbSgpLmlzQXR0cmlidXRlVXNlZCgndmVydGV4TUMnKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWNlbGxCT1xuICAgICAgICAgICAgLmdldFZBTygpXG4gICAgICAgICAgICAuYWRkQXR0cmlidXRlQXJyYXkoXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCksXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCksXG4gICAgICAgICAgICAgICd2ZXJ0ZXhNQycsXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0VmVydGV4T2Zmc2V0KCksXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0U3RyaWRlKCksXG4gICAgICAgICAgICAgIG1vZGVsLmNvbnRleHQuRkxPQVQsXG4gICAgICAgICAgICAgIDMsXG4gICAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIHZ0a0Vycm9yTWFjcm8oJ0Vycm9yIHNldHRpbmcgdmVydGV4TUMgaW4gc2hhZGVyIFZBTy4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKFxuICAgICAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpLmlzQXR0cmlidXRlVXNlZCgnbm9ybWFsTUMnKSAmJlxuICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLmdldE5vcm1hbE9mZnNldCgpICYmXG4gICAgICAgIGxhc3RMaWdodENvbXBsZXhpdHkgPiAwXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFjZWxsQk9cbiAgICAgICAgICAgIC5nZXRWQU8oKVxuICAgICAgICAgICAgLmFkZEF0dHJpYnV0ZUFycmF5KFxuICAgICAgICAgICAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpLFxuICAgICAgICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLFxuICAgICAgICAgICAgICAnbm9ybWFsTUMnLFxuICAgICAgICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLmdldE5vcm1hbE9mZnNldCgpLFxuICAgICAgICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLmdldFN0cmlkZSgpLFxuICAgICAgICAgICAgICBtb2RlbC5jb250ZXh0LkZMT0FULFxuICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICB2dGtFcnJvck1hY3JvKCdFcnJvciBzZXR0aW5nIG5vcm1hbE1DIGluIHNoYWRlciBWQU8uJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGxCTy5nZXRWQU8oKS5yZW1vdmVBdHRyaWJ1dGVBcnJheSgnbm9ybWFsTUMnKTtcbiAgICAgIH1cblxuICAgICAgbW9kZWwucmVuZGVyYWJsZS5nZXRDdXN0b21TaGFkZXJBdHRyaWJ1dGVzKCkuZm9yRWFjaCgoYXR0ck5hbWUsIGlkeCkgPT4ge1xuICAgICAgICBpZiAoY2VsbEJPLmdldFByb2dyYW0oKS5pc0F0dHJpYnV0ZVVzZWQoYCR7YXR0ck5hbWV9TUNgKSkge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFjZWxsQk9cbiAgICAgICAgICAgICAgLmdldFZBTygpXG4gICAgICAgICAgICAgIC5hZGRBdHRyaWJ1dGVBcnJheShcbiAgICAgICAgICAgICAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpLFxuICAgICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCksXG4gICAgICAgICAgICAgICAgYCR7YXR0ck5hbWV9TUNgLFxuICAgICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0Q3VzdG9tRGF0YSgpW2lkeF0ub2Zmc2V0LFxuICAgICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0U3RyaWRlKCksXG4gICAgICAgICAgICAgICAgbW9kZWwuY29udGV4dC5GTE9BVCxcbiAgICAgICAgICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLmdldEN1c3RvbURhdGEoKVtpZHhdLmNvbXBvbmVudHMsXG4gICAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdnRrRXJyb3JNYWNybyhgRXJyb3Igc2V0dGluZyAke2F0dHJOYW1lfU1DIGluIHNoYWRlciBWQU8uYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKFxuICAgICAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpLmlzQXR0cmlidXRlVXNlZCgndGNvb3JkTUMnKSAmJlxuICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLmdldFRDb29yZE9mZnNldCgpXG4gICAgICApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFjZWxsQk9cbiAgICAgICAgICAgIC5nZXRWQU8oKVxuICAgICAgICAgICAgLmFkZEF0dHJpYnV0ZUFycmF5KFxuICAgICAgICAgICAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpLFxuICAgICAgICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLFxuICAgICAgICAgICAgICAndGNvb3JkTUMnLFxuICAgICAgICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLmdldFRDb29yZE9mZnNldCgpLFxuICAgICAgICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLmdldFN0cmlkZSgpLFxuICAgICAgICAgICAgICBtb2RlbC5jb250ZXh0LkZMT0FULFxuICAgICAgICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLmdldFRDb29yZENvbXBvbmVudHMoKSxcbiAgICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgdnRrRXJyb3JNYWNybygnRXJyb3Igc2V0dGluZyB0Y29vcmRNQyBpbiBzaGFkZXIgVkFPLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZWxsQk8uZ2V0VkFPKCkucmVtb3ZlQXR0cmlidXRlQXJyYXkoJ3Rjb29yZE1DJyk7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCkuaXNBdHRyaWJ1dGVVc2VkKCdzY2FsYXJDb2xvcicpICYmXG4gICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0Q29sb3JDb21wb25lbnRzKClcbiAgICAgICkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWNlbGxCT1xuICAgICAgICAgICAgLmdldFZBTygpXG4gICAgICAgICAgICAuYWRkQXR0cmlidXRlQXJyYXkoXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCksXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0Q29sb3JCTygpLFxuICAgICAgICAgICAgICAnc2NhbGFyQ29sb3InLFxuICAgICAgICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLmdldENvbG9yT2Zmc2V0KCksXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0Q29sb3JCT1N0cmlkZSgpLFxuICAgICAgICAgICAgICBtb2RlbC5jb250ZXh0LlVOU0lHTkVEX0JZVEUsXG4gICAgICAgICAgICAgIDQsXG4gICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgdnRrRXJyb3JNYWNybygnRXJyb3Igc2V0dGluZyBzY2FsYXJDb2xvciBpbiBzaGFkZXIgVkFPLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZWxsQk8uZ2V0VkFPKCkucmVtb3ZlQXR0cmlidXRlQXJyYXkoJ3NjYWxhckNvbG9yJyk7XG4gICAgICB9XG5cbiAgICAgIGNlbGxCTy5nZXRBdHRyaWJ1dGVVcGRhdGVUaW1lKCkubW9kaWZpZWQoKTtcbiAgICB9XG5cbiAgICBpZiAobW9kZWwucmVuZGVyYWJsZS5nZXROdW1iZXJPZkNsaXBwaW5nUGxhbmVzKCkpIHtcbiAgICAgIC8vIGFkZCBhbGwgdGhlIGNsaXBwaW5nIHBsYW5lc1xuICAgICAgbGV0IG51bUNsaXBQbGFuZXMgPSBtb2RlbC5yZW5kZXJhYmxlLmdldE51bWJlck9mQ2xpcHBpbmdQbGFuZXMoKTtcbiAgICAgIGlmIChudW1DbGlwUGxhbmVzID4gNikge1xuICAgICAgICBtYWNyby52dGtFcnJvck1hY3JvKCdPcGVuR0wgaGFzIGEgbGltaXQgb2YgNiBjbGlwcGluZyBwbGFuZXMnKTtcbiAgICAgICAgbnVtQ2xpcFBsYW5lcyA9IDY7XG4gICAgICB9XG4gICAgICBjb25zdCBwbGFuZUVxdWF0aW9ucyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DbGlwUGxhbmVzOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGxhbmVFcXVhdGlvbiA9IFtdO1xuICAgICAgICBtb2RlbC5yZW5kZXJhYmxlLmdldENsaXBwaW5nUGxhbmVJbkRhdGFDb29yZHMoXG4gICAgICAgICAgYWN0b3IuZ2V0TWF0cml4KCksXG4gICAgICAgICAgaSxcbiAgICAgICAgICBwbGFuZUVxdWF0aW9uXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICBwbGFuZUVxdWF0aW9ucy5wdXNoKHBsYW5lRXF1YXRpb25bal0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpLnNldFVuaWZvcm1pKCdudW1DbGlwUGxhbmVzJywgbnVtQ2xpcFBsYW5lcyk7XG4gICAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpLnNldFVuaWZvcm00ZnYoJ2NsaXBQbGFuZXMnLCA2LCBwbGFuZUVxdWF0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgbW9kZWwuaW50ZXJuYWxDb2xvclRleHR1cmUgJiZcbiAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCkuaXNVbmlmb3JtVXNlZCgndGV4dHVyZTEnKVxuICAgICkge1xuICAgICAgY2VsbEJPXG4gICAgICAgIC5nZXRQcm9ncmFtKClcbiAgICAgICAgLnNldFVuaWZvcm1pKCd0ZXh0dXJlMScsIG1vZGVsLmludGVybmFsQ29sb3JUZXh0dXJlLmdldFRleHR1cmVVbml0KCkpO1xuICAgIH1cbiAgICBjb25zdCB0dXMgPSBtb2RlbC5vcGVuR0xBY3Rvci5nZXRBY3RpdmVUZXh0dXJlcygpO1xuICAgIGlmICh0dXMpIHtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0dXMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIGNvbnN0IHRleCA9IHR1c1tpbmRleF07XG4gICAgICAgIGNvbnN0IHRleFVuaXQgPSB0ZXguZ2V0VGV4dHVyZVVuaXQoKTtcbiAgICAgICAgY29uc3QgdG5hbWUgPSBgdGV4dHVyZSR7dGV4VW5pdCArIDF9YDtcbiAgICAgICAgaWYgKGNlbGxCTy5nZXRQcm9ncmFtKCkuaXNVbmlmb3JtVXNlZCh0bmFtZSkpIHtcbiAgICAgICAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpLnNldFVuaWZvcm1pKHRuYW1lLCB0ZXhVbml0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSBkZXB0aCByZXF1ZXN0c1xuICAgIGlmIChtb2RlbC5oYXZlU2VlbkRlcHRoUmVxdWVzdCkge1xuICAgICAgY2VsbEJPXG4gICAgICAgIC5nZXRQcm9ncmFtKClcbiAgICAgICAgLnNldFVuaWZvcm1pKCdkZXB0aFJlcXVlc3QnLCBtb2RlbC5yZW5kZXJEZXB0aCA/IDEgOiAwKTtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgY29pbmNpZGVudFxuICAgIGlmIChjZWxsQk8uZ2V0UHJvZ3JhbSgpLmlzVW5pZm9ybVVzZWQoJ2NvZmZzZXQnKSkge1xuICAgICAgY29uc3QgY3AgPSBwdWJsaWNBUEkuZ2V0Q29pbmNpZGVudFBhcmFtZXRlcnMocmVuLCBhY3Rvcik7XG4gICAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpLnNldFVuaWZvcm1mKCdjb2Zmc2V0JywgY3Aub2Zmc2V0KTtcbiAgICAgIC8vIGNmYWN0b3IgaXNuJ3QgYWx3YXlzIHVzZWQgd2hlbiBjb2Zmc2V0IGlzLlxuICAgICAgaWYgKGNlbGxCTy5nZXRQcm9ncmFtKCkuaXNVbmlmb3JtVXNlZCgnY2ZhY3RvcicpKSB7XG4gICAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCkuc2V0VW5pZm9ybWYoJ2NmYWN0b3InLCBjcC5mYWN0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdG9yID0gbW9kZWwub3BlbkdMUmVuZGVyZXIuZ2V0U2VsZWN0b3IoKTtcbiAgICBjZWxsQk9cbiAgICAgIC5nZXRQcm9ncmFtKClcbiAgICAgIC5zZXRVbmlmb3JtM2ZBcnJheShcbiAgICAgICAgJ21hcHBlckluZGV4JyxcbiAgICAgICAgc2VsZWN0b3IgPyBzZWxlY3Rvci5nZXRQcm9wQ29sb3JWYWx1ZSgpIDogWzAuMCwgMC4wLCAwLjBdXG4gICAgICApO1xuICAgIGNlbGxCT1xuICAgICAgLmdldFByb2dyYW0oKVxuICAgICAgLnNldFVuaWZvcm1pKCdwaWNraW5nJywgc2VsZWN0b3IgPyBzZWxlY3Rvci5nZXRDdXJyZW50UGFzcygpICsgMSA6IDApO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRMaWdodGluZ1NoYWRlclBhcmFtZXRlcnMgPSAoY2VsbEJPLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgLy8gZm9yIHVubGl0IGFuZCBoZWFkbGlnaHQgdGhlcmUgYXJlIG5vIGxpZ2h0aW5nIHBhcmFtZXRlcnNcbiAgICBjb25zdCBsYXN0TGlnaHRDb21wbGV4aXR5ID0gbW9kZWwubGFzdEJvdW5kQk8uZ2V0UmVmZXJlbmNlQnlOYW1lKFxuICAgICAgJ2xhc3RMaWdodENvbXBsZXhpdHknXG4gICAgKTtcbiAgICBpZiAobGFzdExpZ2h0Q29tcGxleGl0eSA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9ncmFtID0gY2VsbEJPLmdldFByb2dyYW0oKTtcblxuICAgIC8vIGJpbmQgc29tZSBsaWdodCBzZXR0aW5nc1xuICAgIGxldCBudW1iZXJPZkxpZ2h0cyA9IDA7XG5cbiAgICBjb25zdCBsaWdodHMgPSByZW4uZ2V0TGlnaHRzQnlSZWZlcmVuY2UoKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGlnaHRzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgY29uc3QgbGlnaHQgPSBsaWdodHNbaW5kZXhdO1xuICAgICAgY29uc3Qgc3RhdHVzID0gbGlnaHQuZ2V0U3dpdGNoKCk7XG4gICAgICBpZiAoc3RhdHVzID4gMC4wKSB7XG4gICAgICAgIGNvbnN0IGRDb2xvciA9IGxpZ2h0LmdldENvbG9yQnlSZWZlcmVuY2UoKTtcbiAgICAgICAgY29uc3QgaW50ZW5zaXR5ID0gbGlnaHQuZ2V0SW50ZW5zaXR5KCk7XG4gICAgICAgIG1vZGVsLmxpZ2h0Q29sb3JbMF0gPSBkQ29sb3JbMF0gKiBpbnRlbnNpdHk7XG4gICAgICAgIG1vZGVsLmxpZ2h0Q29sb3JbMV0gPSBkQ29sb3JbMV0gKiBpbnRlbnNpdHk7XG4gICAgICAgIG1vZGVsLmxpZ2h0Q29sb3JbMl0gPSBkQ29sb3JbMl0gKiBpbnRlbnNpdHk7XG4gICAgICAgIC8vIGdldCByZXF1aXJlZCBpbmZvIGZyb20gbGlnaHRcbiAgICAgICAgY29uc3QgbGQgPSBsaWdodC5nZXREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gcmVuLmdldEFjdGl2ZUNhbWVyYSgpLmdldFZpZXdNYXRyaXgoKTtcblxuICAgICAgICBjb25zdCBuZXdMaWdodERpcmVjdGlvbiA9IFsuLi5sZF07XG4gICAgICAgIGlmIChsaWdodC5saWdodFR5cGVJc1NjZW5lTGlnaHQoKSkge1xuICAgICAgICAgIG5ld0xpZ2h0RGlyZWN0aW9uWzBdID1cbiAgICAgICAgICAgIHRyYW5zZm9ybVswXSAqIGxkWzBdICsgdHJhbnNmb3JtWzFdICogbGRbMV0gKyB0cmFuc2Zvcm1bMl0gKiBsZFsyXTtcbiAgICAgICAgICBuZXdMaWdodERpcmVjdGlvblsxXSA9XG4gICAgICAgICAgICB0cmFuc2Zvcm1bNF0gKiBsZFswXSArIHRyYW5zZm9ybVs1XSAqIGxkWzFdICsgdHJhbnNmb3JtWzZdICogbGRbMl07XG4gICAgICAgICAgbmV3TGlnaHREaXJlY3Rpb25bMl0gPVxuICAgICAgICAgICAgdHJhbnNmb3JtWzhdICogbGRbMF0gKyB0cmFuc2Zvcm1bOV0gKiBsZFsxXSArIHRyYW5zZm9ybVsxMF0gKiBsZFsyXTtcbiAgICAgICAgICB2dGtNYXRoLm5vcm1hbGl6ZShuZXdMaWdodERpcmVjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RlbC5saWdodERpcmVjdGlvblswXSA9IG5ld0xpZ2h0RGlyZWN0aW9uWzBdO1xuICAgICAgICBtb2RlbC5saWdodERpcmVjdGlvblsxXSA9IG5ld0xpZ2h0RGlyZWN0aW9uWzFdO1xuICAgICAgICBtb2RlbC5saWdodERpcmVjdGlvblsyXSA9IG5ld0xpZ2h0RGlyZWN0aW9uWzJdO1xuICAgICAgICBtb2RlbC5saWdodEhhbGZBbmdsZVswXSA9IC1tb2RlbC5saWdodERpcmVjdGlvblswXTtcbiAgICAgICAgbW9kZWwubGlnaHRIYWxmQW5nbGVbMV0gPSAtbW9kZWwubGlnaHREaXJlY3Rpb25bMV07XG4gICAgICAgIG1vZGVsLmxpZ2h0SGFsZkFuZ2xlWzJdID0gLW1vZGVsLmxpZ2h0RGlyZWN0aW9uWzJdICsgMS4wO1xuICAgICAgICB2dGtNYXRoLm5vcm1hbGl6ZShtb2RlbC5saWdodERpcmVjdGlvbik7XG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybTNmQXJyYXkoXG4gICAgICAgICAgYGxpZ2h0Q29sb3Ike251bWJlck9mTGlnaHRzfWAsXG4gICAgICAgICAgbW9kZWwubGlnaHRDb2xvclxuICAgICAgICApO1xuICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm0zZkFycmF5KFxuICAgICAgICAgIGBsaWdodERpcmVjdGlvblZDJHtudW1iZXJPZkxpZ2h0c31gLFxuICAgICAgICAgIG1vZGVsLmxpZ2h0RGlyZWN0aW9uXG4gICAgICAgICk7XG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybTNmQXJyYXkoXG4gICAgICAgICAgYGxpZ2h0SGFsZkFuZ2xlVkMke251bWJlck9mTGlnaHRzfWAsXG4gICAgICAgICAgbW9kZWwubGlnaHRIYWxmQW5nbGVcbiAgICAgICAgKTtcbiAgICAgICAgbnVtYmVyT2ZMaWdodHMrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSBhcmUgZG9uZSB1bmxlc3Mgd2UgaGF2ZSBwb3NpdGlvbmFsIGxpZ2h0c1xuICAgIGlmIChsYXN0TGlnaHRDb21wbGV4aXR5IDwgMykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGZvciBsaWdodGtpdCBjYXNlIHRoZXJlIGFyZSBzb21lIHBhcmFtZXRlcnMgdG8gc2V0XG4gICAgY29uc3QgY2FtID0gcmVuLmdldEFjdGl2ZUNhbWVyYSgpO1xuICAgIGNvbnN0IHZpZXdURiA9IGNhbS5nZXRWaWV3TWF0cml4KCk7XG4gICAgbWF0NC50cmFuc3Bvc2Uodmlld1RGLCB2aWV3VEYpO1xuXG4gICAgbnVtYmVyT2ZMaWdodHMgPSAwO1xuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxpZ2h0cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIGNvbnN0IGxpZ2h0ID0gbGlnaHRzW2luZGV4XTtcbiAgICAgIGNvbnN0IHN0YXR1cyA9IGxpZ2h0LmdldFN3aXRjaCgpO1xuICAgICAgaWYgKHN0YXR1cyA+IDAuMCkge1xuICAgICAgICBjb25zdCBscCA9IGxpZ2h0LmdldFRyYW5zZm9ybWVkUG9zaXRpb24oKTtcbiAgICAgICAgY29uc3QgbnAgPSB2ZWMzLmZyb21WYWx1ZXMobHBbMF0sIGxwWzFdLCBscFsyXSk7XG4gICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NChucCwgbnAsIHZpZXdURik7XG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybTNmQXJyYXkoXG4gICAgICAgICAgYGxpZ2h0QXR0ZW51YXRpb24ke251bWJlck9mTGlnaHRzfWAsXG4gICAgICAgICAgbGlnaHQuZ2V0QXR0ZW51YXRpb25WYWx1ZXNCeVJlZmVyZW5jZSgpXG4gICAgICAgICk7XG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybWkoXG4gICAgICAgICAgYGxpZ2h0UG9zaXRpb25hbCR7bnVtYmVyT2ZMaWdodHN9YCxcbiAgICAgICAgICBsaWdodC5nZXRQb3NpdGlvbmFsKClcbiAgICAgICAgKTtcbiAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtZihcbiAgICAgICAgICBgbGlnaHRFeHBvbmVudCR7bnVtYmVyT2ZMaWdodHN9YCxcbiAgICAgICAgICBsaWdodC5nZXRFeHBvbmVudCgpXG4gICAgICAgICk7XG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoXG4gICAgICAgICAgYGxpZ2h0Q29uZUFuZ2xlJHtudW1iZXJPZkxpZ2h0c31gLFxuICAgICAgICAgIGxpZ2h0LmdldENvbmVBbmdsZSgpXG4gICAgICAgICk7XG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybTNmQXJyYXkoYGxpZ2h0UG9zaXRpb25WQyR7bnVtYmVyT2ZMaWdodHN9YCwgW1xuICAgICAgICAgIG5wWzBdLFxuICAgICAgICAgIG5wWzFdLFxuICAgICAgICAgIG5wWzJdLFxuICAgICAgICBdKTtcbiAgICAgICAgbnVtYmVyT2ZMaWdodHMrKztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gc2FmZU1hdHJpeE11bHRpcGx5KG1hdHJpeEFycmF5LCBtYXRyaXhUeXBlLCB0bXBNYXQpIHtcbiAgICBtYXRyaXhUeXBlLmlkZW50aXR5KHRtcE1hdCk7XG4gICAgcmV0dXJuIG1hdHJpeEFycmF5LnJlZHVjZSgocmVzLCBtYXRyaXgsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG1hdHJpeCA/IG1hdHJpeFR5cGUuY29weShyZXMsIG1hdHJpeCkgOiBtYXRyaXhUeXBlLmlkZW50aXR5KHJlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0cml4ID8gbWF0cml4VHlwZS5tdWx0aXBseShyZXMsIHJlcywgbWF0cml4KSA6IHJlcztcbiAgICB9LCB0bXBNYXQpO1xuICB9XG5cbiAgcHVibGljQVBJLnNldENhbWVyYVNoYWRlclBhcmFtZXRlcnMgPSAoY2VsbEJPLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNlbGxCTy5nZXRQcm9ncmFtKCk7XG5cbiAgICAvLyBbV01WUF1DID09IHt3b3JsZCwgbW9kZWwsIHZpZXcsIHByb2plY3Rpb259IGNvb3JkaW5hdGVzXG4gICAgLy8gRS5nLiwgV0NQQyA9PSB3b3JsZCB0byBwcm9qZWN0aW9uIGNvb3JkaW5hdGUgdHJhbnNmb3JtYXRpb25cbiAgICBjb25zdCBrZXlNYXRzID0gbW9kZWwub3BlbkdMQ2FtZXJhLmdldEtleU1hdHJpY2VzKHJlbik7XG4gICAgY29uc3QgY2FtID0gcmVuLmdldEFjdGl2ZUNhbWVyYSgpO1xuXG4gICAgY29uc3QgY2FtbSA9IG1vZGVsLm9wZW5HTENhbWVyYS5nZXRLZXlNYXRyaXhUaW1lKCkuZ2V0TVRpbWUoKTtcbiAgICBjb25zdCBwcm9nbSA9IHByb2dyYW0uZ2V0TGFzdENhbWVyYU1UaW1lKCk7XG5cbiAgICBjb25zdCBzaGlmdFNjYWxlRW5hYmxlZCA9IGNlbGxCTy5nZXRDQUJPKCkuZ2V0Q29vcmRTaGlmdEFuZFNjYWxlRW5hYmxlZCgpO1xuICAgIGNvbnN0IGludmVyc2VTaGlmdFNjYWxlTWF0cml4ID0gc2hpZnRTY2FsZUVuYWJsZWRcbiAgICAgID8gY2VsbEJPLmdldENBQk8oKS5nZXRJbnZlcnNlU2hpZnRBbmRTY2FsZU1hdHJpeCgpXG4gICAgICA6IG51bGw7XG5cbiAgICBjb25zdCBhY3RvcklzSWRlbnRpdHkgPSBhY3Rvci5nZXRJc0lkZW50aXR5KCk7XG4gICAgY29uc3QgYWN0TWF0cyA9IGFjdG9ySXNJZGVudGl0eVxuICAgICAgPyB7IG1jd2M6IG51bGwsIG5vcm1hbE1hdHJpeDogbnVsbCB9XG4gICAgICA6IG1vZGVsLm9wZW5HTEFjdG9yLmdldEtleU1hdHJpY2VzKCk7XG5cbiAgICBwcm9ncmFtLnNldFVuaWZvcm1NYXRyaXgoXG4gICAgICAnTUNQQ01hdHJpeCcsXG4gICAgICBzYWZlTWF0cml4TXVsdGlwbHkoXG4gICAgICAgIFtrZXlNYXRzLndjcGMsIGFjdE1hdHMubWN3YywgaW52ZXJzZVNoaWZ0U2NhbGVNYXRyaXhdLFxuICAgICAgICBtYXQ0LFxuICAgICAgICBtb2RlbC50bXBNYXQ0XG4gICAgICApXG4gICAgKTtcbiAgICBpZiAocHJvZ3JhbS5pc1VuaWZvcm1Vc2VkKCdNQ1ZDTWF0cml4JykpIHtcbiAgICAgIHByb2dyYW0uc2V0VW5pZm9ybU1hdHJpeChcbiAgICAgICAgJ01DVkNNYXRyaXgnLFxuICAgICAgICBzYWZlTWF0cml4TXVsdGlwbHkoXG4gICAgICAgICAgW2tleU1hdHMud2N2YywgYWN0TWF0cy5tY3djLCBpbnZlcnNlU2hpZnRTY2FsZU1hdHJpeF0sXG4gICAgICAgICAgbWF0NCxcbiAgICAgICAgICBtb2RlbC50bXBNYXQ0XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChwcm9ncmFtLmlzVW5pZm9ybVVzZWQoJ25vcm1hbE1hdHJpeCcpKSB7XG4gICAgICBwcm9ncmFtLnNldFVuaWZvcm1NYXRyaXgzeDMoXG4gICAgICAgICdub3JtYWxNYXRyaXgnLFxuICAgICAgICBzYWZlTWF0cml4TXVsdGlwbHkoXG4gICAgICAgICAgW2tleU1hdHMubm9ybWFsTWF0cml4LCBhY3RNYXRzLm5vcm1hbE1hdHJpeF0sXG4gICAgICAgICAgbWF0MyxcbiAgICAgICAgICBtb2RlbC50bXBNYXQzXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHByb2dtICE9PSBjYW1tKSB7XG4gICAgICBpZiAocHJvZ3JhbS5pc1VuaWZvcm1Vc2VkKCdjYW1lcmFQYXJhbGxlbCcpKSB7XG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybWkoJ2NhbWVyYVBhcmFsbGVsJywgY2FtLmdldFBhcmFsbGVsUHJvamVjdGlvbigpKTtcbiAgICAgIH1cbiAgICAgIHByb2dyYW0uc2V0TGFzdENhbWVyYU1UaW1lKGNhbW0pO1xuICAgIH1cblxuICAgIGlmICghYWN0b3JJc0lkZW50aXR5KSB7XG4gICAgICAvLyByZXNldCB0aGUgY2FtIG10aW1lIGFzIGFjdG9yIG1vZGlmaWVkIHRoZSBzaGFkZXIgdmFsdWVzXG4gICAgICBwcm9ncmFtLnNldExhc3RDYW1lcmFNVGltZSgwKTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLnNldFByb3BlcnR5U2hhZGVyUGFyYW1ldGVycyA9IChjZWxsQk8sIHJlbiwgYWN0b3IpID0+IHtcbiAgICBjb25zdCBwcm9ncmFtID0gY2VsbEJPLmdldFByb2dyYW0oKTtcblxuICAgIGNvbnN0IHBwdHkgPSBhY3Rvci5nZXRQcm9wZXJ0eSgpO1xuXG4gICAgY29uc3Qgb3BhY2l0eSA9IHBwdHkuZ2V0T3BhY2l0eSgpO1xuICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoJ29wYWNpdHlVbmlmb3JtJywgb3BhY2l0eSk7XG5cbiAgICBjb25zdCBhQ29sb3IgPSBtb2RlbC5kcmF3aW5nRWRnZXNcbiAgICAgID8gcHB0eS5nZXRFZGdlQ29sb3JCeVJlZmVyZW5jZSgpXG4gICAgICA6IHBwdHkuZ2V0QW1iaWVudENvbG9yQnlSZWZlcmVuY2UoKTtcbiAgICBwcm9ncmFtLnNldFVuaWZvcm0zZkFycmF5KCdhbWJpZW50Q29sb3JVbmlmb3JtJywgYUNvbG9yKTtcbiAgICBwcm9ncmFtLnNldFVuaWZvcm1mKCdhbWJpZW50JywgcHB0eS5nZXRBbWJpZW50KCkpO1xuXG4gICAgY29uc3QgZENvbG9yID0gbW9kZWwuZHJhd2luZ0VkZ2VzXG4gICAgICA/IHBwdHkuZ2V0RWRnZUNvbG9yQnlSZWZlcmVuY2UoKVxuICAgICAgOiBwcHR5LmdldERpZmZ1c2VDb2xvckJ5UmVmZXJlbmNlKCk7XG4gICAgcHJvZ3JhbS5zZXRVbmlmb3JtM2ZBcnJheSgnZGlmZnVzZUNvbG9yVW5pZm9ybScsIGRDb2xvcik7XG4gICAgcHJvZ3JhbS5zZXRVbmlmb3JtZignZGlmZnVzZScsIHBwdHkuZ2V0RGlmZnVzZSgpKTtcblxuICAgIC8vIHdlIGFyZSBkb25lIHVubGVzcyB3ZSBoYXZlIGxpZ2h0aW5nXG4gICAgY29uc3QgbGFzdExpZ2h0Q29tcGxleGl0eSA9IG1vZGVsLmxhc3RCb3VuZEJPLmdldFJlZmVyZW5jZUJ5TmFtZShcbiAgICAgICdsYXN0TGlnaHRDb21wbGV4aXR5J1xuICAgICk7XG4gICAgaWYgKGxhc3RMaWdodENvbXBsZXhpdHkgPCAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNDb2xvciA9IHBwdHkuZ2V0U3BlY3VsYXJDb2xvckJ5UmVmZXJlbmNlKCk7XG4gICAgcHJvZ3JhbS5zZXRVbmlmb3JtM2ZBcnJheSgnc3BlY3VsYXJDb2xvclVuaWZvcm0nLCBzQ29sb3IpO1xuICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoJ3NwZWN1bGFyJywgcHB0eS5nZXRTcGVjdWxhcigpKTtcbiAgICBwcm9ncmFtLnNldFVuaWZvcm1mKCdzcGVjdWxhclBvd2VyVW5pZm9ybScsIHBwdHkuZ2V0U3BlY3VsYXJQb3dlcigpKTtcblxuICAgIC8vIC8vIG5vdyBzZXQgdGhlIGJhY2tmYWNlIHByb3BlcnRpZXMgaWYgd2UgaGF2ZSB0aGVtXG4gICAgLy8gaWYgKGFjdG9yLmdldEJhY2tmYWNlUHJvcGVydHkoKSAmJiAhbW9kZWwuRHJhd2luZ0VkZ2VzKVxuICAgIC8vICAge1xuICAgIC8vICAgcHB0eSA9IGFjdG9yLmdldEJhY2tmYWNlUHJvcGVydHkoKTtcblxuICAgIC8vICAgbGV0IG9wYWNpdHkgPSBzdGF0aWNfY2FzdDxmbG9hdD4ocHB0eS5nZXRPcGFjaXR5KCkpO1xuICAgIC8vICAgZG91YmxlICphQ29sb3IgPSBwcHR5LmdldEFtYmllbnRDb2xvcigpO1xuICAgIC8vICAgZG91YmxlIGFJbnRlbnNpdHkgPSBwcHR5LmdldEFtYmllbnQoKTsgIC8vIGlnbm9yaW5nIHJlbmRlcmVyIGFtYmllbnRcbiAgICAvLyAgIGxldCBhbWJpZW50Q29sb3JbM10gPSB7c3RhdGljX2Nhc3Q8ZmxvYXQ+KGFDb2xvclswXSAqIGFJbnRlbnNpdHkpLFxuICAgIC8vICAgICBzdGF0aWNfY2FzdDxmbG9hdD4oYUNvbG9yWzFdICogYUludGVuc2l0eSksXG4gICAgLy8gICAgIHN0YXRpY19jYXN0PGZsb2F0PihhQ29sb3JbMl0gKiBhSW50ZW5zaXR5KX07XG4gICAgLy8gICBkb3VibGUgKmRDb2xvciA9IHBwdHkuZ2V0RGlmZnVzZUNvbG9yKCk7XG4gICAgLy8gICBkb3VibGUgZEludGVuc2l0eSA9IHBwdHkuZ2V0RGlmZnVzZSgpO1xuICAgIC8vICAgbGV0IGRpZmZ1c2VDb2xvclszXSA9IHtzdGF0aWNfY2FzdDxmbG9hdD4oZENvbG9yWzBdICogZEludGVuc2l0eSksXG4gICAgLy8gICAgIHN0YXRpY19jYXN0PGZsb2F0PihkQ29sb3JbMV0gKiBkSW50ZW5zaXR5KSxcbiAgICAvLyAgICAgc3RhdGljX2Nhc3Q8ZmxvYXQ+KGRDb2xvclsyXSAqIGRJbnRlbnNpdHkpfTtcbiAgICAvLyAgIGRvdWJsZSAqc0NvbG9yID0gcHB0eS5nZXRTcGVjdWxhckNvbG9yKCk7XG4gICAgLy8gICBkb3VibGUgc0ludGVuc2l0eSA9IHBwdHkuZ2V0U3BlY3VsYXIoKTtcbiAgICAvLyAgIGxldCBzcGVjdWxhckNvbG9yWzNdID0ge3N0YXRpY19jYXN0PGZsb2F0PihzQ29sb3JbMF0gKiBzSW50ZW5zaXR5KSxcbiAgICAvLyAgICAgc3RhdGljX2Nhc3Q8ZmxvYXQ+KHNDb2xvclsxXSAqIHNJbnRlbnNpdHkpLFxuICAgIC8vICAgICBzdGF0aWNfY2FzdDxmbG9hdD4oc0NvbG9yWzJdICogc0ludGVuc2l0eSl9O1xuICAgIC8vICAgZG91YmxlIHNwZWN1bGFyUG93ZXIgPSBwcHR5LmdldFNwZWN1bGFyUG93ZXIoKTtcblxuICAgIC8vICAgcHJvZ3JhbS5TZXRVbmlmb3JtZignb3BhY2l0eVVuaWZvcm1CRicsIG9wYWNpdHkpO1xuICAgIC8vICAgcHJvZ3JhbS5TZXRVbmlmb3JtM2YoJ2FtYmllbnRDb2xvclVuaWZvcm1CRicsIGFtYmllbnRDb2xvcik7XG4gICAgLy8gICBwcm9ncmFtLlNldFVuaWZvcm0zZignZGlmZnVzZUNvbG9yVW5pZm9ybUJGJywgZGlmZnVzZUNvbG9yKTtcbiAgICAvLyAgIC8vIHdlIGFyZSBkb25lIHVubGVzcyB3ZSBoYXZlIGxpZ2h0aW5nXG4gICAgLy8gICBpZiAobW9kZWwuTGFzdExpZ2h0Q29tcGxleGl0eVsmY2VsbEJPXSA8IDEpXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgcmV0dXJuO1xuICAgIC8vICAgICB9XG4gICAgLy8gICBwcm9ncmFtLlNldFVuaWZvcm0zZignc3BlY3VsYXJDb2xvclVuaWZvcm1CRicsIHNwZWN1bGFyQ29sb3IpO1xuICAgIC8vICAgcHJvZ3JhbS5TZXRVbmlmb3JtZignc3BlY3VsYXJQb3dlclVuaWZvcm1CRicsIHNwZWN1bGFyUG93ZXIpO1xuICAgIC8vICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5yZW5kZXJQaWVjZVN0YXJ0ID0gKHJlbiwgYWN0b3IpID0+IHtcbiAgICBtb2RlbC5wcmltaXRpdmVJRE9mZnNldCA9IDA7XG5cbiAgICBpZiAobW9kZWwub3BlbkdMUmVuZGVyZXIuZ2V0U2VsZWN0b3IoKSkge1xuICAgICAgc3dpdGNoIChtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRTZWxlY3RvcigpLmdldEN1cnJlbnRQYXNzKCkpIHtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRTZWxlY3RvcigpLnJlbmRlclByb3AoYWN0b3IpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGUgQk9zIGFyZSB1cCB0byBkYXRlXG4gICAgcHVibGljQVBJLnVwZGF0ZUJ1ZmZlck9iamVjdHMocmVuLCBhY3Rvcik7XG5cbiAgICAvLyBJZiB3ZSBhcmUgY29sb3JpbmcgYnkgdGV4dHVyZSwgdGhlbiBsb2FkIHRoZSB0ZXh0dXJlIG1hcC5cbiAgICAvLyBVc2UgTWFwIGFzIGluZGljYXRvciwgYmVjYXVzZSB0ZXh0dXJlIGhhbmdzIGFyb3VuZC5cbiAgICBpZiAobW9kZWwucmVuZGVyYWJsZS5nZXRDb2xvclRleHR1cmVNYXAoKSkge1xuICAgICAgbW9kZWwuaW50ZXJuYWxDb2xvclRleHR1cmUuYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBCaW5kIHRoZSBPcGVuR0wsIHRoaXMgaXMgc2hhcmVkIGJldHdlZW4gdGhlIGRpZmZlcmVudCBwcmltaXRpdmUvY2VsbCB0eXBlcy5cbiAgICBtb2RlbC5sYXN0Qm91bmRCTyA9IG51bGw7XG4gIH07XG5cbiAgcHVibGljQVBJLnJlbmRlclBpZWNlRHJhdyA9IChyZW4sIGFjdG9yKSA9PiB7XG4gICAgY29uc3QgcmVwcmVzZW50YXRpb24gPSBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldFJlcHJlc2VudGF0aW9uKCk7XG5cbiAgICBjb25zdCBnbCA9IG1vZGVsLmNvbnRleHQ7XG5cbiAgICBjb25zdCBkcmF3U3VyZmFjZVdpdGhFZGdlcyA9XG4gICAgICBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldEVkZ2VWaXNpYmlsaXR5KCkgJiZcbiAgICAgIHJlcHJlc2VudGF0aW9uID09PSBSZXByZXNlbnRhdGlvbi5TVVJGQUNFO1xuXG4gICAgZ2wubGluZVdpZHRoKGFjdG9yLmdldFByb3BlcnR5KCkuZ2V0TGluZVdpZHRoKCkpO1xuXG4gICAgLy8gZm9yIGV2ZXJ5IHByaW1pdGl2ZSB0eXBlXG4gICAgZm9yIChsZXQgaSA9IHByaW1UeXBlcy5TdGFydDsgaSA8IHByaW1UeXBlcy5FbmQ7IGkrKykge1xuICAgICAgLy8gaWYgdGhlcmUgYXJlIGVudHJpZXNcbiAgICAgIGNvbnN0IGNhYm8gPSBtb2RlbC5wcmltaXRpdmVzW2ldLmdldENBQk8oKTtcbiAgICAgIGlmIChjYWJvLmdldEVsZW1lbnRDb3VudCgpKSB7XG4gICAgICAgIC8vIGFyZSB3ZSBkcmF3aW5nIGVkZ2VzXG4gICAgICAgIG1vZGVsLmRyYXdpbmdFZGdlcyA9XG4gICAgICAgICAgZHJhd1N1cmZhY2VXaXRoRWRnZXMgJiZcbiAgICAgICAgICAoaSA9PT0gcHJpbVR5cGVzLlRyaXNFZGdlcyB8fCBpID09PSBwcmltVHlwZXMuVHJpU3RyaXBzRWRnZXMpO1xuICAgICAgICBjb25zdCBtb2RlID0gcHVibGljQVBJLmdldE9wZW5HTE1vZGUocmVwcmVzZW50YXRpb24sIGkpO1xuICAgICAgICBpZiAoIW1vZGVsLmRyYXdpbmdFZGdlcyB8fCAhbW9kZWwucmVuZGVyRGVwdGgpIHtcbiAgICAgICAgICBwdWJsaWNBUEkudXBkYXRlU2hhZGVycyhtb2RlbC5wcmltaXRpdmVzW2ldLCByZW4sIGFjdG9yKTtcbiAgICAgICAgICBnbC5kcmF3QXJyYXlzKG1vZGUsIDAsIGNhYm8uZ2V0RWxlbWVudENvdW50KCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmlkZSA9XG4gICAgICAgICAgKG1vZGUgPT09IGdsLlBPSU5UUyA/IDEgOiAwKSB8fCAobW9kZSA9PT0gZ2wuTElORVMgPyAyIDogMyk7XG4gICAgICAgIG1vZGVsLnByaW1pdGl2ZUlET2Zmc2V0ICs9IGNhYm8uZ2V0RWxlbWVudENvdW50KCkgLyBzdHJpZGU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHJlc2V0IHRoZSBsaW5lIHdpZHRoXG4gICAgZ2wubGluZVdpZHRoKDEpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRPcGVuR0xNb2RlID0gKHJlcCwgdHlwZSkgPT4ge1xuICAgIGlmIChyZXAgPT09IFJlcHJlc2VudGF0aW9uLlBPSU5UUyB8fCB0eXBlID09PSBwcmltVHlwZXMuUG9pbnRzKSB7XG4gICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5QT0lOVFM7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHJlcCA9PT0gUmVwcmVzZW50YXRpb24uV0lSRUZSQU1FIHx8XG4gICAgICB0eXBlID09PSBwcmltVHlwZXMuTGluZXMgfHxcbiAgICAgIHR5cGUgPT09IHByaW1UeXBlcy5UcmlzRWRnZXMgfHxcbiAgICAgIHR5cGUgPT09IHByaW1UeXBlcy5UcmlTdHJpcHNFZGdlc1xuICAgICkge1xuICAgICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuTElORVM7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbC5jb250ZXh0LlRSSUFOR0xFUztcbiAgfTtcblxuICBwdWJsaWNBUEkucmVuZGVyUGllY2VGaW5pc2ggPSAocmVuLCBhY3RvcikgPT4ge1xuICAgIGlmIChtb2RlbC5MYXN0Qm91bmRCTykge1xuICAgICAgbW9kZWwuTGFzdEJvdW5kQk8uZ2V0VkFPKCkucmVsZWFzZSgpO1xuICAgIH1cbiAgICBpZiAobW9kZWwucmVuZGVyYWJsZS5nZXRDb2xvclRleHR1cmVNYXAoKSkge1xuICAgICAgbW9kZWwuaW50ZXJuYWxDb2xvclRleHR1cmUuZGVhY3RpdmF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkucmVuZGVyUGllY2UgPSAocmVuLCBhY3RvcikgPT4ge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYmVlbiBwcm9wZXJseSBpbml0aWFsaXplZC5cbiAgICAvLyBpZiAocmVuLmdldFJlbmRlcldpbmRvdygpLmNoZWNrQWJvcnRTdGF0dXMoKSkge1xuICAgIC8vICAgcmV0dXJuO1xuICAgIC8vIH1cblxuICAgIHB1YmxpY0FQSS5pbnZva2VFdmVudChTdGFydEV2ZW50KTtcbiAgICBpZiAoIW1vZGVsLnJlbmRlcmFibGUuZ2V0U3RhdGljKCkpIHtcbiAgICAgIG1vZGVsLnJlbmRlcmFibGUudXBkYXRlKCk7XG4gICAgfVxuICAgIG1vZGVsLmN1cnJlbnRJbnB1dCA9IG1vZGVsLnJlbmRlcmFibGUuZ2V0SW5wdXREYXRhKCk7XG4gICAgcHVibGljQVBJLmludm9rZUV2ZW50KEVuZEV2ZW50KTtcblxuICAgIGlmICghbW9kZWwuY3VycmVudElucHV0KSB7XG4gICAgICB2dGtFcnJvck1hY3JvKCdObyBpbnB1dCEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIHRoZW4gd2UgYXJlIGRvbmVcbiAgICBpZiAoXG4gICAgICAhbW9kZWwuY3VycmVudElucHV0LmdldFBvaW50cyB8fFxuICAgICAgIW1vZGVsLmN1cnJlbnRJbnB1dC5nZXRQb2ludHMoKS5nZXROdW1iZXJPZlZhbHVlcygpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgZmFjZUN1bGxpbmdcbiAgICBjb25zdCBnbCA9IG1vZGVsLmNvbnRleHQ7XG4gICAgY29uc3QgYmFja2ZhY2VDdWxsaW5nID0gYWN0b3IuZ2V0UHJvcGVydHkoKS5nZXRCYWNrZmFjZUN1bGxpbmcoKTtcbiAgICBjb25zdCBmcm9udGZhY2VDdWxsaW5nID0gYWN0b3IuZ2V0UHJvcGVydHkoKS5nZXRGcm9udGZhY2VDdWxsaW5nKCk7XG4gICAgaWYgKCFiYWNrZmFjZUN1bGxpbmcgJiYgIWZyb250ZmFjZUN1bGxpbmcpIHtcbiAgICAgIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5kaXNhYmxlQ3VsbEZhY2UoKTtcbiAgICB9IGVsc2UgaWYgKGZyb250ZmFjZUN1bGxpbmcpIHtcbiAgICAgIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5lbmFibGVDdWxsRmFjZSgpO1xuICAgICAgZ2wuY3VsbEZhY2UoZ2wuRlJPTlQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZW5hYmxlQ3VsbEZhY2UoKTtcbiAgICAgIGdsLmN1bGxGYWNlKGdsLkJBQ0spO1xuICAgIH1cblxuICAgIHB1YmxpY0FQSS5yZW5kZXJQaWVjZVN0YXJ0KHJlbiwgYWN0b3IpO1xuICAgIHB1YmxpY0FQSS5yZW5kZXJQaWVjZURyYXcocmVuLCBhY3Rvcik7XG4gICAgcHVibGljQVBJLnJlbmRlclBpZWNlRmluaXNoKHJlbiwgYWN0b3IpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5jb21wdXRlQm91bmRzID0gKHJlbiwgYWN0b3IpID0+IHtcbiAgICBpZiAoIXB1YmxpY0FQSS5nZXRJbnB1dCgpKSB7XG4gICAgICB2dGtNYXRoLnVuaW5pdGlhbGl6ZUJvdW5kcyhtb2RlbC5ib3VuZHMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtb2RlbC5ib3VuZHMgPSBwdWJsaWNBUEkuZ2V0SW5wdXQoKS5nZXRCb3VuZHMoKTtcbiAgfTtcblxuICBwdWJsaWNBUEkudXBkYXRlQnVmZmVyT2JqZWN0cyA9IChyZW4sIGFjdG9yKSA9PiB7XG4gICAgLy8gUmVidWlsZCBidWZmZXJzIGlmIG5lZWRlZFxuICAgIGlmIChwdWJsaWNBUEkuZ2V0TmVlZFRvUmVidWlsZEJ1ZmZlck9iamVjdHMocmVuLCBhY3RvcikpIHtcbiAgICAgIHB1YmxpY0FQSS5idWlsZEJ1ZmZlck9iamVjdHMocmVuLCBhY3Rvcik7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXROZWVkVG9SZWJ1aWxkQnVmZmVyT2JqZWN0cyA9IChyZW4sIGFjdG9yKSA9PiB7XG4gICAgLy8gZmlyc3QgZG8gYSBjb2Fyc2UgY2hlY2tcbiAgICAvLyBOb3RlIHRoYXQgdGhlIGFjdG9yJ3MgbXRpbWUgaW5jbHVkZXMgaXQncyBwcm9wZXJ0aWVzIG10aW1lXG4gICAgY29uc3Qgdm10aW1lID0gbW9kZWwuVkJPQnVpbGRUaW1lLmdldE1UaW1lKCk7XG4gICAgaWYgKFxuICAgICAgdm10aW1lIDwgcHVibGljQVBJLmdldE1UaW1lKCkgfHxcbiAgICAgIHZtdGltZSA8IG1vZGVsLnJlbmRlcmFibGUuZ2V0TVRpbWUoKSB8fFxuICAgICAgdm10aW1lIDwgYWN0b3IuZ2V0TVRpbWUoKSB8fFxuICAgICAgdm10aW1lIDwgbW9kZWwuY3VycmVudElucHV0LmdldE1UaW1lKClcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcHVibGljQVBJLmJ1aWxkQnVmZmVyT2JqZWN0cyA9IChyZW4sIGFjdG9yKSA9PiB7XG4gICAgY29uc3QgcG9seSA9IG1vZGVsLmN1cnJlbnRJbnB1dDtcblxuICAgIGlmIChwb2x5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbW9kZWwucmVuZGVyYWJsZS5tYXBTY2FsYXJzKHBvbHksIDEuMCk7XG4gICAgY29uc3QgYyA9IG1vZGVsLnJlbmRlcmFibGUuZ2V0Q29sb3JNYXBDb2xvcnMoKTtcblxuICAgIG1vZGVsLmhhdmVDZWxsU2NhbGFycyA9IGZhbHNlO1xuICAgIGNvbnN0IHNjYWxhck1vZGUgPSBtb2RlbC5yZW5kZXJhYmxlLmdldFNjYWxhck1vZGUoKTtcbiAgICBpZiAobW9kZWwucmVuZGVyYWJsZS5nZXRTY2FsYXJWaXNpYmlsaXR5KCkpIHtcbiAgICAgIC8vIFdlIG11c3QgZmlndXJlIG91dCBob3cgdGhlIHNjYWxhcnMgc2hvdWxkIGJlIG1hcHBlZCB0byB0aGUgcG9seWRhdGEuXG4gICAgICBpZiAoXG4gICAgICAgIChzY2FsYXJNb2RlID09PSBTY2FsYXJNb2RlLlVTRV9DRUxMX0RBVEEgfHxcbiAgICAgICAgICBzY2FsYXJNb2RlID09PSBTY2FsYXJNb2RlLlVTRV9DRUxMX0ZJRUxEX0RBVEEgfHxcbiAgICAgICAgICBzY2FsYXJNb2RlID09PSBTY2FsYXJNb2RlLlVTRV9GSUVMRF9EQVRBIHx8XG4gICAgICAgICAgIXBvbHkuZ2V0UG9pbnREYXRhKCkuZ2V0U2NhbGFycygpKSAmJlxuICAgICAgICBzY2FsYXJNb2RlICE9PSBTY2FsYXJNb2RlLlVTRV9QT0lOVF9GSUVMRF9EQVRBICYmXG4gICAgICAgIGNcbiAgICAgICkge1xuICAgICAgICBtb2RlbC5oYXZlQ2VsbFNjYWxhcnMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERvIHdlIGhhdmUgbm9ybWFscz9cbiAgICBsZXQgbiA9XG4gICAgICBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldEludGVycG9sYXRpb24oKSAhPT0gU2hhZGluZy5GTEFUXG4gICAgICAgID8gcG9seS5nZXRQb2ludERhdGEoKS5nZXROb3JtYWxzKClcbiAgICAgICAgOiBudWxsO1xuICAgIGlmIChuID09PSBudWxsICYmIHBvbHkuZ2V0Q2VsbERhdGEoKS5nZXROb3JtYWxzKCkpIHtcbiAgICAgIG1vZGVsLmhhdmVDZWxsTm9ybWFscyA9IHRydWU7XG4gICAgICBuID0gcG9seS5nZXRDZWxsRGF0YSgpLmdldE5vcm1hbHMoKTtcbiAgICB9XG5cbiAgICAvLyByZWJ1aWxkIHRoZSBWQk8gaWYgdGhlIGRhdGEgaGFzIGNoYW5nZWQgd2UgY3JlYXRlIGEgc3RyaW5nIGZvciB0aGUgVkJPIHdoYXRcbiAgICAvLyBjYW4gY2hhbmdlIHRoZSBWQk8/IHBvaW50cyBub3JtYWxzIHRjb29yZHMgY29sb3JzIHNvIHdoYXQgY2FuIGNoYW5nZSB0aG9zZT9cbiAgICAvLyB0aGUgaW5wdXQgZGF0YSBpcyBjbGVhcmx5IG9uZSBhcyBpdCBjYW4gY2hhbmdlIGFsbCBmb3VyIGl0ZW1zIHRjb29yZHMgbWF5XG4gICAgLy8gaGF2ZVRleHR1cmVzIG9yIG5vdCBjb2xvcnMgbWF5IGNoYW5nZSBiYXNlZCBvbiBxdWl0ZSBhIGZldyBtYXBwaW5nXG4gICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgbWFwcGVyXG5cbiAgICBjb25zdCByZXByZXNlbnRhdGlvbiA9IGFjdG9yLmdldFByb3BlcnR5KCkuZ2V0UmVwcmVzZW50YXRpb24oKTtcblxuICAgIGxldCB0Y29vcmRzID0gcG9seS5nZXRQb2ludERhdGEoKS5nZXRUQ29vcmRzKCk7XG4gICAgaWYgKCFtb2RlbC5vcGVuR0xBY3Rvci5nZXRBY3RpdmVUZXh0dXJlcygpKSB7XG4gICAgICB0Y29vcmRzID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgY29sb3IgbWFwcGluZyB2aWEgdGV4dHVyZVxuICAgIGlmIChtb2RlbC5yZW5kZXJhYmxlLmdldENvbG9yQ29vcmRpbmF0ZXMoKSkge1xuICAgICAgdGNvb3JkcyA9IG1vZGVsLnJlbmRlcmFibGUuZ2V0Q29sb3JDb29yZGluYXRlcygpO1xuICAgICAgaWYgKCFtb2RlbC5pbnRlcm5hbENvbG9yVGV4dHVyZSkge1xuICAgICAgICBtb2RlbC5pbnRlcm5hbENvbG9yVGV4dHVyZSA9IHZ0a09wZW5HTFRleHR1cmUubmV3SW5zdGFuY2UoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleCA9IG1vZGVsLmludGVybmFsQ29sb3JUZXh0dXJlO1xuICAgICAgLy8gdGhlIGZvbGxvd2luZyA0IGxpbmVzIGFsbG93IGZvciBOUE9UIHRleHR1cmVzXG4gICAgICB0ZXguc2V0TWluaWZpY2F0aW9uRmlsdGVyKEZpbHRlci5ORUFSRVNUKTtcbiAgICAgIHRleC5zZXRNYWduaWZpY2F0aW9uRmlsdGVyKEZpbHRlci5ORUFSRVNUKTtcbiAgICAgIHRleC5zZXRXcmFwUyhXcmFwLkNMQU1QX1RPX0VER0UpO1xuICAgICAgdGV4LnNldFdyYXBUKFdyYXAuQ0xBTVBfVE9fRURHRSk7XG4gICAgICB0ZXguc2V0T3BlbkdMUmVuZGVyV2luZG93KG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyk7XG5cbiAgICAgIGNvbnN0IGlucHV0ID0gbW9kZWwucmVuZGVyYWJsZS5nZXRDb2xvclRleHR1cmVNYXAoKTtcbiAgICAgIGNvbnN0IGV4dCA9IGlucHV0LmdldEV4dGVudCgpO1xuICAgICAgY29uc3QgaW5TY2FsYXJzID0gaW5wdXQuZ2V0UG9pbnREYXRhKCkuZ2V0U2NhbGFycygpO1xuICAgICAgdGV4LmNyZWF0ZTJERnJvbVJhdyhcbiAgICAgICAgZXh0WzFdIC0gZXh0WzBdICsgMSxcbiAgICAgICAgZXh0WzNdIC0gZXh0WzJdICsgMSxcbiAgICAgICAgaW5TY2FsYXJzLmdldE51bWJlck9mQ29tcG9uZW50cygpLFxuICAgICAgICBpblNjYWxhcnMuZ2V0RGF0YVR5cGUoKSxcbiAgICAgICAgaW5TY2FsYXJzLmdldERhdGEoKVxuICAgICAgKTtcbiAgICAgIHRleC5hY3RpdmF0ZSgpO1xuICAgICAgdGV4LnNlbmRQYXJhbWV0ZXJzKCk7XG4gICAgICB0ZXguZGVhY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IHRvU3RyaW5nID1cbiAgICAgIGAke3BvbHkuZ2V0TVRpbWUoKX1BJHtyZXByZXNlbnRhdGlvbn1CJHtwb2x5LmdldE1UaW1lKCl9YCArXG4gICAgICBgQyR7biA/IG4uZ2V0TVRpbWUoKSA6IDF9RCR7YyA/IGMuZ2V0TVRpbWUoKSA6IDF9YCArXG4gICAgICBgRSR7YWN0b3IuZ2V0UHJvcGVydHkoKS5nZXRFZGdlVmlzaWJpbGl0eSgpfWAgK1xuICAgICAgYEYke3Rjb29yZHMgPyB0Y29vcmRzLmdldE1UaW1lKCkgOiAxfWA7XG4gICAgaWYgKG1vZGVsLlZCT0J1aWxkU3RyaW5nICE9PSB0b1N0cmluZykge1xuICAgICAgLy8gQnVpbGQgdGhlIFZCT3NcbiAgICAgIGNvbnN0IHBvaW50cyA9IHBvbHkuZ2V0UG9pbnRzKCk7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBwb2ludHMsXG4gICAgICAgIG5vcm1hbHM6IG4sXG4gICAgICAgIHRjb29yZHMsXG4gICAgICAgIGNvbG9yczogYyxcbiAgICAgICAgY2VsbE9mZnNldDogMCxcbiAgICAgICAgaGF2ZUNlbGxTY2FsYXJzOiBtb2RlbC5oYXZlQ2VsbFNjYWxhcnMsXG4gICAgICAgIGhhdmVDZWxsTm9ybWFsczogbW9kZWwuaGF2ZUNlbGxOb3JtYWxzLFxuICAgICAgICBjdXN0b21BdHRyaWJ1dGVzOiBtb2RlbC5yZW5kZXJhYmxlXG4gICAgICAgICAgLmdldEN1c3RvbVNoYWRlckF0dHJpYnV0ZXMoKVxuICAgICAgICAgIC5tYXAoKGFycmF5TmFtZSkgPT4gcG9seS5nZXRQb2ludERhdGEoKS5nZXRBcnJheUJ5TmFtZShhcnJheU5hbWUpKSxcbiAgICAgIH07XG4gICAgICBvcHRpb25zLmNlbGxPZmZzZXQgKz0gbW9kZWwucHJpbWl0aXZlc1twcmltVHlwZXMuUG9pbnRzXVxuICAgICAgICAuZ2V0Q0FCTygpXG4gICAgICAgIC5jcmVhdGVWQk8ocG9seS5nZXRWZXJ0cygpLCAndmVydHMnLCByZXByZXNlbnRhdGlvbiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmNlbGxPZmZzZXQgKz0gbW9kZWwucHJpbWl0aXZlc1twcmltVHlwZXMuTGluZXNdXG4gICAgICAgIC5nZXRDQUJPKClcbiAgICAgICAgLmNyZWF0ZVZCTyhwb2x5LmdldExpbmVzKCksICdsaW5lcycsIHJlcHJlc2VudGF0aW9uLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuY2VsbE9mZnNldCArPSBtb2RlbC5wcmltaXRpdmVzW3ByaW1UeXBlcy5UcmlzXVxuICAgICAgICAuZ2V0Q0FCTygpXG4gICAgICAgIC5jcmVhdGVWQk8ocG9seS5nZXRQb2x5cygpLCAncG9seXMnLCByZXByZXNlbnRhdGlvbiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmNlbGxPZmZzZXQgKz0gbW9kZWwucHJpbWl0aXZlc1twcmltVHlwZXMuVHJpU3RyaXBzXVxuICAgICAgICAuZ2V0Q0FCTygpXG4gICAgICAgIC5jcmVhdGVWQk8ocG9seS5nZXRTdHJpcHMoKSwgJ3N0cmlwcycsIHJlcHJlc2VudGF0aW9uLCBvcHRpb25zKTtcblxuICAgICAgY29uc3QgZHJhd1N1cmZhY2VXaXRoRWRnZXMgPVxuICAgICAgICBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldEVkZ2VWaXNpYmlsaXR5KCkgJiZcbiAgICAgICAgcmVwcmVzZW50YXRpb24gPT09IFJlcHJlc2VudGF0aW9uLlNVUkZBQ0U7XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgZWRnZSB2aXNpYmlsaXR5IGJ1aWxkIHRoZSBlZGdlIFZCT3NcbiAgICAgIGlmIChkcmF3U3VyZmFjZVdpdGhFZGdlcykge1xuICAgICAgICBtb2RlbC5wcmltaXRpdmVzW3ByaW1UeXBlcy5UcmlzRWRnZXNdXG4gICAgICAgICAgLmdldENBQk8oKVxuICAgICAgICAgIC5jcmVhdGVWQk8ocG9seS5nZXRQb2x5cygpLCAncG9seXMnLCBSZXByZXNlbnRhdGlvbi5XSVJFRlJBTUUsIHtcbiAgICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICAgIG5vcm1hbHM6IG4sXG4gICAgICAgICAgICB0Y29vcmRzOiBudWxsLFxuICAgICAgICAgICAgY29sb3JzOiBudWxsLFxuICAgICAgICAgICAgY2VsbE9mZnNldDogMCxcbiAgICAgICAgICAgIGhhdmVDZWxsU2NhbGFyczogZmFsc2UsXG4gICAgICAgICAgICBoYXZlQ2VsbE5vcm1hbHM6IGZhbHNlLFxuICAgICAgICAgIH0pO1xuICAgICAgICBtb2RlbC5wcmltaXRpdmVzW3ByaW1UeXBlcy5UcmlTdHJpcHNFZGdlc11cbiAgICAgICAgICAuZ2V0Q0FCTygpXG4gICAgICAgICAgLmNyZWF0ZVZCTyhwb2x5LmdldFN0cmlwcygpLCAnc3RyaXBzJywgUmVwcmVzZW50YXRpb24uV0lSRUZSQU1FLCB7XG4gICAgICAgICAgICBwb2ludHMsXG4gICAgICAgICAgICBub3JtYWxzOiBuLFxuICAgICAgICAgICAgdGNvb3JkczogbnVsbCxcbiAgICAgICAgICAgIGNvbG9yczogbnVsbCxcbiAgICAgICAgICAgIGNlbGxPZmZzZXQ6IDAsXG4gICAgICAgICAgICBoYXZlQ2VsbFNjYWxhcnM6IGZhbHNlLFxuICAgICAgICAgICAgaGF2ZUNlbGxOb3JtYWxzOiBmYWxzZSxcbiAgICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBmcmVlIHRoZW1cbiAgICAgICAgbW9kZWwucHJpbWl0aXZlc1twcmltVHlwZXMuVHJpc0VkZ2VzXS5yZWxlYXNlR3JhcGhpY3NSZXNvdXJjZXMoXG4gICAgICAgICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93XG4gICAgICAgICk7XG4gICAgICAgIG1vZGVsLnByaW1pdGl2ZXNbcHJpbVR5cGVzLlRyaVN0cmlwc0VkZ2VzXS5yZWxlYXNlR3JhcGhpY3NSZXNvdXJjZXMoXG4gICAgICAgICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG1vZGVsLlZCT0J1aWxkVGltZS5tb2RpZmllZCgpO1xuICAgICAgbW9kZWwuVkJPQnVpbGRTdHJpbmcgPSB0b1N0cmluZztcbiAgICB9XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBjb250ZXh0OiBudWxsLFxuICBWQk9CdWlsZFRpbWU6IDAsXG4gIFZCT0J1aWxkU3RyaW5nOiBudWxsLFxuICBwcmltaXRpdmVzOiBudWxsLFxuICBwcmltVHlwZXM6IG51bGwsXG4gIHNoYWRlclJlYnVpbGRTdHJpbmc6IG51bGwsXG4gIHRtcE1hdDQ6IG51bGwsXG4gIGFtYmllbnRDb2xvcjogW10sIC8vIHVzZWQgaW50ZXJuYWxseVxuICBkaWZmdXNlQ29sb3I6IFtdLCAvLyB1c2VkIGludGVybmFsbHlcbiAgc3BlY3VsYXJDb2xvcjogW10sIC8vIHVzZWQgaW50ZXJuYWxseVxuICBsaWdodENvbG9yOiBbXSwgLy8gdXNlZCBpbnRlcm5hbGx5XG4gIGxpZ2h0SGFsZkFuZ2xlOiBbXSwgLy8gdXNlZCBpbnRlcm5hbGx5XG4gIGxpZ2h0RGlyZWN0aW9uOiBbXSwgLy8gdXNlZCBpbnRlcm5hbGx5XG4gIGxhc3RIYXZlU2VlbkRlcHRoUmVxdWVzdDogZmFsc2UsXG4gIGhhdmVTZWVuRGVwdGhSZXF1ZXN0OiBmYWxzZSxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEluaGVyaXRhbmNlXG4gIHZ0a1ZpZXdOb2RlLmV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzKTtcbiAgdnRrUmVwbGFjZW1lbnRTaGFkZXJNYXBwZXIuaW1wbGVtZW50UmVwbGFjZVNoYWRlckNvaW5jaWRlbnRPZmZzZXQoXG4gICAgcHVibGljQVBJLFxuICAgIG1vZGVsLFxuICAgIGluaXRpYWxWYWx1ZXNcbiAgKTtcblxuICBtb2RlbC5wcmltaXRpdmVzID0gW107XG4gIG1vZGVsLnByaW1UeXBlcyA9IHByaW1UeXBlcztcblxuICBtb2RlbC50bXBNYXQzID0gbWF0My5jcmVhdGUoKTtcbiAgbW9kZWwudG1wTWF0NCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgZm9yIChsZXQgaSA9IHByaW1UeXBlcy5TdGFydDsgaSA8IHByaW1UeXBlcy5FbmQ7IGkrKykge1xuICAgIG1vZGVsLnByaW1pdGl2ZXNbaV0gPSB2dGtIZWxwZXIubmV3SW5zdGFuY2UoKTtcbiAgICBtb2RlbC5wcmltaXRpdmVzW2ldLnNldFByaW1pdGl2ZVR5cGUoaSk7XG4gICAgbW9kZWwucHJpbWl0aXZlc1tpXS5zZXQoXG4gICAgICB7IGxhc3RMaWdodENvbXBsZXhpdHk6IDAsIGxhc3RMaWdodENvdW50OiAwLCBsYXN0U2VsZWN0aW9uUGFzczogZmFsc2UgfSxcbiAgICAgIHRydWVcbiAgICApO1xuICB9XG5cbiAgLy8gQnVpbGQgVlRLIEFQSVxuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgWydjb250ZXh0J10pO1xuXG4gIG1vZGVsLlZCT0J1aWxkVGltZSA9IHt9O1xuICBtYWNyby5vYmoobW9kZWwuVkJPQnVpbGRUaW1lLCB7IG10aW1lOiAwIH0pO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIHZ0a09wZW5HTFBvbHlEYXRhTWFwcGVyKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a09wZW5HTFBvbHlEYXRhTWFwcGVyJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kIH07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0IHZ0a0ZvcndhcmRQYXNzIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvRm9yd2FyZFBhc3MnO1xuaW1wb3J0IHZ0a09wZW5HTFZpZXdOb2RlRmFjdG9yeSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1ZpZXdOb2RlRmFjdG9yeSc7XG5pbXBvcnQgdnRrUmVuZGVyUGFzcyBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvU2NlbmVHcmFwaC9SZW5kZXJQYXNzJztcbmltcG9ydCB2dGtTaGFkZXJDYWNoZSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1NoYWRlckNhY2hlJztcbmltcG9ydCB2dGtWaWV3Tm9kZSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvU2NlbmVHcmFwaC9WaWV3Tm9kZSc7XG5pbXBvcnQgdnRrT3BlbkdMVGV4dHVyZVVuaXRNYW5hZ2VyIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvVGV4dHVyZVVuaXRNYW5hZ2VyJztcbmltcG9ydCB7IFZ0a0RhdGFUeXBlcyB9IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL0RhdGFBcnJheS9Db25zdGFudHMnO1xuaW1wb3J0IFdlYlZSUG9seWZpbGwgZnJvbSAnd2VidnItcG9seWZpbGwnO1xuXG5jb25zdCB7IHZ0a0RlYnVnTWFjcm8sIHZ0a0Vycm9yTWFjcm8gfSA9IG1hY3JvO1xuY29uc3QgSVNfQ0hST01FID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSAhPT0gLTE7XG5cbmZ1bmN0aW9uIGNoZWNrUmVuZGVyVGFyZ2V0U3VwcG9ydChnbCwgZm9ybWF0LCB0eXBlKSB7XG4gIC8vIGNyZWF0ZSB0ZW1wb3JhcnkgZnJhbWUgYnVmZmVyIGFuZCB0ZXh0dXJlXG4gIGNvbnN0IGZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIDIsIDIsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbCk7XG5cbiAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKFxuICAgIGdsLkZSQU1FQlVGRkVSLFxuICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxuICAgIGdsLlRFWFRVUkVfMkQsXG4gICAgdGV4dHVyZSxcbiAgICAwXG4gICk7XG5cbiAgLy8gY2hlY2sgZnJhbWUgYnVmZmVyIHN0YXR1c1xuICBjb25zdCBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcblxuICAvLyBjbGVhbiB1cFxuICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcblxuICByZXR1cm4gc3RhdHVzID09PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTW9uaXRvciB0aGUgdXNhZ2Ugb2YgR0wgY29udGV4dCBhY3Jvc3MgdnRrT3BlbkdMUmVuZGVyV2luZG93IGluc3RhbmNlc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5sZXQgR0xfQ09OVEVYVF9DT1VOVCA9IDA7XG5jb25zdCBHTF9DT05URVhUX0xJU1RFTkVSUyA9IFtdO1xuXG5mdW5jdGlvbiBjcmVhdGVHTENvbnRleHQoKSB7XG4gIEdMX0NPTlRFWFRfQ09VTlQrKztcbiAgR0xfQ09OVEVYVF9MSVNURU5FUlMuZm9yRWFjaCgoY2IpID0+IGNiKEdMX0NPTlRFWFRfQ09VTlQpKTtcbn1cblxuZnVuY3Rpb24gZGVsZXRlR0xDb250ZXh0KCkge1xuICBHTF9DT05URVhUX0NPVU5ULS07XG4gIEdMX0NPTlRFWFRfTElTVEVORVJTLmZvckVhY2goKGNiKSA9PiBjYihHTF9DT05URVhUX0NPVU5UKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwdXNoTW9uaXRvckdMQ29udGV4dENvdW50KGNiKSB7XG4gIEdMX0NPTlRFWFRfTElTVEVORVJTLnB1c2goY2IpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wTW9uaXRvckdMQ29udGV4dENvdW50KGNiKSB7XG4gIHJldHVybiBHTF9DT05URVhUX0xJU1RFTkVSUy5wb3AoKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrT3BlbkdMUmVuZGVyV2luZG93IG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrT3BlbkdMUmVuZGVyV2luZG93KHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrT3BlbkdMUmVuZGVyV2luZG93Jyk7XG5cbiAgLy8gQXV0byB1cGRhdGUgc3R5bGVcbiAgY29uc3QgcHJldmlvdXNTaXplID0gWzAsIDBdO1xuICBmdW5jdGlvbiB1cGRhdGVXaW5kb3coKSB7XG4gICAgLy8gQ2FudmFzIHNpemVcbiAgICBpZiAobW9kZWwucmVuZGVyYWJsZSkge1xuICAgICAgaWYgKFxuICAgICAgICBtb2RlbC5zaXplWzBdICE9PSBwcmV2aW91c1NpemVbMF0gfHxcbiAgICAgICAgbW9kZWwuc2l6ZVsxXSAhPT0gcHJldmlvdXNTaXplWzFdXG4gICAgICApIHtcbiAgICAgICAgcHJldmlvdXNTaXplWzBdID0gbW9kZWwuc2l6ZVswXTtcbiAgICAgICAgcHJldmlvdXNTaXplWzFdID0gbW9kZWwuc2l6ZVsxXTtcbiAgICAgICAgbW9kZWwuY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBtb2RlbC5zaXplWzBdKTtcbiAgICAgICAgbW9kZWwuY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgbW9kZWwuc2l6ZVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW1hZ2VTdHJlYW0gc2l6ZVxuICAgIGlmIChtb2RlbC52aWV3U3RyZWFtKSB7XG4gICAgICAvLyBJZiBzYW1lIHNpemUgdGhhdCdzIGEgTm9PcFxuICAgICAgbW9kZWwudmlld1N0cmVhbS5zZXRTaXplKG1vZGVsLnNpemVbMF0sIG1vZGVsLnNpemVbMV0pO1xuICAgIH1cblxuICAgIC8vIE9mZnNjcmVlbiA/XG4gICAgbW9kZWwuY2FudmFzLnN0eWxlLmRpc3BsYXkgPSBtb2RlbC51c2VPZmZTY3JlZW4gPyAnbm9uZScgOiAnYmxvY2snO1xuXG4gICAgLy8gQ3Vyc29yIHR5cGVcbiAgICBpZiAobW9kZWwuZWwpIHtcbiAgICAgIG1vZGVsLmVsLnN0eWxlLmN1cnNvciA9IG1vZGVsLmN1cnNvclZpc2liaWxpdHkgPyBtb2RlbC5jdXJzb3IgOiAnbm9uZSc7XG4gICAgfVxuXG4gICAgLy8gSW52YWxpZGF0ZSBjYWNoZWQgRE9NIGNvbnRhaW5lciBzaXplXG4gICAgbW9kZWwuY29udGFpbmVyU2l6ZSA9IG51bGw7XG4gIH1cbiAgcHVibGljQVBJLm9uTW9kaWZpZWQodXBkYXRlV2luZG93KTtcblxuICAvLyBCdWlsZHMgbXlzZWxmLlxuICBwdWJsaWNBUEkuYnVpbGRQYXNzID0gKHByZXBhc3MpID0+IHtcbiAgICBpZiAocHJlcGFzcykge1xuICAgICAgaWYgKCFtb2RlbC5yZW5kZXJhYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcHVibGljQVBJLnByZXBhcmVOb2RlcygpO1xuICAgICAgcHVibGljQVBJLmFkZE1pc3NpbmdOb2Rlcyhtb2RlbC5yZW5kZXJhYmxlLmdldFJlbmRlcmVyc0J5UmVmZXJlbmNlKCkpO1xuICAgICAgcHVibGljQVBJLnJlbW92ZVVudXNlZE5vZGVzKCk7XG5cbiAgICAgIHB1YmxpY0FQSS5pbml0aWFsaXplKCk7XG4gICAgICBtb2RlbC5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICBjaGlsZC5zZXRPcGVuR0xSZW5kZXJXaW5kb3cocHVibGljQVBJKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuaW5pdGlhbGl6ZSA9ICgpID0+IHtcbiAgICBpZiAoIW1vZGVsLmluaXRpYWxpemVkKSB7XG4gICAgICBtb2RlbC5jb250ZXh0ID0gcHVibGljQVBJLmdldDNEQ29udGV4dCgpO1xuICAgICAgbW9kZWwudGV4dHVyZVVuaXRNYW5hZ2VyID0gdnRrT3BlbkdMVGV4dHVyZVVuaXRNYW5hZ2VyLm5ld0luc3RhbmNlKCk7XG4gICAgICBtb2RlbC50ZXh0dXJlVW5pdE1hbmFnZXIuc2V0Q29udGV4dChtb2RlbC5jb250ZXh0KTtcbiAgICAgIG1vZGVsLnNoYWRlckNhY2hlLnNldENvbnRleHQobW9kZWwuY29udGV4dCk7XG4gICAgICAvLyBpbml0aWFsaXplIGJsZW5kaW5nIGZvciB0cmFuc3BhcmVuY3lcbiAgICAgIGNvbnN0IGdsID0gbW9kZWwuY29udGV4dDtcbiAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKFxuICAgICAgICBnbC5TUkNfQUxQSEEsXG4gICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsXG4gICAgICAgIGdsLk9ORSxcbiAgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQVxuICAgICAgKTtcbiAgICAgIGdsLmRlcHRoRnVuYyhnbC5MRVFVQUwpO1xuICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcbiAgICAgIG1vZGVsLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLm1ha2VDdXJyZW50ID0gKCkgPT4ge1xuICAgIG1vZGVsLmNvbnRleHQubWFrZUN1cnJlbnQoKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0Q29udGFpbmVyID0gKGVsKSA9PiB7XG4gICAgaWYgKG1vZGVsLmVsICYmIG1vZGVsLmVsICE9PSBlbCkge1xuICAgICAgaWYgKG1vZGVsLmNhbnZhcy5wYXJlbnROb2RlICE9PSBtb2RlbC5lbCkge1xuICAgICAgICB2dGtFcnJvck1hY3JvKCdFcnJvcjogY2FudmFzIHBhcmVudCBub2RlIGRvZXMgbm90IG1hdGNoIGNvbnRhaW5lcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgY2FudmFzIGZyb20gcHJldmlvdXMgY29udGFpbmVyXG4gICAgICBtb2RlbC5lbC5yZW1vdmVDaGlsZChtb2RlbC5jYW52YXMpO1xuXG4gICAgICAvLyBJZiB0aGUgcmVuZGVyZXIgaGFzIHByZXZpb3VzbHkgYWRkZWRcbiAgICAgIC8vIGEgYmFja2dyb3VuZCBpbWFnZSwgcmVtb3ZlIGl0IGZyb20gdGhlIERPTS5cbiAgICAgIGlmIChtb2RlbC5lbC5jb250YWlucyhtb2RlbC5iZ0ltYWdlKSkge1xuICAgICAgICBtb2RlbC5lbC5yZW1vdmVDaGlsZChtb2RlbC5iZ0ltYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kZWwuZWwgIT09IGVsKSB7XG4gICAgICBtb2RlbC5lbCA9IGVsO1xuICAgICAgaWYgKG1vZGVsLmVsKSB7XG4gICAgICAgIG1vZGVsLmVsLmFwcGVuZENoaWxkKG1vZGVsLmNhbnZhcyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHJlbmRlcmVyIGlzIHNldCB0byB1c2UgYSBiYWNrZ3JvdW5kXG4gICAgICAgIC8vIGltYWdlLCBhdHRhY2ggaXQgdG8gdGhlIERPTS5cbiAgICAgICAgaWYgKG1vZGVsLnVzZUJhY2tncm91bmRJbWFnZSkge1xuICAgICAgICAgIG1vZGVsLmVsLmFwcGVuZENoaWxkKG1vZGVsLmJnSW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRyaWdnZXIgbW9kaWZpZWQoKVxuICAgICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRDb250YWluZXIgPSAoKSA9PiBtb2RlbC5lbDtcblxuICBwdWJsaWNBUEkuZ2V0Q29udGFpbmVyU2l6ZSA9ICgpID0+IHtcbiAgICBpZiAoIW1vZGVsLmNvbnRhaW5lclNpemUgJiYgbW9kZWwuZWwpIHtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gbW9kZWwuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBtb2RlbC5jb250YWluZXJTaXplID0gW3dpZHRoLCBoZWlnaHRdO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWwuY29udGFpbmVyU2l6ZSB8fCBtb2RlbC5zaXplO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRGcmFtZWJ1ZmZlclNpemUgPSAoKSA9PiB7XG4gICAgaWYgKG1vZGVsLmFjdGl2ZUZyYW1lYnVmZmVyKSB7XG4gICAgICByZXR1cm4gbW9kZWwuYWN0aXZlRnJhbWVidWZmZXIuZ2V0U2l6ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWwuc2l6ZTtcbiAgfTtcblxuICBwdWJsaWNBUEkuaXNJblZpZXdwb3J0ID0gKHgsIHksIHZpZXdwb3J0KSA9PiB7XG4gICAgY29uc3QgdkNvb3JkcyA9IHZpZXdwb3J0LmdldFZpZXdwb3J0QnlSZWZlcmVuY2UoKTtcbiAgICBjb25zdCBzaXplID0gcHVibGljQVBJLmdldEZyYW1lYnVmZmVyU2l6ZSgpO1xuICAgIGlmIChcbiAgICAgIHZDb29yZHNbMF0gKiBzaXplWzBdIDw9IHggJiZcbiAgICAgIHZDb29yZHNbMl0gKiBzaXplWzBdID49IHggJiZcbiAgICAgIHZDb29yZHNbMV0gKiBzaXplWzFdIDw9IHkgJiZcbiAgICAgIHZDb29yZHNbM10gKiBzaXplWzFdID49IHlcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcHVibGljQVBJLmdldFZpZXdwb3J0U2l6ZSA9ICh2aWV3cG9ydCkgPT4ge1xuICAgIGNvbnN0IHZDb29yZHMgPSB2aWV3cG9ydC5nZXRWaWV3cG9ydEJ5UmVmZXJlbmNlKCk7XG4gICAgY29uc3Qgc2l6ZSA9IHB1YmxpY0FQSS5nZXRGcmFtZWJ1ZmZlclNpemUoKTtcblxuICAgIHJldHVybiBbXG4gICAgICAodkNvb3Jkc1syXSAtIHZDb29yZHNbMF0pICogc2l6ZVswXSxcbiAgICAgICh2Q29vcmRzWzNdIC0gdkNvb3Jkc1sxXSkgKiBzaXplWzFdLFxuICAgIF07XG4gIH07XG5cbiAgcHVibGljQVBJLmdldFZpZXdwb3J0Q2VudGVyID0gKHZpZXdwb3J0KSA9PiB7XG4gICAgY29uc3Qgc2l6ZSA9IHB1YmxpY0FQSS5nZXRWaWV3cG9ydFNpemUodmlld3BvcnQpO1xuICAgIHJldHVybiBbc2l6ZVswXSAqIDAuNSwgc2l6ZVsxXSAqIDAuNV07XG4gIH07XG5cbiAgcHVibGljQVBJLmRpc3BsYXlUb05vcm1hbGl6ZWREaXNwbGF5ID0gKHgsIHksIHopID0+IHtcbiAgICBjb25zdCBzaXplID0gcHVibGljQVBJLmdldEZyYW1lYnVmZmVyU2l6ZSgpO1xuICAgIHJldHVybiBbeCAvIHNpemVbMF0sIHkgLyBzaXplWzFdLCB6XTtcbiAgfTtcblxuICBwdWJsaWNBUEkubm9ybWFsaXplZERpc3BsYXlUb0Rpc3BsYXkgPSAoeCwgeSwgeikgPT4ge1xuICAgIGNvbnN0IHNpemUgPSBwdWJsaWNBUEkuZ2V0RnJhbWVidWZmZXJTaXplKCk7XG4gICAgcmV0dXJuIFt4ICogc2l6ZVswXSwgeSAqIHNpemVbMV0sIHpdO1xuICB9O1xuXG4gIHB1YmxpY0FQSS53b3JsZFRvVmlldyA9ICh4LCB5LCB6LCByZW5kZXJlcikgPT4gcmVuZGVyZXIud29ybGRUb1ZpZXcoeCwgeSwgeik7XG5cbiAgcHVibGljQVBJLnZpZXdUb1dvcmxkID0gKHgsIHksIHosIHJlbmRlcmVyKSA9PiByZW5kZXJlci52aWV3VG9Xb3JsZCh4LCB5LCB6KTtcblxuICBwdWJsaWNBUEkud29ybGRUb0Rpc3BsYXkgPSAoeCwgeSwgeiwgcmVuZGVyZXIpID0+IHtcbiAgICBjb25zdCB2YWwgPSByZW5kZXJlci53b3JsZFRvVmlldyh4LCB5LCB6KTtcbiAgICBjb25zdCBkaW1zID0gcHVibGljQVBJLmdldFZpZXdwb3J0U2l6ZShyZW5kZXJlcik7XG4gICAgY29uc3QgdmFsMiA9IHJlbmRlcmVyLnZpZXdUb1Byb2plY3Rpb24oXG4gICAgICB2YWxbMF0sXG4gICAgICB2YWxbMV0sXG4gICAgICB2YWxbMl0sXG4gICAgICBkaW1zWzBdIC8gZGltc1sxXVxuICAgICk7XG4gICAgY29uc3QgdmFsMyA9IHJlbmRlcmVyLnByb2plY3Rpb25Ub05vcm1hbGl6ZWREaXNwbGF5KFxuICAgICAgdmFsMlswXSxcbiAgICAgIHZhbDJbMV0sXG4gICAgICB2YWwyWzJdXG4gICAgKTtcbiAgICByZXR1cm4gcHVibGljQVBJLm5vcm1hbGl6ZWREaXNwbGF5VG9EaXNwbGF5KHZhbDNbMF0sIHZhbDNbMV0sIHZhbDNbMl0pO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5kaXNwbGF5VG9Xb3JsZCA9ICh4LCB5LCB6LCByZW5kZXJlcikgPT4ge1xuICAgIGNvbnN0IHZhbCA9IHB1YmxpY0FQSS5kaXNwbGF5VG9Ob3JtYWxpemVkRGlzcGxheSh4LCB5LCB6KTtcbiAgICBjb25zdCB2YWwyID0gcmVuZGVyZXIubm9ybWFsaXplZERpc3BsYXlUb1Byb2plY3Rpb24odmFsWzBdLCB2YWxbMV0sIHZhbFsyXSk7XG4gICAgY29uc3QgZGltcyA9IHB1YmxpY0FQSS5nZXRWaWV3cG9ydFNpemUocmVuZGVyZXIpO1xuICAgIGNvbnN0IHZhbDMgPSByZW5kZXJlci5wcm9qZWN0aW9uVG9WaWV3KFxuICAgICAgdmFsMlswXSxcbiAgICAgIHZhbDJbMV0sXG4gICAgICB2YWwyWzJdLFxuICAgICAgZGltc1swXSAvIGRpbXNbMV1cbiAgICApO1xuICAgIHJldHVybiByZW5kZXJlci52aWV3VG9Xb3JsZCh2YWwzWzBdLCB2YWwzWzFdLCB2YWwzWzJdKTtcbiAgfTtcblxuICBwdWJsaWNBUEkubm9ybWFsaXplZERpc3BsYXlUb1ZpZXdwb3J0ID0gKHgsIHksIHosIHJlbmRlcmVyKSA9PiB7XG4gICAgbGV0IHZDb29yZHMgPSByZW5kZXJlci5nZXRWaWV3cG9ydEJ5UmVmZXJlbmNlKCk7XG4gICAgdkNvb3JkcyA9IHB1YmxpY0FQSS5ub3JtYWxpemVkRGlzcGxheVRvRGlzcGxheSh2Q29vcmRzWzBdLCB2Q29vcmRzWzFdLCAwLjApO1xuICAgIGNvbnN0IGNvb3JkcyA9IHB1YmxpY0FQSS5ub3JtYWxpemVkRGlzcGxheVRvRGlzcGxheSh4LCB5LCB6KTtcbiAgICByZXR1cm4gW2Nvb3Jkc1swXSAtIHZDb29yZHNbMF0gLSAwLjUsIGNvb3Jkc1sxXSAtIHZDb29yZHNbMV0gLSAwLjUsIHpdO1xuICB9O1xuXG4gIHB1YmxpY0FQSS52aWV3cG9ydFRvTm9ybWFsaXplZFZpZXdwb3J0ID0gKHgsIHksIHosIHJlbmRlcmVyKSA9PiB7XG4gICAgY29uc3Qgc2l6ZSA9IHB1YmxpY0FQSS5nZXRWaWV3cG9ydFNpemUocmVuZGVyZXIpO1xuICAgIGlmIChzaXplICYmIHNpemVbMF0gIT09IDAgJiYgc2l6ZVsxXSAhPT0gMCkge1xuICAgICAgcmV0dXJuIFt4IC8gKHNpemVbMF0gLSAxLjApLCB5IC8gKHNpemVbMV0gLSAxLjApLCB6XTtcbiAgICB9XG4gICAgcmV0dXJuIFt4LCB5LCB6XTtcbiAgfTtcblxuICBwdWJsaWNBUEkubm9ybWFsaXplZFZpZXdwb3J0VG9WaWV3cG9ydCA9ICh4LCB5LCB6KSA9PiB7XG4gICAgY29uc3Qgc2l6ZSA9IHB1YmxpY0FQSS5nZXRGcmFtZWJ1ZmZlclNpemUoKTtcbiAgICByZXR1cm4gW3ggKiAoc2l6ZVswXSAtIDEuMCksIHkgKiAoc2l6ZVsxXSAtIDEuMCksIHpdO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5kaXNwbGF5VG9Mb2NhbERpc3BsYXkgPSAoeCwgeSwgeikgPT4ge1xuICAgIGNvbnN0IHNpemUgPSBwdWJsaWNBUEkuZ2V0RnJhbWVidWZmZXJTaXplKCk7XG4gICAgcmV0dXJuIFt4LCBzaXplWzFdIC0geSAtIDEsIHpdO1xuICB9O1xuXG4gIHB1YmxpY0FQSS52aWV3cG9ydFRvTm9ybWFsaXplZERpc3BsYXkgPSAoeCwgeSwgeiwgcmVuZGVyZXIpID0+IHtcbiAgICBsZXQgdkNvb3JkcyA9IHJlbmRlcmVyLmdldFZpZXdwb3J0QnlSZWZlcmVuY2UoKTtcbiAgICB2Q29vcmRzID0gcHVibGljQVBJLm5vcm1hbGl6ZWREaXNwbGF5VG9EaXNwbGF5KHZDb29yZHNbMF0sIHZDb29yZHNbMV0sIDAuMCk7XG4gICAgY29uc3QgeDIgPSB4ICsgdkNvb3Jkc1swXSArIDAuNTtcbiAgICBjb25zdCB5MiA9IHkgKyB2Q29vcmRzWzFdICsgMC41O1xuICAgIHJldHVybiBwdWJsaWNBUEkuZGlzcGxheVRvTm9ybWFsaXplZERpc3BsYXkoeDIsIHkyLCB6KTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0UGl4ZWxEYXRhID0gKHgxLCB5MSwgeDIsIHkyKSA9PiB7XG4gICAgY29uc3QgcGl4ZWxzID0gbmV3IFVpbnQ4QXJyYXkoKHgyIC0geDEgKyAxKSAqICh5MiAtIHkxICsgMSkgKiA0KTtcbiAgICBtb2RlbC5jb250ZXh0LnJlYWRQaXhlbHMoXG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIgLSB4MSArIDEsXG4gICAgICB5MiAtIHkxICsgMSxcbiAgICAgIG1vZGVsLmNvbnRleHQuUkdCQSxcbiAgICAgIG1vZGVsLmNvbnRleHQuVU5TSUdORURfQllURSxcbiAgICAgIHBpeGVsc1xuICAgICk7XG4gICAgcmV0dXJuIHBpeGVscztcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0M0RDb250ZXh0ID0gKFxuICAgIG9wdGlvbnMgPSB7IHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsIGRlcHRoOiB0cnVlLCBhbHBoYTogdHJ1ZSB9XG4gICkgPT4ge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuXG4gICAgY29uc3Qgd2ViZ2wyU3VwcG9ydGVkID0gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnO1xuICAgIG1vZGVsLndlYmdsMiA9IGZhbHNlO1xuICAgIGlmIChtb2RlbC5kZWZhdWx0VG9XZWJnbDIgJiYgd2ViZ2wyU3VwcG9ydGVkKSB7XG4gICAgICByZXN1bHQgPSBtb2RlbC5jYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgb3B0aW9ucyk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIG1vZGVsLndlYmdsMiA9IHRydWU7XG4gICAgICAgIHZ0a0RlYnVnTWFjcm8oJ3VzaW5nIHdlYmdsMicpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdnRrRGVidWdNYWNybygndXNpbmcgd2ViZ2wxJyk7XG4gICAgICByZXN1bHQgPVxuICAgICAgICBtb2RlbC5jYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRpb25zKSB8fFxuICAgICAgICBtb2RlbC5jYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyogZXNsaW50LWRpc2FibGUgKi9cbiAgICBjb25zdCBwb2x5ZmlsbCA9IG5ldyBXZWJWUlBvbHlmaWxsKHtcbiAgICAgIC8vIEVuc3VyZXMgdGhlIHBvbHlmaWxsIGlzIGFsd2F5cyBhY3RpdmUgb24gbW9iaWxlLCBkdWUgdG8gcHJvdmlkaW5nXG4gICAgICAvLyBhIHBvbHlmaWxsZWQgQ2FyZGJvYXJkVlJEaXNwbGF5IHdoZW4gbm8gbmF0aXZlIEFQSSBpcyBhdmFpbGFibGUsXG4gICAgICAvLyBhbmQgYWxzbyBwb2x5ZmlsbGluZyBldmVuIHdoZW4gdGhlIG5hdGl2ZSBBUEkgaXMgYXZhaWxhYmxlLCBkdWUgdG9cbiAgICAgIC8vIHByb3ZpZGluZyBhIENhcmRib2FyZFZSRGlzcGxheSB3aGVuIG5vIG5hdGl2ZSBWUkRpc3BsYXlzIGV4aXN0LlxuICAgICAgUFJPVklERV9NT0JJTEVfVlJESVNQTEFZOiB0cnVlLFxuICAgICAgLy8gUG9seWZpbGwgb3B0aW1pemF0aW9uc1xuICAgICAgRElSVFlfU1VCTUlUX0ZSQU1FX0JJTkRJTkdTOiBmYWxzZSxcbiAgICAgIEJVRkZFUl9TQ0FMRTogMC43NSxcbiAgICB9KTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlICovXG5cbiAgICAvLyBEbyB3ZSBoYXZlIHdlYnZyIHN1cHBvcnRcbiAgICBpZiAobmF2aWdhdG9yLmdldFZSRGlzcGxheXMpIHtcbiAgICAgIG5hdmlnYXRvci5nZXRWUkRpc3BsYXlzKCkudGhlbigoZGlzcGxheXMpID0+IHtcbiAgICAgICAgaWYgKGRpc3BsYXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyB0YWtlIHRoZSBmaXJzdCBkaXNwbGF5IGZvciBub3dcbiAgICAgICAgICBtb2RlbC52ckRpc3BsYXkgPSBkaXNwbGF5c1swXTtcbiAgICAgICAgICAvLyBzZXQgdGhlIGNsaXBwaW5nIHJhbmdlc1xuICAgICAgICAgIG1vZGVsLnZyRGlzcGxheS5kZXB0aE5lYXIgPSAwLjAxOyAvLyBtZXRlcnNcbiAgICAgICAgICBtb2RlbC52ckRpc3BsYXkuZGVwdGhGYXIgPSAxMDAuMDsgLy8gbWV0ZXJzXG4gICAgICAgICAgcHVibGljQVBJLmludm9rZUhhdmVWUkRpc3BsYXkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcHJldmVudCBkZWZhdWx0IGNvbnRleHQgbG9zdCBoYW5kbGVyXG4gICAgbW9kZWwuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAnd2ViZ2xjb250ZXh0bG9zdCcsXG4gICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgICk7XG5cbiAgICBtb2RlbC5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsXG4gICAgICBwdWJsaWNBUEkucmVzdG9yZUNvbnRleHQsXG4gICAgICBmYWxzZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zdGFydFZSID0gKCkgPT4ge1xuICAgIG1vZGVsLm9sZENhbnZhc1NpemUgPSBtb2RlbC5zaXplLnNsaWNlKCk7XG4gICAgaWYgKG1vZGVsLnZyRGlzcGxheS5jYXBhYmlsaXRpZXMuY2FuUHJlc2VudCkge1xuICAgICAgbW9kZWwudnJEaXNwbGF5XG4gICAgICAgIC5yZXF1ZXN0UHJlc2VudChbeyBzb3VyY2U6IG1vZGVsLmNhbnZhcyB9XSlcbiAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG1vZGVsLmVsICYmXG4gICAgICAgICAgICBtb2RlbC52ckRpc3BsYXkuY2FwYWJpbGl0aWVzLmhhc0V4dGVybmFsRGlzcGxheSAmJlxuICAgICAgICAgICAgbW9kZWwuaGlkZUNhbnZhc0luVlJcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG1vZGVsLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RlbC5xdWVyeVZSU2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgbGVmdEV5ZSA9IG1vZGVsLnZyRGlzcGxheS5nZXRFeWVQYXJhbWV0ZXJzKCdsZWZ0Jyk7XG4gICAgICAgICAgICBjb25zdCByaWdodEV5ZSA9IG1vZGVsLnZyRGlzcGxheS5nZXRFeWVQYXJhbWV0ZXJzKCdyaWdodCcpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICBsZWZ0RXllLnJlbmRlcldpZHRoICsgcmlnaHRFeWUucmVuZGVyV2lkdGhcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICBNYXRoLm1heChsZWZ0RXllLnJlbmRlckhlaWdodCwgcmlnaHRFeWUucmVuZGVySGVpZ2h0KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHB1YmxpY0FQSS5zZXRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwdWJsaWNBUEkuc2V0U2l6ZShtb2RlbC52clJlc29sdXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHJlbiA9IG1vZGVsLnJlbmRlcmFibGUuZ2V0UmVuZGVyZXJzKClbMF07XG4gICAgICAgICAgcmVuLnJlc2V0Q2FtZXJhKCk7XG4gICAgICAgICAgbW9kZWwudnJGcmFtZURhdGEgPSBuZXcgVlJGcmFtZURhdGEoKTtcbiAgICAgICAgICBtb2RlbC5yZW5kZXJhYmxlLmdldEludGVyYWN0b3IoKS5zd2l0Y2hUb1ZSQW5pbWF0aW9uKCk7XG5cbiAgICAgICAgICBtb2RlbC52clNjZW5lRnJhbWUgPSBtb2RlbC52ckRpc3BsYXkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgICAgICAgcHVibGljQVBJLnZyUmVuZGVyXG4gICAgICAgICAgKTtcbiAgICAgICAgICAvLyBJZiBCcm9zd2VyIGlzIGNocm9tZSB3ZSBuZWVkIHRvIHJlcXVlc3QgYW5pbWF0aW9uIGFnYWluIHRvIGNhbnZhcyB1cGRhdGVcbiAgICAgICAgICBpZiAoSVNfQ0hST01FKSB7XG4gICAgICAgICAgICBtb2RlbC52clNjZW5lRnJhbWUgPSBtb2RlbC52ckRpc3BsYXkucmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgICAgICAgICBwdWJsaWNBUEkudnJSZW5kZXJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byByZXF1ZXN0UHJlc2VudCcpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdnRrRXJyb3JNYWNybygndnJEaXNwbGF5IGlzIG5vdCBjb25uZWN0ZWQnKTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLnN0b3BWUiA9ICgpID0+IHtcbiAgICBtb2RlbC5yZW5kZXJhYmxlLmdldEludGVyYWN0b3IoKS5yZXR1cm5Gcm9tVlJBbmltYXRpb24oKTtcbiAgICBtb2RlbC52ckRpc3BsYXkuZXhpdFByZXNlbnQoKTtcbiAgICBtb2RlbC52ckRpc3BsYXkuY2FuY2VsQW5pbWF0aW9uRnJhbWUobW9kZWwudnJTY2VuZUZyYW1lKTtcblxuICAgIHB1YmxpY0FQSS5zZXRTaXplKC4uLm1vZGVsLm9sZENhbnZhc1NpemUpO1xuICAgIGlmIChtb2RlbC5lbCAmJiBtb2RlbC52ckRpc3BsYXkuY2FwYWJpbGl0aWVzLmhhc0V4dGVybmFsRGlzcGxheSkge1xuICAgICAgbW9kZWwuZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuXG4gICAgY29uc3QgcmVuID0gbW9kZWwucmVuZGVyYWJsZS5nZXRSZW5kZXJlcnMoKVswXTtcbiAgICByZW4uZ2V0QWN0aXZlQ2FtZXJhKCkuc2V0UHJvamVjdGlvbk1hdHJpeChudWxsKTtcblxuICAgIHJlbi5zZXRWaWV3cG9ydCgwLjAsIDAsIDEuMCwgMS4wKTtcbiAgICBwdWJsaWNBUEkudHJhdmVyc2VBbGxQYXNzZXMoKTtcbiAgfTtcblxuICBwdWJsaWNBUEkudnJSZW5kZXIgPSAoKSA9PiB7XG4gICAgLy8gSWYgbm90IHByZXNlbnRpbmcgZm9yIGFueSByZWFzb24sIHdlIGRvIG5vdCBzdWJtaXQgZnJhbWVcbiAgICBpZiAoIW1vZGVsLnZyRGlzcGxheS5pc1ByZXNlbnRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbW9kZWwucmVuZGVyYWJsZS5nZXRJbnRlcmFjdG9yKCkudXBkYXRlR2FtZXBhZHMobW9kZWwudnJEaXNwbGF5LmRpc3BsYXlJZCk7XG4gICAgbW9kZWwudnJTY2VuZUZyYW1lID0gbW9kZWwudnJEaXNwbGF5LnJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgIHB1YmxpY0FQSS52clJlbmRlclxuICAgICk7XG4gICAgbW9kZWwudnJEaXNwbGF5LmdldEZyYW1lRGF0YShtb2RlbC52ckZyYW1lRGF0YSk7XG5cbiAgICAvLyBnZXQgdGhlIGZpcnN0IHJlbmRlcmVyXG4gICAgY29uc3QgcmVuID0gbW9kZWwucmVuZGVyYWJsZS5nZXRSZW5kZXJlcnMoKVswXTtcblxuICAgIC8vIGRvIHRoZSBsZWZ0IGV5ZVxuICAgIHJlbi5zZXRWaWV3cG9ydCgwLCAwLCAwLjUsIDEuMCk7XG4gICAgcmVuXG4gICAgICAuZ2V0QWN0aXZlQ2FtZXJhKClcbiAgICAgIC5jb21wdXRlVmlld1BhcmFtZXRlcnNGcm9tUGh5c2ljYWxNYXRyaXgoXG4gICAgICAgIG1vZGVsLnZyRnJhbWVEYXRhLmxlZnRWaWV3TWF0cml4XG4gICAgICApO1xuICAgIHJlblxuICAgICAgLmdldEFjdGl2ZUNhbWVyYSgpXG4gICAgICAuc2V0UHJvamVjdGlvbk1hdHJpeChtb2RlbC52ckZyYW1lRGF0YS5sZWZ0UHJvamVjdGlvbk1hdHJpeCk7XG4gICAgcHVibGljQVBJLnRyYXZlcnNlQWxsUGFzc2VzKCk7XG5cbiAgICByZW4uc2V0Vmlld3BvcnQoMC41LCAwLCAxLjAsIDEuMCk7XG4gICAgcmVuXG4gICAgICAuZ2V0QWN0aXZlQ2FtZXJhKClcbiAgICAgIC5jb21wdXRlVmlld1BhcmFtZXRlcnNGcm9tUGh5c2ljYWxNYXRyaXgoXG4gICAgICAgIG1vZGVsLnZyRnJhbWVEYXRhLnJpZ2h0Vmlld01hdHJpeFxuICAgICAgKTtcbiAgICByZW5cbiAgICAgIC5nZXRBY3RpdmVDYW1lcmEoKVxuICAgICAgLnNldFByb2plY3Rpb25NYXRyaXgobW9kZWwudnJGcmFtZURhdGEucmlnaHRQcm9qZWN0aW9uTWF0cml4KTtcbiAgICBwdWJsaWNBUEkudHJhdmVyc2VBbGxQYXNzZXMoKTtcblxuICAgIG1vZGVsLnZyRGlzcGxheS5zdWJtaXRGcmFtZSgpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZXN0b3JlQ29udGV4dCA9ICgpID0+IHtcbiAgICBjb25zdCBycCA9IHZ0a1JlbmRlclBhc3MubmV3SW5zdGFuY2UoKTtcbiAgICBycC5zZXRDdXJyZW50T3BlcmF0aW9uKCdSZWxlYXNlJyk7XG4gICAgcnAudHJhdmVyc2UocHVibGljQVBJLCBudWxsKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuYWN0aXZhdGVUZXh0dXJlID0gKHRleHR1cmUpID0+IHtcbiAgICAvLyBPbmx5IGFkZCBpZiBpdCBpc24ndCBhbHJlYWR5IHRoZXJlXG4gICAgY29uc3QgcmVzdWx0ID0gbW9kZWwudGV4dHVyZVJlc291cmNlSWRzLmdldCh0ZXh0dXJlKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG1vZGVsLmNvbnRleHQuYWN0aXZlVGV4dHVyZShtb2RlbC5jb250ZXh0LlRFWFRVUkUwICsgcmVzdWx0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmVVbml0ID0gcHVibGljQVBJLmdldFRleHR1cmVVbml0TWFuYWdlcigpLmFsbG9jYXRlKCk7XG4gICAgaWYgKGFjdGl2ZVVuaXQgPCAwKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKFxuICAgICAgICAnSGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCB0aGUgbnVtYmVyIG9mIHRleHR1cmVzIGRlZmluZWQuJ1xuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtb2RlbC50ZXh0dXJlUmVzb3VyY2VJZHMuc2V0KHRleHR1cmUsIGFjdGl2ZVVuaXQpO1xuICAgIG1vZGVsLmNvbnRleHQuYWN0aXZlVGV4dHVyZShtb2RlbC5jb250ZXh0LlRFWFRVUkUwICsgYWN0aXZlVW5pdCk7XG4gIH07XG5cbiAgcHVibGljQVBJLmRlYWN0aXZhdGVUZXh0dXJlID0gKHRleHR1cmUpID0+IHtcbiAgICAvLyBPbmx5IGRlYWN0aXZhdGUgaWYgaXQgaXNuJ3QgYWxyZWFkeSB0aGVyZVxuICAgIGNvbnN0IHJlc3VsdCA9IG1vZGVsLnRleHR1cmVSZXNvdXJjZUlkcy5nZXQodGV4dHVyZSk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdWJsaWNBUEkuZ2V0VGV4dHVyZVVuaXRNYW5hZ2VyKCkuZnJlZShyZXN1bHQpO1xuICAgICAgZGVsZXRlIG1vZGVsLnRleHR1cmVSZXNvdXJjZUlkcy5kZWxldGUodGV4dHVyZSk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRUZXh0dXJlVW5pdEZvclRleHR1cmUgPSAodGV4dHVyZSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IG1vZGVsLnRleHR1cmVSZXNvdXJjZUlkcy5nZXQodGV4dHVyZSk7XG4gICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgcHVibGljQVBJLmdldERlZmF1bHRUZXh0dXJlSW50ZXJuYWxGb3JtYXQgPSAodnRrdHlwZSwgbnVtQ29tcHMsIHVzZUZsb2F0KSA9PiB7XG4gICAgaWYgKG1vZGVsLndlYmdsMikge1xuICAgICAgc3dpdGNoICh2dGt0eXBlKSB7XG4gICAgICAgIGNhc2UgVnRrRGF0YVR5cGVzLlVOU0lHTkVEX0NIQVI6XG4gICAgICAgICAgc3dpdGNoIChudW1Db21wcykge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5SODtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuUkc4O1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5SR0I4O1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuUkdCQTg7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBjYXNlIFZ0a0RhdGFUeXBlcy5GTE9BVDpcbiAgICAgICAgICBzd2l0Y2ggKG51bUNvbXBzKSB7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgIHJldHVybiBtb2RlbC5jb250ZXh0LlIxNkY7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHJldHVybiBtb2RlbC5jb250ZXh0LlJHMTZGO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5SR0IxNkY7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5SR0JBMTZGO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZWJnbDEgb25seSBzdXBwb3J0cyBmb3VyIHR5cGVzXG4gICAgc3dpdGNoIChudW1Db21wcykge1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5MVU1JTkFOQ0U7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiBtb2RlbC5jb250ZXh0LkxVTUlOQU5DRV9BTFBIQTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuUkdCO1xuICAgICAgY2FzZSA0OlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuUkdCQTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLnNldEJhY2tncm91bmRJbWFnZSA9IChpbWcpID0+IHtcbiAgICBtb2RlbC5iZ0ltYWdlLnNyYyA9IGltZy5zcmM7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldFVzZUJhY2tncm91bmRJbWFnZSA9ICh2YWx1ZSkgPT4ge1xuICAgIG1vZGVsLnVzZUJhY2tncm91bmRJbWFnZSA9IHZhbHVlO1xuXG4gICAgLy8gQWRkIG9yIHJlbW92ZSB0aGUgYmFja2dyb3VuZCBpbWFnZSBmcm9tIHRoZVxuICAgIC8vIERPTSBhcyBzcGVjaWZpZWQuXG4gICAgaWYgKG1vZGVsLnVzZUJhY2tncm91bmRJbWFnZSAmJiAhbW9kZWwuZWwuY29udGFpbnMobW9kZWwuYmdJbWFnZSkpIHtcbiAgICAgIG1vZGVsLmVsLmFwcGVuZENoaWxkKG1vZGVsLmJnSW1hZ2UpO1xuICAgIH0gZWxzZSBpZiAoIW1vZGVsLnVzZUJhY2tncm91bmRJbWFnZSAmJiBtb2RlbC5lbC5jb250YWlucyhtb2RlbC5iZ0ltYWdlKSkge1xuICAgICAgbW9kZWwuZWwucmVtb3ZlQ2hpbGQobW9kZWwuYmdJbWFnZSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldENhbnZhc0RhdGFVUkwoZm9ybWF0ID0gbW9kZWwuaW1hZ2VGb3JtYXQpIHtcbiAgICAvLyBDb3B5IGN1cnJlbnQgY2FudmFzIHRvIG5vdCBtb2RpZnkgdGhlIG9yaWdpbmFsXG4gICAgY29uc3QgdGVtcG9yYXJ5Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY29uc3QgdGVtcG9yYXJ5Q29udGV4dCA9IHRlbXBvcmFyeUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRlbXBvcmFyeUNhbnZhcy53aWR0aCA9IG1vZGVsLmNhbnZhcy53aWR0aDtcbiAgICB0ZW1wb3JhcnlDYW52YXMuaGVpZ2h0ID0gbW9kZWwuY2FudmFzLmhlaWdodDtcbiAgICB0ZW1wb3JhcnlDb250ZXh0LmRyYXdJbWFnZShtb2RlbC5jYW52YXMsIDAsIDApO1xuXG4gICAgLy8gR2V0IGN1cnJlbnQgY2xpZW50IHJlY3QgdG8gcGxhY2UgY2FudmFzXG4gICAgY29uc3QgbWFpbkJvdW5kaW5nQ2xpZW50UmVjdCA9IG1vZGVsLmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIGNvbnN0IHJlbmRlcldpbmRvdyA9IG1vZGVsLnJlbmRlcmFibGU7XG4gICAgY29uc3QgcmVuZGVyZXJzID0gcmVuZGVyV2luZG93LmdldFJlbmRlcmVycygpO1xuICAgIHJlbmRlcmVycy5mb3JFYWNoKChyZW5kZXJlcikgPT4ge1xuICAgICAgY29uc3Qgdmlld1Byb3BzID0gcmVuZGVyZXIuZ2V0Vmlld1Byb3BzKCk7XG4gICAgICB2aWV3UHJvcHMuZm9yRWFjaCgodmlld1Byb3ApID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHByb3AgaGFzIGEgY29udGFpbmVyIHRoYXQgc2hvdWxkIGhhdmUgY2FudmFzXG4gICAgICAgIGlmICh2aWV3UHJvcC5nZXRDb250YWluZXIpIHtcbiAgICAgICAgICBjb25zdCBjb250YWluZXIgPSB2aWV3UHJvcC5nZXRDb250YWluZXIoKTtcbiAgICAgICAgICBjb25zdCBjYW52YXNMaXN0ID0gY29udGFpbmVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjYW52YXMnKTtcbiAgICAgICAgICAvLyBHbyB0aHJvdWdob3V0IGFsbCBjYW52YXMgYW5kIGNvcHkgaXQgaW50byB0ZW1wb3JhcnkgbWFpbiBjYW52YXNcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbnZhc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDYW52YXMgPSBjYW52YXNMaXN0W2ldO1xuICAgICAgICAgICAgY29uc3QgYm91bmRpbmdDbGllbnRSZWN0ID0gY3VycmVudENhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1hQb3NpdGlvbiA9XG4gICAgICAgICAgICAgIGJvdW5kaW5nQ2xpZW50UmVjdC54IC0gbWFpbkJvdW5kaW5nQ2xpZW50UmVjdC54O1xuICAgICAgICAgICAgY29uc3QgbmV3WVBvc2l0aW9uID1cbiAgICAgICAgICAgICAgYm91bmRpbmdDbGllbnRSZWN0LnkgLSBtYWluQm91bmRpbmdDbGllbnRSZWN0Lnk7XG4gICAgICAgICAgICB0ZW1wb3JhcnlDb250ZXh0LmRyYXdJbWFnZShcbiAgICAgICAgICAgICAgY3VycmVudENhbnZhcyxcbiAgICAgICAgICAgICAgbmV3WFBvc2l0aW9uLFxuICAgICAgICAgICAgICBuZXdZUG9zaXRpb25cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHNjcmVlbnNob3QgPSB0ZW1wb3JhcnlDYW52YXMudG9EYXRhVVJMKGZvcm1hdCk7XG4gICAgdGVtcG9yYXJ5Q2FudmFzLnJlbW92ZSgpO1xuICAgIHB1YmxpY0FQSS5pbnZva2VJbWFnZVJlYWR5KHNjcmVlbnNob3QpO1xuICB9XG5cbiAgcHVibGljQVBJLmNhcHR1cmVOZXh0SW1hZ2UgPSAoZm9ybWF0ID0gJ2ltYWdlL3BuZycpID0+IHtcbiAgICBpZiAobW9kZWwuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG1vZGVsLmltYWdlRm9ybWF0ID0gZm9ybWF0O1xuICAgIGNvbnN0IHByZXZpb3VzID0gbW9kZWwubm90aWZ5U3RhcnRDYXB0dXJlSW1hZ2U7XG4gICAgbW9kZWwubm90aWZ5U3RhcnRDYXB0dXJlSW1hZ2UgPSB0cnVlO1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHB1YmxpY0FQSS5vbkltYWdlUmVhZHkoKGltYWdlVVJMKSA9PiB7XG4gICAgICAgIG1vZGVsLm5vdGlmeVN0YXJ0Q2FwdHVyZUltYWdlID0gcHJldmlvdXM7XG4gICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICByZXNvbHZlKGltYWdlVVJMKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRHTEluZm9ybWF0aW9ucyA9ICgpID0+IHtcbiAgICBjb25zdCBnbCA9IHB1YmxpY0FQSS5nZXQzRENvbnRleHQoKTtcblxuICAgIGNvbnN0IGdsVGV4dHVyZUZsb2F0ID0gZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpO1xuICAgIGNvbnN0IGdsVGV4dHVyZUhhbGZGbG9hdCA9IGdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcpO1xuICAgIGNvbnN0IGdsRGVidWdSZW5kZXJlckluZm8gPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RlYnVnX3JlbmRlcmVyX2luZm8nKTtcbiAgICBjb25zdCBnbERyYXdCdWZmZXJzID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKTtcbiAgICBjb25zdCBnbEFuaXNvdHJvcGljID1cbiAgICAgIGdsLmdldEV4dGVuc2lvbignRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJykgfHxcbiAgICAgIGdsLmdldEV4dGVuc2lvbignV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpO1xuXG4gICAgY29uc3QgcGFyYW1zID0gW1xuICAgICAgW1xuICAgICAgICAnTWF4IFZlcnRleCBBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ01BWF9WRVJURVhfQVRUUklCUycsXG4gICAgICAgIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVkVSVEVYX0FUVFJJQlMpLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ01heCBWYXJ5aW5nIFZlY3RvcnMnLFxuICAgICAgICAnTUFYX1ZBUllJTkdfVkVDVE9SUycsXG4gICAgICAgIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVkFSWUlOR19WRUNUT1JTKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdNYXggVmVydGV4IFVuaWZvcm0gVmVjdG9ycycsXG4gICAgICAgICdNQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUycsXG4gICAgICAgIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVkVSVEVYX1VOSUZPUk1fVkVDVE9SUyksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnTWF4IEZyYWdtZW50IFVuaWZvcm0gVmVjdG9ycycsXG4gICAgICAgICdNQVhfRlJBR01FTlRfVU5JRk9STV9WRUNUT1JTJyxcbiAgICAgICAgZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9GUkFHTUVOVF9VTklGT1JNX1ZFQ1RPUlMpLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ01heCBGcmFnbWVudCBUZXh0dXJlIEltYWdlIFVuaXRzJyxcbiAgICAgICAgJ01BWF9URVhUVVJFX0lNQUdFX1VOSVRTJyxcbiAgICAgICAgZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdNYXggVmVydGV4IFRleHR1cmUgSW1hZ2UgVW5pdHMnLFxuICAgICAgICAnTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTJyxcbiAgICAgICAgZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnTWF4IENvbWJpbmVkIFRleHR1cmUgSW1hZ2UgVW5pdHMnLFxuICAgICAgICAnTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMnLFxuICAgICAgICBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX0NPTUJJTkVEX1RFWFRVUkVfSU1BR0VfVU5JVFMpLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ01heCAyRCBUZXh0dXJlIFNpemUnLFxuICAgICAgICAnTUFYX1RFWFRVUkVfU0laRScsXG4gICAgICAgIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdNYXggQ3ViZSBUZXh0dXJlIFNpemUnLFxuICAgICAgICAnTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRScsXG4gICAgICAgIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdNYXggVGV4dHVyZSBBbmlzb3Ryb3B5JyxcbiAgICAgICAgJ01BWF9URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCcsXG4gICAgICAgIGdsQW5pc290cm9waWMgJiZcbiAgICAgICAgICBnbC5nZXRQYXJhbWV0ZXIoZ2xBbmlzb3Ryb3BpYy5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQpLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ1BvaW50IFNpemUgUmFuZ2UnLFxuICAgICAgICAnQUxJQVNFRF9QT0lOVF9TSVpFX1JBTkdFJyxcbiAgICAgICAgZ2wuZ2V0UGFyYW1ldGVyKGdsLkFMSUFTRURfUE9JTlRfU0laRV9SQU5HRSkuam9pbignIC0gJyksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnTGluZSBXaWR0aCBSYW5nZScsXG4gICAgICAgICdBTElBU0VEX0xJTkVfV0lEVEhfUkFOR0UnLFxuICAgICAgICBnbC5nZXRQYXJhbWV0ZXIoZ2wuQUxJQVNFRF9MSU5FX1dJRFRIX1JBTkdFKS5qb2luKCcgLSAnKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdNYXggVmlld3BvcnQgRGltZW5zaW9ucycsXG4gICAgICAgICdNQVhfVklFV1BPUlRfRElNUycsXG4gICAgICAgIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVklFV1BPUlRfRElNUykuam9pbignIC0gJyksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnTWF4IFJlbmRlcmJ1ZmZlciBTaXplJyxcbiAgICAgICAgJ01BWF9SRU5ERVJCVUZGRVJfU0laRScsXG4gICAgICAgIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfUkVOREVSQlVGRkVSX1NJWkUpLFxuICAgICAgXSxcbiAgICAgIFsnRnJhbWVidWZmZXIgUmVkIEJpdHMnLCAnUkVEX0JJVFMnLCBnbC5nZXRQYXJhbWV0ZXIoZ2wuUkVEX0JJVFMpXSxcbiAgICAgIFsnRnJhbWVidWZmZXIgR3JlZW4gQml0cycsICdHUkVFTl9CSVRTJywgZ2wuZ2V0UGFyYW1ldGVyKGdsLkdSRUVOX0JJVFMpXSxcbiAgICAgIFsnRnJhbWVidWZmZXIgQmx1ZSBCaXRzJywgJ0JMVUVfQklUUycsIGdsLmdldFBhcmFtZXRlcihnbC5CTFVFX0JJVFMpXSxcbiAgICAgIFsnRnJhbWVidWZmZXIgQWxwaGEgQml0cycsICdBTFBIQV9CSVRTJywgZ2wuZ2V0UGFyYW1ldGVyKGdsLkFMUEhBX0JJVFMpXSxcbiAgICAgIFsnRnJhbWVidWZmZXIgRGVwdGggQml0cycsICdERVBUSF9CSVRTJywgZ2wuZ2V0UGFyYW1ldGVyKGdsLkRFUFRIX0JJVFMpXSxcbiAgICAgIFtcbiAgICAgICAgJ0ZyYW1lYnVmZmVyIFN0ZW5jaWwgQml0cycsXG4gICAgICAgICdTVEVOQ0lMX0JJVFMnLFxuICAgICAgICBnbC5nZXRQYXJhbWV0ZXIoZ2wuU1RFTkNJTF9CSVRTKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdGcmFtZWJ1ZmZlciBTdWJwaXhlbCBCaXRzJyxcbiAgICAgICAgJ1NVQlBJWEVMX0JJVFMnLFxuICAgICAgICBnbC5nZXRQYXJhbWV0ZXIoZ2wuU1VCUElYRUxfQklUUyksXG4gICAgICBdLFxuICAgICAgWydNU0FBIFNhbXBsZXMnLCAnU0FNUExFUycsIGdsLmdldFBhcmFtZXRlcihnbC5TQU1QTEVTKV0sXG4gICAgICBbXG4gICAgICAgICdNU0FBIFNhbXBsZSBCdWZmZXJzJyxcbiAgICAgICAgJ1NBTVBMRV9CVUZGRVJTJyxcbiAgICAgICAgZ2wuZ2V0UGFyYW1ldGVyKGdsLlNBTVBMRV9CVUZGRVJTKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdTdXBwb3J0ZWQgRm9ybWF0cyBmb3IgVUJ5dGUgUmVuZGVyIFRhcmdldHMgICAgICcsXG4gICAgICAgICdVTlNJR05FRF9CWVRFIFJFTkRFUiBUQVJHRVQgRk9STUFUUycsXG4gICAgICAgIFtcbiAgICAgICAgICBnbFRleHR1cmVGbG9hdCAmJlxuICAgICAgICAgIGNoZWNrUmVuZGVyVGFyZ2V0U3VwcG9ydChnbCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSlcbiAgICAgICAgICAgID8gJ1JHQkEnXG4gICAgICAgICAgICA6ICcnLFxuICAgICAgICAgIGdsVGV4dHVyZUZsb2F0ICYmXG4gICAgICAgICAgY2hlY2tSZW5kZXJUYXJnZXRTdXBwb3J0KGdsLCBnbC5SR0IsIGdsLlVOU0lHTkVEX0JZVEUpXG4gICAgICAgICAgICA/ICdSR0InXG4gICAgICAgICAgICA6ICcnLFxuICAgICAgICAgIGdsVGV4dHVyZUZsb2F0ICYmXG4gICAgICAgICAgY2hlY2tSZW5kZXJUYXJnZXRTdXBwb3J0KGdsLCBnbC5MVU1JTkFOQ0UsIGdsLlVOU0lHTkVEX0JZVEUpXG4gICAgICAgICAgICA/ICdMVU1JTkFOQ0UnXG4gICAgICAgICAgICA6ICcnLFxuICAgICAgICAgIGdsVGV4dHVyZUZsb2F0ICYmXG4gICAgICAgICAgY2hlY2tSZW5kZXJUYXJnZXRTdXBwb3J0KGdsLCBnbC5BTFBIQSwgZ2wuVU5TSUdORURfQllURSlcbiAgICAgICAgICAgID8gJ0FMUEhBJ1xuICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICBnbFRleHR1cmVGbG9hdCAmJlxuICAgICAgICAgIGNoZWNrUmVuZGVyVGFyZ2V0U3VwcG9ydChnbCwgZ2wuTFVNSU5BTkNFX0FMUEhBLCBnbC5VTlNJR05FRF9CWVRFKVxuICAgICAgICAgICAgPyAnTFVNSU5BTkNFX0FMUEhBJ1xuICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgXS5qb2luKCcgJyksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnU3VwcG9ydGVkIEZvcm1hdHMgZm9yIEhhbGYgRmxvYXQgUmVuZGVyIFRhcmdldHMnLFxuICAgICAgICAnSEFMRiBGTE9BVCBSRU5ERVIgVEFSR0VUIEZPUk1BVFMnLFxuICAgICAgICBbXG4gICAgICAgICAgZ2xUZXh0dXJlSGFsZkZsb2F0ICYmXG4gICAgICAgICAgY2hlY2tSZW5kZXJUYXJnZXRTdXBwb3J0KFxuICAgICAgICAgICAgZ2wsXG4gICAgICAgICAgICBnbC5SR0JBLFxuICAgICAgICAgICAgZ2xUZXh0dXJlSGFsZkZsb2F0LkhBTEZfRkxPQVRfT0VTXG4gICAgICAgICAgKVxuICAgICAgICAgICAgPyAnUkdCQSdcbiAgICAgICAgICAgIDogJycsXG4gICAgICAgICAgZ2xUZXh0dXJlSGFsZkZsb2F0ICYmXG4gICAgICAgICAgY2hlY2tSZW5kZXJUYXJnZXRTdXBwb3J0KFxuICAgICAgICAgICAgZ2wsXG4gICAgICAgICAgICBnbC5SR0IsXG4gICAgICAgICAgICBnbFRleHR1cmVIYWxmRmxvYXQuSEFMRl9GTE9BVF9PRVNcbiAgICAgICAgICApXG4gICAgICAgICAgICA/ICdSR0InXG4gICAgICAgICAgICA6ICcnLFxuICAgICAgICAgIGdsVGV4dHVyZUhhbGZGbG9hdCAmJlxuICAgICAgICAgIGNoZWNrUmVuZGVyVGFyZ2V0U3VwcG9ydChcbiAgICAgICAgICAgIGdsLFxuICAgICAgICAgICAgZ2wuTFVNSU5BTkNFLFxuICAgICAgICAgICAgZ2xUZXh0dXJlSGFsZkZsb2F0LkhBTEZfRkxPQVRfT0VTXG4gICAgICAgICAgKVxuICAgICAgICAgICAgPyAnTFVNSU5BTkNFJ1xuICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICBnbFRleHR1cmVIYWxmRmxvYXQgJiZcbiAgICAgICAgICBjaGVja1JlbmRlclRhcmdldFN1cHBvcnQoXG4gICAgICAgICAgICBnbCxcbiAgICAgICAgICAgIGdsLkFMUEhBLFxuICAgICAgICAgICAgZ2xUZXh0dXJlSGFsZkZsb2F0LkhBTEZfRkxPQVRfT0VTXG4gICAgICAgICAgKVxuICAgICAgICAgICAgPyAnQUxQSEEnXG4gICAgICAgICAgICA6ICcnLFxuICAgICAgICAgIGdsVGV4dHVyZUhhbGZGbG9hdCAmJlxuICAgICAgICAgIGNoZWNrUmVuZGVyVGFyZ2V0U3VwcG9ydChcbiAgICAgICAgICAgIGdsLFxuICAgICAgICAgICAgZ2wuTFVNSU5BTkNFX0FMUEhBLFxuICAgICAgICAgICAgZ2xUZXh0dXJlSGFsZkZsb2F0LkhBTEZfRkxPQVRfT0VTXG4gICAgICAgICAgKVxuICAgICAgICAgICAgPyAnTFVNSU5BTkNFX0FMUEhBJ1xuICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgXS5qb2luKCcgJyksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnU3VwcG9ydGVkIEZvcm1hdHMgZm9yIEZ1bGwgRmxvYXQgUmVuZGVyIFRhcmdldHMnLFxuICAgICAgICAnRkxPQVQgUkVOREVSIFRBUkdFVCBGT1JNQVRTJyxcbiAgICAgICAgW1xuICAgICAgICAgIGdsVGV4dHVyZUZsb2F0ICYmIGNoZWNrUmVuZGVyVGFyZ2V0U3VwcG9ydChnbCwgZ2wuUkdCQSwgZ2wuRkxPQVQpXG4gICAgICAgICAgICA/ICdSR0JBJ1xuICAgICAgICAgICAgOiAnJyxcbiAgICAgICAgICBnbFRleHR1cmVGbG9hdCAmJiBjaGVja1JlbmRlclRhcmdldFN1cHBvcnQoZ2wsIGdsLlJHQiwgZ2wuRkxPQVQpXG4gICAgICAgICAgICA/ICdSR0InXG4gICAgICAgICAgICA6ICcnLFxuICAgICAgICAgIGdsVGV4dHVyZUZsb2F0ICYmIGNoZWNrUmVuZGVyVGFyZ2V0U3VwcG9ydChnbCwgZ2wuTFVNSU5BTkNFLCBnbC5GTE9BVClcbiAgICAgICAgICAgID8gJ0xVTUlOQU5DRSdcbiAgICAgICAgICAgIDogJycsXG4gICAgICAgICAgZ2xUZXh0dXJlRmxvYXQgJiYgY2hlY2tSZW5kZXJUYXJnZXRTdXBwb3J0KGdsLCBnbC5BTFBIQSwgZ2wuRkxPQVQpXG4gICAgICAgICAgICA/ICdBTFBIQSdcbiAgICAgICAgICAgIDogJycsXG4gICAgICAgICAgZ2xUZXh0dXJlRmxvYXQgJiZcbiAgICAgICAgICBjaGVja1JlbmRlclRhcmdldFN1cHBvcnQoZ2wsIGdsLkxVTUlOQU5DRV9BTFBIQSwgZ2wuRkxPQVQpXG4gICAgICAgICAgICA/ICdMVU1JTkFOQ0VfQUxQSEEnXG4gICAgICAgICAgICA6ICcnLFxuICAgICAgICBdLmpvaW4oJyAnKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdNYXggTXVsdGlwbGUgUmVuZGVyIFRhcmdldHMgQnVmZmVycycsXG4gICAgICAgICdNQVhfRFJBV19CVUZGRVJTX1dFQkdMJyxcbiAgICAgICAgZ2xEcmF3QnVmZmVyc1xuICAgICAgICAgID8gZ2wuZ2V0UGFyYW1ldGVyKGdsRHJhd0J1ZmZlcnMuTUFYX0RSQVdfQlVGRkVSU19XRUJHTClcbiAgICAgICAgICA6IDAsXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnSGlnaCBGbG9hdCBQcmVjaXNpb24gaW4gVmVydGV4IFNoYWRlcicsXG4gICAgICAgICdISUdIX0ZMT0FUIFZFUlRFWF9TSEFERVInLFxuICAgICAgICBbXG4gICAgICAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLlZFUlRFWF9TSEFERVIsIGdsLkhJR0hfRkxPQVQpXG4gICAgICAgICAgICAucHJlY2lzaW9uLFxuICAgICAgICAgICcgKC0yPHN1cD4nLFxuICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5WRVJURVhfU0hBREVSLCBnbC5ISUdIX0ZMT0FUKS5yYW5nZU1pbixcbiAgICAgICAgICAnPC9zdXA+IC0gMjxzdXA+JyxcbiAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuVkVSVEVYX1NIQURFUiwgZ2wuSElHSF9GTE9BVCkucmFuZ2VNYXgsXG4gICAgICAgICAgJzwvc3VwPiknLFxuICAgICAgICBdLmpvaW4oJycpLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ01lZGl1bSBGbG9hdCBQcmVjaXNpb24gaW4gVmVydGV4IFNoYWRlcicsXG4gICAgICAgICdNRURJVU1fRkxPQVQgVkVSVEVYX1NIQURFUicsXG4gICAgICAgIFtcbiAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUKVxuICAgICAgICAgICAgLnByZWNpc2lvbixcbiAgICAgICAgICAnICgtMjxzdXA+JyxcbiAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUKVxuICAgICAgICAgICAgLnJhbmdlTWluLFxuICAgICAgICAgICc8L3N1cD4gLSAyPHN1cD4nLFxuICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5WRVJURVhfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQpXG4gICAgICAgICAgICAucmFuZ2VNYXgsXG4gICAgICAgICAgJzwvc3VwPiknLFxuICAgICAgICBdLmpvaW4oJycpLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ0xvdyBGbG9hdCBQcmVjaXNpb24gaW4gVmVydGV4IFNoYWRlcicsXG4gICAgICAgICdMT1dfRkxPQVQgVkVSVEVYX1NIQURFUicsXG4gICAgICAgIFtcbiAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTE9XX0ZMT0FUKS5wcmVjaXNpb24sXG4gICAgICAgICAgJyAoLTI8c3VwPicsXG4gICAgICAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLlZFUlRFWF9TSEFERVIsIGdsLkxPV19GTE9BVCkucmFuZ2VNaW4sXG4gICAgICAgICAgJzwvc3VwPiAtIDI8c3VwPicsXG4gICAgICAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLlZFUlRFWF9TSEFERVIsIGdsLkxPV19GTE9BVCkucmFuZ2VNYXgsXG4gICAgICAgICAgJzwvc3VwPiknLFxuICAgICAgICBdLmpvaW4oJycpLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ0hpZ2ggRmxvYXQgUHJlY2lzaW9uIGluIEZyYWdtZW50IFNoYWRlcicsXG4gICAgICAgICdISUdIX0ZMT0FUIEZSQUdNRU5UX1NIQURFUicsXG4gICAgICAgIFtcbiAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUKVxuICAgICAgICAgICAgLnByZWNpc2lvbixcbiAgICAgICAgICAnICgtMjxzdXA+JyxcbiAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0ZMT0FUKVxuICAgICAgICAgICAgLnJhbmdlTWluLFxuICAgICAgICAgICc8L3N1cD4gLSAyPHN1cD4nLFxuICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfRkxPQVQpXG4gICAgICAgICAgICAucmFuZ2VNYXgsXG4gICAgICAgICAgJzwvc3VwPiknLFxuICAgICAgICBdLmpvaW4oJycpLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ01lZGl1bSBGbG9hdCBQcmVjaXNpb24gaW4gRnJhZ21lbnQgU2hhZGVyJyxcbiAgICAgICAgJ01FRElVTV9GTE9BVCBGUkFHTUVOVF9TSEFERVInLFxuICAgICAgICBbXG4gICAgICAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUKVxuICAgICAgICAgICAgLnByZWNpc2lvbixcbiAgICAgICAgICAnICgtMjxzdXA+JyxcbiAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fRkxPQVQpXG4gICAgICAgICAgICAucmFuZ2VNaW4sXG4gICAgICAgICAgJzwvc3VwPiAtIDI8c3VwPicsXG4gICAgICAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUKVxuICAgICAgICAgICAgLnJhbmdlTWF4LFxuICAgICAgICAgICc8L3N1cD4pJyxcbiAgICAgICAgXS5qb2luKCcnKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdMb3cgRmxvYXQgUHJlY2lzaW9uIGluIEZyYWdtZW50IFNoYWRlcicsXG4gICAgICAgICdMT1dfRkxPQVQgRlJBR01FTlRfU0hBREVSJyxcbiAgICAgICAgW1xuICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkxPV19GTE9BVClcbiAgICAgICAgICAgIC5wcmVjaXNpb24sXG4gICAgICAgICAgJyAoLTI8c3VwPicsXG4gICAgICAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTE9XX0ZMT0FUKVxuICAgICAgICAgICAgLnJhbmdlTWluLFxuICAgICAgICAgICc8L3N1cD4gLSAyPHN1cD4nLFxuICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkxPV19GTE9BVClcbiAgICAgICAgICAgIC5yYW5nZU1heCxcbiAgICAgICAgICAnPC9zdXA+KScsXG4gICAgICAgIF0uam9pbignJyksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnSGlnaCBJbnQgUHJlY2lzaW9uIGluIFZlcnRleCBTaGFkZXInLFxuICAgICAgICAnSElHSF9JTlQgVkVSVEVYX1NIQURFUicsXG4gICAgICAgIFtcbiAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuVkVSVEVYX1NIQURFUiwgZ2wuSElHSF9JTlQpLnByZWNpc2lvbixcbiAgICAgICAgICAnICgtMjxzdXA+JyxcbiAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuVkVSVEVYX1NIQURFUiwgZ2wuSElHSF9JTlQpLnJhbmdlTWluLFxuICAgICAgICAgICc8L3N1cD4gLSAyPHN1cD4nLFxuICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5WRVJURVhfU0hBREVSLCBnbC5ISUdIX0lOVCkucmFuZ2VNYXgsXG4gICAgICAgICAgJzwvc3VwPiknLFxuICAgICAgICBdLmpvaW4oJycpLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ01lZGl1bSBJbnQgUHJlY2lzaW9uIGluIFZlcnRleCBTaGFkZXInLFxuICAgICAgICAnTUVESVVNX0lOVCBWRVJURVhfU0hBREVSJyxcbiAgICAgICAgW1xuICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5WRVJURVhfU0hBREVSLCBnbC5NRURJVU1fSU5UKVxuICAgICAgICAgICAgLnByZWNpc2lvbixcbiAgICAgICAgICAnICgtMjxzdXA+JyxcbiAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTUVESVVNX0lOVCkucmFuZ2VNaW4sXG4gICAgICAgICAgJzwvc3VwPiAtIDI8c3VwPicsXG4gICAgICAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLlZFUlRFWF9TSEFERVIsIGdsLk1FRElVTV9JTlQpLnJhbmdlTWF4LFxuICAgICAgICAgICc8L3N1cD4pJyxcbiAgICAgICAgXS5qb2luKCcnKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdMb3cgSW50IFByZWNpc2lvbiBpbiBWZXJ0ZXggU2hhZGVyJyxcbiAgICAgICAgJ0xPV19JTlQgVkVSVEVYX1NIQURFUicsXG4gICAgICAgIFtcbiAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTE9XX0lOVCkucHJlY2lzaW9uLFxuICAgICAgICAgICcgKC0yPHN1cD4nLFxuICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5WRVJURVhfU0hBREVSLCBnbC5MT1dfSU5UKS5yYW5nZU1pbixcbiAgICAgICAgICAnPC9zdXA+IC0gMjxzdXA+JyxcbiAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTE9XX0lOVCkucmFuZ2VNYXgsXG4gICAgICAgICAgJzwvc3VwPiknLFxuICAgICAgICBdLmpvaW4oJycpLFxuICAgICAgXSxcbiAgICAgIFtcbiAgICAgICAgJ0hpZ2ggSW50IFByZWNpc2lvbiBpbiBGcmFnbWVudCBTaGFkZXInLFxuICAgICAgICAnSElHSF9JTlQgRlJBR01FTlRfU0hBREVSJyxcbiAgICAgICAgW1xuICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkhJR0hfSU5UKVxuICAgICAgICAgICAgLnByZWNpc2lvbixcbiAgICAgICAgICAnICgtMjxzdXA+JyxcbiAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5ISUdIX0lOVCkucmFuZ2VNaW4sXG4gICAgICAgICAgJzwvc3VwPiAtIDI8c3VwPicsXG4gICAgICAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9JTlQpLnJhbmdlTWF4LFxuICAgICAgICAgICc8L3N1cD4pJyxcbiAgICAgICAgXS5qb2luKCcnKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdNZWRpdW0gSW50IFByZWNpc2lvbiBpbiBGcmFnbWVudCBTaGFkZXInLFxuICAgICAgICAnTUVESVVNX0lOVCBGUkFHTUVOVF9TSEFERVInLFxuICAgICAgICBbXG4gICAgICAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0lOVClcbiAgICAgICAgICAgIC5wcmVjaXNpb24sXG4gICAgICAgICAgJyAoLTI8c3VwPicsXG4gICAgICAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTUVESVVNX0lOVClcbiAgICAgICAgICAgIC5yYW5nZU1pbixcbiAgICAgICAgICAnPC9zdXA+IC0gMjxzdXA+JyxcbiAgICAgICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoZ2wuRlJBR01FTlRfU0hBREVSLCBnbC5NRURJVU1fSU5UKVxuICAgICAgICAgICAgLnJhbmdlTWF4LFxuICAgICAgICAgICc8L3N1cD4pJyxcbiAgICAgICAgXS5qb2luKCcnKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdMb3cgSW50IFByZWNpc2lvbiBpbiBGcmFnbWVudCBTaGFkZXInLFxuICAgICAgICAnTE9XX0lOVCBGUkFHTUVOVF9TSEFERVInLFxuICAgICAgICBbXG4gICAgICAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuTE9XX0lOVCkucHJlY2lzaW9uLFxuICAgICAgICAgICcgKC0yPHN1cD4nLFxuICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkxPV19JTlQpLnJhbmdlTWluLFxuICAgICAgICAgICc8L3N1cD4gLSAyPHN1cD4nLFxuICAgICAgICAgIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChnbC5GUkFHTUVOVF9TSEFERVIsIGdsLkxPV19JTlQpLnJhbmdlTWF4LFxuICAgICAgICAgICc8L3N1cD4pJyxcbiAgICAgICAgXS5qb2luKCcnKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdTdXBwb3J0ZWQgRXh0ZW5zaW9ucycsXG4gICAgICAgICdFWFRFTlNJT05TJyxcbiAgICAgICAgZ2wuZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpLmpvaW4oJzxici8+XFx0XFx0XFx0XFx0XFx0ICAgICcpLFxuICAgICAgXSxcbiAgICAgIFsnV2ViR0wgUmVuZGVyZXInLCAnUkVOREVSRVInLCBnbC5nZXRQYXJhbWV0ZXIoZ2wuUkVOREVSRVIpXSxcbiAgICAgIFsnV2ViR0wgVmVuZG9yJywgJ1ZFTkRPUicsIGdsLmdldFBhcmFtZXRlcihnbC5WRU5ET1IpXSxcbiAgICAgIFsnV2ViR0wgVmVyc2lvbicsICdWRVJTSU9OJywgZ2wuZ2V0UGFyYW1ldGVyKGdsLlZFUlNJT04pXSxcbiAgICAgIFtcbiAgICAgICAgJ1NoYWRpbmcgTGFuZ3VhZ2UgVmVyc2lvbicsXG4gICAgICAgICdTSEFESU5HX0xBTkdVQUdFX1ZFUlNJT04nLFxuICAgICAgICBnbC5nZXRQYXJhbWV0ZXIoZ2wuU0hBRElOR19MQU5HVUFHRV9WRVJTSU9OKSxcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgICdVbm1hc2tlZCBSZW5kZXJlcicsXG4gICAgICAgICdVTk1BU0tFRF9SRU5ERVJFUicsXG4gICAgICAgIGdsRGVidWdSZW5kZXJlckluZm8gJiZcbiAgICAgICAgICBnbC5nZXRQYXJhbWV0ZXIoZ2xEZWJ1Z1JlbmRlcmVySW5mby5VTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCksXG4gICAgICBdLFxuICAgICAgW1xuICAgICAgICAnVW5tYXNrZWQgVmVuZG9yJyxcbiAgICAgICAgJ1VOTUFTS0VEX1ZFTkRPUicsXG4gICAgICAgIGdsRGVidWdSZW5kZXJlckluZm8gJiZcbiAgICAgICAgICBnbC5nZXRQYXJhbWV0ZXIoZ2xEZWJ1Z1JlbmRlcmVySW5mby5VTk1BU0tFRF9WRU5ET1JfV0VCR0wpLFxuICAgICAgXSxcbiAgICAgIFsnV2ViR0wgVmVyc2lvbicsICdXRUJHTF9WRVJTSU9OJywgbW9kZWwud2ViZ2wyID8gMiA6IDFdLFxuICAgIF07XG5cbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICB3aGlsZSAocGFyYW1zLmxlbmd0aCkge1xuICAgICAgY29uc3QgW2xhYmVsLCBrZXksIHZhbHVlXSA9IHBhcmFtcy5wb3AoKTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB7IGxhYmVsLCB2YWx1ZSB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIHB1YmxpY0FQSS50cmF2ZXJzZUFsbFBhc3NlcyA9ICgpID0+IHtcbiAgICBpZiAobW9kZWwucmVuZGVyUGFzc2VzKSB7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbW9kZWwucmVuZGVyUGFzc2VzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICBtb2RlbC5yZW5kZXJQYXNzZXNbaW5kZXhdLnRyYXZlcnNlKHB1YmxpY0FQSSwgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtb2RlbC5ub3RpZnlTdGFydENhcHR1cmVJbWFnZSkge1xuICAgICAgZ2V0Q2FudmFzRGF0YVVSTCgpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuZGlzYWJsZURlcHRoTWFzayA9ICgpID0+IHtcbiAgICBpZiAobW9kZWwuZGVwdGhNYXNrRW5hYmxlZCkge1xuICAgICAgbW9kZWwuY29udGV4dC5kZXB0aE1hc2soZmFsc2UpO1xuICAgICAgbW9kZWwuZGVwdGhNYXNrRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuZW5hYmxlRGVwdGhNYXNrID0gKCkgPT4ge1xuICAgIGlmICghbW9kZWwuZGVwdGhNYXNrRW5hYmxlZCkge1xuICAgICAgbW9kZWwuY29udGV4dC5kZXB0aE1hc2sodHJ1ZSk7XG4gICAgICBtb2RlbC5kZXB0aE1hc2tFbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmRpc2FibGVDdWxsRmFjZSA9ICgpID0+IHtcbiAgICBpZiAobW9kZWwuY3VsbEZhY2VFbmFibGVkKSB7XG4gICAgICBtb2RlbC5jb250ZXh0LmRpc2FibGUobW9kZWwuY29udGV4dC5DVUxMX0ZBQ0UpO1xuICAgICAgbW9kZWwuY3VsbEZhY2VFbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5lbmFibGVDdWxsRmFjZSA9ICgpID0+IHtcbiAgICBpZiAoIW1vZGVsLmN1bGxGYWNlRW5hYmxlZCkge1xuICAgICAgbW9kZWwuY29udGV4dC5lbmFibGUobW9kZWwuY29udGV4dC5DVUxMX0ZBQ0UpO1xuICAgICAgbW9kZWwuY3VsbEZhY2VFbmFibGVkID0gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLnNldFZpZXdTdHJlYW0gPSAoc3RyZWFtKSA9PiB7XG4gICAgaWYgKG1vZGVsLnZpZXdTdHJlYW0gPT09IHN0cmVhbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobW9kZWwuc3Vic2NyaXB0aW9uKSB7XG4gICAgICBtb2RlbC5zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgIG1vZGVsLnN1YnNjcmlwdGlvbiA9IG51bGw7XG4gICAgfVxuICAgIG1vZGVsLnZpZXdTdHJlYW0gPSBzdHJlYW07XG4gICAgaWYgKG1vZGVsLnZpZXdTdHJlYW0pIHtcbiAgICAgIC8vIEZvcmNlIGJhY2tncm91bmQgdG8gYmUgdHJhbnNwYXJlbnQgKyByZW5kZXJcbiAgICAgIGNvbnN0IG1haW5SZW5kZXJlciA9IG1vZGVsLnJlbmRlcmFibGUuZ2V0UmVuZGVyZXJzKClbMF07XG4gICAgICBtYWluUmVuZGVyZXIuZ2V0QmFja2dyb3VuZEJ5UmVmZXJlbmNlKClbM10gPSAwO1xuXG4gICAgICAvLyBFbmFibGUgZGlzcGxheSBvZiB0aGUgYmFja2dyb3VuZCBpbWFnZVxuICAgICAgcHVibGljQVBJLnNldFVzZUJhY2tncm91bmRJbWFnZSh0cnVlKTtcblxuICAgICAgLy8gQmluZCB0byByZW1vdGUgc3RyZWFtXG4gICAgICBtb2RlbC5zdWJzY3JpcHRpb24gPSBtb2RlbC52aWV3U3RyZWFtLm9uSW1hZ2VSZWFkeSgoZSkgPT5cbiAgICAgICAgcHVibGljQVBJLnNldEJhY2tncm91bmRJbWFnZShlLmltYWdlKVxuICAgICAgKTtcbiAgICAgIG1vZGVsLnZpZXdTdHJlYW0uc2V0U2l6ZShtb2RlbC5zaXplWzBdLCBtb2RlbC5zaXplWzFdKTtcbiAgICAgIG1vZGVsLnZpZXdTdHJlYW0uaW52YWxpZGF0ZUNhY2hlKCk7XG4gICAgICBtb2RlbC52aWV3U3RyZWFtLnJlbmRlcigpO1xuXG4gICAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLmRlbGV0ZSA9IG1hY3JvLmNoYWluKFxuICAgIHB1YmxpY0FQSS5kZWxldGUsXG4gICAgcHVibGljQVBJLnNldFZpZXdTdHJlYW0sXG4gICAgZGVsZXRlR0xDb250ZXh0XG4gICk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBjdWxsRmFjZUVuYWJsZWQ6IGZhbHNlLFxuICBkZXB0aE1hc2tFbmFibGVkOiB0cnVlLFxuICBzaGFkZXJDYWNoZTogbnVsbCxcbiAgaW5pdGlhbGl6ZWQ6IGZhbHNlLFxuICBjb250ZXh0OiBudWxsLFxuICBjYW52YXM6IG51bGwsXG4gIHNpemU6IFszMDAsIDMwMF0sXG4gIGN1cnNvclZpc2liaWxpdHk6IHRydWUsXG4gIGN1cnNvcjogJ3BvaW50ZXInLFxuICB0ZXh0dXJlVW5pdE1hbmFnZXI6IG51bGwsXG4gIHRleHR1cmVSZXNvdXJjZUlkczogbnVsbCxcbiAgY29udGFpbmVyU2l6ZTogbnVsbCxcbiAgcmVuZGVyUGFzc2VzOiBbXSxcbiAgbm90aWZ5U3RhcnRDYXB0dXJlSW1hZ2U6IGZhbHNlLFxuICB3ZWJnbDI6IGZhbHNlLFxuICBkZWZhdWx0VG9XZWJnbDI6IHRydWUsIC8vIGF0dGVtcHQgd2ViZ2wyIG9uIGJ5IGRlZmF1bHRcbiAgdnJSZXNvbHV0aW9uOiBbMjE2MCwgMTIwMF0sXG4gIHF1ZXJ5VlJTaXplOiBmYWxzZSxcbiAgaGlkZUNhbnZhc0luVlI6IHRydWUsXG4gIGFjdGl2ZUZyYW1lYnVmZmVyOiBudWxsLFxuICB2ckRpc3BsYXk6IG51bGwsXG4gIGltYWdlRm9ybWF0OiAnaW1hZ2UvcG5nJyxcbiAgdXNlT2ZmU2NyZWVuOiBmYWxzZSxcbiAgdXNlQmFja2dyb3VuZEltYWdlOiBmYWxzZSxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIENyZWF0ZSBpbnRlcm5hbCBpbnN0YW5jZXNcbiAgbW9kZWwuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIG1vZGVsLmNhbnZhcy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgY3JlYXRlR0xDb250ZXh0KCk7XG5cbiAgLy8gQ3JlYXRlIGludGVybmFsIGJnSW1hZ2VcbiAgbW9kZWwuYmdJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICBtb2RlbC5iZ0ltYWdlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgbW9kZWwuYmdJbWFnZS5zdHlsZS5sZWZ0ID0gJzAnO1xuICBtb2RlbC5iZ0ltYWdlLnN0eWxlLnRvcCA9ICcwJztcbiAgbW9kZWwuYmdJbWFnZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgbW9kZWwuYmdJbWFnZS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gIG1vZGVsLmJnSW1hZ2Uuc3R5bGUuekluZGV4ID0gJy0xJztcblxuICBtb2RlbC50ZXh0dXJlUmVzb3VyY2VJZHMgPSBuZXcgTWFwKCk7XG5cbiAgLy8gSW5oZXJpdGFuY2VcbiAgdnRrVmlld05vZGUuZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIG1vZGVsLm15RmFjdG9yeSA9IHZ0a09wZW5HTFZpZXdOb2RlRmFjdG9yeS5uZXdJbnN0YW5jZSgpO1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuICBtb2RlbC5teUZhY3RvcnkucmVnaXN0ZXJPdmVycmlkZSgndnRrUmVuZGVyV2luZG93JywgbmV3SW5zdGFuY2UpO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5cbiAgbW9kZWwuc2hhZGVyQ2FjaGUgPSB2dGtTaGFkZXJDYWNoZS5uZXdJbnN0YW5jZSgpO1xuICBtb2RlbC5zaGFkZXJDYWNoZS5zZXRPcGVuR0xSZW5kZXJXaW5kb3cocHVibGljQVBJKTtcblxuICAvLyBzZXR1cCBkZWZhdWx0IGZvcndhcmQgcGFzcyByZW5kZXJpbmdcbiAgbW9kZWwucmVuZGVyUGFzc2VzWzBdID0gdnRrRm9yd2FyZFBhc3MubmV3SW5zdGFuY2UoKTtcblxuICBtYWNyby5ldmVudChwdWJsaWNBUEksIG1vZGVsLCAnaW1hZ2VSZWFkeScpO1xuICBtYWNyby5ldmVudChwdWJsaWNBUEksIG1vZGVsLCAnaGF2ZVZSRGlzcGxheScpO1xuXG4gIC8vIEJ1aWxkIFZUSyBBUElcbiAgbWFjcm8uZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIFtcbiAgICAnc2hhZGVyQ2FjaGUnLFxuICAgICd0ZXh0dXJlVW5pdE1hbmFnZXInLFxuICAgICd3ZWJnbDInLFxuICAgICd2ckRpc3BsYXknLFxuICAgICd1c2VCYWNrZ3JvdW5kSW1hZ2UnLFxuICBdKTtcblxuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgW1xuICAgICdpbml0aWFsaXplZCcsXG4gICAgJ2NvbnRleHQnLFxuICAgICdjYW52YXMnLFxuICAgICdyZW5kZXJQYXNzZXMnLFxuICAgICdub3RpZnlTdGFydENhcHR1cmVJbWFnZScsXG4gICAgJ2RlZmF1bHRUb1dlYmdsMicsXG4gICAgJ2N1cnNvcicsXG4gICAgJ3F1ZXJ5VlJTaXplJyxcbiAgICAnaGlkZUNhbnZhc0luVlInLFxuICAgICd1c2VPZmZTY3JlZW4nLFxuICAgIC8vIG1pZ2h0IHdhbnQgdG8gbWFrZSB0aGlzIG5vdCBjYWxsIG1vZGlmaWVkIGFzXG4gICAgLy8gd2UgY2hhbmdlIHRoZSBhY3RpdmUgZnJhbWVidWZmZXIgYSBsb3QuIE9yIG1heWJlXG4gICAgLy8gb25seSBtYXJrIG1vZGlmaWVkIGlmIHRoZSBzaXplIG9yIGRlcHRoXG4gICAgLy8gb2YgdGhlIGJ1ZmZlciBoYXMgY2hhbmdlZFxuICAgICdhY3RpdmVGcmFtZWJ1ZmZlcicsXG4gIF0pO1xuXG4gIG1hY3JvLnNldEdldEFycmF5KHB1YmxpY0FQSSwgbW9kZWwsIFsnc2l6ZScsICd2clJlc29sdXRpb24nXSwgMik7XG5cbiAgLy8gT2JqZWN0IG1ldGhvZHNcbiAgdnRrT3BlbkdMUmVuZGVyV2luZG93KHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a09wZW5HTFJlbmRlcldpbmRvdycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmV3SW5zdGFuY2UsXG4gIGV4dGVuZCxcbiAgcHVzaE1vbml0b3JHTENvbnRleHRDb3VudCxcbiAgcG9wTW9uaXRvckdMQ29udGV4dENvdW50LFxufTtcbiIsImltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgdnRrVmlld05vZGUgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL1NjZW5lR3JhcGgvVmlld05vZGUnO1xuaW1wb3J0ICogYXMgdnRrTWF0aCBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9NYXRoJztcblxuY29uc3QgeyB2dGtEZWJ1Z01hY3JvIH0gPSBtYWNybztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrT3BlbkdMUmVuZGVyZXIgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG5mdW5jdGlvbiB2dGtPcGVuR0xSZW5kZXJlcihwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a09wZW5HTFJlbmRlcmVyJyk7XG5cbiAgLy8gQnVpbGRzIG15c2VsZi5cbiAgcHVibGljQVBJLmJ1aWxkUGFzcyA9IChwcmVwYXNzKSA9PiB7XG4gICAgaWYgKHByZXBhc3MpIHtcbiAgICAgIGlmICghbW9kZWwucmVuZGVyYWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBoYXZlIGEgY2FtZXJhXG4gICAgICBpZiAoIW1vZGVsLnJlbmRlcmFibGUuaXNBY3RpdmVDYW1lcmFDcmVhdGVkKCkpIHtcbiAgICAgICAgbW9kZWwucmVuZGVyYWJsZS5yZXNldENhbWVyYSgpO1xuICAgICAgfVxuICAgICAgcHVibGljQVBJLnVwZGF0ZUxpZ2h0cygpO1xuICAgICAgcHVibGljQVBJLnByZXBhcmVOb2RlcygpO1xuICAgICAgcHVibGljQVBJLmFkZE1pc3NpbmdOb2RlKG1vZGVsLnJlbmRlcmFibGUuZ2V0QWN0aXZlQ2FtZXJhKCkpO1xuICAgICAgcHVibGljQVBJLmFkZE1pc3NpbmdOb2Rlcyhtb2RlbC5yZW5kZXJhYmxlLmdldFZpZXdQcm9wc1dpdGhOZXN0ZWRQcm9wcygpKTtcbiAgICAgIHB1YmxpY0FQSS5yZW1vdmVVbnVzZWROb2RlcygpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkudXBkYXRlTGlnaHRzID0gKCkgPT4ge1xuICAgIGxldCBjb3VudCA9IDA7XG5cbiAgICBjb25zdCBsaWdodHMgPSBtb2RlbC5yZW5kZXJhYmxlLmdldExpZ2h0c0J5UmVmZXJlbmNlKCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxpZ2h0cy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIGlmIChsaWdodHNbaW5kZXhdLmdldFN3aXRjaCgpID4gMC4wKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb3VudCkge1xuICAgICAgdnRrRGVidWdNYWNybygnTm8gbGlnaHRzIGFyZSBvbiwgY3JlYXRpbmcgb25lLicpO1xuICAgICAgbW9kZWwucmVuZGVyYWJsZS5jcmVhdGVMaWdodCgpO1xuICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfTtcblxuICBwdWJsaWNBUEkub3BhcXVlWkJ1ZmZlclBhc3MgPSAocHJlcGFzcykgPT4ge1xuICAgIGlmIChwcmVwYXNzKSB7XG4gICAgICBsZXQgY2xlYXJNYXNrID0gMDtcbiAgICAgIGNvbnN0IGdsID0gbW9kZWwuY29udGV4dDtcbiAgICAgIGlmICghbW9kZWwucmVuZGVyYWJsZS5nZXRUcmFuc3BhcmVudCgpKSB7XG4gICAgICAgIG1vZGVsLmNvbnRleHQuY2xlYXJDb2xvcigxLjAsIDAuMCwgMC4wLCAxLjApO1xuICAgICAgICBjbGVhck1hc2sgfD0gZ2wuQ09MT1JfQlVGRkVSX0JJVDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtb2RlbC5yZW5kZXJhYmxlLmdldFByZXNlcnZlRGVwdGhCdWZmZXIoKSkge1xuICAgICAgICBnbC5jbGVhckRlcHRoKDEuMCk7XG4gICAgICAgIGNsZWFyTWFzayB8PSBnbC5ERVBUSF9CVUZGRVJfQklUO1xuICAgICAgICBnbC5kZXB0aE1hc2sodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRzID0gcHVibGljQVBJLmdldFRpbGVkU2l6ZUFuZE9yaWdpbigpO1xuICAgICAgZ2wuZW5hYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICBnbC5zY2lzc29yKHRzLmxvd2VyTGVmdFUsIHRzLmxvd2VyTGVmdFYsIHRzLnVzaXplLCB0cy52c2l6ZSk7XG4gICAgICBnbC52aWV3cG9ydCh0cy5sb3dlckxlZnRVLCB0cy5sb3dlckxlZnRWLCB0cy51c2l6ZSwgdHMudnNpemUpO1xuXG4gICAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBnbC5jbGVhcihjbGVhck1hc2spO1xuXG4gICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlbmRlcnMgbXlzZWxmXG4gIHB1YmxpY0FQSS5jYW1lcmFQYXNzID0gKHByZXBhc3MpID0+IHtcbiAgICBpZiAocHJlcGFzcykge1xuICAgICAgcHVibGljQVBJLmNsZWFyKCk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRBc3BlY3RSYXRpbyA9ICgpID0+IHtcbiAgICBjb25zdCBzaXplID0gbW9kZWwucGFyZW50LmdldFNpemVCeVJlZmVyZW5jZSgpO1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gbW9kZWwucmVuZGVyYWJsZS5nZXRWaWV3cG9ydEJ5UmVmZXJlbmNlKCk7XG4gICAgcmV0dXJuIChcbiAgICAgIChzaXplWzBdICogKHZpZXdwb3J0WzJdIC0gdmlld3BvcnRbMF0pKSAvXG4gICAgICAoKHZpZXdwb3J0WzNdIC0gdmlld3BvcnRbMV0pICogc2l6ZVsxXSlcbiAgICApO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRUaWxlZFNpemVBbmRPcmlnaW4gPSAoKSA9PiB7XG4gICAgY29uc3QgdnBvcnQgPSBtb2RlbC5yZW5kZXJhYmxlLmdldFZpZXdwb3J0QnlSZWZlcmVuY2UoKTtcblxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIHdpbmRvdyBhc3N1bWUgMCAxXG4gICAgY29uc3QgdGlsZVZpZXdQb3J0ID0gWzAuMCwgMC4wLCAxLjAsIDEuMF07XG5cbiAgICAvLyBmaW5kIHRoZSBsb3dlciBsZWZ0IGNvcm5lciBvZiB0aGUgdmlld3BvcnQsIHRha2luZyBpbnRvIGFjY291bnQgdGhlXG4gICAgLy8gbG93ZXIgbGVmdCBib3VuZGFyeSBvZiB0aGlzIHRpbGVcbiAgICBjb25zdCB2cHUgPSB2dGtNYXRoLmNsYW1wVmFsdWUodnBvcnRbMF0gLSB0aWxlVmlld1BvcnRbMF0sIDAuMCwgMS4wKTtcbiAgICBjb25zdCB2cHYgPSB2dGtNYXRoLmNsYW1wVmFsdWUodnBvcnRbMV0gLSB0aWxlVmlld1BvcnRbMV0sIDAuMCwgMS4wKTtcblxuICAgIC8vIHN0b3JlIHRoZSByZXN1bHQgYXMgYSBwaXhlbCB2YWx1ZVxuICAgIGNvbnN0IG5kdnAgPSBtb2RlbC5wYXJlbnQubm9ybWFsaXplZERpc3BsYXlUb0Rpc3BsYXkodnB1LCB2cHYpO1xuICAgIGNvbnN0IGxvd2VyTGVmdFUgPSBNYXRoLnJvdW5kKG5kdnBbMF0pO1xuICAgIGNvbnN0IGxvd2VyTGVmdFYgPSBNYXRoLnJvdW5kKG5kdnBbMV0pO1xuXG4gICAgLy8gZmluZCB0aGUgdXBwZXIgcmlnaHQgY29ybmVyIG9mIHRoZSB2aWV3cG9ydCwgdGFraW5nIGludG8gYWNjb3VudCB0aGVcbiAgICAvLyBsb3dlciBsZWZ0IGJvdW5kYXJ5IG9mIHRoaXMgdGlsZVxuICAgIGxldCB2cHUyID0gdnRrTWF0aC5jbGFtcFZhbHVlKHZwb3J0WzJdIC0gdGlsZVZpZXdQb3J0WzBdLCAwLjAsIDEuMCk7XG4gICAgbGV0IHZwdjIgPSB2dGtNYXRoLmNsYW1wVmFsdWUodnBvcnRbM10gLSB0aWxlVmlld1BvcnRbMV0sIDAuMCwgMS4wKTtcbiAgICAvLyBhbHNvIHdhdGNoIGZvciB0aGUgdXBwZXIgcmlnaHQgYm91bmRhcnkgb2YgdGhlIHRpbGVcbiAgICBpZiAodnB1MiA+IHRpbGVWaWV3UG9ydFsyXSAtIHRpbGVWaWV3UG9ydFswXSkge1xuICAgICAgdnB1MiA9IHRpbGVWaWV3UG9ydFsyXSAtIHRpbGVWaWV3UG9ydFswXTtcbiAgICB9XG4gICAgaWYgKHZwdjIgPiB0aWxlVmlld1BvcnRbM10gLSB0aWxlVmlld1BvcnRbMV0pIHtcbiAgICAgIHZwdjIgPSB0aWxlVmlld1BvcnRbM10gLSB0aWxlVmlld1BvcnRbMV07XG4gICAgfVxuICAgIGNvbnN0IG5kdnAyID0gbW9kZWwucGFyZW50Lm5vcm1hbGl6ZWREaXNwbGF5VG9EaXNwbGF5KHZwdTIsIHZwdjIpO1xuXG4gICAgLy8gbm93IGNvbXB1dGUgdGhlIHNpemUgb2YgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdmlld3BvcnQgd2l0aCB0aGVcbiAgICAvLyBjdXJyZW50IHRpbGVcbiAgICBsZXQgdXNpemUgPSBNYXRoLnJvdW5kKG5kdnAyWzBdKSAtIGxvd2VyTGVmdFU7XG4gICAgbGV0IHZzaXplID0gTWF0aC5yb3VuZChuZHZwMlsxXSkgLSBsb3dlckxlZnRWO1xuXG4gICAgaWYgKHVzaXplIDwgMCkge1xuICAgICAgdXNpemUgPSAwO1xuICAgIH1cbiAgICBpZiAodnNpemUgPCAwKSB7XG4gICAgICB2c2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdXNpemUsIHZzaXplLCBsb3dlckxlZnRVLCBsb3dlckxlZnRWIH07XG4gIH07XG5cbiAgcHVibGljQVBJLmNsZWFyID0gKCkgPT4ge1xuICAgIGxldCBjbGVhck1hc2sgPSAwO1xuICAgIGNvbnN0IGdsID0gbW9kZWwuY29udGV4dDtcblxuICAgIGlmICghbW9kZWwucmVuZGVyYWJsZS5nZXRUcmFuc3BhcmVudCgpKSB7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kID0gbW9kZWwucmVuZGVyYWJsZS5nZXRCYWNrZ3JvdW5kQnlSZWZlcmVuY2UoKTtcbiAgICAgIC8vIHJlbmRlcmFibGUgZW5zdXJlcyB0aGF0IGJhY2tncm91bmQgaGFzIDQgZW50cmllcy5cbiAgICAgIG1vZGVsLmNvbnRleHQuY2xlYXJDb2xvcihcbiAgICAgICAgYmFja2dyb3VuZFswXSxcbiAgICAgICAgYmFja2dyb3VuZFsxXSxcbiAgICAgICAgYmFja2dyb3VuZFsyXSxcbiAgICAgICAgYmFja2dyb3VuZFszXVxuICAgICAgKTtcbiAgICAgIGNsZWFyTWFzayB8PSBnbC5DT0xPUl9CVUZGRVJfQklUO1xuICAgIH1cblxuICAgIGlmICghbW9kZWwucmVuZGVyYWJsZS5nZXRQcmVzZXJ2ZURlcHRoQnVmZmVyKCkpIHtcbiAgICAgIGdsLmNsZWFyRGVwdGgoMS4wKTtcbiAgICAgIGNsZWFyTWFzayB8PSBnbC5ERVBUSF9CVUZGRVJfQklUO1xuICAgICAgZ2wuZGVwdGhNYXNrKHRydWUpO1xuICAgIH1cblxuICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcblxuICAgIGNvbnN0IHRzID0gcHVibGljQVBJLmdldFRpbGVkU2l6ZUFuZE9yaWdpbigpO1xuICAgIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICAgIGdsLnNjaXNzb3IodHMubG93ZXJMZWZ0VSwgdHMubG93ZXJMZWZ0ViwgdHMudXNpemUsIHRzLnZzaXplKTtcbiAgICBnbC52aWV3cG9ydCh0cy5sb3dlckxlZnRVLCB0cy5sb3dlckxlZnRWLCB0cy51c2l6ZSwgdHMudnNpemUpO1xuXG4gICAgZ2wuY2xlYXIoY2xlYXJNYXNrKTtcblxuICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWJpdHdpc2UgKi9cbiAgfTtcblxuICBwdWJsaWNBUEkucmVsZWFzZUdyYXBoaWNzUmVzb3VyY2VzID0gKCkgPT4ge1xuICAgIGlmIChtb2RlbC5zZWxlY3RvciAhPT0gbnVsbCkge1xuICAgICAgbW9kZWwuc2VsZWN0b3IucmVsZWFzZUdyYXBoaWNzUmVzb3VyY2VzKCk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRPcGVuR0xSZW5kZXJXaW5kb3cgPSAocncpID0+IHtcbiAgICBpZiAobW9kZWwub3BlbkdMUmVuZGVyV2luZG93ID09PSBydykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwdWJsaWNBUEkucmVsZWFzZUdyYXBoaWNzUmVzb3VyY2VzKCk7XG4gICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93ID0gcnc7XG4gICAgbW9kZWwuY29udGV4dCA9IG51bGw7XG4gICAgaWYgKHJ3KSB7XG4gICAgICBtb2RlbC5jb250ZXh0ID0gbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldENvbnRleHQoKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBjb250ZXh0OiBudWxsLFxuICBvcGVuR0xSZW5kZXJXaW5kb3c6IG51bGwsXG4gIHNlbGVjdG9yOiBudWxsLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gSW5oZXJpdGFuY2VcbiAgdnRrVmlld05vZGUuZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEJ1aWxkIFZUSyBBUElcbiAgbWFjcm8uZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsnc2hhZGVyQ2FjaGUnXSk7XG5cbiAgbWFjcm8uc2V0R2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsnc2VsZWN0b3InXSk7XG5cbiAgLy8gT2JqZWN0IG1ldGhvZHNcbiAgdnRrT3BlbkdMUmVuZGVyZXIocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrT3BlbkdMUmVuZGVyZXInKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImltcG9ydCB2dGtTaGFkZXJQcm9ncmFtIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvU2hhZGVyUHJvZ3JhbSc7XG5cbmZ1bmN0aW9uIGltcGxlbWVudFJlcGxhY2VTaGFkZXJDb2luY2lkZW50T2Zmc2V0KFxuICBwdWJsaWNBUEksXG4gIG1vZGVsLFxuICBpbml0aWFsVmFsdWVzID0ge31cbikge1xuICBwdWJsaWNBUEkucmVwbGFjZVNoYWRlckNvaW5jaWRlbnRPZmZzZXQgPSAoc2hhZGVycywgcmVuLCBhY3RvcikgPT4ge1xuICAgIGNvbnN0IGNwID0gcHVibGljQVBJLmdldENvaW5jaWRlbnRQYXJhbWV0ZXJzKHJlbiwgYWN0b3IpO1xuXG4gICAgLy8gaWYgd2UgbmVlZCBhbiBvZmZzZXQgaGFuZGxlIGl0IGhlcmVcbiAgICAvLyBUaGUgdmFsdWUgb2YgLjAwMDAxNiBpcyBzdWl0YWJsZSBmb3IgZGVwdGggYnVmZmVyc1xuICAgIC8vIG9mIGF0IGxlYXN0IDE2IGJpdCBkZXB0aC4gV2UgZG8gbm90IHF1ZXJ5IHRoZSBkZXB0aFxuICAgIC8vIHJpZ2h0IG5vdyBiZWNhdXNlIHdlIHdvdWxkIG5lZWQgc29tZSBtZWNoYW5pc20gdG9cbiAgICAvLyBjYWNoZSB0aGUgcmVzdWx0IHRha2luZyBpbnRvIGFjY291bnQgRkJPIGNoYW5nZXMgZXRjLlxuICAgIGlmIChjcCAmJiAoY3AuZmFjdG9yICE9PSAwLjAgfHwgY3Aub2Zmc2V0ICE9PSAwLjApKSB7XG4gICAgICBsZXQgRlNTb3VyY2UgPSBzaGFkZXJzLkZyYWdtZW50O1xuXG4gICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgRlNTb3VyY2UsXG4gICAgICAgICcvL1ZUSzo6Q29pbmNpZGVudDo6RGVjJyxcbiAgICAgICAgWyd1bmlmb3JtIGZsb2F0IGNmYWN0b3I7JywgJ3VuaWZvcm0gZmxvYXQgY29mZnNldDsnXVxuICAgICAgKS5yZXN1bHQ7XG5cbiAgICAgIGlmIChtb2RlbC5jb250ZXh0LmdldEV4dGVuc2lvbignRVhUX2ZyYWdfZGVwdGgnKSkge1xuICAgICAgICBpZiAoY3AuZmFjdG9yICE9PSAwLjApIHtcbiAgICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgIEZTU291cmNlLFxuICAgICAgICAgICAgJy8vVlRLOjpVbmlmb3JtRmxvdzo6SW1wbCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdmbG9hdCBjc2NhbGUgPSBsZW5ndGgodmVjMihkRmR4KGdsX0ZyYWdDb29yZC56KSxkRmR5KGdsX0ZyYWdDb29yZC56KSkpOycsXG4gICAgICAgICAgICAgICcvL1ZUSzo6VW5pZm9ybUZsb3c6OkltcGwnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKS5yZXN1bHQ7XG4gICAgICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgICAgICcvL1ZUSzo6RGVwdGg6OkltcGwnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdEZXB0aEVYVCA9IGdsX0ZyYWdDb29yZC56ICsgY2ZhY3Rvcipjc2NhbGUgKyAwLjAwMDAxNipjb2Zmc2V0OydcbiAgICAgICAgICApLnJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgIEZTU291cmNlLFxuICAgICAgICAgICAgJy8vVlRLOjpEZXB0aDo6SW1wbCcsXG4gICAgICAgICAgICAnZ2xfRnJhZ0RlcHRoRVhUID0gZ2xfRnJhZ0Nvb3JkLnogKyAwLjAwMDAxNipjb2Zmc2V0OydcbiAgICAgICAgICApLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRXZWJnbDIoKSkge1xuICAgICAgICBpZiAoY3AuZmFjdG9yICE9PSAwLjApIHtcbiAgICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgIEZTU291cmNlLFxuICAgICAgICAgICAgJy8vVlRLOjpVbmlmb3JtRmxvdzo6SW1wbCcsXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICdmbG9hdCBjc2NhbGUgPSBsZW5ndGgodmVjMihkRmR4KGdsX0ZyYWdDb29yZC56KSxkRmR5KGdsX0ZyYWdDb29yZC56KSkpOycsXG4gICAgICAgICAgICAgICcvL1ZUSzo6VW5pZm9ybUZsb3c6OkltcGwnLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICAgKS5yZXN1bHQ7XG4gICAgICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgICAgICcvL1ZUSzo6RGVwdGg6OkltcGwnLFxuICAgICAgICAgICAgJ2dsX0ZyYWdEZXB0aCA9IGdsX0ZyYWdDb29yZC56ICsgY2ZhY3Rvcipjc2NhbGUgKyAwLjAwMDAxNipjb2Zmc2V0OydcbiAgICAgICAgICApLnJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgIEZTU291cmNlLFxuICAgICAgICAgICAgJy8vVlRLOjpEZXB0aDo6SW1wbCcsXG4gICAgICAgICAgICAnZ2xfRnJhZ0RlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogKyAwLjAwMDAxNipjb2Zmc2V0OydcbiAgICAgICAgICApLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2hhZGVycy5GcmFnbWVudCA9IEZTU291cmNlO1xuICAgIH1cbiAgfTtcbn1cbmV4cG9ydCBkZWZhdWx0IHsgaW1wbGVtZW50UmVwbGFjZVNoYWRlckNvaW5jaWRlbnRPZmZzZXQgfTtcbiIsImltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5cbmNvbnN0IHsgdnRrRXJyb3JNYWNybyB9ID0gbWFjcm87XG5cbi8vIGV4cG9ydCBjb25zdCBTSEFERVJfVFlQRVMgPSBbJ1ZlcnRleCcsICdGcmFnbWVudCcsICdHZW9tZXRyeScsICdVbmtub3duJ107XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a1NoYWRlciBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a1NoYWRlcihwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a1NoYWRlcicpO1xuXG4gIHB1YmxpY0FQSS5jb21waWxlID0gKCkgPT4ge1xuICAgIGxldCBzdHlwZSA9IG1vZGVsLmNvbnRleHQuVkVSVEVYX1NIQURFUjtcblxuICAgIGlmIChcbiAgICAgICFtb2RlbC5zb3VyY2UgfHxcbiAgICAgICFtb2RlbC5zb3VyY2UubGVuZ3RoIHx8XG4gICAgICBtb2RlbC5zaGFkZXJUeXBlID09PSAnVW5rbm93bidcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgd2UgZGVsZXRlIHRoZSBwcmV2aW91cyBzaGFkZXIgaWYgbmVjZXNzYXJ5LlxuICAgIGlmIChtb2RlbC5oYW5kbGUgIT09IDApIHtcbiAgICAgIG1vZGVsLmNvbnRleHQuZGVsZXRlU2hhZGVyKG1vZGVsLmhhbmRsZSk7XG4gICAgICBtb2RlbC5oYW5kbGUgPSAwO1xuICAgIH1cblxuICAgIHN3aXRjaCAobW9kZWwuc2hhZGVyVHlwZSkge1xuICAgICAgLy8gY2FzZSB2dGtTaGFkZXI6Okdlb21ldHJ5OlxuICAgICAgLy8gICB0eXBlID0gR0xfR0VPTUVUUllfU0hBREVSO1xuICAgICAgLy8gICBicmVhaztcbiAgICAgIGNhc2UgJ0ZyYWdtZW50JzpcbiAgICAgICAgc3R5cGUgPSBtb2RlbC5jb250ZXh0LkZSQUdNRU5UX1NIQURFUjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdWZXJ0ZXgnOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3R5cGUgPSBtb2RlbC5jb250ZXh0LlZFUlRFWF9TSEFERVI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG1vZGVsLmhhbmRsZSA9IG1vZGVsLmNvbnRleHQuY3JlYXRlU2hhZGVyKHN0eXBlKTtcbiAgICBtb2RlbC5jb250ZXh0LnNoYWRlclNvdXJjZShtb2RlbC5oYW5kbGUsIG1vZGVsLnNvdXJjZSk7XG4gICAgbW9kZWwuY29udGV4dC5jb21waWxlU2hhZGVyKG1vZGVsLmhhbmRsZSk7XG4gICAgY29uc3QgaXNDb21waWxlZCA9IG1vZGVsLmNvbnRleHQuZ2V0U2hhZGVyUGFyYW1ldGVyKFxuICAgICAgbW9kZWwuaGFuZGxlLFxuICAgICAgbW9kZWwuY29udGV4dC5DT01QSUxFX1NUQVRVU1xuICAgICk7XG4gICAgaWYgKCFpc0NvbXBpbGVkKSB7XG4gICAgICBjb25zdCBsYXN0RXJyb3IgPSBtb2RlbC5jb250ZXh0LmdldFNoYWRlckluZm9Mb2cobW9kZWwuaGFuZGxlKTtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oYEVycm9yIGNvbXBpbGluZyBzaGFkZXIgJyR7bW9kZWwuc291cmNlfSc6ICR7bGFzdEVycm9yfWApO1xuICAgICAgbW9kZWwuY29udGV4dC5kZWxldGVTaGFkZXIobW9kZWwuaGFuZGxlKTtcbiAgICAgIG1vZGVsLmhhbmRsZSA9IDA7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gVGhlIHNoYWRlciBjb21waWxlZCwgc3RvcmUgaXRzIGhhbmRsZSBhbmQgcmV0dXJuIHN1Y2Nlc3MuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLmNsZWFudXAgPSAoKSA9PiB7XG4gICAgaWYgKG1vZGVsLnNoYWRlclR5cGUgPT09ICdVbmtub3duJyB8fCBtb2RlbC5oYW5kbGUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtb2RlbC5jb250ZXh0LmRlbGV0ZVNoYWRlcihtb2RlbC5oYW5kbGUpO1xuICAgIG1vZGVsLmhhbmRsZSA9IDA7XG4gICAgbW9kZWwuZGlydHkgPSB0cnVlO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgc2hhZGVyVHlwZTogJ1Vua25vd24nLFxuICBzb3VyY2U6ICcnLFxuICBlcnJvcjogJycsXG4gIGhhbmRsZTogMCxcbiAgZGlydHk6IGZhbHNlLFxuICBjb250ZXh0OiBudWxsLFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gQnVpbGQgVlRLIEFQSVxuICBtYWNyby5vYmoocHVibGljQVBJLCBtb2RlbCk7XG4gIG1hY3JvLnNldEdldChwdWJsaWNBUEksIG1vZGVsLCBbXG4gICAgJ3NoYWRlclR5cGUnLFxuICAgICdzb3VyY2UnLFxuICAgICdlcnJvcicsXG4gICAgJ2hhbmRsZScsXG4gICAgJ2NvbnRleHQnLFxuICBdKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICB2dGtTaGFkZXIocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrU2hhZGVyJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kIH07XG4iLCJpbXBvcnQgbWQ1IGZyb20gJ2JsdWVpbXAtbWQ1JztcblxuaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB2dGtTaGFkZXJQcm9ncmFtIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvU2hhZGVyUHJvZ3JhbSc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgU0VUX0dFVF9GSUVMRFMgPSBbJ2xhc3RTaGFkZXJCb3VuZCcsICdjb250ZXh0JywgJ29wZW5HTFJlbmRlcldpbmRvdyddO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtTaGFkZXJDYWNoZSBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a1NoYWRlckNhY2hlKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrU2hhZGVyQ2FjaGUnKTtcblxuICBwdWJsaWNBUEkucmVwbGFjZVNoYWRlclZhbHVlcyA9IChWU1NvdXJjZSwgRlNTb3VyY2UsIEdTU291cmNlKSA9PiB7XG4gICAgLy8gZmlyc3QgaGFuZGxlIHJlbmFtaW5nIGFueSBGcmFnbWVudCBzaGFkZXIgaW5wdXRzXG4gICAgLy8gaWYgd2UgaGF2ZSBhIGdlb21ldHJ5IHNoYWRlci4gQnkgZGVmYXVsdCBmcmFnbWVudCBzaGFkZXJzXG4gICAgLy8gYXNzdW1lIHRoZWlyIGlucHV0cyBjb21lIGZyb20gYSBWZXJ0ZXggU2hhZGVyLiBXaGVuIHdlXG4gICAgLy8gaGF2ZSBhIEdlb21ldHJ5IHNoYWRlciB3ZSByZW5hbWUgdGhlIGZyYW1lbnQgc2hhZGVyIGlucHV0c1xuICAgIC8vIHRvIGNvbWUgZnJvbSB0aGUgZ2VvbWV0cnkgc2hhZGVyXG5cbiAgICBsZXQgbkZTU291cmNlID0gRlNTb3VyY2U7XG4gICAgaWYgKEdTU291cmNlLmxlbmd0aCA+IDApIHtcbiAgICAgIG5GU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShuRlNTb3VyY2UsICdWU091dCcsICdHU091dCcpXG4gICAgICAgIC5yZXN1bHQ7XG4gICAgfVxuXG4gICAgY29uc3QgZ2wyID0gbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldFdlYmdsMigpO1xuXG4gICAgbGV0IGZyYWdEZXB0aFN0cmluZyA9ICdcXG4nO1xuXG4gICAgbGV0IHZlcnNpb24gPSAnI3ZlcnNpb24gMTAwXFxuJztcbiAgICBpZiAoZ2wyKSB7XG4gICAgICB2ZXJzaW9uID1cbiAgICAgICAgJyN2ZXJzaW9uIDMwMCBlc1xcbicgK1xuICAgICAgICAnI2RlZmluZSBhdHRyaWJ1dGUgaW5cXG4nICtcbiAgICAgICAgJyNkZWZpbmUgdGV4dHVyZUN1YmUgdGV4dHVyZVxcbicgK1xuICAgICAgICAnI2RlZmluZSB0ZXh0dXJlMkQgdGV4dHVyZVxcbicgK1xuICAgICAgICAnI2RlZmluZSB0ZXh0dXJlQ3ViZUxvZCB0ZXh0dXJlTG9kXFxuJyArXG4gICAgICAgICcjZGVmaW5lIHRleHR1cmUyRExvZCB0ZXh0dXJlTG9kXFxuJztcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWwuY29udGV4dC5nZXRFeHRlbnNpb24oJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycpO1xuICAgICAgaWYgKG1vZGVsLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdFWFRfZnJhZ19kZXB0aCcpKSB7XG4gICAgICAgIGZyYWdEZXB0aFN0cmluZyA9ICcjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlXFxuJztcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbC5jb250ZXh0LmdldEV4dGVuc2lvbignRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCcpKSB7XG4gICAgICAgIGZyYWdEZXB0aFN0cmluZyArPVxuICAgICAgICAgICcjZXh0ZW5zaW9uIEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QgOiBlbmFibGVcXG4nICtcbiAgICAgICAgICAnI2RlZmluZSB0ZXh0dXJlQ3ViZUxvZCB0ZXh0dXJlQ3ViZUxvZEVYVFxcbicgK1xuICAgICAgICAgICcjZGVmaW5lIHRleHR1cmUyRExvZCB0ZXh0dXJlMkRMb2RFWFQnO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5GU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShuRlNTb3VyY2UsICcvL1ZUSzo6U3lzdGVtOjpEZWMnLCBbXG4gICAgICBgJHt2ZXJzaW9ufVxcbmAsXG4gICAgICBnbDIgPyAnJyA6ICcjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcbicsXG4gICAgICBmcmFnRGVwdGhTdHJpbmcsXG4gICAgICAnI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIJyxcbiAgICAgICdwcmVjaXNpb24gaGlnaHAgZmxvYXQ7JyxcbiAgICAgICdwcmVjaXNpb24gaGlnaHAgaW50OycsXG4gICAgICAnI2Vsc2UnLFxuICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAncHJlY2lzaW9uIG1lZGl1bXAgaW50OycsXG4gICAgICAnI2VuZGlmJyxcbiAgICBdKS5yZXN1bHQ7XG5cbiAgICBsZXQgblZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgVlNTb3VyY2UsXG4gICAgICAnLy9WVEs6OlN5c3RlbTo6RGVjJyxcbiAgICAgIFtcbiAgICAgICAgYCR7dmVyc2lvbn1cXG5gLFxuICAgICAgICAnI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIJyxcbiAgICAgICAgJ3ByZWNpc2lvbiBoaWdocCBmbG9hdDsnLFxuICAgICAgICAncHJlY2lzaW9uIGhpZ2hwIGludDsnLFxuICAgICAgICAnI2Vsc2UnLFxuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGludDsnLFxuICAgICAgICAnI2VuZGlmJyxcbiAgICAgIF1cbiAgICApLnJlc3VsdDtcblxuICAgIGlmIChnbDIpIHtcbiAgICAgIG5WU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShuVlNTb3VyY2UsICd2YXJ5aW5nJywgJ291dCcpXG4gICAgICAgIC5yZXN1bHQ7XG4gICAgICBuRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUobkZTU291cmNlLCAndmFyeWluZycsICdpbicpXG4gICAgICAgIC5yZXN1bHQ7XG4gICAgICBuRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgIG5GU1NvdXJjZSxcbiAgICAgICAgJ2dsX0ZyYWdEYXRhXFxcXFswXFxcXF0nLFxuICAgICAgICAnZnJhZ091dHB1dDAnXG4gICAgICApLnJlc3VsdDtcbiAgICAgIG5GU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgbkZTU291cmNlLFxuICAgICAgICAnLy9WVEs6Ok91dHB1dDo6RGVjJyxcbiAgICAgICAgJ2xheW91dChsb2NhdGlvbiA9IDApIG91dCB2ZWM0IGZyYWdPdXRwdXQwOydcbiAgICAgICkucmVzdWx0O1xuICAgIH1cblxuICAgIC8vIG5GU1NvdXJjZSA9IFNoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShuRlNTb3VyY2UsICdnbF9GcmFnRGF0YVxcXFxbMFxcXFxdJyxcbiAgICAvLyAgICdnbF9GcmFnQ29sb3InKS5yZXN1bHQ7XG5cbiAgICBjb25zdCBuR1NTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICBHU1NvdXJjZSxcbiAgICAgICcvL1ZUSzo6U3lzdGVtOjpEZWMnLFxuICAgICAgdmVyc2lvblxuICAgICkucmVzdWx0O1xuXG4gICAgcmV0dXJuIHsgVlNTb3VyY2U6IG5WU1NvdXJjZSwgRlNTb3VyY2U6IG5GU1NvdXJjZSwgR1NTb3VyY2U6IG5HU1NvdXJjZSB9O1xuICB9O1xuXG4gIC8vIHJldHVybiBOVUxMIGlmIHRoZXJlIGlzIGFuIGlzc3VlXG4gIHB1YmxpY0FQSS5yZWFkeVNoYWRlclByb2dyYW1BcnJheSA9IChcbiAgICB2ZXJ0ZXhDb2RlLFxuICAgIGZyYWdtZW50Q29kZSxcbiAgICBnZW9tZXRyeUNvZGVcbiAgKSA9PiB7XG4gICAgY29uc3QgZGF0YSA9IHB1YmxpY0FQSS5yZXBsYWNlU2hhZGVyVmFsdWVzKFxuICAgICAgdmVydGV4Q29kZSxcbiAgICAgIGZyYWdtZW50Q29kZSxcbiAgICAgIGdlb21ldHJ5Q29kZVxuICAgICk7XG5cbiAgICBjb25zdCBzaGFkZXIgPSBwdWJsaWNBUEkuZ2V0U2hhZGVyUHJvZ3JhbShcbiAgICAgIGRhdGEuVlNTb3VyY2UsXG4gICAgICBkYXRhLkZTU291cmNlLFxuICAgICAgZGF0YS5HU1NvdXJjZVxuICAgICk7XG5cbiAgICByZXR1cm4gcHVibGljQVBJLnJlYWR5U2hhZGVyUHJvZ3JhbShzaGFkZXIpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZWFkeVNoYWRlclByb2dyYW0gPSAoc2hhZGVyKSA9PiB7XG4gICAgaWYgKCFzaGFkZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGNvbXBpbGUgaWYgbmVlZGVkXG4gICAgaWYgKCFzaGFkZXIuZ2V0Q29tcGlsZWQoKSAmJiAhc2hhZGVyLmNvbXBpbGVTaGFkZXIoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gYmluZCBpZiBuZWVkZWRcbiAgICBpZiAoIXB1YmxpY0FQSS5iaW5kU2hhZGVyKHNoYWRlcikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXI7XG4gIH07XG5cbiAgcHVibGljQVBJLmdldFNoYWRlclByb2dyYW0gPSAodmVydGV4Q29kZSwgZnJhZ21lbnRDb2RlLCBnZW9tZXRyeUNvZGUpID0+IHtcbiAgICAvLyBjb21wdXRlIHRoZSBNRDUgYW5kIHRoZSBjaGVjayB0aGUgbWFwXG4gICAgY29uc3QgaGFzaElucHV0ID0gYCR7dmVydGV4Q29kZX0ke2ZyYWdtZW50Q29kZX0ke2dlb21ldHJ5Q29kZX1gO1xuICAgIGNvbnN0IHJlc3VsdCA9IG1kNShoYXNoSW5wdXQpO1xuXG4gICAgLy8gZG9lcyBpdCBhbHJlYWR5IGV4aXN0P1xuICAgIGNvbnN0IGxvYyA9IE9iamVjdC5rZXlzKG1vZGVsLnNoYWRlclByb2dyYW1zKS5pbmRleE9mKHJlc3VsdCk7XG5cbiAgICBpZiAobG9jID09PSAtMSkge1xuICAgICAgLy8gY3JlYXRlIG9uZVxuICAgICAgY29uc3Qgc3BzID0gdnRrU2hhZGVyUHJvZ3JhbS5uZXdJbnN0YW5jZSgpO1xuICAgICAgc3BzLnNldENvbnRleHQobW9kZWwuY29udGV4dCk7XG4gICAgICBzcHMuZ2V0VmVydGV4U2hhZGVyKCkuc2V0U291cmNlKHZlcnRleENvZGUpO1xuICAgICAgc3BzLmdldEZyYWdtZW50U2hhZGVyKCkuc2V0U291cmNlKGZyYWdtZW50Q29kZSk7XG4gICAgICBpZiAoZ2VvbWV0cnlDb2RlKSB7XG4gICAgICAgIHNwcy5nZXRHZW9tZXRyeVNoYWRlcigpLnNldFNvdXJjZShnZW9tZXRyeUNvZGUpO1xuICAgICAgfVxuICAgICAgc3BzLnNldE1kNUhhc2gocmVzdWx0KTtcbiAgICAgIG1vZGVsLnNoYWRlclByb2dyYW1zW3Jlc3VsdF0gPSBzcHM7XG4gICAgICByZXR1cm4gc3BzO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RlbC5zaGFkZXJQcm9ncmFtc1tyZXN1bHRdO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZWxlYXNlR3JhcGhpY3NSZXNvdXJjZXMgPSAod2luKSA9PiB7XG4gICAgLy8gTk9URTpcbiAgICAvLyBJbiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBhcyBvZiBPY3RvYmVyIDI2dGgsIGlmIGEgc2hhZGVyXG4gICAgLy8gcHJvZ3JhbSBpcyBjcmVhdGVkIGJ5IFNoYWRlckNhY2hlIHRoZW4gaXQgc2hvdWxkIG1ha2Ugc3VyZVxuICAgIC8vIHRoYXQgaXQgcmVsZWFzZXMgdGhlIGdyYXBoaWNzIHJlc291cmNlcyB1c2VkIGJ5IHRoZXNlIHByb2dyYW1zLlxuICAgIC8vIEl0IGlzIG5vdCB3aXNlbHkgZm9yIGNhbGxlcnMgdG8gZG8gdGhhdCBzaW5jZSB0aGVuIHRoZXkgd291bGRcbiAgICAvLyBoYXZlIHRvIGxvb3Agb3ZlciBhbGwgdGhlIHByb2dyYW1zIHdlcmUgaW4gdXNlIGFuZCBpbnZva2VcbiAgICAvLyByZWxlYXNlIGdyYXBoaWNzIHJlc291cmNlcyBpbmRpdmlkdWFsbHkuXG5cbiAgICBwdWJsaWNBUEkucmVsZWFzZUN1cnJlbnRTaGFkZXIoKTtcblxuICAgIE9iamVjdC5rZXlzKG1vZGVsLnNoYWRlclByb2dyYW1zKVxuICAgICAgLm1hcCgoa2V5KSA9PiBtb2RlbC5zaGFkZXJQcm9ncmFtc1trZXldKVxuICAgICAgLmZvckVhY2goKHNwKSA9PiBzcC5yZWxlYXNlR3JhcGhpY3NSZXNvdXJjZXMod2luKSk7XG4gIH07XG5cbiAgcHVibGljQVBJLnJlbGVhc2VHcmFwaGljc1Jlc291cmNlcyA9ICgpID0+IHtcbiAgICAvLyByZWxlYXNlIHByaW9yIHNoYWRlclxuICAgIGlmIChtb2RlbC5hc3RTaGFkZXJCb3VuZCkge1xuICAgICAgbW9kZWwubGFzdFNoYWRlckJvdW5kLnJlbGVhc2UoKTtcbiAgICAgIG1vZGVsLmxhc3RTaGFkZXJCb3VuZCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5iaW5kU2hhZGVyID0gKHNoYWRlcikgPT4ge1xuICAgIGlmIChtb2RlbC5sYXN0U2hhZGVyQm91bmQgPT09IHNoYWRlcikge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgLy8gcmVsZWFzZSBwcmlvciBzaGFkZXJcbiAgICBpZiAobW9kZWwubGFzdFNoYWRlckJvdW5kKSB7XG4gICAgICBtb2RlbC5sYXN0U2hhZGVyQm91bmQucmVsZWFzZSgpO1xuICAgIH1cbiAgICBzaGFkZXIuYmluZCgpO1xuICAgIG1vZGVsLmxhc3RTaGFkZXJCb3VuZCA9IHNoYWRlcjtcbiAgICByZXR1cm4gMTtcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIGxhc3RTaGFkZXJCb3VuZDogbnVsbCxcbiAgc2hhZGVyUHJvZ3JhbXM6IG51bGwsXG4gIGNvbnRleHQ6IG51bGwsXG4gIG9wZW5HTFJlbmRlcldpbmRvdzogbnVsbCxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEludGVybmFsIG9iamVjdHNcbiAgbW9kZWwuc2hhZGVyUHJvZ3JhbXMgPSB7fTtcblxuICAvLyBCdWlsZCBWVEsgQVBJXG4gIG1hY3JvLm9iaihwdWJsaWNBUEksIG1vZGVsKTtcbiAgbWFjcm8uc2V0R2V0KHB1YmxpY0FQSSwgbW9kZWwsIFNFVF9HRVRfRklFTERTKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICB2dGtTaGFkZXJDYWNoZShwdWJsaWNBUEksIG1vZGVsKTtcblxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShwdWJsaWNBUEkpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a1NoYWRlckNhY2hlJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kIH07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0IHZ0a1NoYWRlciBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1NoYWRlcic7XG5cbmNvbnN0IHsgdnRrRXJyb3JNYWNybyB9ID0gbWFjcm87XG5cbi8vIHBlcmZvcm0gaW4gcGxhY2Ugc3RyaW5nIHN1YnN0aXR1dGlvbnMsIGluZGljYXRlIGlmIGEgc3Vic3RpdHV0aW9uIHdhcyBkb25lXG4vLyB0aGlzIGlzIHVzZWZ1bCBmb3IgYnVpbGRpbmcgdXAgc2hhZGVyIHN0cmluZ3Mgd2hpY2ggdHlwaWNhbGx5IGludm9sdmVcbi8vIGxvdHMgb2Ygc3RyaW5nIHN1YnN0aXR1dGlvbnMuIFJldHVybiB0cnVlIGlmIGEgc3Vic3RpdHV0aW9uIHdhcyBkb25lLlxuZnVuY3Rpb24gc3Vic3RpdHV0ZShzb3VyY2UsIHNlYXJjaCwgcmVwbGFjZSwgYWxsID0gdHJ1ZSkge1xuICBjb25zdCByZXBsYWNlU3RyID0gQXJyYXkuaXNBcnJheShyZXBsYWNlKSA/IHJlcGxhY2Uuam9pbignXFxuJykgOiByZXBsYWNlO1xuICBsZXQgcmVwbGFjZWQgPSBmYWxzZTtcbiAgaWYgKHNvdXJjZS5zZWFyY2goc2VhcmNoKSAhPT0gLTEpIHtcbiAgICByZXBsYWNlZCA9IHRydWU7XG4gIH1cbiAgbGV0IGdmbGFnID0gJyc7XG4gIGlmIChhbGwpIHtcbiAgICBnZmxhZyA9ICdnJztcbiAgfVxuICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoc2VhcmNoLCBnZmxhZyk7XG4gIGNvbnN0IHJlc3VsdHN0ciA9IHNvdXJjZS5yZXBsYWNlKHJlZ2V4LCByZXBsYWNlU3RyKTtcbiAgcmV0dXJuIHsgcmVwbGFjZTogcmVwbGFjZWQsIHJlc3VsdDogcmVzdWx0c3RyIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a1NoYWRlclByb2dyYW0gbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtTaGFkZXJQcm9ncmFtKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrU2hhZGVyUHJvZ3JhbScpO1xuXG4gIHB1YmxpY0FQSS5jb21waWxlU2hhZGVyID0gKCkgPT4ge1xuICAgIGlmICghbW9kZWwudmVydGV4U2hhZGVyLmNvbXBpbGUoKSkge1xuICAgICAgdnRrRXJyb3JNYWNybyhcbiAgICAgICAgbW9kZWwudmVydGV4U2hhZGVyXG4gICAgICAgICAgLmdldFNvdXJjZSgpXG4gICAgICAgICAgLnNwbGl0KCdcXG4nKVxuICAgICAgICAgIC5tYXAoKGxpbmUsIGluZGV4KSA9PiBgJHtpbmRleH06ICR7bGluZX1gKVxuICAgICAgICAgIC5qb2luKCdcXG4nKVxuICAgICAgKTtcbiAgICAgIHZ0a0Vycm9yTWFjcm8obW9kZWwudmVydGV4U2hhZGVyLmdldEVycm9yKCkpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICghbW9kZWwuZnJhZ21lbnRTaGFkZXIuY29tcGlsZSgpKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKFxuICAgICAgICBtb2RlbC5mcmFnbWVudFNoYWRlclxuICAgICAgICAgIC5nZXRTb3VyY2UoKVxuICAgICAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgICAgICAubWFwKChsaW5lLCBpbmRleCkgPT4gYCR7aW5kZXh9OiAke2xpbmV9YClcbiAgICAgICAgICAuam9pbignXFxuJylcbiAgICAgICk7XG4gICAgICB2dGtFcnJvck1hY3JvKG1vZGVsLmZyYWdtZW50U2hhZGVyLmdldEVycm9yKCkpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIHNraXAgZ2VvbWV0cnkgZm9yIG5vd1xuICAgIGlmICghcHVibGljQVBJLmF0dGFjaFNoYWRlcihtb2RlbC52ZXJ0ZXhTaGFkZXIpKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKG1vZGVsLmVycm9yKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoIXB1YmxpY0FQSS5hdHRhY2hTaGFkZXIobW9kZWwuZnJhZ21lbnRTaGFkZXIpKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKG1vZGVsLmVycm9yKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIGlmICghcHVibGljQVBJLmxpbmsoKSkge1xuICAgICAgdnRrRXJyb3JNYWNybyhgTGlua3MgZmFpbGVkOiAke21vZGVsLmVycm9yfWApO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcHVibGljQVBJLnNldENvbXBpbGVkKHRydWUpO1xuICAgIHJldHVybiAxO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5jbGVhbnVwID0gKCkgPT4ge1xuICAgIGlmIChtb2RlbC5zaGFkZXJUeXBlID09PSAnVW5rbm93bicgfHwgbW9kZWwuaGFuZGxlID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbW9kZWwuY29udGV4dC5kZWxldGVTaGFkZXIobW9kZWwuaGFuZGxlKTtcbiAgICBtb2RlbC5oYW5kbGUgPSAwO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5iaW5kID0gKCkgPT4ge1xuICAgIGlmICghbW9kZWwubGlua2VkICYmICFwdWJsaWNBUEkubGluaygpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbW9kZWwuY29udGV4dC51c2VQcm9ncmFtKG1vZGVsLmhhbmRsZSk7XG4gICAgcHVibGljQVBJLnNldEJvdW5kKHRydWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5pc0JvdW5kID0gKCkgPT4gISFtb2RlbC5ib3VuZDtcblxuICBwdWJsaWNBUEkucmVsZWFzZSA9ICgpID0+IHtcbiAgICBtb2RlbC5jb250ZXh0LnVzZVByb2dyYW0obnVsbCk7XG4gICAgcHVibGljQVBJLnNldEJvdW5kKGZhbHNlKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0Q29udGV4dCA9IChjdHgpID0+IHtcbiAgICBtb2RlbC52ZXJ0ZXhTaGFkZXIuc2V0Q29udGV4dChjdHgpO1xuICAgIG1vZGVsLmZyYWdtZW50U2hhZGVyLnNldENvbnRleHQoY3R4KTtcbiAgICBtb2RlbC5nZW9tZXRyeVNoYWRlci5zZXRDb250ZXh0KGN0eCk7XG4gIH07XG5cbiAgcHVibGljQVBJLmxpbmsgPSAoKSA9PiB7XG4gICAgaWYgKG1vZGVsLmlua2VkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobW9kZWwuaGFuZGxlID09PSAwKSB7XG4gICAgICBtb2RlbC5lcnJvciA9XG4gICAgICAgICdQcm9ncmFtIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCwgYW5kL29yIGRvZXMgbm90IGhhdmUgc2hhZGVycy4nO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGNsZWFyIG91dCB0aGUgbGlzdCBvZiB1bmlmb3JtcyB1c2VkXG4gICAgbW9kZWwudW5pZm9ybUxvY3MgPSB7fTtcblxuICAgIG1vZGVsLmNvbnRleHQubGlua1Byb2dyYW0obW9kZWwuaGFuZGxlKTtcbiAgICBjb25zdCBpc0NvbXBpbGVkID0gbW9kZWwuY29udGV4dC5nZXRQcm9ncmFtUGFyYW1ldGVyKFxuICAgICAgbW9kZWwuaGFuZGxlLFxuICAgICAgbW9kZWwuY29udGV4dC5MSU5LX1NUQVRVU1xuICAgICk7XG4gICAgaWYgKCFpc0NvbXBpbGVkKSB7XG4gICAgICBjb25zdCBsYXN0RXJyb3IgPSBtb2RlbC5jb250ZXh0LmdldFByb2dyYW1JbmZvTG9nKG1vZGVsLmhhbmRsZSk7XG4gICAgICB2dGtFcnJvck1hY3JvKGBFcnJvciBsaW5raW5nIHNoYWRlciAke2xhc3RFcnJvcn1gKTtcbiAgICAgIG1vZGVsLmhhbmRsZSA9IDA7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHVibGljQVBJLnNldExpbmtlZCh0cnVlKTtcbiAgICBtb2RlbC5hdHRyaWJ1dGVMb2NzID0ge307XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldFVuaWZvcm1NYXRyaXggPSAobmFtZSwgdikgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcHVibGljQVBJLmZpbmRVbmlmb3JtKG5hbWUpO1xuICAgIGlmIChsb2NhdGlvbiA9PT0gLTEpIHtcbiAgICAgIG1vZGVsLmVycm9yID0gYENvdWxkIG5vdCBzZXQgdW5pZm9ybSAke25hbWV9IC4gTm8gc3VjaCB1bmlmb3JtLmA7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vZGVsLmNvbnRleHQudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIHYpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRVbmlmb3JtTWF0cml4M3gzID0gKG5hbWUsIHYpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHB1YmxpY0FQSS5maW5kVW5pZm9ybShuYW1lKTtcbiAgICBpZiAobG9jYXRpb24gPT09IC0xKSB7XG4gICAgICBtb2RlbC5lcnJvciA9IGBDb3VsZCBub3Qgc2V0IHVuaWZvcm0gJHtuYW1lfSAuIE5vIHN1Y2ggdW5pZm9ybS5gO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtb2RlbC5jb250ZXh0LnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCB2KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0VW5pZm9ybWYgPSAobmFtZSwgdikgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcHVibGljQVBJLmZpbmRVbmlmb3JtKG5hbWUpO1xuICAgIGlmIChsb2NhdGlvbiA9PT0gLTEpIHtcbiAgICAgIG1vZGVsLmVycm9yID0gYENvdWxkIG5vdCBzZXQgdW5pZm9ybSAke25hbWV9IC4gTm8gc3VjaCB1bmlmb3JtLmA7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vZGVsLmNvbnRleHQudW5pZm9ybTFmKGxvY2F0aW9uLCB2KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0VW5pZm9ybWZ2ID0gKG5hbWUsIHYpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHB1YmxpY0FQSS5maW5kVW5pZm9ybShuYW1lKTtcbiAgICBpZiAobG9jYXRpb24gPT09IC0xKSB7XG4gICAgICBtb2RlbC5lcnJvciA9IGBDb3VsZCBub3Qgc2V0IHVuaWZvcm0gJHtuYW1lfSAuIE5vIHN1Y2ggdW5pZm9ybS5gO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtb2RlbC5jb250ZXh0LnVuaWZvcm0xZnYobG9jYXRpb24sIHYpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRVbmlmb3JtaSA9IChuYW1lLCB2KSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSBwdWJsaWNBUEkuZmluZFVuaWZvcm0obmFtZSk7XG4gICAgaWYgKGxvY2F0aW9uID09PSAtMSkge1xuICAgICAgbW9kZWwuZXJyb3IgPSBgQ291bGQgbm90IHNldCB1bmlmb3JtICR7bmFtZX0gLiBObyBzdWNoIHVuaWZvcm0uYDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW9kZWwuY29udGV4dC51bmlmb3JtMWkobG9jYXRpb24sIHYpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRVbmlmb3JtaXYgPSAobmFtZSwgdikgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcHVibGljQVBJLmZpbmRVbmlmb3JtKG5hbWUpO1xuICAgIGlmIChsb2NhdGlvbiA9PT0gLTEpIHtcbiAgICAgIG1vZGVsLmVycm9yID0gYENvdWxkIG5vdCBzZXQgdW5pZm9ybSAke25hbWV9IC4gTm8gc3VjaCB1bmlmb3JtLmA7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vZGVsLmNvbnRleHQudW5pZm9ybTFpdihsb2NhdGlvbiwgdik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldFVuaWZvcm0yZiA9IChuYW1lLCB2MSwgdjIpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHB1YmxpY0FQSS5maW5kVW5pZm9ybShuYW1lKTtcbiAgICBpZiAobG9jYXRpb24gPT09IC0xKSB7XG4gICAgICBtb2RlbC5lcnJvciA9IGBDb3VsZCBub3Qgc2V0IHVuaWZvcm0gJHtuYW1lfSAuIE5vIHN1Y2ggdW5pZm9ybS5gO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIHZhbHVlcyBmb3IgYXJyYXknKTtcbiAgICB9XG4gICAgbW9kZWwuY29udGV4dC51bmlmb3JtMmYobG9jYXRpb24sIHYxLCB2Mik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldFVuaWZvcm0yZnYgPSAobmFtZSwgdikgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcHVibGljQVBJLmZpbmRVbmlmb3JtKG5hbWUpO1xuICAgIGlmIChsb2NhdGlvbiA9PT0gLTEpIHtcbiAgICAgIG1vZGVsLmVycm9yID0gYENvdWxkIG5vdCBzZXQgdW5pZm9ybSAke25hbWV9IC4gTm8gc3VjaCB1bmlmb3JtLmA7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vZGVsLmNvbnRleHQudW5pZm9ybTJmdihsb2NhdGlvbiwgdik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldFVuaWZvcm0yaSA9IChuYW1lLCB2MSwgdjIpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHB1YmxpY0FQSS5maW5kVW5pZm9ybShuYW1lKTtcbiAgICBpZiAobG9jYXRpb24gPT09IC0xKSB7XG4gICAgICBtb2RlbC5lcnJvciA9IGBDb3VsZCBub3Qgc2V0IHVuaWZvcm0gJHtuYW1lfSAuIE5vIHN1Y2ggdW5pZm9ybS5gO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIHZhbHVlcyBmb3IgYXJyYXknKTtcbiAgICB9XG4gICAgbW9kZWwuY29udGV4dC51bmlmb3JtMmkobG9jYXRpb24sIHYxLCB2Mik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldFVuaWZvcm0yaXYgPSAobmFtZSwgdikgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcHVibGljQVBJLmZpbmRVbmlmb3JtKG5hbWUpO1xuICAgIGlmIChsb2NhdGlvbiA9PT0gLTEpIHtcbiAgICAgIG1vZGVsLmVycm9yID0gYENvdWxkIG5vdCBzZXQgdW5pZm9ybSAke25hbWV9IC4gTm8gc3VjaCB1bmlmb3JtLmA7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vZGVsLmNvbnRleHQudW5pZm9ybTJpdihsb2NhdGlvbiwgdik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldFVuaWZvcm0zZiA9IChuYW1lLCBhMSwgYTIsIGEzKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSBwdWJsaWNBUEkuZmluZFVuaWZvcm0obmFtZSk7XG4gICAgaWYgKGxvY2F0aW9uID09PSAtMSkge1xuICAgICAgbW9kZWwuZXJyb3IgPSBgQ291bGQgbm90IHNldCB1bmlmb3JtICR7bmFtZX0gLiBObyBzdWNoIHVuaWZvcm0uYDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIG51bWJlciBvZiB2YWx1ZXMgZm9yIGFycmF5Jyk7XG4gICAgfVxuICAgIG1vZGVsLmNvbnRleHQudW5pZm9ybTNmKGxvY2F0aW9uLCBhMSwgYTIsIGEzKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0VW5pZm9ybTNmQXJyYXkgPSAobmFtZSwgYSkgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcHVibGljQVBJLmZpbmRVbmlmb3JtKG5hbWUpO1xuICAgIGlmIChsb2NhdGlvbiA9PT0gLTEpIHtcbiAgICAgIG1vZGVsLmVycm9yID0gYENvdWxkIG5vdCBzZXQgdW5pZm9ybSAke25hbWV9IC4gTm8gc3VjaCB1bmlmb3JtLmA7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShhKSB8fCBhLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIHZhbHVlcyBmb3IgYXJyYXknKTtcbiAgICB9XG4gICAgbW9kZWwuY29udGV4dC51bmlmb3JtM2YobG9jYXRpb24sIGFbMF0sIGFbMV0sIGFbMl0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRVbmlmb3JtM2Z2ID0gKG5hbWUsIHYpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHB1YmxpY0FQSS5maW5kVW5pZm9ybShuYW1lKTtcbiAgICBpZiAobG9jYXRpb24gPT09IC0xKSB7XG4gICAgICBtb2RlbC5lcnJvciA9IGBDb3VsZCBub3Qgc2V0IHVuaWZvcm0gJHtuYW1lfSAuIE5vIHN1Y2ggdW5pZm9ybS5gO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtb2RlbC5jb250ZXh0LnVuaWZvcm0zZnYobG9jYXRpb24sIHYpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRVbmlmb3JtM2kgPSAobmFtZSwgLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcHVibGljQVBJLmZpbmRVbmlmb3JtKG5hbWUpO1xuICAgIGlmIChsb2NhdGlvbiA9PT0gLTEpIHtcbiAgICAgIG1vZGVsLmVycm9yID0gYENvdWxkIG5vdCBzZXQgdW5pZm9ybSAke25hbWV9IC4gTm8gc3VjaCB1bmlmb3JtLmA7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBhcnJheSA9IGFyZ3M7XG4gICAgLy8gYWxsb3cgYW4gYXJyYXkgcGFzc2VkIGFzIGEgc2luZ2xlIGFyZ3VtZW50XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFycmF5WzBdKSkge1xuICAgICAgYXJyYXkgPSBhcnJheVswXTtcbiAgICB9XG4gICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIHZhbHVlcyBmb3IgYXJyYXknKTtcbiAgICB9XG4gICAgbW9kZWwuY29udGV4dC51bmlmb3JtM2kobG9jYXRpb24sIGFycmF5WzBdLCBhcnJheVsxXSwgYXJyYXlbMl0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRVbmlmb3JtM2l2ID0gKG5hbWUsIHYpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHB1YmxpY0FQSS5maW5kVW5pZm9ybShuYW1lKTtcbiAgICBpZiAobG9jYXRpb24gPT09IC0xKSB7XG4gICAgICBtb2RlbC5lcnJvciA9IGBDb3VsZCBub3Qgc2V0IHVuaWZvcm0gJHtuYW1lfSAuIE5vIHN1Y2ggdW5pZm9ybS5gO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtb2RlbC5jb250ZXh0LnVuaWZvcm0zaXYobG9jYXRpb24sIHYpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRVbmlmb3JtNGYgPSAobmFtZSwgLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcHVibGljQVBJLmZpbmRVbmlmb3JtKG5hbWUpO1xuICAgIGlmIChsb2NhdGlvbiA9PT0gLTEpIHtcbiAgICAgIG1vZGVsLmVycm9yID0gYENvdWxkIG5vdCBzZXQgdW5pZm9ybSAke25hbWV9IC4gTm8gc3VjaCB1bmlmb3JtLmA7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBhcnJheSA9IGFyZ3M7XG4gICAgLy8gYWxsb3cgYW4gYXJyYXkgcGFzc2VkIGFzIGEgc2luZ2xlIGFyZ3VtZW50XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFycmF5WzBdKSkge1xuICAgICAgYXJyYXkgPSBhcnJheVswXTtcbiAgICB9XG4gICAgaWYgKGFycmF5Lmxlbmd0aCAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIHZhbHVlcyBmb3IgYXJyYXknKTtcbiAgICB9XG4gICAgbW9kZWwuY29udGV4dC51bmlmb3JtNGYobG9jYXRpb24sIGFycmF5WzBdLCBhcnJheVsxXSwgYXJyYXlbMl0sIGFycmF5WzNdKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0VW5pZm9ybTRmdiA9IChuYW1lLCB2KSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSBwdWJsaWNBUEkuZmluZFVuaWZvcm0obmFtZSk7XG4gICAgaWYgKGxvY2F0aW9uID09PSAtMSkge1xuICAgICAgbW9kZWwuZXJyb3IgPSBgQ291bGQgbm90IHNldCB1bmlmb3JtICR7bmFtZX0gLiBObyBzdWNoIHVuaWZvcm0uYDtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbW9kZWwuY29udGV4dC51bmlmb3JtNGZ2KGxvY2F0aW9uLCB2KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0VW5pZm9ybTRpID0gKG5hbWUsIC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHB1YmxpY0FQSS5maW5kVW5pZm9ybShuYW1lKTtcbiAgICBpZiAobG9jYXRpb24gPT09IC0xKSB7XG4gICAgICBtb2RlbC5lcnJvciA9IGBDb3VsZCBub3Qgc2V0IHVuaWZvcm0gJHtuYW1lfSAuIE5vIHN1Y2ggdW5pZm9ybS5gO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgYXJyYXkgPSBhcmdzO1xuICAgIC8vIGFsbG93IGFuIGFycmF5IHBhc3NlZCBhcyBhIHNpbmdsZSBhcmd1bWVudFxuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcnJheVswXSkpIHtcbiAgICAgIGFycmF5ID0gYXJyYXlbMF07XG4gICAgfVxuICAgIGlmIChhcnJheS5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIG51bWJlciBvZiB2YWx1ZXMgZm9yIGFycmF5Jyk7XG4gICAgfVxuICAgIG1vZGVsLmNvbnRleHQudW5pZm9ybTRpKGxvY2F0aW9uLCBhcnJheVswXSwgYXJyYXlbMV0sIGFycmF5WzJdLCBhcnJheVszXSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldFVuaWZvcm00aXYgPSAobmFtZSwgdikgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcHVibGljQVBJLmZpbmRVbmlmb3JtKG5hbWUpO1xuICAgIGlmIChsb2NhdGlvbiA9PT0gLTEpIHtcbiAgICAgIG1vZGVsLmVycm9yID0gYENvdWxkIG5vdCBzZXQgdW5pZm9ybSAke25hbWV9IC4gTm8gc3VjaCB1bmlmb3JtLmA7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG1vZGVsLmNvbnRleHQudW5pZm9ybTRpdihsb2NhdGlvbiwgdik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldFVuaWZvcm00ZnYgPSAobmFtZSwgY291bnQsIHYpID0+IHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IHB1YmxpY0FQSS5maW5kVW5pZm9ybShuYW1lKTtcbiAgICBpZiAobG9jYXRpb24gPT09IC0xKSB7XG4gICAgICBtb2RlbC5lcnJvciA9IGBDb3VsZCBub3Qgc2V0IHVuaWZvcm0gJHtuYW1lfSAuIE5vIHN1Y2ggdW5pZm9ybS5gO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtb2RlbC5jb250ZXh0LnVuaWZvcm00ZnYobG9jYXRpb24sIHYpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5maW5kVW5pZm9ybSA9IChuYW1lKSA9PiB7XG4gICAgaWYgKCFuYW1lIHx8ICFtb2RlbC5saW5rZWQpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvLyBzZWUgaWYgd2UgaGF2ZSBjYWNoZWQgdGhlIHJlc3VsdFxuICAgIGxldCBsb2MgPSBtb2RlbC51bmlmb3JtTG9jc1tuYW1lXTtcbiAgICBpZiAobG9jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBsb2M7XG4gICAgfVxuXG4gICAgbG9jID0gbW9kZWwuY29udGV4dC5nZXRVbmlmb3JtTG9jYXRpb24obW9kZWwuaGFuZGxlLCBuYW1lKTtcbiAgICBpZiAobG9jID09PSBudWxsKSB7XG4gICAgICBtb2RlbC5lcnJvciA9IGBVbmlmb3JtICR7bmFtZX0gbm90IGZvdW5kIGluIGN1cnJlbnQgc2hhZGVyIHByb2dyYW0uYDtcbiAgICAgIG1vZGVsLnVuaWZvcm1Mb2NzW25hbWVdID0gLTE7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgbW9kZWwudW5pZm9ybUxvY3NbbmFtZV0gPSBsb2M7XG4gICAgcmV0dXJuIGxvYztcbiAgfTtcblxuICBwdWJsaWNBUEkuaXNVbmlmb3JtVXNlZCA9IChuYW1lKSA9PiB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gc2VlIGlmIHdlIGhhdmUgY2FjaGVkIHRoZSByZXN1bHRcbiAgICBsZXQgbG9jID0gbW9kZWwudW5pZm9ybUxvY3NbbmFtZV07XG4gICAgaWYgKGxvYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbG9jICE9PSBudWxsO1xuICAgIH1cblxuICAgIGlmICghbW9kZWwubGlua2VkKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKFxuICAgICAgICAnYXR0ZW1wdCB0byBmaW5kIHVuaWZvcm0gd2hlbiB0aGUgc2hhZGVyIHByb2dyYW0gaXMgbm90IGxpbmtlZCdcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbG9jID0gbW9kZWwuY29udGV4dC5nZXRVbmlmb3JtTG9jYXRpb24obW9kZWwuaGFuZGxlLCBuYW1lKTtcbiAgICBtb2RlbC51bmlmb3JtTG9jc1tuYW1lXSA9IGxvYztcblxuICAgIGlmIChsb2MgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBwdWJsaWNBUEkuaXNBdHRyaWJ1dGVVc2VkID0gKG5hbWUpID0+IHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBzZWUgaWYgd2UgaGF2ZSBjYWNoZWQgdGhlIHJlc3VsdFxuICAgIGxldCBsb2MgPSBPYmplY3Qua2V5cyhtb2RlbC5hdHRyaWJ1dGVMb2NzKS5pbmRleE9mKG5hbWUpO1xuICAgIGlmIChsb2MgIT09IC0xKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIW1vZGVsLmxpbmtlZCkge1xuICAgICAgdnRrRXJyb3JNYWNybyhcbiAgICAgICAgJ2F0dGVtcHQgdG8gZmluZCB1bmlmb3JtIHdoZW4gdGhlIHNoYWRlciBwcm9ncmFtIGlzIG5vdCBsaW5rZWQnXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGxvYyA9IG1vZGVsLmNvbnRleHQuZ2V0QXR0cmliTG9jYXRpb24obW9kZWwuaGFuZGxlLCBuYW1lKTtcbiAgICBpZiAobG9jID09PSAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBtb2RlbC5hdHRyaWJ1dGVMb2NzW25hbWVdID0gbG9jO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLmF0dGFjaFNoYWRlciA9IChzaGFkZXIpID0+IHtcbiAgICBpZiAoc2hhZGVyLmdldEhhbmRsZSgpID09PSAwKSB7XG4gICAgICBtb2RlbC5lcnJvciA9ICdTaGFkZXIgb2JqZWN0IHdhcyBub3QgaW5pdGlhbGl6ZWQsIGNhbm5vdCBhdHRhY2ggaXQuJztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHNoYWRlci5nZXRTaGFkZXJUeXBlKCkgPT09ICdVbmtub3duJykge1xuICAgICAgbW9kZWwuZXJyb3IgPSAnU2hhZGVyIG9iamVjdCBpcyBvZiB0eXBlIFVua25vd24gYW5kIGNhbm5vdCBiZSB1c2VkLic7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG1vZGVsLmhhbmRsZSA9PT0gMCkge1xuICAgICAgY29uc3QgdGhhbmRsZSA9IG1vZGVsLmNvbnRleHQuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgaWYgKHRoYW5kbGUgPT09IDApIHtcbiAgICAgICAgbW9kZWwuZXJyb3IgPSAnQ291bGQgbm90IGNyZWF0ZSBzaGFkZXIgcHJvZ3JhbS4nO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBtb2RlbC5oYW5kbGUgPSB0aGFuZGxlO1xuICAgICAgbW9kZWwubGlua2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHNoYWRlci5nZXRTaGFkZXJUeXBlKCkgPT09ICdWZXJ0ZXgnKSB7XG4gICAgICBpZiAobW9kZWwudmVydGV4U2hhZGVySGFuZGxlICE9PSAwKSB7XG4gICAgICAgIG1vZGVsLmNvbW50ZXh0LmRldGFjaFNoYWRlcihtb2RlbC5oYW5kbGUsIG1vZGVsLnZlcnRleFNoYWRlckhhbmRsZSk7XG4gICAgICB9XG4gICAgICBtb2RlbC52ZXJ0ZXhTaGFkZXJIYW5kbGUgPSBzaGFkZXIuZ2V0SGFuZGxlKCk7XG4gICAgfVxuICAgIGlmIChzaGFkZXIuZ2V0U2hhZGVyVHlwZSgpID09PSAnRnJhZ21lbnQnKSB7XG4gICAgICBpZiAobW9kZWwuZnJhZ21lbnRTaGFkZXJIYW5kbGUgIT09IDApIHtcbiAgICAgICAgbW9kZWwuY29udGV4dC5kZXRhY2hTaGFkZXIobW9kZWwuaGFuZGxlLCBtb2RlbC5mcmFnbWVudFNoYWRlckhhbmRsZSk7XG4gICAgICB9XG4gICAgICBtb2RlbC5mcmFnbWVudFNoYWRlckhhbmRsZSA9IHNoYWRlci5nZXRIYW5kbGUoKTtcbiAgICB9XG5cbiAgICBtb2RlbC5jb250ZXh0LmF0dGFjaFNoYWRlcihtb2RlbC5oYW5kbGUsIHNoYWRlci5nZXRIYW5kbGUoKSk7XG4gICAgcHVibGljQVBJLnNldExpbmtlZChmYWxzZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLmRldGFjaFNoYWRlciA9IChzaGFkZXIpID0+IHtcbiAgICBpZiAoc2hhZGVyLmdldEhhbmRsZSgpID09PSAwKSB7XG4gICAgICBtb2RlbC5lcnJvciA9ICdzaGFkZXIgb2JqZWN0IHdhcyBub3QgaW5pdGlhbGl6ZWQsIGNhbm5vdCBhdHRhY2ggaXQuJztcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHNoYWRlci5nZXRTaGFkZXJUeXBlKCkgPT09ICdVbmtub3duJykge1xuICAgICAgbW9kZWwuZXJyb3IgPSAnU2hhZGVyIG9iamVjdCBpcyBvZiB0eXBlIFVua25vd24gYW5kIGNhbm5vdCBiZSB1c2VkLic7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChtb2RlbC5oYW5kbGUgPT09IDApIHtcbiAgICAgIG1vZGVsLmVycm9yID0gJ1RoaXMgc2hhZGVyIHByb2dyYW0gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldC4nO1xuICAgIH1cblxuICAgIHN3aXRjaCAoc2hhZGVyLmdldFNoYWRlclR5cGUoKSkge1xuICAgICAgY2FzZSAnVmVydGV4JzpcbiAgICAgICAgaWYgKG1vZGVsLnZlcnRleFNoYWRlckhhbmRsZSAhPT0gc2hhZGVyLmdldEhhbmRsZSgpKSB7XG4gICAgICAgICAgbW9kZWwuZXJyb3IgPSAnVGhlIHN1cHBsaWVkIHNoYWRlciB3YXMgbm90IGF0dGFjaGVkIHRvIHRoaXMgcHJvZ3JhbS4nO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbC5jb250ZXh0LmRldGFjaFNoYWRlcihtb2RlbC5oYW5kbGUsIHNoYWRlci5nZXRIYW5kbGUoKSk7XG4gICAgICAgIG1vZGVsLnZlcnRleFNoYWRlckhhbmRsZSA9IDA7XG4gICAgICAgIG1vZGVsLmxpbmtlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ0ZyYWdtZW50JzpcbiAgICAgICAgaWYgKG1vZGVsLmZyYWdtZW50U2hhZGVySGFuZGxlICE9PSBzaGFkZXIuZ2V0SGFuZGxlKCkpIHtcbiAgICAgICAgICBtb2RlbC5lcnJvciA9ICdUaGUgc3VwcGxpZWQgc2hhZGVyIHdhcyBub3QgYXR0YWNoZWQgdG8gdGhpcyBwcm9ncmFtLic7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLmNvbnRleHQuZGV0YWNoU2hhZGVyKG1vZGVsLmhhbmRsZSwgc2hhZGVyLmdldEhhbmRsZSgpKTtcbiAgICAgICAgbW9kZWwuZnJhZ21lbnRTaGFkZXJIYW5kbGUgPSAwO1xuICAgICAgICBtb2RlbC5saW5rZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRDb250ZXh0ID0gKGN0eCkgPT4ge1xuICAgIG1vZGVsLmNvbnRleHQgPSBjdHg7XG4gICAgbW9kZWwudmVydGV4U2hhZGVyLnNldENvbnRleHQoY3R4KTtcbiAgICBtb2RlbC5mcmFnbWVudFNoYWRlci5zZXRDb250ZXh0KGN0eCk7XG4gICAgbW9kZWwuZ2VvbWV0cnlTaGFkZXIuc2V0Q29udGV4dChjdHgpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRMYXN0Q2FtZXJhTVRpbWUgPSAobXRpbWUpID0+IHtcbiAgICBtb2RlbC5sYXN0Q2FtZXJhTVRpbWUgPSBtdGltZTtcbiAgfTtcblxuICAvLyBwdWJsaWNBUEkuZW5hYmxlQXR0cmlidXRlQXJyYXkgPSAobmFtZSkgPT4ge1xuICAvLyAgIGNvbnN0IGxvY2F0aW9uID0gcHVibGljQVBJLmZpbmRBdHRyaWJ1dGVBcnJheShuYW1lKTtcbiAgLy8gICBpZiAobG9jYXRpb24gPT09IC0xKSB7XG4gIC8vICAgICBtb2RlbC5lcnJvciA9IGBDb3VsZCBub3QgZW5hYmxlIGF0dHJpYnV0ZSAke25hbWV9IE5vIHN1Y2ggYXR0cmlidXRlLmA7XG4gIC8vICAgICByZXR1cm4gZmFsc2U7XG4gIC8vICAgfVxuICAvLyAgIG1vZGVsLmNvbnRleHQuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xuICAvLyAgIHJldHVybiB0cnVlO1xuICAvLyB9O1xuXG4gIC8vIHB1YmxpY0FQSS5kaXNhYmxlQXR0cmlidXRlQXJyYXkgPSAobmFtZSkgPT4ge1xuICAvLyAgIGNvbnN0IGxvY2F0aW9uID0gcHVibGljQVBJLmZpbmRBdHRyaWJ1dGVBcnJheShuYW1lKTtcbiAgLy8gICBpZiAobG9jYXRpb24gPT09IC0xKSB7XG4gIC8vICAgICBtb2RlbC5lcnJvciA9IGBDb3VsZCBub3QgZW5hYmxlIGF0dHJpYnV0ZSAke25hbWV9IE5vIHN1Y2ggYXR0cmlidXRlLmA7XG4gIC8vICAgICByZXR1cm4gZmFsc2U7XG4gIC8vICAgfVxuICAvLyAgIG1vZGVsLmNvbnRleHQuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbiAgLy8gICByZXR1cm4gdHJ1ZTtcbiAgLy8gfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIHZlcnRleFNoYWRlckhhbmRsZTogMCxcbiAgZnJhZ21lbnRTaGFkZXJIYW5kbGU6IDAsXG4gIGdlb21ldHJ5U2hhZGVySGFuZGxlOiAwLFxuICB2ZXJ0ZXhTaGFkZXI6IG51bGwsXG4gIGZyYWdtZW50U2hhZGVyOiBudWxsLFxuICBnZW9tZXRyeVNoYWRlcjogbnVsbCxcblxuICBsaW5rZWQ6IGZhbHNlLFxuICBib3VuZDogZmFsc2UsXG4gIGNvbXBpbGVkOiBmYWxzZSxcbiAgZXJyb3I6ICcnLFxuICBoYW5kbGU6IDAsXG4gIG51bWJlck9mT3V0cHV0czogMCxcbiAgYXR0cmlidXRlc0xvY3M6IG51bGwsXG4gIHVuaWZvcm1Mb2NzOiBudWxsLFxuICBtZDVIYXNoOiAwLFxuICBjb250ZXh0OiBudWxsLFxuICBsYXN0Q2FtZXJhTVRpbWU6IG51bGwsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEluc3RhbnRpYXRlIGludGVybmFsIG9iamVjdHNcbiAgbW9kZWwuYXR0cmlidXRlc0xvY3MgPSB7fTtcbiAgbW9kZWwudW5pZm9ybUxvY3MgPSB7fTtcbiAgbW9kZWwudmVydGV4U2hhZGVyID0gdnRrU2hhZGVyLm5ld0luc3RhbmNlKCk7XG4gIG1vZGVsLnZlcnRleFNoYWRlci5zZXRTaGFkZXJUeXBlKCdWZXJ0ZXgnKTtcbiAgbW9kZWwuZnJhZ21lbnRTaGFkZXIgPSB2dGtTaGFkZXIubmV3SW5zdGFuY2UoKTtcbiAgbW9kZWwuZnJhZ21lbnRTaGFkZXIuc2V0U2hhZGVyVHlwZSgnRnJhZ21lbnQnKTtcbiAgbW9kZWwuZ2VvbWV0cnlTaGFkZXIgPSB2dGtTaGFkZXIubmV3SW5zdGFuY2UoKTtcbiAgbW9kZWwuZ2VvbWV0cnlTaGFkZXIuc2V0U2hhZGVyVHlwZSgnR2VvbWV0cnknKTtcblxuICAvLyBCdWlsZCBWVEsgQVBJXG4gIG1hY3JvLm9iaihwdWJsaWNBUEksIG1vZGVsKTtcbiAgbWFjcm8uZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsnbGFzdENhbWVyYU1UaW1lJ10pO1xuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgW1xuICAgICdlcnJvcicsXG4gICAgJ2hhbmRsZScsXG4gICAgJ2NvbXBpbGVkJyxcbiAgICAnYm91bmQnLFxuICAgICdtZDVIYXNoJyxcbiAgICAndmVydGV4U2hhZGVyJyxcbiAgICAnZnJhZ21lbnRTaGFkZXInLFxuICAgICdnZW9tZXRyeVNoYWRlcicsXG4gICAgJ2xpbmtlZCcsXG4gIF0pO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIHZ0a1NoYWRlclByb2dyYW0ocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQsICd2dGtTaGFkZXJQcm9ncmFtJyk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kLCBzdWJzdGl0dXRlIH07XG4iLCJpbXBvcnQgeyBtYXQzLCBtYXQ0IH0gZnJvbSAnZ2wtbWF0cml4JztcblxuaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB2dGtEYXRhQXJyYXkgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvRGF0YUFycmF5JztcbmltcG9ydCB2dGtIZWxwZXIgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9IZWxwZXInO1xuaW1wb3J0IHZ0a1ZpZXdOb2RlIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9TY2VuZUdyYXBoL1ZpZXdOb2RlJztcbmltcG9ydCB2dGtPcGVuR0xUZXh0dXJlIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvVGV4dHVyZSc7XG5cbmltcG9ydCB7IFJlcHJlc2VudGF0aW9uIH0gZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvUHJvcGVydHkvQ29uc3RhbnRzJztcblxuY29uc3QgeyB2dGtFcnJvck1hY3JvIH0gPSBtYWNybztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrT3BlbkdMU2t5Ym94IG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrT3BlbkdMU2t5Ym94KHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrT3BlbkdMU2t5Ym94Jyk7XG5cbiAgLy8gQnVpbGRzIG15c2VsZi5cbiAgcHVibGljQVBJLmJ1aWxkUGFzcyA9IChwcmVwYXNzKSA9PiB7XG4gICAgaWYgKHByZXBhc3MpIHtcbiAgICAgIG1vZGVsLm9wZW5HTFJlbmRlcmVyID0gcHVibGljQVBJLmdldEZpcnN0QW5jZXN0b3JPZlR5cGUoXG4gICAgICAgICd2dGtPcGVuR0xSZW5kZXJlcidcbiAgICAgICk7XG4gICAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cgPSBtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRQYXJlbnQoKTtcbiAgICAgIG1vZGVsLmNvbnRleHQgPSBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0Q29udGV4dCgpO1xuICAgICAgbW9kZWwudHJpcy5zZXRPcGVuR0xSZW5kZXJXaW5kb3cobW9kZWwub3BlbkdMUmVuZGVyV2luZG93KTtcbiAgICAgIG1vZGVsLm9wZW5HTFRleHR1cmUuc2V0T3BlbkdMUmVuZGVyV2luZG93KG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyk7XG4gICAgICBjb25zdCByZW4gPSBtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRSZW5kZXJhYmxlKCk7XG4gICAgICBtb2RlbC5vcGVuR0xDYW1lcmEgPSBtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRWaWV3Tm9kZUZvcihcbiAgICAgICAgcmVuLmdldEFjdGl2ZUNhbWVyYSgpXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkucXVlcnlQYXNzID0gKHByZXBhc3MsIHJlbmRlclBhc3MpID0+IHtcbiAgICBpZiAocHJlcGFzcykge1xuICAgICAgaWYgKCFtb2RlbC5yZW5kZXJhYmxlIHx8ICFtb2RlbC5yZW5kZXJhYmxlLmdldFZpc2liaWxpdHkoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZW5kZXJQYXNzLmluY3JlbWVudE9wYXF1ZUFjdG9yQ291bnQoKTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLm9wYXF1ZVBhc3MgPSAocHJlcGFzcywgcmVuZGVyUGFzcykgPT4ge1xuICAgIGlmIChwcmVwYXNzICYmICFtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRTZWxlY3RvcigpKSB7XG4gICAgICBwdWJsaWNBUEkudXBkYXRlQnVmZmVyT2JqZWN0cygpO1xuXG4gICAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZW5hYmxlRGVwdGhNYXNrKCk7XG5cbiAgICAgIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvd1xuICAgICAgICAuZ2V0U2hhZGVyQ2FjaGUoKVxuICAgICAgICAucmVhZHlTaGFkZXJQcm9ncmFtKG1vZGVsLnRyaXMuZ2V0UHJvZ3JhbSgpKTtcblxuICAgICAgbW9kZWwub3BlbkdMVGV4dHVyZS5yZW5kZXIobW9kZWwub3BlbkdMUmVuZGVyV2luZG93KTtcblxuICAgICAgY29uc3QgdGV4VW5pdCA9IG1vZGVsLm9wZW5HTFRleHR1cmUuZ2V0VGV4dHVyZVVuaXQoKTtcbiAgICAgIG1vZGVsLnRyaXMuZ2V0UHJvZ3JhbSgpLnNldFVuaWZvcm1pKCdzYnRleHR1cmUnLCB0ZXhVbml0KTtcblxuICAgICAgY29uc3QgcmVuID0gbW9kZWwub3BlbkdMUmVuZGVyZXIuZ2V0UmVuZGVyYWJsZSgpO1xuXG4gICAgICBjb25zdCBrZXlNYXRzID0gbW9kZWwub3BlbkdMQ2FtZXJhLmdldEtleU1hdHJpY2VzKHJlbik7XG4gICAgICBjb25zdCBpbWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgIG1hdDQuaW52ZXJ0KGltYXQsIGtleU1hdHMud2NwYyk7XG4gICAgICBtb2RlbC50cmlzLmdldFByb2dyYW0oKS5zZXRVbmlmb3JtTWF0cml4KCdJTUNQQ01hdHJpeCcsIGltYXQpO1xuXG4gICAgICBpZiAobW9kZWwubGFzdEZvcm1hdCA9PT0gJ2JveCcpIHtcbiAgICAgICAgY29uc3QgY2FtUG9zID0gcmVuLmdldEFjdGl2ZUNhbWVyYSgpLmdldFBvc2l0aW9uKCk7XG4gICAgICAgIG1vZGVsLnRyaXNcbiAgICAgICAgICAuZ2V0UHJvZ3JhbSgpXG4gICAgICAgICAgLnNldFVuaWZvcm0zZignY2FtUG9zJywgY2FtUG9zWzBdLCBjYW1Qb3NbMV0sIGNhbVBvc1syXSk7XG4gICAgICB9XG5cbiAgICAgIG1vZGVsLnRyaXMuZ2V0VkFPKCkuYmluZCgpO1xuXG4gICAgICAvLyBkcmF3IHBvbHlnb25zXG4gICAgICBtb2RlbC5jb250ZXh0LmRyYXdBcnJheXMoXG4gICAgICAgIG1vZGVsLmNvbnRleHQuVFJJQU5HTEVTLFxuICAgICAgICAwLFxuICAgICAgICBtb2RlbC50cmlzLmdldENBQk8oKS5nZXRFbGVtZW50Q291bnQoKVxuICAgICAgKTtcbiAgICAgIG1vZGVsLnRyaXMuZ2V0VkFPKCkucmVsZWFzZSgpO1xuXG4gICAgICBtb2RlbC5vcGVuR0xUZXh0dXJlLmRlYWN0aXZhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLnVwZGF0ZUJ1ZmZlck9iamVjdHMgPSAoKSA9PiB7XG4gICAgLy8gYnVpbGQgdGhlIFZCTyBpZiBuZWVkZWQsIG9ubHkgaGFwcGVucyBvbmNlXG4gICAgaWYgKCFtb2RlbC50cmlzLmdldENBQk8oKS5nZXRFbGVtZW50Q291bnQoKSkge1xuICAgICAgY29uc3QgcHRzQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDEyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIHB0c0FycmF5W2kgKiAzXSA9IChpICUgMikgKiAyIC0gMS4wO1xuICAgICAgICBwdHNBcnJheVtpICogMyArIDFdID0gaSA+IDEgPyAxLjAgOiAtMS4wO1xuICAgICAgICBwdHNBcnJheVtpICogMyArIDJdID0gMS4wO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9pbnRzID0gdnRrRGF0YUFycmF5Lm5ld0luc3RhbmNlKHtcbiAgICAgICAgbnVtYmVyT2ZDb21wb25lbnRzOiAzLFxuICAgICAgICB2YWx1ZXM6IHB0c0FycmF5LFxuICAgICAgfSk7XG4gICAgICBwb2ludHMuc2V0TmFtZSgncG9pbnRzJyk7XG5cbiAgICAgIGNvbnN0IGNlbGxBcnJheSA9IG5ldyBVaW50MTZBcnJheSg4KTtcbiAgICAgIGNlbGxBcnJheVswXSA9IDM7XG4gICAgICBjZWxsQXJyYXlbMV0gPSAwO1xuICAgICAgY2VsbEFycmF5WzJdID0gMTtcbiAgICAgIGNlbGxBcnJheVszXSA9IDM7XG4gICAgICBjZWxsQXJyYXlbNF0gPSAzO1xuICAgICAgY2VsbEFycmF5WzVdID0gMDtcbiAgICAgIGNlbGxBcnJheVs2XSA9IDM7XG4gICAgICBjZWxsQXJyYXlbN10gPSAyO1xuICAgICAgY29uc3QgY2VsbHMgPSB2dGtEYXRhQXJyYXkubmV3SW5zdGFuY2Uoe1xuICAgICAgICBudW1iZXJPZkNvbXBvbmVudHM6IDEsXG4gICAgICAgIHZhbHVlczogY2VsbEFycmF5LFxuICAgICAgfSk7XG5cbiAgICAgIG1vZGVsLnRyaXMuZ2V0Q0FCTygpLmNyZWF0ZVZCTyhjZWxscywgJ3BvbHlzJywgUmVwcmVzZW50YXRpb24uU1VSRkFDRSwge1xuICAgICAgICBwb2ludHMsXG4gICAgICAgIGNlbGxPZmZzZXQ6IDAsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIHByb2dyYW0/XG4gICAgaWYgKG1vZGVsLnJlbmRlcmFibGUuZ2V0Rm9ybWF0KCkgIT09IG1vZGVsLmxhc3RGb3JtYXQpIHtcbiAgICAgIG1vZGVsLmxhc3RGb3JtYXQgPSBtb2RlbC5yZW5kZXJhYmxlLmdldEZvcm1hdCgpO1xuXG4gICAgICBpZiAobW9kZWwubGFzdEZvcm1hdCA9PT0gJ2JveCcpIHtcbiAgICAgICAgLy8gd2UgaW52ZXJ0IFkgYmVsb3cgYmVjYXVzZSBvcGVuZ2wgaXMgbWVzc2VkIHVwIVxuICAgICAgICAvLyBDdWJlIE1hcHMgaGF2ZSBiZWVuIHNwZWNpZmllZCB0byBmb2xsb3cgdGhlIFJlbmRlck1hblxuICAgICAgICAvLyBzcGVjaWZpY2F0aW9uIChmb3Igd2hhdGV2ZXIgcmVhc29uKSwgYW5kIFJlbmRlck1hblxuICAgICAgICAvLyBhc3N1bWVzIHRoZSBpbWFnZXMnIG9yaWdpbiBiZWluZyBpbiB0aGUgdXBwZXIgbGVmdCxcbiAgICAgICAgLy8gY29udHJhcnkgdG8gdGhlIHVzdWFsIE9wZW5HTCBiZWhhdmlvdXIgb2YgaGF2aW5nIHRoZVxuICAgICAgICAvLyBpbWFnZSBvcmlnaW4gaW4gdGhlIGxvd2VyIGxlZnQuIFRoYXQncyB3aHkgdGhpbmdzIGdldFxuICAgICAgICAvLyBzd2FwcGVkIGluIHRoZSBZIGRpcmVjdGlvbi4gSXQgdG90YWxseSBicmVha3Mgd2l0aCB0aGUgdXN1YWxcbiAgICAgICAgLy8gT3BlbkdMIHNlbWFudGljcyBhbmQgZG9lc24ndCBtYWtlIHNlbnNlIGF0IGFsbC5cbiAgICAgICAgLy8gQnV0IG5vdyB3ZSdyZSBzdHVjayB3aXRoIGl0LiAgRnJvbVxuICAgICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMTY4NTYwOC9jb252ZW50aW9uLW9mLWZhY2VzLWluLW9wZW5nbC1jdWJlbWFwcGluZ1xuICAgICAgICAvL1xuICAgICAgICBtb2RlbC50cmlzLnNldFByb2dyYW0oXG4gICAgICAgICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldFNoYWRlckNhY2hlKCkucmVhZHlTaGFkZXJQcm9ncmFtQXJyYXkoXG4gICAgICAgICAgICBgLy9WVEs6OlN5c3RlbTo6RGVjXG4gICAgICAgICAgICAgYXR0cmlidXRlIHZlYzMgdmVydGV4TUM7XG4gICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IElNQ1BDTWF0cml4O1xuICAgICAgICAgICAgIHZhcnlpbmcgdmVjMyBUZXhDb29yZHM7XG4gICAgICAgICAgICAgdm9pZCBtYWluICgpIHtcbiAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHZlcnRleE1DLnh5eiwgMS4wKTtcbiAgICAgICAgICAgICAgdmVjNCB3cG9zID0gSU1DUENNYXRyaXggKiBnbF9Qb3NpdGlvbjtcbiAgICAgICAgICAgICAgVGV4Q29vcmRzID0gd3Bvcy54eXovd3Bvcy53O1xuICAgICAgICAgICAgIH1gLFxuICAgICAgICAgICAgYC8vVlRLOjpTeXN0ZW06OkRlY1xuICAgICAgICAgICAgIC8vVlRLOjpPdXRwdXQ6OkRlY1xuICAgICAgICAgICAgIHZhcnlpbmcgdmVjMyBUZXhDb29yZHM7XG4gICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyQ3ViZSBzYnRleHR1cmU7XG4gICAgICAgICAgICAgdW5pZm9ybSB2ZWMzIGNhbVBvcztcbiAgICAgICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgICAgLy8gc2t5Ym94IGxvb2tzIGZyb20gaW5zaWRlIG91dFxuICAgICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgd2UgaGF2ZSB0byBhZGp1c3RcbiAgICAgICAgICAgICAgIC8vIG91ciB0Y29vcmRzLiBPdGhlcndpc2UgdGV4dCB3b3VsZFxuICAgICAgICAgICAgICAgLy8gYmUgZmxpcHBlZFxuICAgICAgICAgICAgICAgdmVjMyB0YyA9IG5vcm1hbGl6ZShUZXhDb29yZHMgLSBjYW1Qb3MpO1xuICAgICAgICAgICAgICAgaWYgKGFicyh0Yy56KSA8IG1heChhYnModGMueCksYWJzKHRjLnkpKSlcbiAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgdGMgPSB2ZWMzKDEuMCwgMS4wLCAtMS4wKSAqIHRjO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICB0YyA9IHZlYzMoLTEuMCwgMS4wLCAxLjApICogdGM7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBnbF9GcmFnRGF0YVswXSA9IHRleHR1cmVDdWJlKHNidGV4dHVyZSwgdGMpO1xuICAgICAgICAgICAgIH1gLFxuICAgICAgICAgICAgJydcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlbC5sYXN0Rm9ybWF0ID09PSAnYmFja2dyb3VuZCcpIHtcbiAgICAgICAgLy8gbWFwcyB0aGUgdGV4dHVyZSB0byB0aGUgd2luZG93XG4gICAgICAgIG1vZGVsLnRyaXMuc2V0UHJvZ3JhbShcbiAgICAgICAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0U2hhZGVyQ2FjaGUoKS5yZWFkeVNoYWRlclByb2dyYW1BcnJheShcbiAgICAgICAgICAgIGAvL1ZUSzo6U3lzdGVtOjpEZWNcbiAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMyB2ZXJ0ZXhNQztcbiAgICAgICAgICAgICB1bmlmb3JtIG1hdDQgSU1DUENNYXRyaXg7XG4gICAgICAgICAgICAgdmFyeWluZyB2ZWMyIFRleENvb3JkcztcbiAgICAgICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQodmVydGV4TUMueHl6LCAxLjApO1xuICAgICAgICAgICAgICB2ZWM0IHdwb3MgPSBJTUNQQ01hdHJpeCAqIGdsX1Bvc2l0aW9uO1xuICAgICAgICAgICAgICBUZXhDb29yZHMgPSB2ZWMyKHZlcnRleE1DLngsIHZlcnRleE1DLnkpKjAuNSArIDAuNTtcbiAgICAgICAgICAgICB9YCxcbiAgICAgICAgICAgIGAvL1ZUSzo6U3lzdGVtOjpEZWNcbiAgICAgICAgICAgICAvL1ZUSzo6T3V0cHV0OjpEZWNcbiAgICAgICAgICAgICB2YXJ5aW5nIHZlYzIgVGV4Q29vcmRzO1xuICAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHNidGV4dHVyZTtcbiAgICAgICAgICAgICB2b2lkIG1haW4gKCkge1xuICAgICAgICAgICAgICAgZ2xfRnJhZ0RhdGFbMF0gPSB0ZXh0dXJlMkQoc2J0ZXh0dXJlLCBUZXhDb29yZHMpO1xuICAgICAgICAgICAgIH1gLFxuICAgICAgICAgICAgJydcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIG1vZGVsLnRyaXMuZ2V0U2hhZGVyU291cmNlVGltZSgpLm1vZGlmaWVkKCk7XG5cbiAgICAgIG1vZGVsLnRyaXMuZ2V0VkFPKCkuYmluZCgpO1xuXG4gICAgICBpZiAoXG4gICAgICAgICFtb2RlbC50cmlzXG4gICAgICAgICAgLmdldFZBTygpXG4gICAgICAgICAgLmFkZEF0dHJpYnV0ZUFycmF5KFxuICAgICAgICAgICAgbW9kZWwudHJpcy5nZXRQcm9ncmFtKCksXG4gICAgICAgICAgICBtb2RlbC50cmlzLmdldENBQk8oKSxcbiAgICAgICAgICAgICd2ZXJ0ZXhNQycsXG4gICAgICAgICAgICBtb2RlbC50cmlzLmdldENBQk8oKS5nZXRWZXJ0ZXhPZmZzZXQoKSxcbiAgICAgICAgICAgIG1vZGVsLnRyaXMuZ2V0Q0FCTygpLmdldFN0cmlkZSgpLFxuICAgICAgICAgICAgbW9kZWwuY29udGV4dC5GTE9BVCxcbiAgICAgICAgICAgIDMsXG4gICAgICAgICAgICBtb2RlbC5jb250ZXh0LkZBTFNFXG4gICAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHZ0a0Vycm9yTWFjcm8oJ0Vycm9yIHNldHRpbmcgdmVydGV4TUMgaW4gc2hhZGVyIFZBTy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzZXQvdXBkYXRlIHRoZSB0ZXh0dXJlIG1hcCBpZiBuZWVkZWRcbiAgICBjb25zdCB0bWFwcyA9IG1vZGVsLnJlbmRlcmFibGUuZ2V0VGV4dHVyZXMoKTtcbiAgICBpZiAoIXRtYXBzLmxlbmd0aCkge1xuICAgICAgdnRrRXJyb3JNYWNybygndnRrU2t5Ym94IHJlcXVpcmVzIGEgdGV4dHVyZSBtYXAnKTtcbiAgICB9XG4gICAgaWYgKG1vZGVsLm9wZW5HTFRleHR1cmUuZ2V0UmVuZGVyYWJsZSgpICE9PSB0bWFwc1swXSkge1xuICAgICAgbW9kZWwub3BlbkdMVGV4dHVyZS5yZWxlYXNlR3JhcGhpY3NSZXNvdXJjZXMobW9kZWwub3BlbkdMUmVuZGVyV2luZG93KTtcbiAgICAgIG1vZGVsLm9wZW5HTFRleHR1cmUuc2V0UmVuZGVyYWJsZSh0bWFwc1swXSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgY29udGV4dDogbnVsbCxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEluaGVyaXRhbmNlXG4gIHZ0a1ZpZXdOb2RlLmV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzKTtcblxuICBtb2RlbC5vcGVuR0xUZXh0dXJlID0gdnRrT3BlbkdMVGV4dHVyZS5uZXdJbnN0YW5jZSgpO1xuICBtb2RlbC50cmlzID0gdnRrSGVscGVyLm5ld0luc3RhbmNlKCk7XG5cbiAgbW9kZWwua2V5TWF0cml4VGltZSA9IHt9O1xuICBtYWNyby5vYmoobW9kZWwua2V5TWF0cml4VGltZSwgeyBtdGltZTogMCB9KTtcbiAgbW9kZWwua2V5TWF0cmljZXMgPSB7XG4gICAgbm9ybWFsTWF0cml4OiBtYXQzLmNyZWF0ZSgpLFxuICAgIG1jd2M6IG1hdDQuY3JlYXRlKCksXG4gIH07XG5cbiAgLy8gQnVpbGQgVlRLIEFQSVxuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgWydjb250ZXh0J10pO1xuXG4gIG1hY3JvLmdldChwdWJsaWNBUEksIG1vZGVsLCBbJ2FjdGl2ZVRleHR1cmVzJ10pO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIHZ0a09wZW5HTFNreWJveChwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCB9O1xuIiwiaW1wb3J0IHsgbWF0NCB9IGZyb20gJ2dsLW1hdHJpeCc7XG5pbXBvcnQgeyBPYmplY3RUeXBlIH0gZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9CdWZmZXJPYmplY3QvQ29uc3RhbnRzJztcblxuaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcblxuaW1wb3J0IHZ0a0J1ZmZlck9iamVjdCBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML0J1ZmZlck9iamVjdCc7XG5pbXBvcnQgKiBhcyB2dGtNYXRoIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9Db3JlL01hdGgnO1xuXG5pbXBvcnQgdnRrU2hhZGVyUHJvZ3JhbSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1NoYWRlclByb2dyYW0nO1xuaW1wb3J0IHZ0a09wZW5HTFBvbHlEYXRhTWFwcGVyIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvUG9seURhdGFNYXBwZXInO1xuXG5pbXBvcnQgdnRrU3BoZXJlTWFwcGVyVlMgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9nbHNsL3Z0a1NwaGVyZU1hcHBlclZTLmdsc2wnO1xuaW1wb3J0IHZ0a1BvbHlEYXRhRlMgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9nbHNsL3Z0a1BvbHlEYXRhRlMuZ2xzbCc7XG5cbmNvbnN0IHsgdnRrRXJyb3JNYWNybyB9ID0gbWFjcm87XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a09wZW5HTFNwaGVyZU1hcHBlciBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a09wZW5HTFNwaGVyZU1hcHBlcihwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a09wZW5HTFNwaGVyZU1hcHBlcicpO1xuXG4gIC8vIENhcHR1cmUgJ3BhcmVudENsYXNzJyBhcGkgZm9yIGludGVybmFsIHVzZVxuICBjb25zdCBzdXBlckNsYXNzID0geyAuLi5wdWJsaWNBUEkgfTtcblxuICBwdWJsaWNBUEkuZ2V0U2hhZGVyVGVtcGxhdGUgPSAoc2hhZGVycywgcmVuLCBhY3RvcikgPT4ge1xuICAgIHNoYWRlcnMuVmVydGV4ID0gdnRrU3BoZXJlTWFwcGVyVlM7XG4gICAgc2hhZGVycy5GcmFnbWVudCA9IHZ0a1BvbHlEYXRhRlM7XG4gICAgc2hhZGVycy5HZW9tZXRyeSA9ICcnO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZXBsYWNlU2hhZGVyVmFsdWVzID0gKHNoYWRlcnMsIHJlbiwgYWN0b3IpID0+IHtcbiAgICBsZXQgVlNTb3VyY2UgPSBzaGFkZXJzLlZlcnRleDtcbiAgICBsZXQgRlNTb3VyY2UgPSBzaGFkZXJzLkZyYWdtZW50O1xuXG4gICAgVlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoVlNTb3VyY2UsICcvL1ZUSzo6Q2FtZXJhOjpEZWMnLCBbXG4gICAgICAndW5pZm9ybSBtYXQ0IFZDUENNYXRyaXg7XFxuJyxcbiAgICAgICd1bmlmb3JtIG1hdDQgTUNWQ01hdHJpeDsnLFxuICAgIF0pLnJlc3VsdDtcblxuICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKEZTU291cmNlLCAnLy9WVEs6OlBvc2l0aW9uVkM6OkRlYycsIFtcbiAgICAgICd2YXJ5aW5nIHZlYzQgdmVydGV4VkNWU091dHB1dDsnLFxuICAgIF0pLnJlc3VsdDtcblxuICAgIC8vIHdlIGNyZWF0ZSB2ZXJ0ZXhWQyBiZWxvdywgc28gdHVybiBvZmYgdGhlIGRlZmF1bHRcbiAgICAvLyBpbXBsZW1lbnRhdGlvblxuICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgRlNTb3VyY2UsXG4gICAgICAnLy9WVEs6OlBvc2l0aW9uVkM6OkltcGwnLFxuICAgICAgWyd2ZWM0IHZlcnRleFZDID0gdmVydGV4VkNWU091dHB1dDtcXG4nXVxuICAgICkucmVzdWx0O1xuXG4gICAgLy8gZm9yIGxpZ2h0cyBraXQgYW5kIHBvc2l0aW9uYWwgdGhlIFZDUEMgbWF0cml4IGlzIGFscmVhZHkgZGVmaW5lZFxuICAgIC8vIHNvIGRvbid0IHJlZGVmaW5lIGl0XG4gICAgY29uc3QgcmVwbGFjZW1lbnQgPSBbXG4gICAgICAndW5pZm9ybSBmbG9hdCBpbnZlcnRlZERlcHRoO1xcbicsXG4gICAgICAndW5pZm9ybSBpbnQgY2FtZXJhUGFyYWxsZWw7XFxuJyxcbiAgICAgICd2YXJ5aW5nIGZsb2F0IHJhZGl1c1ZDVlNPdXRwdXQ7XFxuJyxcbiAgICAgICd2YXJ5aW5nIHZlYzMgY2VudGVyVkNWU091dHB1dDtcXG4nLFxuICAgICAgJ3VuaWZvcm0gbWF0NCBWQ1BDTWF0cml4O1xcbicsXG4gICAgXTtcbiAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgIEZTU291cmNlLFxuICAgICAgJy8vVlRLOjpOb3JtYWw6OkRlYycsXG4gICAgICByZXBsYWNlbWVudFxuICAgICkucmVzdWx0O1xuXG4gICAgbGV0IGZyYWdTdHJpbmcgPSAnJztcbiAgICBpZiAobW9kZWwuY29udGV4dC5nZXRFeHRlbnNpb24oJ0VYVF9mcmFnX2RlcHRoJykpIHtcbiAgICAgIGZyYWdTdHJpbmcgPSAnZ2xfRnJhZ0RlcHRoRVhUID0gKHBvcy56IC8gcG9zLncgKyAxLjApIC8gMi4wO1xcbic7XG4gICAgfVxuICAgIGlmIChtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0V2ViZ2wyKCkpIHtcbiAgICAgIGZyYWdTdHJpbmcgPSAnZ2xfRnJhZ0RlcHRoID0gKHBvcy56IC8gcG9zLncgKyAxLjApIC8gMi4wO1xcbic7XG4gICAgfVxuICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKEZTU291cmNlLCAnLy9WVEs6OkRlcHRoOjpJbXBsJywgW1xuICAgICAgLy8gY29tcHV0ZSB0aGUgZXllIHBvc2l0aW9uIGFuZCB1bml0IGRpcmVjdGlvblxuICAgICAgJyAgdmVjMyBFeWVQb3M7XFxuJyxcbiAgICAgICcgIHZlYzMgRXllRGlyO1xcbicsXG4gICAgICAnICBpZiAoY2FtZXJhUGFyYWxsZWwgIT0gMCkge1xcbicsXG4gICAgICAnICAgIEV5ZVBvcyA9IHZlYzModmVydGV4VkMueCwgdmVydGV4VkMueSwgdmVydGV4VkMueiArIDMuMCpyYWRpdXNWQ1ZTT3V0cHV0KTtcXG4nLFxuICAgICAgJyAgICBFeWVEaXIgPSB2ZWMzKDAuMCwwLjAsLTEuMCk7IH1cXG4nLFxuICAgICAgJyAgZWxzZSB7XFxuJyxcbiAgICAgICcgICAgRXllRGlyID0gdmVydGV4VkMueHl6O1xcbicsXG4gICAgICAnICAgIEV5ZVBvcyA9IHZlYzMoMC4wLDAuMCwwLjApO1xcbicsXG4gICAgICAnICAgIGZsb2F0IGxlbmd0aEVEID0gbGVuZ3RoKEV5ZURpcik7XFxuJyxcbiAgICAgICcgICAgRXllRGlyID0gbm9ybWFsaXplKEV5ZURpcik7XFxuJyxcbiAgICAgIC8vIHdlIGFkanVzdCB0aGUgRXllUG9zIHRvIGJlIGNsb3NlciBpZiBpdCBpcyB0b28gZmFyIGF3YXlcbiAgICAgIC8vIHRvIHByZXZlbnQgZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uIG5vaXNlXG4gICAgICAnICAgIGlmIChsZW5ndGhFRCA+IHJhZGl1c1ZDVlNPdXRwdXQqMy4wKSB7XFxuJyxcbiAgICAgICcgICAgICBFeWVQb3MgPSB2ZXJ0ZXhWQy54eXogLSBFeWVEaXIqMy4wKnJhZGl1c1ZDVlNPdXRwdXQ7IH1cXG4nLFxuICAgICAgJyAgICB9XFxuJyxcblxuICAgICAgLy8gdHJhbnNsYXRlIHRvIFNwaGVyZSBjZW50ZXJcbiAgICAgICcgIEV5ZVBvcyA9IEV5ZVBvcyAtIGNlbnRlclZDVlNPdXRwdXQ7XFxuJyxcbiAgICAgIC8vIHNjYWxlIHRvIHJhZGl1cyAxLjBcbiAgICAgICcgIEV5ZVBvcyA9IEV5ZVBvcy9yYWRpdXNWQ1ZTT3V0cHV0O1xcbicsXG4gICAgICAvLyBmaW5kIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAgICcgIGZsb2F0IGIgPSAyLjAqZG90KEV5ZVBvcyxFeWVEaXIpO1xcbicsXG4gICAgICAnICBmbG9hdCBjID0gZG90KEV5ZVBvcyxFeWVQb3MpIC0gMS4wO1xcbicsXG4gICAgICAnICBmbG9hdCBkID0gYipiIC0gNC4wKmM7XFxuJyxcbiAgICAgICcgIHZlYzMgbm9ybWFsVkNWU091dHB1dCA9IHZlYzMoMC4wLDAuMCwxLjApO1xcbicsXG4gICAgICAnICBpZiAoZCA8IDAuMCkgeyBkaXNjYXJkOyB9XFxuJyxcbiAgICAgICcgIGVsc2Uge1xcbicsXG4gICAgICAnICAgIGZsb2F0IHQgPSAoLWIgLSBpbnZlcnRlZERlcHRoKnNxcnQoZCkpKjAuNTtcXG4nLFxuXG4gICAgICAvLyBjb21wdXRlIHRoZSBub3JtYWwsIGZvciB1bml0IHNwaGVyZSB0aGlzIGlzIGp1c3RcbiAgICAgIC8vIHRoZSBpbnRlcnNlY3Rpb24gcG9pbnRcbiAgICAgICcgICAgbm9ybWFsVkNWU091dHB1dCA9IGludmVydGVkRGVwdGgqbm9ybWFsaXplKEV5ZVBvcyArIHQqRXllRGlyKTtcXG4nLFxuICAgICAgLy8gY29tcHV0ZSB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IGluIFZDXG4gICAgICAnICAgIHZlcnRleFZDLnh5eiA9IG5vcm1hbFZDVlNPdXRwdXQqcmFkaXVzVkNWU091dHB1dCArIGNlbnRlclZDVlNPdXRwdXQ7XFxuJyxcbiAgICAgICcgICAgfVxcbicsXG4gICAgICAvLyBjb21wdXRlIHRoZSBwaXhlbCdzIGRlcHRoXG4gICAgICAvLyAnIG5vcm1hbFZDVlNPdXRwdXQgPSB2ZWMzKDAsMCwxKTtcXG4nXG4gICAgICAnICB2ZWM0IHBvcyA9IFZDUENNYXRyaXggKiB2ZXJ0ZXhWQztcXG4nLFxuICAgICAgZnJhZ1N0cmluZyxcbiAgICBdKS5yZXN1bHQ7XG5cbiAgICAvLyBTdHJpcCBvdXQgdGhlIG5vcm1hbCBsaW5lIC0tIHRoZSBub3JtYWwgaXMgY29tcHV0ZWQgYXMgcGFydCBvZiB0aGUgZGVwdGhcbiAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShGU1NvdXJjZSwgJy8vVlRLOjpOb3JtYWw6OkltcGwnLCAnJylcbiAgICAgIC5yZXN1bHQ7XG5cbiAgICBpZiAobW9kZWwuaGF2ZVNlZW5EZXB0aFJlcXVlc3QpIHtcbiAgICAgIC8vIHNwZWNpYWwgZGVwdGggaW1wbFxuICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoRlNTb3VyY2UsICcvL1ZUSzo6WkJ1ZmZlcjo6SW1wbCcsIFtcbiAgICAgICAgJ2lmIChkZXB0aFJlcXVlc3QgPT0gMSkgeycsXG4gICAgICAgICdmbG9hdCBjb21wdXRlZFogPSAocG9zLnogLyBwb3MudyArIDEuMCkgLyAyLjA7JyxcbiAgICAgICAgJ2Zsb2F0IGl6ID0gZmxvb3IoY29tcHV0ZWRaICogNjU1MzUuMCArIDAuMSk7JyxcbiAgICAgICAgJ2Zsb2F0IHJmID0gZmxvb3IoaXovMjU2LjApLzI1NS4wOycsXG4gICAgICAgICdmbG9hdCBnZiA9IG1vZChpeiwyNTYuMCkvMjU1LjA7JyxcbiAgICAgICAgJ2dsX0ZyYWdEYXRhWzBdID0gdmVjNChyZiwgZ2YsIDAuMCwgMS4wKTsgfScsXG4gICAgICBdKS5yZXN1bHQ7XG4gICAgfVxuXG4gICAgc2hhZGVycy5WZXJ0ZXggPSBWU1NvdXJjZTtcbiAgICBzaGFkZXJzLkZyYWdtZW50ID0gRlNTb3VyY2U7XG5cbiAgICBzdXBlckNsYXNzLnJlcGxhY2VTaGFkZXJWYWx1ZXMoc2hhZGVycywgcmVuLCBhY3Rvcik7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldE1hcHBlclNoYWRlclBhcmFtZXRlcnMgPSAoY2VsbEJPLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgaWYgKFxuICAgICAgY2VsbEJPLmdldENBQk8oKS5nZXRFbGVtZW50Q291bnQoKSAmJlxuICAgICAgKG1vZGVsLlZCT0J1aWxkVGltZSA+IGNlbGxCTy5nZXRBdHRyaWJ1dGVVcGRhdGVUaW1lKCkuZ2V0TVRpbWUoKSB8fFxuICAgICAgICBjZWxsQk8uZ2V0U2hhZGVyU291cmNlVGltZSgpLmdldE1UaW1lKCkgPlxuICAgICAgICAgIGNlbGxCTy5nZXRBdHRyaWJ1dGVVcGRhdGVUaW1lKCkuZ2V0TVRpbWUoKSkgJiZcbiAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCkuaXNBdHRyaWJ1dGVVc2VkKCdvZmZzZXRNQycpXG4gICAgKSB7XG4gICAgICBpZiAoXG4gICAgICAgICFjZWxsQk8uZ2V0VkFPKCkuYWRkQXR0cmlidXRlQXJyYXkoXG4gICAgICAgICAgY2VsbEJPLmdldFByb2dyYW0oKSxcbiAgICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLFxuICAgICAgICAgICdvZmZzZXRNQycsXG4gICAgICAgICAgMTIsIC8vIDEyOnRoaXMtPlZCTy0+Q29sb3JPZmZzZXQrc2l6ZW9mKGZsb2F0KVxuICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0U3RyaWRlKCksXG4gICAgICAgICAgbW9kZWwuY29udGV4dC5GTE9BVCxcbiAgICAgICAgICAyLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICB2dGtFcnJvck1hY3JvKFwiRXJyb3Igc2V0dGluZyAnb2Zmc2V0TUMnIGluIHNoYWRlciBWQU8uXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjZWxsQk8uZ2V0UHJvZ3JhbSgpLmlzVW5pZm9ybVVzZWQoJ2ludmVydGVkRGVwdGgnKSkge1xuICAgICAgY2VsbEJPXG4gICAgICAgIC5nZXRQcm9ncmFtKClcbiAgICAgICAgLnNldFVuaWZvcm1mKCdpbnZlcnRlZERlcHRoJywgbW9kZWwuaW52ZXJ0ID8gLTEuMCA6IDEuMCk7XG4gICAgfVxuXG4gICAgc3VwZXJDbGFzcy5zZXRNYXBwZXJTaGFkZXJQYXJhbWV0ZXJzKGNlbGxCTywgcmVuLCBhY3Rvcik7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldENhbWVyYVNoYWRlclBhcmFtZXRlcnMgPSAoY2VsbEJPLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNlbGxCTy5nZXRQcm9ncmFtKCk7XG5cbiAgICBjb25zdCBjYW0gPSByZW4uZ2V0QWN0aXZlQ2FtZXJhKCk7XG4gICAgY29uc3Qga2V5TWF0cyA9IG1vZGVsLm9wZW5HTENhbWVyYS5nZXRLZXlNYXRyaWNlcyhyZW4pO1xuXG4gICAgaWYgKHByb2dyYW0uaXNVbmlmb3JtVXNlZCgnVkNQQ01hdHJpeCcpKSB7XG4gICAgICBwcm9ncmFtLnNldFVuaWZvcm1NYXRyaXgoJ1ZDUENNYXRyaXgnLCBrZXlNYXRzLnZjcGMpO1xuICAgIH1cblxuICAgIGlmIChwcm9ncmFtLmlzVW5pZm9ybVVzZWQoJ01DVkNNYXRyaXgnKSkge1xuICAgICAgaWYgKCFhY3Rvci5nZXRJc0lkZW50aXR5KCkpIHtcbiAgICAgICAgY29uc3QgYWN0TWF0cyA9IG1vZGVsLm9wZW5HTEFjdG9yLmdldEtleU1hdHJpY2VzKCk7XG4gICAgICAgIGNvbnN0IHRtcDQgPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICBtYXQ0Lm11bHRpcGx5KHRtcDQsIGtleU1hdHMud2N2YywgYWN0TWF0cy5tY3djKTtcbiAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtTWF0cml4KCdNQ1ZDTWF0cml4JywgdG1wNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1NYXRyaXgoJ01DVkNNYXRyaXgnLCBrZXlNYXRzLndjdmMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9ncmFtLmlzVW5pZm9ybVVzZWQoJ2NhbWVyYVBhcmFsbGVsJykpIHtcbiAgICAgIGNlbGxCT1xuICAgICAgICAuZ2V0UHJvZ3JhbSgpXG4gICAgICAgIC5zZXRVbmlmb3JtaSgnY2FtZXJhUGFyYWxsZWwnLCBjYW0uZ2V0UGFyYWxsZWxQcm9qZWN0aW9uKCkpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0T3BlbkdMTW9kZSA9IChyZXAsIHR5cGUpID0+IG1vZGVsLmNvbnRleHQuVFJJQU5HTEVTO1xuXG4gIHB1YmxpY0FQSS5idWlsZEJ1ZmZlck9iamVjdHMgPSAocmVuLCBhY3RvcikgPT4ge1xuICAgIGNvbnN0IHBvbHkgPSBtb2RlbC5jdXJyZW50SW5wdXQ7XG5cbiAgICBpZiAocG9seSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1vZGVsLnJlbmRlcmFibGUubWFwU2NhbGFycyhwb2x5LCAxLjApO1xuICAgIGNvbnN0IGMgPSBtb2RlbC5yZW5kZXJhYmxlLmdldENvbG9yTWFwQ29sb3JzKCk7XG5cbiAgICBjb25zdCB2Ym8gPSBtb2RlbC5wcmltaXRpdmVzW21vZGVsLnByaW1UeXBlcy5UcmlzXS5nZXRDQUJPKCk7XG5cbiAgICBjb25zdCBwb2ludERhdGEgPSBwb2x5LmdldFBvaW50RGF0YSgpO1xuICAgIGNvbnN0IHBvaW50cyA9IHBvbHkuZ2V0UG9pbnRzKCk7XG4gICAgY29uc3QgbnVtUG9pbnRzID0gcG9pbnRzLmdldE51bWJlck9mUG9pbnRzKCk7XG4gICAgY29uc3QgcG9pbnRBcnJheSA9IHBvaW50cy5nZXREYXRhKCk7XG5cbiAgICBjb25zdCBwb2ludFNpemUgPSA1OyAvLyB4LHkseixvcmllbnRhdGlvbjEsb3JpZW50YXRpb24yXG4gICAgbGV0IHNjYWxlcyA9IG51bGw7XG5cbiAgICBpZiAoXG4gICAgICBtb2RlbC5yZW5kZXJhYmxlLmdldFNjYWxlQXJyYXkoKSAhPSBudWxsICYmXG4gICAgICBwb2ludERhdGEuaGFzQXJyYXkobW9kZWwucmVuZGVyYWJsZS5nZXRTY2FsZUFycmF5KCkpXG4gICAgKSB7XG4gICAgICBzY2FsZXMgPSBwb2ludERhdGEuZ2V0QXJyYXkobW9kZWwucmVuZGVyYWJsZS5nZXRTY2FsZUFycmF5KCkpLmdldERhdGEoKTtcbiAgICB9XG5cbiAgICBsZXQgY29sb3JEYXRhID0gbnVsbDtcbiAgICBsZXQgY29sb3JDb21wb25lbnRzID0gMDtcbiAgICBsZXQgcGFja2VkVUNWQk8gPSBudWxsO1xuICAgIGlmIChjKSB7XG4gICAgICBjb2xvckNvbXBvbmVudHMgPSBjLmdldE51bWJlck9mQ29tcG9uZW50cygpO1xuICAgICAgdmJvLnNldENvbG9yT2Zmc2V0KDApO1xuICAgICAgdmJvLnNldENvbG9yQk9TdHJpZGUoNCk7XG4gICAgICBjb2xvckRhdGEgPSBjLmdldERhdGEoKTtcbiAgICAgIHBhY2tlZFVDVkJPID0gbmV3IFVpbnQ4QXJyYXkoMyAqIG51bVBvaW50cyAqIDQpO1xuICAgICAgaWYgKCF2Ym8uZ2V0Q29sb3JCTygpKSB7XG4gICAgICAgIHZiby5zZXRDb2xvckJPKHZ0a0J1ZmZlck9iamVjdC5uZXdJbnN0YW5jZSgpKTtcbiAgICAgIH1cbiAgICAgIHZiby5nZXRDb2xvckJPKCkuc2V0T3BlbkdMUmVuZGVyV2luZG93KG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyk7XG4gICAgfSBlbHNlIGlmICh2Ym8uZ2V0Q29sb3JCTygpKSB7XG4gICAgICB2Ym8uc2V0Q29sb3JCTyhudWxsKTtcbiAgICB9XG4gICAgdmJvLnNldENvbG9yQ29tcG9uZW50cyhjb2xvckNvbXBvbmVudHMpO1xuXG4gICAgY29uc3QgcGFja2VkVkJPID0gbmV3IEZsb2F0MzJBcnJheShwb2ludFNpemUgKiBudW1Qb2ludHMgKiAzKTtcblxuICAgIHZiby5zZXRTdHJpZGUocG9pbnRTaXplICogNCk7XG5cbiAgICBjb25zdCBjb3MzMCA9IE1hdGguY29zKHZ0a01hdGgucmFkaWFuc0Zyb21EZWdyZWVzKDMwLjApKTtcbiAgICBsZXQgcG9pbnRJZHggPSAwO1xuICAgIGxldCBjb2xvcklkeCA9IDA7XG5cbiAgICAvL1xuICAgIC8vIEdlbmVyYXRlIHBvaW50cyBhbmQgcG9pbnQgZGF0YSBmb3Igc2lkZXNcbiAgICAvL1xuICAgIGxldCB2Ym9JZHggPSAwO1xuICAgIGxldCB1Y0lkeCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Qb2ludHM7ICsraSkge1xuICAgICAgbGV0IHJhZGl1cyA9IG1vZGVsLnJlbmRlcmFibGUuZ2V0UmFkaXVzKCk7XG4gICAgICBpZiAoc2NhbGVzKSB7XG4gICAgICAgIHJhZGl1cyA9IHNjYWxlc1tpXTtcbiAgICAgIH1cblxuICAgICAgcG9pbnRJZHggPSBpICogMztcbiAgICAgIHBhY2tlZFZCT1t2Ym9JZHgrK10gPSBwb2ludEFycmF5W3BvaW50SWR4KytdO1xuICAgICAgcGFja2VkVkJPW3Zib0lkeCsrXSA9IHBvaW50QXJyYXlbcG9pbnRJZHgrK107XG4gICAgICBwYWNrZWRWQk9bdmJvSWR4KytdID0gcG9pbnRBcnJheVtwb2ludElkeCsrXTtcbiAgICAgIHBhY2tlZFZCT1t2Ym9JZHgrK10gPSAtMi4wICogcmFkaXVzICogY29zMzA7XG4gICAgICBwYWNrZWRWQk9bdmJvSWR4KytdID0gLXJhZGl1cztcbiAgICAgIGlmIChjb2xvckRhdGEpIHtcbiAgICAgICAgY29sb3JJZHggPSBpICogY29sb3JDb21wb25lbnRzO1xuICAgICAgICBwYWNrZWRVQ1ZCT1t1Y0lkeCsrXSA9IGNvbG9yRGF0YVtjb2xvcklkeF07XG4gICAgICAgIHBhY2tlZFVDVkJPW3VjSWR4KytdID0gY29sb3JEYXRhW2NvbG9ySWR4ICsgMV07XG4gICAgICAgIHBhY2tlZFVDVkJPW3VjSWR4KytdID0gY29sb3JEYXRhW2NvbG9ySWR4ICsgMl07XG4gICAgICAgIHBhY2tlZFVDVkJPW3VjSWR4KytdID0gY29sb3JEYXRhW2NvbG9ySWR4ICsgM107XG4gICAgICB9XG5cbiAgICAgIHBvaW50SWR4ID0gaSAqIDM7XG4gICAgICBwYWNrZWRWQk9bdmJvSWR4KytdID0gcG9pbnRBcnJheVtwb2ludElkeCsrXTtcbiAgICAgIHBhY2tlZFZCT1t2Ym9JZHgrK10gPSBwb2ludEFycmF5W3BvaW50SWR4KytdO1xuICAgICAgcGFja2VkVkJPW3Zib0lkeCsrXSA9IHBvaW50QXJyYXlbcG9pbnRJZHgrK107XG4gICAgICBwYWNrZWRWQk9bdmJvSWR4KytdID0gMi4wICogcmFkaXVzICogY29zMzA7XG4gICAgICBwYWNrZWRWQk9bdmJvSWR4KytdID0gLXJhZGl1cztcbiAgICAgIGlmIChjb2xvckRhdGEpIHtcbiAgICAgICAgcGFja2VkVUNWQk9bdWNJZHgrK10gPSBjb2xvckRhdGFbY29sb3JJZHhdO1xuICAgICAgICBwYWNrZWRVQ1ZCT1t1Y0lkeCsrXSA9IGNvbG9yRGF0YVtjb2xvcklkeCArIDFdO1xuICAgICAgICBwYWNrZWRVQ1ZCT1t1Y0lkeCsrXSA9IGNvbG9yRGF0YVtjb2xvcklkeCArIDJdO1xuICAgICAgICBwYWNrZWRVQ1ZCT1t1Y0lkeCsrXSA9IGNvbG9yRGF0YVtjb2xvcklkeCArIDNdO1xuICAgICAgfVxuXG4gICAgICBwb2ludElkeCA9IGkgKiAzO1xuICAgICAgcGFja2VkVkJPW3Zib0lkeCsrXSA9IHBvaW50QXJyYXlbcG9pbnRJZHgrK107XG4gICAgICBwYWNrZWRWQk9bdmJvSWR4KytdID0gcG9pbnRBcnJheVtwb2ludElkeCsrXTtcbiAgICAgIHBhY2tlZFZCT1t2Ym9JZHgrK10gPSBwb2ludEFycmF5W3BvaW50SWR4KytdO1xuICAgICAgcGFja2VkVkJPW3Zib0lkeCsrXSA9IDAuMDtcbiAgICAgIHBhY2tlZFZCT1t2Ym9JZHgrK10gPSAyLjAgKiByYWRpdXM7XG4gICAgICBpZiAoY29sb3JEYXRhKSB7XG4gICAgICAgIHBhY2tlZFVDVkJPW3VjSWR4KytdID0gY29sb3JEYXRhW2NvbG9ySWR4XTtcbiAgICAgICAgcGFja2VkVUNWQk9bdWNJZHgrK10gPSBjb2xvckRhdGFbY29sb3JJZHggKyAxXTtcbiAgICAgICAgcGFja2VkVUNWQk9bdWNJZHgrK10gPSBjb2xvckRhdGFbY29sb3JJZHggKyAyXTtcbiAgICAgICAgcGFja2VkVUNWQk9bdWNJZHgrK10gPSBjb2xvckRhdGFbY29sb3JJZHggKyAzXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2Ym8uc2V0RWxlbWVudENvdW50KHZib0lkeCAvIHBvaW50U2l6ZSk7XG4gICAgdmJvLnVwbG9hZChwYWNrZWRWQk8sIE9iamVjdFR5cGUuQVJSQVlfQlVGRkVSKTtcbiAgICBpZiAoYykge1xuICAgICAgdmJvLmdldENvbG9yQk8oKS51cGxvYWQocGFja2VkVUNWQk8sIE9iamVjdFR5cGUuQVJSQVlfQlVGRkVSKTtcbiAgICB9XG5cbiAgICBtb2RlbC5WQk9CdWlsZFRpbWUubW9kaWZpZWQoKTtcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7fTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gSW5oZXJpdGFuY2VcbiAgdnRrT3BlbkdMUG9seURhdGFNYXBwZXIuZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIHZ0a09wZW5HTFNwaGVyZU1hcHBlcihwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQsICd2dGtPcGVuR0xTcGhlcmVNYXBwZXInKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImltcG9ydCB7IG1hdDMsIG1hdDQgfSBmcm9tICdnbC1tYXRyaXgnO1xuaW1wb3J0IHsgT2JqZWN0VHlwZSB9IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvQnVmZmVyT2JqZWN0L0NvbnN0YW50cyc7XG5cbmltcG9ydCAqIGFzIG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcblxuaW1wb3J0IHZ0a0J1ZmZlck9iamVjdCBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML0J1ZmZlck9iamVjdCc7XG5pbXBvcnQgdnRrU3RpY2tNYXBwZXJWUyBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML2dsc2wvdnRrU3RpY2tNYXBwZXJWUy5nbHNsJztcbmltcG9ydCB2dGtQb2x5RGF0YUZTIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvZ2xzbC92dGtQb2x5RGF0YUZTLmdsc2wnO1xuXG5pbXBvcnQgdnRrU2hhZGVyUHJvZ3JhbSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1NoYWRlclByb2dyYW0nO1xuaW1wb3J0IHZ0a09wZW5HTFBvbHlEYXRhTWFwcGVyIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvUG9seURhdGFNYXBwZXInO1xuXG5jb25zdCB7IHZ0a0Vycm9yTWFjcm8gfSA9IG1hY3JvO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtPcGVuR0xTdGlja01hcHBlciBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a09wZW5HTFN0aWNrTWFwcGVyKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrT3BlbkdMU3RpY2tNYXBwZXInKTtcblxuICAvLyBDYXB0dXJlICdwYXJlbnRDbGFzcycgYXBpIGZvciBpbnRlcm5hbCB1c2VcbiAgY29uc3Qgc3VwZXJDbGFzcyA9IHsgLi4ucHVibGljQVBJIH07XG5cbiAgcHVibGljQVBJLmdldFNoYWRlclRlbXBsYXRlID0gKHNoYWRlcnMsIHJlbiwgYWN0b3IpID0+IHtcbiAgICBzaGFkZXJzLlZlcnRleCA9IHZ0a1N0aWNrTWFwcGVyVlM7XG4gICAgc2hhZGVycy5GcmFnbWVudCA9IHZ0a1BvbHlEYXRhRlM7XG4gICAgc2hhZGVycy5HZW9tZXRyeSA9ICcnO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZXBsYWNlU2hhZGVyVmFsdWVzID0gKHNoYWRlcnMsIHJlbiwgYWN0b3IpID0+IHtcbiAgICBsZXQgVlNTb3VyY2UgPSBzaGFkZXJzLlZlcnRleDtcbiAgICBsZXQgRlNTb3VyY2UgPSBzaGFkZXJzLkZyYWdtZW50O1xuXG4gICAgVlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoVlNTb3VyY2UsICcvL1ZUSzo6Q2FtZXJhOjpEZWMnLCBbXG4gICAgICAndW5pZm9ybSBtYXQ0IFZDUENNYXRyaXg7XFxuJyxcbiAgICAgICd1bmlmb3JtIG1hdDQgTUNWQ01hdHJpeDsnLFxuICAgIF0pLnJlc3VsdDtcblxuICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgRlNTb3VyY2UsXG4gICAgICAnLy9WVEs6OlBvc2l0aW9uVkM6OkRlYycsXG4gICAgICAndmFyeWluZyB2ZWM0IHZlcnRleFZDVlNPdXRwdXQ7J1xuICAgICkucmVzdWx0O1xuXG4gICAgLy8gd2UgY3JlYXRlIHZlcnRleFZDIGJlbG93LCBzbyB0dXJuIG9mZiB0aGUgZGVmYXVsdFxuICAgIC8vIGltcGxlbWVudGF0aW9uXG4gICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICBGU1NvdXJjZSxcbiAgICAgICcvL1ZUSzo6UG9zaXRpb25WQzo6SW1wbCcsXG4gICAgICAnICB2ZWM0IHZlcnRleFZDID0gdmVydGV4VkNWU091dHB1dDtcXG4nXG4gICAgKS5yZXN1bHQ7XG5cbiAgICAvLyBmb3IgbGlnaHRzIGtpdCBhbmQgcG9zaXRpb25hbCB0aGUgVkNQQyBtYXRyaXggaXMgYWxyZWFkeSBkZWZpbmVkXG4gICAgLy8gc28gZG9uJ3QgcmVkZWZpbmUgaXRcbiAgICBjb25zdCByZXBsYWNlbWVudCA9IFtcbiAgICAgICd1bmlmb3JtIGludCBjYW1lcmFQYXJhbGxlbDtcXG4nLFxuICAgICAgJ3ZhcnlpbmcgZmxvYXQgcmFkaXVzVkNWU091dHB1dDtcXG4nLFxuICAgICAgJ3ZhcnlpbmcgdmVjMyBvcmllbnRWQ1ZTT3V0cHV0O1xcbicsXG4gICAgICAndmFyeWluZyBmbG9hdCBsZW5ndGhWQ1ZTT3V0cHV0O1xcbicsXG4gICAgICAndmFyeWluZyB2ZWMzIGNlbnRlclZDVlNPdXRwdXQ7XFxuJyxcbiAgICAgICd1bmlmb3JtIG1hdDQgVkNQQ01hdHJpeDtcXG4nLFxuICAgIF07XG4gICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICBGU1NvdXJjZSxcbiAgICAgICcvL1ZUSzo6Tm9ybWFsOjpEZWMnLFxuICAgICAgcmVwbGFjZW1lbnRcbiAgICApLnJlc3VsdDtcblxuICAgIGxldCBmcmFnU3RyaW5nID0gJyc7XG4gICAgaWYgKG1vZGVsLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdFWFRfZnJhZ19kZXB0aCcpKSB7XG4gICAgICBmcmFnU3RyaW5nID0gJyAgZ2xfRnJhZ0RlcHRoRVhUID0gKHBvcy56IC8gcG9zLncgKyAxLjApIC8gMi4wO1xcbic7XG4gICAgfVxuICAgIGlmIChtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0V2ViZ2wyKCkpIHtcbiAgICAgIGZyYWdTdHJpbmcgPSAnZ2xfRnJhZ0RlcHRoID0gKHBvcy56IC8gcG9zLncgKyAxLjApIC8gMi4wO1xcbic7XG4gICAgfVxuICAgIC8vIHNlZSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvdGVhY2hpbmcvMTk5OS9BR3JhcGhIQ0kvU01BRy9ub2RlMi5odG1sXG4gICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoRlNTb3VyY2UsICcvL1ZUSzo6RGVwdGg6OkltcGwnLCBbXG4gICAgICAvLyBjb21wdXRlIHRoZSBleWUgcG9zaXRpb24gYW5kIHVuaXQgZGlyZWN0aW9uXG4gICAgICAnICB2ZWMzIEV5ZVBvcztcXG4nLFxuICAgICAgJyAgdmVjMyBFeWVEaXI7XFxuJyxcbiAgICAgICcgIGlmIChjYW1lcmFQYXJhbGxlbCAhPSAwKSB7XFxuJyxcbiAgICAgICcgICAgRXllUG9zID0gdmVjMyh2ZXJ0ZXhWQy54LCB2ZXJ0ZXhWQy55LCB2ZXJ0ZXhWQy56ICsgMy4wKnJhZGl1c1ZDVlNPdXRwdXQpO1xcbicsXG4gICAgICAnICAgIEV5ZURpciA9IHZlYzMoMC4wLDAuMCwtMS4wKTsgfVxcbicsXG4gICAgICAnICBlbHNlIHtcXG4nLFxuICAgICAgJyAgICBFeWVEaXIgPSB2ZXJ0ZXhWQy54eXo7XFxuJyxcbiAgICAgICcgICAgRXllUG9zID0gdmVjMygwLjAsMC4wLDAuMCk7XFxuJyxcbiAgICAgICcgICAgZmxvYXQgbGVuZ3RoRUQgPSBsZW5ndGgoRXllRGlyKTtcXG4nLFxuICAgICAgJyAgICBFeWVEaXIgPSBub3JtYWxpemUoRXllRGlyKTtcXG4nLFxuICAgICAgLy8gd2UgYWRqdXN0IHRoZSBFeWVQb3MgdG8gYmUgY2xvc2VyIGlmIGl0IGlzIHRvbyBmYXIgYXdheVxuICAgICAgLy8gdG8gcHJldmVudCBmbG9hdGluZyBwb2ludCBwcmVjaXNpb24gbm9pc2VcbiAgICAgICcgICAgaWYgKGxlbmd0aEVEID4gcmFkaXVzVkNWU091dHB1dCozLjApIHtcXG4nLFxuICAgICAgJyAgICAgIEV5ZVBvcyA9IHZlcnRleFZDLnh5eiAtIEV5ZURpciozLjAqcmFkaXVzVkNWU091dHB1dDsgfVxcbicsXG4gICAgICAnICAgIH1cXG4nLFxuXG4gICAgICAvLyB0cmFuc2xhdGUgdG8gU3RpY2sgY2VudGVyXG4gICAgICAnICBFeWVQb3MgPSBFeWVQb3MgLSBjZW50ZXJWQ1ZTT3V0cHV0O1xcbicsXG5cbiAgICAgIC8vIHJvdGF0ZSB0byBuZXcgYmFzaXNcbiAgICAgIC8vIGJhc2UxLCBiYXNlMiwgb3JpZW50VkNcbiAgICAgICcgIHZlYzMgYmFzZTE7XFxuJyxcbiAgICAgICcgIGlmIChhYnMob3JpZW50VkNWU091dHB1dC56KSA8IDAuOTkpIHtcXG4nLFxuICAgICAgJyAgICBiYXNlMSA9IG5vcm1hbGl6ZShjcm9zcyhvcmllbnRWQ1ZTT3V0cHV0LHZlYzMoMC4wLDAuMCwxLjApKSk7IH1cXG4nLFxuICAgICAgJyAgZWxzZSB7XFxuJyxcbiAgICAgICcgICAgYmFzZTEgPSBub3JtYWxpemUoY3Jvc3Mob3JpZW50VkNWU091dHB1dCx2ZWMzKDAuMCwxLjAsMC4wKSkpOyB9XFxuJyxcbiAgICAgICcgIHZlYzMgYmFzZTIgPSBjcm9zcyhvcmllbnRWQ1ZTT3V0cHV0LGJhc2UxKTtcXG4nLFxuICAgICAgJyAgRXllUG9zID0gdmVjMyhkb3QoRXllUG9zLGJhc2UxKSxkb3QoRXllUG9zLGJhc2UyKSxkb3QoRXllUG9zLG9yaWVudFZDVlNPdXRwdXQpKTtcXG4nLFxuICAgICAgJyAgRXllRGlyID0gdmVjMyhkb3QoRXllRGlyLGJhc2UxKSxkb3QoRXllRGlyLGJhc2UyKSxkb3QoRXllRGlyLG9yaWVudFZDVlNPdXRwdXQpKTtcXG4nLFxuXG4gICAgICAvLyBzY2FsZSBieSByYWRpdXNcbiAgICAgICcgIEV5ZVBvcyA9IEV5ZVBvcy9yYWRpdXNWQ1ZTT3V0cHV0O1xcbicsXG5cbiAgICAgIC8vIGZpbmQgdGhlIGludGVyc2VjdGlvblxuICAgICAgJyAgZmxvYXQgYSA9IEV5ZURpci54KkV5ZURpci54ICsgRXllRGlyLnkqRXllRGlyLnk7XFxuJyxcbiAgICAgICcgIGZsb2F0IGIgPSAyLjAqKEV5ZVBvcy54KkV5ZURpci54ICsgRXllUG9zLnkqRXllRGlyLnkpO1xcbicsXG4gICAgICAnICBmbG9hdCBjID0gRXllUG9zLngqRXllUG9zLnggKyBFeWVQb3MueSpFeWVQb3MueSAtIDEuMDtcXG4nLFxuICAgICAgJyAgZmxvYXQgZCA9IGIqYiAtIDQuMCphKmM7XFxuJyxcbiAgICAgICcgIHZlYzMgbm9ybWFsVkNWU091dHB1dCA9IHZlYzMoMC4wLDAuMCwxLjApO1xcbicsXG4gICAgICAnICBpZiAoZCA8IDAuMCkgeyBkaXNjYXJkOyB9XFxuJyxcbiAgICAgICcgIGVsc2Uge1xcbicsXG4gICAgICAnICAgIGZsb2F0IHQgPSAgKC1iIC0gc3FydChkKSkvKDIuMCphKTtcXG4nLFxuICAgICAgJyAgICBmbG9hdCB0eiA9IEV5ZVBvcy56ICsgdCpFeWVEaXIuejtcXG4nLFxuICAgICAgJyAgICB2ZWMzIGlQb2ludCA9IEV5ZVBvcyArIHQqRXllRGlyO1xcbicsXG4gICAgICAnICAgIGlmIChhYnMoaVBvaW50LnopKnJhZGl1c1ZDVlNPdXRwdXQgPiBsZW5ndGhWQ1ZTT3V0cHV0KjAuNSkge1xcbicsXG4gICAgICAvLyB0ZXN0IGZvciBlbmQgY2FwXG4gICAgICAnICAgICAgZmxvYXQgdDIgPSAoLWIgKyBzcXJ0KGQpKS8oMi4wKmEpO1xcbicsXG4gICAgICAnICAgICAgZmxvYXQgdHoyID0gRXllUG9zLnogKyB0MipFeWVEaXIuejtcXG4nLFxuICAgICAgJyAgICAgIGlmICh0ejIqcmFkaXVzVkNWU091dHB1dCA+IGxlbmd0aFZDVlNPdXRwdXQqMC41IHx8IHR6KnJhZGl1c1ZDVlNPdXRwdXQgPCAtMC41Kmxlbmd0aFZDVlNPdXRwdXQpIHsgZGlzY2FyZDsgfVxcbicsXG4gICAgICAnICAgICAgZWxzZSB7XFxuJyxcbiAgICAgICcgICAgICAgIG5vcm1hbFZDVlNPdXRwdXQgPSBvcmllbnRWQ1ZTT3V0cHV0O1xcbicsXG4gICAgICAnICAgICAgICBmbG9hdCB0MyA9IChsZW5ndGhWQ1ZTT3V0cHV0KjAuNS9yYWRpdXNWQ1ZTT3V0cHV0IC0gRXllUG9zLnopL0V5ZURpci56O1xcbicsXG4gICAgICAnICAgICAgICBpUG9pbnQgPSBFeWVQb3MgKyB0MypFeWVEaXI7XFxuJyxcbiAgICAgICcgICAgICAgIHZlcnRleFZDLnh5eiA9IHJhZGl1c1ZDVlNPdXRwdXQqKGlQb2ludC54KmJhc2UxICsgaVBvaW50LnkqYmFzZTIgKyBpUG9pbnQueipvcmllbnRWQ1ZTT3V0cHV0KSArIGNlbnRlclZDVlNPdXRwdXQ7XFxuJyxcbiAgICAgICcgICAgICAgIH1cXG4nLFxuICAgICAgJyAgICAgIH1cXG4nLFxuICAgICAgJyAgICBlbHNlIHtcXG4nLFxuICAgICAgLy8gVGhlIG5vcm1hbCBpcyB0aGUgaVBvaW50Lnh5IHJvdGF0ZWQgYmFjayBpbnRvIFZDXG4gICAgICAnICAgICAgbm9ybWFsVkNWU091dHB1dCA9IGlQb2ludC54KmJhc2UxICsgaVBvaW50LnkqYmFzZTI7XFxuJyxcbiAgICAgIC8vIHJlc2NhbGUgcmVyb3RhdGUgYW5kIHRyYW5zbGF0ZVxuICAgICAgJyAgICAgIHZlcnRleFZDLnh5eiA9IHJhZGl1c1ZDVlNPdXRwdXQqKG5vcm1hbFZDVlNPdXRwdXQgKyBpUG9pbnQueipvcmllbnRWQ1ZTT3V0cHV0KSArIGNlbnRlclZDVlNPdXRwdXQ7XFxuJyxcbiAgICAgICcgICAgICB9XFxuJyxcbiAgICAgICcgICAgfVxcbicsXG5cbiAgICAgIC8vICAgICcgIHZlYzMgbm9ybWFsVkMgPSB2ZWMzKDAuMCwwLjAsMS4wKTtcXG4nXG4gICAgICAvLyBjb21wdXRlIHRoZSBwaXhlbCdzIGRlcHRoXG4gICAgICAnICB2ZWM0IHBvcyA9IFZDUENNYXRyaXggKiB2ZXJ0ZXhWQztcXG4nLFxuICAgICAgZnJhZ1N0cmluZyxcbiAgICBdKS5yZXN1bHQ7XG5cbiAgICAvLyBTdHJpcCBvdXQgdGhlIG5vcm1hbCBsaW5lIC0tIHRoZSBub3JtYWwgaXMgY29tcHV0ZWQgYXMgcGFydCBvZiB0aGUgZGVwdGhcbiAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShGU1NvdXJjZSwgJy8vVlRLOjpOb3JtYWw6OkltcGwnLCAnJylcbiAgICAgIC5yZXN1bHQ7XG5cbiAgICBpZiAobW9kZWwuaGF2ZVNlZW5EZXB0aFJlcXVlc3QpIHtcbiAgICAgIC8vIHNwZWNpYWwgZGVwdGggaW1wbFxuICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoRlNTb3VyY2UsICcvL1ZUSzo6WkJ1ZmZlcjo6SW1wbCcsIFtcbiAgICAgICAgJ2lmIChkZXB0aFJlcXVlc3QgPT0gMSkgeycsXG4gICAgICAgICdmbG9hdCBjb21wdXRlZFogPSAocG9zLnogLyBwb3MudyArIDEuMCkgLyAyLjA7JyxcbiAgICAgICAgJ2Zsb2F0IGl6ID0gZmxvb3IoY29tcHV0ZWRaICogNjU1MzUuMCArIDAuMSk7JyxcbiAgICAgICAgJ2Zsb2F0IHJmID0gZmxvb3IoaXovMjU2LjApLzI1NS4wOycsXG4gICAgICAgICdmbG9hdCBnZiA9IG1vZChpeiwyNTYuMCkvMjU1LjA7JyxcbiAgICAgICAgJ2dsX0ZyYWdEYXRhWzBdID0gdmVjNChyZiwgZ2YsIDAuMCwgMS4wKTsgfScsXG4gICAgICBdKS5yZXN1bHQ7XG4gICAgfVxuXG4gICAgc2hhZGVycy5WZXJ0ZXggPSBWU1NvdXJjZTtcbiAgICBzaGFkZXJzLkZyYWdtZW50ID0gRlNTb3VyY2U7XG5cbiAgICBzdXBlckNsYXNzLnJlcGxhY2VTaGFkZXJWYWx1ZXMoc2hhZGVycywgcmVuLCBhY3Rvcik7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldE1hcHBlclNoYWRlclBhcmFtZXRlcnMgPSAoY2VsbEJPLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgaWYgKFxuICAgICAgY2VsbEJPLmdldENBQk8oKS5nZXRFbGVtZW50Q291bnQoKSAmJlxuICAgICAgKG1vZGVsLlZCT0J1aWxkVGltZSA+IGNlbGxCTy5nZXRBdHRyaWJ1dGVVcGRhdGVUaW1lKCkuZ2V0TVRpbWUoKSB8fFxuICAgICAgICBjZWxsQk8uZ2V0U2hhZGVyU291cmNlVGltZSgpLmdldE1UaW1lKCkgPlxuICAgICAgICAgIGNlbGxCTy5nZXRBdHRyaWJ1dGVVcGRhdGVUaW1lKCkuZ2V0TVRpbWUoKSlcbiAgICApIHtcbiAgICAgIGlmIChjZWxsQk8uZ2V0UHJvZ3JhbSgpLmlzQXR0cmlidXRlVXNlZCgnb3JpZW50TUMnKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWNlbGxCTy5nZXRWQU8oKS5hZGRBdHRyaWJ1dGVBcnJheShcbiAgICAgICAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCksXG4gICAgICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLFxuICAgICAgICAgICAgJ29yaWVudE1DJyxcbiAgICAgICAgICAgIDEyLCAvLyBhZnRlciBYIFkgWlxuICAgICAgICAgICAgY2VsbEJPLmdldENBQk8oKS5nZXRTdHJpZGUoKSxcbiAgICAgICAgICAgIG1vZGVsLmNvbnRleHQuRkxPQVQsXG4gICAgICAgICAgICAzLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIHZ0a0Vycm9yTWFjcm8oXCJFcnJvciBzZXR0aW5nICdvcmllbnRNQycgaW4gc2hhZGVyIFZBTy5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjZWxsQk8uZ2V0UHJvZ3JhbSgpLmlzQXR0cmlidXRlVXNlZCgnb2Zmc2V0TUMnKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWNlbGxCT1xuICAgICAgICAgICAgLmdldFZBTygpXG4gICAgICAgICAgICAuYWRkQXR0cmlidXRlQXJyYXkoXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCksXG4gICAgICAgICAgICAgIGNlbGxCTy5nZXRDQUJPKCkuZ2V0Q29sb3JCTygpLFxuICAgICAgICAgICAgICAnb2Zmc2V0TUMnLFxuICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLmdldENvbG9yQk9TdHJpZGUoKSxcbiAgICAgICAgICAgICAgbW9kZWwuY29udGV4dC5VTlNJR05FRF9CWVRFLFxuICAgICAgICAgICAgICAzLFxuICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIHZ0a0Vycm9yTWFjcm8oXCJFcnJvciBzZXR0aW5nICdvZmZzZXRNQycgaW4gc2hhZGVyIFZBTy5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjZWxsQk8uZ2V0UHJvZ3JhbSgpLmlzQXR0cmlidXRlVXNlZCgncmFkaXVzTUMnKSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIWNlbGxCTy5nZXRWQU8oKS5hZGRBdHRyaWJ1dGVBcnJheShcbiAgICAgICAgICAgIGNlbGxCTy5nZXRQcm9ncmFtKCksXG4gICAgICAgICAgICBjZWxsQk8uZ2V0Q0FCTygpLFxuICAgICAgICAgICAgJ3JhZGl1c01DJyxcbiAgICAgICAgICAgIDI0LCAvLyBYIFkgWiBPWCBPWSBPWlxuICAgICAgICAgICAgY2VsbEJPLmdldENBQk8oKS5nZXRTdHJpZGUoKSxcbiAgICAgICAgICAgIG1vZGVsLmNvbnRleHQuRkxPQVQsXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIHZ0a0Vycm9yTWFjcm8oXCJFcnJvciBzZXR0aW5nICdyYWRpdXNNQycgaW4gc2hhZGVyIFZBTy5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdXBlckNsYXNzLnNldE1hcHBlclNoYWRlclBhcmFtZXRlcnMoY2VsbEJPLCByZW4sIGFjdG9yKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0Q2FtZXJhU2hhZGVyUGFyYW1ldGVycyA9IChjZWxsQk8sIHJlbiwgYWN0b3IpID0+IHtcbiAgICBjb25zdCBwcm9ncmFtID0gY2VsbEJPLmdldFByb2dyYW0oKTtcblxuICAgIGNvbnN0IGNhbSA9IHJlbi5nZXRBY3RpdmVDYW1lcmEoKTtcbiAgICBjb25zdCBrZXlNYXRzID0gbW9kZWwub3BlbkdMQ2FtZXJhLmdldEtleU1hdHJpY2VzKHJlbik7XG5cbiAgICBpZiAocHJvZ3JhbS5pc1VuaWZvcm1Vc2VkKCdWQ1BDTWF0cml4JykpIHtcbiAgICAgIHByb2dyYW0uc2V0VW5pZm9ybU1hdHJpeCgnVkNQQ01hdHJpeCcsIGtleU1hdHMudmNwYyk7XG4gICAgfVxuXG4gICAgaWYgKCFhY3Rvci5nZXRJc0lkZW50aXR5KCkpIHtcbiAgICAgIGNvbnN0IGFjdE1hdHMgPSBtb2RlbC5vcGVuR0xBY3Rvci5nZXRLZXlNYXRyaWNlcygpO1xuICAgICAgY29uc3QgdG1wNCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgICAgIGlmIChwcm9ncmFtLmlzVW5pZm9ybVVzZWQoJ01DVkNNYXRyaXgnKSkge1xuICAgICAgICBtYXQ0Lm11bHRpcGx5KHRtcDQsIGtleU1hdHMud2N2YywgYWN0TWF0cy5tY3djKTtcbiAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtTWF0cml4KCdNQ1ZDTWF0cml4JywgdG1wNCk7XG4gICAgICB9XG4gICAgICBpZiAocHJvZ3JhbS5pc1VuaWZvcm1Vc2VkKCdub3JtYWxNYXRyaXgnKSkge1xuICAgICAgICBjb25zdCBhbm9ybXMgPSBtYXQzLmNyZWF0ZSgpO1xuICAgICAgICBtYXQzLm11bHRpcGx5KGFub3Jtcywga2V5TWF0cy5ub3JtYWxNYXRyaXgsIGFjdE1hdHMubm9ybWFsTWF0cml4KTtcbiAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtTWF0cml4M3gzKCdub3JtYWxNYXRyaXgnLCBhbm9ybXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvZ3JhbS5pc1VuaWZvcm1Vc2VkKCdNQ1ZDTWF0cml4JykpIHtcbiAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtTWF0cml4KCdNQ1ZDTWF0cml4Jywga2V5TWF0cy53Y3ZjKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9ncmFtLmlzVW5pZm9ybVVzZWQoJ25vcm1hbE1hdHJpeCcpKSB7XG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybU1hdHJpeDN4Mygnbm9ybWFsTWF0cml4Jywga2V5TWF0cy5ub3JtYWxNYXRyaXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm9ncmFtLmlzVW5pZm9ybVVzZWQoJ2NhbWVyYVBhcmFsbGVsJykpIHtcbiAgICAgIGNlbGxCT1xuICAgICAgICAuZ2V0UHJvZ3JhbSgpXG4gICAgICAgIC5zZXRVbmlmb3JtaSgnY2FtZXJhUGFyYWxsZWwnLCBjYW0uZ2V0UGFyYWxsZWxQcm9qZWN0aW9uKCkpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0T3BlbkdMTW9kZSA9IChyZXAsIHR5cGUpID0+IG1vZGVsLmNvbnRleHQuVFJJQU5HTEVTO1xuXG4gIHB1YmxpY0FQSS5idWlsZEJ1ZmZlck9iamVjdHMgPSAocmVuLCBhY3RvcikgPT4ge1xuICAgIGNvbnN0IHBvbHkgPSBtb2RlbC5jdXJyZW50SW5wdXQ7XG5cbiAgICBpZiAocG9seSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1vZGVsLnJlbmRlcmFibGUubWFwU2NhbGFycyhwb2x5LCAxLjApO1xuICAgIGNvbnN0IGMgPSBtb2RlbC5yZW5kZXJhYmxlLmdldENvbG9yTWFwQ29sb3JzKCk7XG5cbiAgICBjb25zdCB2Ym8gPSBtb2RlbC5wcmltaXRpdmVzW21vZGVsLnByaW1UeXBlcy5UcmlzXS5nZXRDQUJPKCk7XG5cbiAgICBjb25zdCBwb2ludERhdGEgPSBwb2x5LmdldFBvaW50RGF0YSgpO1xuICAgIGNvbnN0IHBvaW50cyA9IHBvbHkuZ2V0UG9pbnRzKCk7XG4gICAgY29uc3QgbnVtUG9pbnRzID0gcG9pbnRzLmdldE51bWJlck9mUG9pbnRzKCk7XG4gICAgY29uc3QgcG9pbnRBcnJheSA9IHBvaW50cy5nZXREYXRhKCk7XG4gICAgbGV0IHBvaW50U2l6ZSA9IDM7IC8vIHgseSx6XG5cbiAgICAvLyB0aHJlZSBtb3JlIGZsb2F0cyBmb3Igb3JpZW50YXRpb24gKyAxIGZvciByYWRpdXNcbiAgICBwb2ludFNpemUgKz0gNDtcblxuICAgIGxldCBjb2xvckRhdGEgPSBudWxsO1xuICAgIGxldCBjb2xvckNvbXBvbmVudHMgPSAwO1xuICAgIHZiby5zZXRDb2xvckJPU3RyaWRlKDQpO1xuXG4gICAgaWYgKCF2Ym8uZ2V0Q29sb3JCTygpKSB7XG4gICAgICB2Ym8uc2V0Q29sb3JCTyh2dGtCdWZmZXJPYmplY3QubmV3SW5zdGFuY2UoKSk7XG4gICAgfVxuICAgIHZiby5nZXRDb2xvckJPKCkuc2V0T3BlbkdMUmVuZGVyV2luZG93KG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyk7XG4gICAgaWYgKGMpIHtcbiAgICAgIGNvbG9yQ29tcG9uZW50cyA9IGMuZ2V0TnVtYmVyT2ZDb21wb25lbnRzKCk7XG4gICAgICB2Ym8uc2V0Q29sb3JPZmZzZXQoNCk7XG4gICAgICBjb2xvckRhdGEgPSBjLmdldERhdGEoKTtcbiAgICAgIHZiby5zZXRDb2xvckJPU3RyaWRlKDgpO1xuICAgIH1cbiAgICB2Ym8uc2V0Q29sb3JDb21wb25lbnRzKGNvbG9yQ29tcG9uZW50cyk7XG5cbiAgICB2Ym8uc2V0U3RyaWRlKHBvaW50U2l6ZSAqIDQpO1xuXG4gICAgLy8gQ3JlYXRlIGEgYnVmZmVyLCBhbmQgY29weSB0aGUgZGF0YSBvdmVyLlxuICAgIGNvbnN0IHBhY2tlZFZCTyA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRTaXplICogbnVtUG9pbnRzICogMTIpO1xuICAgIGNvbnN0IHBhY2tlZFVDVkJPID0gbmV3IFVpbnQ4QXJyYXkoMTIgKiBudW1Qb2ludHMgKiAoY29sb3JEYXRhID8gOCA6IDQpKTtcblxuICAgIGxldCBzY2FsZXMgPSBudWxsO1xuICAgIGxldCBvcmllbnRhdGlvbkFycmF5ID0gbnVsbDtcbiAgICAvL1xuICAgIC8vIEdlbmVyYXRlIHBvaW50cyBhbmQgcG9pbnQgZGF0YSBmb3Igc2lkZXNcbiAgICAvL1xuICAgIGlmIChcbiAgICAgIG1vZGVsLnJlbmRlcmFibGUuZ2V0U2NhbGVBcnJheSgpICE9IG51bGwgJiZcbiAgICAgIHBvaW50RGF0YS5oYXNBcnJheShtb2RlbC5yZW5kZXJhYmxlLmdldFNjYWxlQXJyYXkoKSlcbiAgICApIHtcbiAgICAgIHNjYWxlcyA9IHBvaW50RGF0YS5nZXRBcnJheShtb2RlbC5yZW5kZXJhYmxlLmdldFNjYWxlQXJyYXkoKSkuZ2V0RGF0YSgpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIG1vZGVsLnJlbmRlcmFibGUuZ2V0T3JpZW50YXRpb25BcnJheSgpICE9IG51bGwgJiZcbiAgICAgIHBvaW50RGF0YS5oYXNBcnJheShtb2RlbC5yZW5kZXJhYmxlLmdldE9yaWVudGF0aW9uQXJyYXkoKSlcbiAgICApIHtcbiAgICAgIG9yaWVudGF0aW9uQXJyYXkgPSBwb2ludERhdGFcbiAgICAgICAgLmdldEFycmF5KG1vZGVsLnJlbmRlcmFibGUuZ2V0T3JpZW50YXRpb25BcnJheSgpKVxuICAgICAgICAuZ2V0RGF0YSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2dGtFcnJvck1hY3JvKFtcbiAgICAgICAgJ0Vycm9yIHNldHRpbmcgb3JpZW50YXRpb25BcnJheS5cXG4nLFxuICAgICAgICAnWW91IGhhdmUgdG8gc3BlY2lmeSB0aGUgc3RpY2sgb3JpZW50YXRpb24nLFxuICAgICAgXSk7XG4gICAgfVxuXG4gICAgLy8gVmVydGljZXNcbiAgICAvLyAwMTMgLSAwMzIgLSAzMjQgLSA0NTNcbiAgICAvL1xuICAgIC8vICAgICAgIF8uNC0tLV8uNVxuICAgIC8vICAgIC4tKiAgIC4tKlxuICAgIC8vICAgMi0tLS0tM1xuICAgIC8vICAgfCAgICAvfFxuICAgIC8vICAgfCAgIC8gfFxuICAgIC8vICAgfCAgLyAgfFxuICAgIC8vICAgfCAvICAgfFxuICAgIC8vICAgfC8gICAgfFxuICAgIC8vICAgMC0tLS0tMVxuICAgIC8vXG4gICAgLy8gY29vcmQgZm9yIGVhY2ggcG9pbnRzXG4gICAgLy8gMDogMDAwXG4gICAgLy8gMTogMTAwXG4gICAgLy8gMjogMDAxXG4gICAgLy8gMzogMTAxXG4gICAgLy8gNDogMDExXG4gICAgLy8gNTogMTExXG5cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCB2ZXJ0aWNlc0FycmF5ID0gW1xuICAgICAgMCwgMSwgMyxcbiAgICAgIDAsIDMsIDIsXG4gICAgICAyLCAzLCA1LFxuICAgICAgMiwgNSwgNCxcbiAgICBdO1xuXG4gICAgbGV0IHBvaW50SWR4ID0gMDtcbiAgICBsZXQgY29sb3JJZHggPSAwO1xuICAgIGxldCB2Ym9JZHggPSAwO1xuICAgIGxldCB1Y0lkeCA9IDA7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvaW50czsgKytpKSB7XG4gICAgICBsZXQgbGVuZ3RoID0gbW9kZWwucmVuZGVyYWJsZS5nZXRMZW5ndGgoKTtcbiAgICAgIGxldCByYWRpdXMgPSBtb2RlbC5yZW5kZXJhYmxlLmdldFJhZGl1cygpO1xuICAgICAgaWYgKHNjYWxlcykge1xuICAgICAgICBsZW5ndGggPSBzY2FsZXNbaSAqIDJdO1xuICAgICAgICByYWRpdXMgPSBzY2FsZXNbaSAqIDIgKyAxXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHBvaW50SWR4ID0gaSAqIDM7XG4gICAgICAgIHBhY2tlZFZCT1t2Ym9JZHgrK10gPSBwb2ludEFycmF5W3BvaW50SWR4KytdO1xuICAgICAgICBwYWNrZWRWQk9bdmJvSWR4KytdID0gcG9pbnRBcnJheVtwb2ludElkeCsrXTtcbiAgICAgICAgcGFja2VkVkJPW3Zib0lkeCsrXSA9IHBvaW50QXJyYXlbcG9pbnRJZHgrK107XG4gICAgICAgIHBvaW50SWR4ID0gaSAqIDM7XG4gICAgICAgIHBhY2tlZFZCT1t2Ym9JZHgrK10gPSBvcmllbnRhdGlvbkFycmF5W3BvaW50SWR4KytdICogbGVuZ3RoO1xuICAgICAgICBwYWNrZWRWQk9bdmJvSWR4KytdID0gb3JpZW50YXRpb25BcnJheVtwb2ludElkeCsrXSAqIGxlbmd0aDtcbiAgICAgICAgcGFja2VkVkJPW3Zib0lkeCsrXSA9IG9yaWVudGF0aW9uQXJyYXlbcG9pbnRJZHgrK10gKiBsZW5ndGg7XG4gICAgICAgIHBhY2tlZFZCT1t2Ym9JZHgrK10gPSByYWRpdXM7XG5cbiAgICAgICAgcGFja2VkVUNWQk9bdWNJZHgrK10gPSAyNTUgKiAodmVydGljZXNBcnJheVtqXSAlIDIpO1xuICAgICAgICBwYWNrZWRVQ1ZCT1t1Y0lkeCsrXSA9IHZlcnRpY2VzQXJyYXlbal0gPj0gNCA/IDI1NSA6IDA7XG4gICAgICAgIHBhY2tlZFVDVkJPW3VjSWR4KytdID0gdmVydGljZXNBcnJheVtqXSA+PSAyID8gMjU1IDogMDtcbiAgICAgICAgcGFja2VkVUNWQk9bdWNJZHgrK10gPSAyNTU7XG5cbiAgICAgICAgY29sb3JJZHggPSBpICogY29sb3JDb21wb25lbnRzO1xuICAgICAgICBpZiAoY29sb3JEYXRhKSB7XG4gICAgICAgICAgcGFja2VkVUNWQk9bdWNJZHgrK10gPSBjb2xvckRhdGFbY29sb3JJZHhdO1xuICAgICAgICAgIHBhY2tlZFVDVkJPW3VjSWR4KytdID0gY29sb3JEYXRhW2NvbG9ySWR4ICsgMV07XG4gICAgICAgICAgcGFja2VkVUNWQk9bdWNJZHgrK10gPSBjb2xvckRhdGFbY29sb3JJZHggKyAyXTtcbiAgICAgICAgICBwYWNrZWRVQ1ZCT1t1Y0lkeCsrXSA9IGNvbG9yRGF0YVtjb2xvcklkeCArIDNdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZiby5zZXRFbGVtZW50Q291bnQodmJvSWR4IC8gcG9pbnRTaXplKTtcbiAgICB2Ym8udXBsb2FkKHBhY2tlZFZCTywgT2JqZWN0VHlwZS5BUlJBWV9CVUZGRVIpO1xuICAgIHZiby5nZXRDb2xvckJPKCkudXBsb2FkKHBhY2tlZFVDVkJPLCBPYmplY3RUeXBlLkFSUkFZX0JVRkZFUik7XG4gICAgbW9kZWwuVkJPQnVpbGRUaW1lLm1vZGlmaWVkKCk7XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge307XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEluaGVyaXRhbmNlXG4gIHZ0a09wZW5HTFBvbHlEYXRhTWFwcGVyLmV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICB2dGtPcGVuR0xTdGlja01hcHBlcihwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShleHRlbmQsICd2dGtPcGVuR0xTdGlja01hcHBlcicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCB9O1xuIiwiZXhwb3J0IGNvbnN0IFdyYXAgPSB7XG4gIENMQU1QX1RPX0VER0U6IDAsXG4gIFJFUEVBVDogMSxcbiAgTUlSUk9SRURfUkVQRUFUOiAyLFxufTtcblxuZXhwb3J0IGNvbnN0IEZpbHRlciA9IHtcbiAgTkVBUkVTVDogMCxcbiAgTElORUFSOiAxLFxuICBORUFSRVNUX01JUE1BUF9ORUFSRVNUOiAyLFxuICBORUFSRVNUX01JUE1BUF9MSU5FQVI6IDMsXG4gIExJTkVBUl9NSVBNQVBfTkVBUkVTVDogNCxcbiAgTElORUFSX01JUE1BUF9MSU5FQVI6IDUsXG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIFdyYXAsXG4gIEZpbHRlcixcbn07XG4iLCJpbXBvcnQgQ29uc3RhbnRzIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvVGV4dHVyZS9Db25zdGFudHMnO1xuaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB2dGtEYXRhQXJyYXkgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvRGF0YUFycmF5JztcbmltcG9ydCAqIGFzIHZ0a01hdGggZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvTWF0aCc7XG5pbXBvcnQgdnRrVmlld05vZGUgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL1NjZW5lR3JhcGgvVmlld05vZGUnO1xuXG5jb25zdCB7IFdyYXAsIEZpbHRlciB9ID0gQ29uc3RhbnRzO1xuY29uc3QgeyBWdGtEYXRhVHlwZXMgfSA9IHZ0a0RhdGFBcnJheTtcbmNvbnN0IHsgdnRrRGVidWdNYWNybywgdnRrRXJyb3JNYWNybywgdnRrV2FybmluZ01hY3JvIH0gPSBtYWNybztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrT3BlbkdMVGV4dHVyZSBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a09wZW5HTFRleHR1cmUocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtPcGVuR0xUZXh0dXJlJyk7XG4gIC8vIFJlbmRlcnMgbXlzZWxmXG4gIHB1YmxpY0FQSS5yZW5kZXIgPSAocmVuV2luID0gbnVsbCkgPT4ge1xuICAgIGlmIChyZW5XaW4pIHtcbiAgICAgIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyA9IHJlbldpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWwub3BlbkdMUmVuZGVyZXIgPSBwdWJsaWNBUEkuZ2V0Rmlyc3RBbmNlc3Rvck9mVHlwZShcbiAgICAgICAgJ3Z0a09wZW5HTFJlbmRlcmVyJ1xuICAgICAgKTtcbiAgICAgIC8vIHN5bmMgcmVuZGVyYWJsZSBwcm9wZXJ0aWVzXG4gICAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cgPSBtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRQYXJlbnQoKTtcbiAgICB9XG4gICAgbW9kZWwuY29udGV4dCA9IG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRDb250ZXh0KCk7XG4gICAgaWYgKG1vZGVsLnJlbmRlcmFibGUuZ2V0SW50ZXJwb2xhdGUoKSkge1xuICAgICAgaWYgKG1vZGVsLmdlbmVyYXRlTWlwbWFwKSB7XG4gICAgICAgIHB1YmxpY0FQSS5zZXRNaW5pZmljYXRpb25GaWx0ZXIoRmlsdGVyLkxJTkVBUl9NSVBNQVBfTElORUFSKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB1YmxpY0FQSS5zZXRNaW5pZmljYXRpb25GaWx0ZXIoRmlsdGVyLkxJTkVBUik7XG4gICAgICB9XG4gICAgICBwdWJsaWNBUEkuc2V0TWFnbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTElORUFSKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVibGljQVBJLnNldE1pbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTkVBUkVTVCk7XG4gICAgICBwdWJsaWNBUEkuc2V0TWFnbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTkVBUkVTVCk7XG4gICAgfVxuICAgIGlmIChtb2RlbC5yZW5kZXJhYmxlLmdldFJlcGVhdCgpKSB7XG4gICAgICBwdWJsaWNBUEkuc2V0V3JhcFIoV3JhcC5SRVBFQVQpO1xuICAgICAgcHVibGljQVBJLnNldFdyYXBTKFdyYXAuUkVQRUFUKTtcbiAgICAgIHB1YmxpY0FQSS5zZXRXcmFwVChXcmFwLlJFUEVBVCk7XG4gICAgfVxuICAgIC8vIGNsZWFyIGltYWdlIGlmIGlucHV0IGRhdGEgaXMgc2V0XG4gICAgaWYgKG1vZGVsLnJlbmRlcmFibGUuZ2V0SW5wdXREYXRhKCkpIHtcbiAgICAgIG1vZGVsLnJlbmRlcmFibGUuc2V0SW1hZ2UobnVsbCk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSB0aGUgdGV4dHVyZSBpZiBpdCBpcyBub3QgZG9uZSBhbHJlYWR5XG4gICAgaWYgKFxuICAgICAgIW1vZGVsLmhhbmRsZSB8fFxuICAgICAgbW9kZWwucmVuZGVyYWJsZS5nZXRNVGltZSgpID4gbW9kZWwudGV4dHVyZUJ1aWxkVGltZS5nZXRNVGltZSgpXG4gICAgKSB7XG4gICAgICAvLyBpZiB3ZSBoYXZlIGFuIEltYWdlXG4gICAgICBpZiAobW9kZWwucmVuZGVyYWJsZS5nZXRJbWFnZSgpICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChtb2RlbC5yZW5kZXJhYmxlLmdldEludGVycG9sYXRlKCkpIHtcbiAgICAgICAgICBtb2RlbC5nZW5lcmF0ZU1pcG1hcCA9IHRydWU7XG4gICAgICAgICAgcHVibGljQVBJLnNldE1pbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTElORUFSX01JUE1BUF9MSU5FQVIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhdmUgYW4gSW1hZ2Ugd2hpY2ggbWF5IG5vdCBiZSBjb21wbGV0ZVxuICAgICAgICBpZiAobW9kZWwucmVuZGVyYWJsZS5nZXRJbWFnZSgpICYmIG1vZGVsLnJlbmRlcmFibGUuZ2V0SW1hZ2VMb2FkZWQoKSkge1xuICAgICAgICAgIHB1YmxpY0FQSS5jcmVhdGUyREZyb21JbWFnZShtb2RlbC5yZW5kZXJhYmxlLmdldEltYWdlKCkpO1xuICAgICAgICAgIHB1YmxpY0FQSS5hY3RpdmF0ZSgpO1xuICAgICAgICAgIHB1YmxpY0FQSS5zZW5kUGFyYW1ldGVycygpO1xuICAgICAgICAgIG1vZGVsLnRleHR1cmVCdWlsZFRpbWUubW9kaWZpZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gaWYgd2UgaGF2ZSBJbnB1dGRhdGFcbiAgICAgIGNvbnN0IGlucHV0ID0gbW9kZWwucmVuZGVyYWJsZS5nZXRJbnB1dERhdGEoMCk7XG4gICAgICBpZiAoaW5wdXQgJiYgaW5wdXQuZ2V0UG9pbnREYXRhKCkuZ2V0U2NhbGFycygpKSB7XG4gICAgICAgIGNvbnN0IGV4dCA9IGlucHV0LmdldEV4dGVudCgpO1xuICAgICAgICBjb25zdCBpblNjYWxhcnMgPSBpbnB1dC5nZXRQb2ludERhdGEoKS5nZXRTY2FsYXJzKCk7XG5cbiAgICAgICAgLy8gZG8gd2UgaGF2ZSBhIGN1YmUgbWFwPyBTaXggaW5wdXRzXG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtb2RlbC5yZW5kZXJhYmxlLmdldE51bWJlck9mSW5wdXRQb3J0cygpOyArK2kpIHtcbiAgICAgICAgICBjb25zdCBpbmRhdGEgPSBtb2RlbC5yZW5kZXJhYmxlLmdldElucHV0RGF0YShpKTtcbiAgICAgICAgICBjb25zdCBzY2FsYXJzID0gaW5kYXRhXG4gICAgICAgICAgICA/IGluZGF0YS5nZXRQb2ludERhdGEoKS5nZXRTY2FsYXJzKCkuZ2V0RGF0YSgpXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgaWYgKHNjYWxhcnMpIHtcbiAgICAgICAgICAgIGRhdGEucHVzaChzY2FsYXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1vZGVsLnJlbmRlcmFibGUuZ2V0SW50ZXJwb2xhdGUoKSAmJlxuICAgICAgICAgIGluU2NhbGFycy5nZXROdW1iZXJPZkNvbXBvbmVudHMoKSA9PT0gNFxuICAgICAgICApIHtcbiAgICAgICAgICBtb2RlbC5nZW5lcmF0ZU1pcG1hcCA9IHRydWU7XG4gICAgICAgICAgcHVibGljQVBJLnNldE1pbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTElORUFSX01JUE1BUF9MSU5FQVIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAlIDYgPT09IDApIHtcbiAgICAgICAgICBwdWJsaWNBUEkuY3JlYXRlQ3ViZUZyb21SYXcoXG4gICAgICAgICAgICBleHRbMV0gLSBleHRbMF0gKyAxLFxuICAgICAgICAgICAgZXh0WzNdIC0gZXh0WzJdICsgMSxcbiAgICAgICAgICAgIGluU2NhbGFycy5nZXROdW1iZXJPZkNvbXBvbmVudHMoKSxcbiAgICAgICAgICAgIGluU2NhbGFycy5nZXREYXRhVHlwZSgpLFxuICAgICAgICAgICAgZGF0YVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVibGljQVBJLmNyZWF0ZTJERnJvbVJhdyhcbiAgICAgICAgICAgIGV4dFsxXSAtIGV4dFswXSArIDEsXG4gICAgICAgICAgICBleHRbM10gLSBleHRbMl0gKyAxLFxuICAgICAgICAgICAgaW5TY2FsYXJzLmdldE51bWJlck9mQ29tcG9uZW50cygpLFxuICAgICAgICAgICAgaW5TY2FsYXJzLmdldERhdGFUeXBlKCksXG4gICAgICAgICAgICBpblNjYWxhcnMuZ2V0RGF0YSgpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBwdWJsaWNBUEkuYWN0aXZhdGUoKTtcbiAgICAgICAgcHVibGljQVBJLnNlbmRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIG1vZGVsLnRleHR1cmVCdWlsZFRpbWUubW9kaWZpZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vZGVsLmhhbmRsZSkge1xuICAgICAgcHVibGljQVBJLmFjdGl2YXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuZGVzdHJveVRleHR1cmUgPSAoKSA9PiB7XG4gICAgLy8gZGVhY3RpdmF0ZSBpdCBmaXJzdFxuICAgIHB1YmxpY0FQSS5kZWFjdGl2YXRlKCk7XG5cbiAgICBpZiAobW9kZWwuY29udGV4dCAmJiBtb2RlbC5oYW5kbGUpIHtcbiAgICAgIG1vZGVsLmNvbnRleHQuZGVsZXRlVGV4dHVyZShtb2RlbC5oYW5kbGUpO1xuICAgIH1cbiAgICBtb2RlbC5oYW5kbGUgPSAwO1xuICAgIG1vZGVsLm51bWJlck9mRGltZW5zaW9ucyA9IDA7XG4gICAgbW9kZWwudGFyZ2V0ID0gMDtcbiAgICBtb2RlbC5jb21wb25lbnRzID0gMDtcbiAgICBtb2RlbC53aWR0aCA9IDA7XG4gICAgbW9kZWwuaGVpZ2h0ID0gMDtcbiAgICBtb2RlbC5kZXB0aCA9IDA7XG4gICAgcHVibGljQVBJLnJlc2V0Rm9ybWF0QW5kVHlwZSgpO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuY3JlYXRlVGV4dHVyZSA9ICgpID0+IHtcbiAgICAvLyByZXVzZSB0aGUgZXhpc3RpbmcgaGFuZGxlIGlmIHdlIGhhdmUgb25lXG4gICAgaWYgKCFtb2RlbC5oYW5kbGUpIHtcbiAgICAgIG1vZGVsLmhhbmRsZSA9IG1vZGVsLmNvbnRleHQuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgICBpZiAobW9kZWwudGFyZ2V0KSB7XG4gICAgICAgIG1vZGVsLmNvbnRleHQuYmluZFRleHR1cmUobW9kZWwudGFyZ2V0LCBtb2RlbC5oYW5kbGUpO1xuXG4gICAgICAgIC8vIFNlZTogaHR0cDovL3d3dy5vcGVubW9kZWwuY29udGV4dC4ub3JnL3dpa2kvQ29tbW9uX01pc3Rha2VzI0NyZWF0aW5nX2FfY29tcGxldGVfdGV4dHVyZVxuICAgICAgICAvLyB0dXJuIG9mZiBtaXAgbWFwIGZpbHRlciBvciBzZXQgdGhlIGJhc2UgYW5kIG1heCBsZXZlbCBjb3JyZWN0bHkuIGhlcmVcbiAgICAgICAgLy8gYm90aCBhcmUgZG9uZS5cbiAgICAgICAgbW9kZWwuY29udGV4dC50ZXhQYXJhbWV0ZXJpKFxuICAgICAgICAgIG1vZGVsLnRhcmdldCxcbiAgICAgICAgICBtb2RlbC5jb250ZXh0LlRFWFRVUkVfTUlOX0ZJTFRFUixcbiAgICAgICAgICBwdWJsaWNBUEkuZ2V0T3BlbkdMRmlsdGVyTW9kZShtb2RlbC5taW5pZmljYXRpb25GaWx0ZXIpXG4gICAgICAgICk7XG4gICAgICAgIG1vZGVsLmNvbnRleHQudGV4UGFyYW1ldGVyaShcbiAgICAgICAgICBtb2RlbC50YXJnZXQsXG4gICAgICAgICAgbW9kZWwuY29udGV4dC5URVhUVVJFX01BR19GSUxURVIsXG4gICAgICAgICAgcHVibGljQVBJLmdldE9wZW5HTEZpbHRlck1vZGUobW9kZWwubWFnbmlmaWNhdGlvbkZpbHRlcilcbiAgICAgICAgKTtcblxuICAgICAgICBtb2RlbC5jb250ZXh0LnRleFBhcmFtZXRlcmkoXG4gICAgICAgICAgbW9kZWwudGFyZ2V0LFxuICAgICAgICAgIG1vZGVsLmNvbnRleHQuVEVYVFVSRV9XUkFQX1MsXG4gICAgICAgICAgcHVibGljQVBJLmdldE9wZW5HTFdyYXBNb2RlKG1vZGVsLndyYXBTKVxuICAgICAgICApO1xuICAgICAgICBtb2RlbC5jb250ZXh0LnRleFBhcmFtZXRlcmkoXG4gICAgICAgICAgbW9kZWwudGFyZ2V0LFxuICAgICAgICAgIG1vZGVsLmNvbnRleHQuVEVYVFVSRV9XUkFQX1QsXG4gICAgICAgICAgcHVibGljQVBJLmdldE9wZW5HTFdyYXBNb2RlKG1vZGVsLndyYXBUKVxuICAgICAgICApO1xuICAgICAgICBpZiAobW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldFdlYmdsMigpKSB7XG4gICAgICAgICAgbW9kZWwuY29udGV4dC50ZXhQYXJhbWV0ZXJpKFxuICAgICAgICAgICAgbW9kZWwudGFyZ2V0LFxuICAgICAgICAgICAgbW9kZWwuY29udGV4dC5URVhUVVJFX1dSQVBfUixcbiAgICAgICAgICAgIHB1YmxpY0FQSS5nZXRPcGVuR0xXcmFwTW9kZShtb2RlbC53cmFwUilcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kZWwuY29udGV4dC5iaW5kVGV4dHVyZShtb2RlbC50YXJnZXQsIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuZ2V0VGV4dHVyZVVuaXQgPSAoKSA9PiB7XG4gICAgaWYgKG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdykge1xuICAgICAgcmV0dXJuIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRUZXh0dXJlVW5pdEZvclRleHR1cmUocHVibGljQVBJKTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5hY3RpdmF0ZSA9ICgpID0+IHtcbiAgICAvLyBhY3RpdmF0ZSBhIGZyZWUgdGV4dHVyZSB1bml0IGZvciB0aGlzIHRleHR1cmVcbiAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuYWN0aXZhdGVUZXh0dXJlKHB1YmxpY0FQSSk7XG4gICAgcHVibGljQVBJLmJpbmQoKTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuZGVhY3RpdmF0ZSA9ICgpID0+IHtcbiAgICBpZiAobW9kZWwub3BlbkdMUmVuZGVyV2luZG93KSB7XG4gICAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZGVhY3RpdmF0ZVRleHR1cmUocHVibGljQVBJKTtcbiAgICB9XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLnJlbGVhc2VHcmFwaGljc1Jlc291cmNlcyA9IChyd2luKSA9PiB7XG4gICAgaWYgKHJ3aW4gJiYgbW9kZWwuaGFuZGxlKSB7XG4gICAgICByd2luLmFjdGl2YXRlVGV4dHVyZShwdWJsaWNBUEkpO1xuICAgICAgcndpbi5kZWFjdGl2YXRlVGV4dHVyZShwdWJsaWNBUEkpO1xuICAgICAgbW9kZWwuY29udGV4dC5kZWxldGVUZXh0dXJlKG1vZGVsLmhhbmRsZSk7XG4gICAgICBtb2RlbC5oYW5kbGUgPSAwO1xuICAgICAgbW9kZWwubnVtYmVyT2ZEaW1lbnNpb25zID0gMDtcbiAgICAgIG1vZGVsLnRhcmdldCA9IDA7XG4gICAgICBtb2RlbC5pbnRlcm5hbEZvcm1hdCA9IDA7XG4gICAgICBtb2RlbC5mb3JtYXQgPSAwO1xuICAgICAgbW9kZWwub3BlbkdMRGF0YVR5cGUgPSAwO1xuICAgICAgbW9kZWwuY29tcG9uZW50cyA9IDA7XG4gICAgICBtb2RlbC53aWR0aCA9IDA7XG4gICAgICBtb2RlbC5oZWlnaHQgPSAwO1xuICAgICAgbW9kZWwuZGVwdGggPSAwO1xuICAgIH1cbiAgICBpZiAobW9kZWwuc2hhZGVyUHJvZ3JhbSkge1xuICAgICAgbW9kZWwuc2hhZGVyUHJvZ3JhbS5yZWxlYXNlR3JhcGhpY3NSZXNvdXJjZXMocndpbik7XG4gICAgICBtb2RlbC5zaGFkZXJQcm9ncmFtID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5iaW5kID0gKCkgPT4ge1xuICAgIG1vZGVsLmNvbnRleHQuYmluZFRleHR1cmUobW9kZWwudGFyZ2V0LCBtb2RlbC5oYW5kbGUpO1xuICAgIGlmIChcbiAgICAgIG1vZGVsLmF1dG9QYXJhbWV0ZXJzICYmXG4gICAgICBwdWJsaWNBUEkuZ2V0TVRpbWUoKSA+IG1vZGVsLnNlbmRQYXJhbWV0ZXJzVGltZS5nZXRNVGltZSgpXG4gICAgKSB7XG4gICAgICBwdWJsaWNBUEkuc2VuZFBhcmFtZXRlcnMoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5pc0JvdW5kID0gKCkgPT4ge1xuICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAobW9kZWwuY29udGV4dCAmJiBtb2RlbC5oYW5kbGUpIHtcbiAgICAgIGxldCB0YXJnZXQgPSAwO1xuICAgICAgc3dpdGNoIChtb2RlbC50YXJnZXQpIHtcbiAgICAgICAgY2FzZSBtb2RlbC5jb250ZXh0LlRFWFRVUkVfMkQ6XG4gICAgICAgICAgdGFyZ2V0ID0gbW9kZWwuY29udGV4dC5URVhUVVJFX0JJTkRJTkdfMkQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdnRrV2FybmluZ01hY3JvKCdpbXBvc3NpYmxlIGNhc2UnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9pZCA9IG1vZGVsLmNvbnRleHQuZ2V0SW50ZWdlcnYodGFyZ2V0KTtcbiAgICAgIHJlc3VsdCA9IG9pZCA9PT0gbW9kZWwuaGFuZGxlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuc2VuZFBhcmFtZXRlcnMgPSAoKSA9PiB7XG4gICAgbW9kZWwuY29udGV4dC50ZXhQYXJhbWV0ZXJpKFxuICAgICAgbW9kZWwudGFyZ2V0LFxuICAgICAgbW9kZWwuY29udGV4dC5URVhUVVJFX1dSQVBfUyxcbiAgICAgIHB1YmxpY0FQSS5nZXRPcGVuR0xXcmFwTW9kZShtb2RlbC53cmFwUylcbiAgICApO1xuICAgIG1vZGVsLmNvbnRleHQudGV4UGFyYW1ldGVyaShcbiAgICAgIG1vZGVsLnRhcmdldCxcbiAgICAgIG1vZGVsLmNvbnRleHQuVEVYVFVSRV9XUkFQX1QsXG4gICAgICBwdWJsaWNBUEkuZ2V0T3BlbkdMV3JhcE1vZGUobW9kZWwud3JhcFQpXG4gICAgKTtcbiAgICBpZiAobW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldFdlYmdsMigpKSB7XG4gICAgICBtb2RlbC5jb250ZXh0LnRleFBhcmFtZXRlcmkoXG4gICAgICAgIG1vZGVsLnRhcmdldCxcbiAgICAgICAgbW9kZWwuY29udGV4dC5URVhUVVJFX1dSQVBfUixcbiAgICAgICAgcHVibGljQVBJLmdldE9wZW5HTFdyYXBNb2RlKG1vZGVsLndyYXBSKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBtb2RlbC5jb250ZXh0LnRleFBhcmFtZXRlcmkoXG4gICAgICBtb2RlbC50YXJnZXQsXG4gICAgICBtb2RlbC5jb250ZXh0LlRFWFRVUkVfTUlOX0ZJTFRFUixcbiAgICAgIHB1YmxpY0FQSS5nZXRPcGVuR0xGaWx0ZXJNb2RlKG1vZGVsLm1pbmlmaWNhdGlvbkZpbHRlcilcbiAgICApO1xuXG4gICAgbW9kZWwuY29udGV4dC50ZXhQYXJhbWV0ZXJpKFxuICAgICAgbW9kZWwudGFyZ2V0LFxuICAgICAgbW9kZWwuY29udGV4dC5URVhUVVJFX01BR19GSUxURVIsXG4gICAgICBwdWJsaWNBUEkuZ2V0T3BlbkdMRmlsdGVyTW9kZShtb2RlbC5tYWduaWZpY2F0aW9uRmlsdGVyKVxuICAgICk7XG5cbiAgICBpZiAobW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldFdlYmdsMigpKSB7XG4gICAgICBtb2RlbC5jb250ZXh0LnRleFBhcmFtZXRlcmkoXG4gICAgICAgIG1vZGVsLnRhcmdldCxcbiAgICAgICAgbW9kZWwuY29udGV4dC5URVhUVVJFX0JBU0VfTEVWRUwsXG4gICAgICAgIG1vZGVsLmJhc2VMZXZlbFxuICAgICAgKTtcblxuICAgICAgbW9kZWwuY29udGV4dC50ZXhQYXJhbWV0ZXJpKFxuICAgICAgICBtb2RlbC50YXJnZXQsXG4gICAgICAgIG1vZGVsLmNvbnRleHQuVEVYVFVSRV9NQVhfTEVWRUwsXG4gICAgICAgIG1vZGVsLm1heExldmVsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIG1vZGVsLmNvbnRleHQudGV4UGFyYW1ldGVyZihtb2RlbC50YXJnZXQsIG1vZGVsLmNvbnRleHQuVEVYVFVSRV9NSU5fTE9ELCBtb2RlbC5taW5MT0QpO1xuICAgIC8vIG1vZGVsLmNvbnRleHQudGV4UGFyYW1ldGVyZihtb2RlbC50YXJnZXQsIG1vZGVsLmNvbnRleHQuVEVYVFVSRV9NQVhfTE9ELCBtb2RlbC5tYXhMT0QpO1xuXG4gICAgbW9kZWwuc2VuZFBhcmFtZXRlcnNUaW1lLm1vZGlmaWVkKCk7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5nZXRJbnRlcm5hbEZvcm1hdCA9ICh2dGt0eXBlLCBudW1Db21wcykgPT4ge1xuICAgIGlmICghbW9kZWwuaW50ZXJuYWxGb3JtYXQpIHtcbiAgICAgIG1vZGVsLmludGVybmFsRm9ybWF0ID0gcHVibGljQVBJLmdldERlZmF1bHRJbnRlcm5hbEZvcm1hdChcbiAgICAgICAgdnRrdHlwZSxcbiAgICAgICAgbnVtQ29tcHNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFtb2RlbC5pbnRlcm5hbEZvcm1hdCkge1xuICAgICAgdnRrRGVidWdNYWNybyhcbiAgICAgICAgYFVuYWJsZSB0byBmaW5kIHN1aXRhYmxlIGludGVybmFsIGZvcm1hdCBmb3IgVD0ke3Z0a3R5cGV9IE5DPSAke251bUNvbXBzfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vZGVsLmludGVybmFsRm9ybWF0O1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuZ2V0RGVmYXVsdEludGVybmFsRm9ybWF0ID0gKHZ0a3R5cGUsIG51bUNvbXBzKSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG5cbiAgICAvLyB0cnkgZGVmYXVsdCBuZXh0XG4gICAgcmVzdWx0ID0gbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldERlZmF1bHRUZXh0dXJlSW50ZXJuYWxGb3JtYXQoXG4gICAgICB2dGt0eXBlLFxuICAgICAgbnVtQ29tcHMsXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyB0cnkgZmxvYXRpbmcgcG9pbnRcbiAgICByZXN1bHQgPSB0aGlzLm9wZW5HTFJlbmRlcldpbmRvdy5nZXREZWZhdWx0VGV4dHVyZUludGVybmFsRm9ybWF0KFxuICAgICAgdnRrdHlwZSxcbiAgICAgIG51bUNvbXBzLFxuICAgICAgdHJ1ZVxuICAgICk7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdnRrRGVidWdNYWNybygnVW5zdXBwb3J0ZWQgaW50ZXJuYWwgdGV4dHVyZSB0eXBlIScpO1xuICAgICAgdnRrRGVidWdNYWNybyhcbiAgICAgICAgYFVuYWJsZSB0byBmaW5kIHN1aXRhYmxlIGludGVybmFsIGZvcm1hdCBmb3IgVD0ke3Z0a3R5cGV9IE5DPSAke251bUNvbXBzfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLnNldEludGVybmFsRm9ybWF0ID0gKGlGb3JtYXQpID0+IHtcbiAgICBpZiAoaUZvcm1hdCAhPT0gbW9kZWwuaW50ZXJuYWxGb3JtYXQpIHtcbiAgICAgIG1vZGVsLmludGVybmFsRm9ybWF0ID0gaUZvcm1hdDtcbiAgICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICAgIH1cbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmdldEZvcm1hdCA9ICh2dGt0eXBlLCBudW1Db21wcykgPT4ge1xuICAgIG1vZGVsLmZvcm1hdCA9IHB1YmxpY0FQSS5nZXREZWZhdWx0Rm9ybWF0KHZ0a3R5cGUsIG51bUNvbXBzKTtcbiAgICByZXR1cm4gbW9kZWwuZm9ybWF0O1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuZ2V0RGVmYXVsdEZvcm1hdCA9ICh2dGt0eXBlLCBudW1Db21wcykgPT4ge1xuICAgIGlmIChtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0V2ViZ2wyKCkpIHtcbiAgICAgIHN3aXRjaCAobnVtQ29tcHMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHJldHVybiBtb2RlbC5jb250ZXh0LlJFRDtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiBtb2RlbC5jb250ZXh0LlJHO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuUkdCO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuUkdCQTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5SR0I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlYmdsMVxuICAgICAgc3dpdGNoIChudW1Db21wcykge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuTFVNSU5BTkNFO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuTFVNSU5BTkNFX0FMUEhBO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuUkdCO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuUkdCQTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5SR0I7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkucmVzZXRGb3JtYXRBbmRUeXBlID0gKCkgPT4ge1xuICAgIG1vZGVsLmZvcm1hdCA9IDA7XG4gICAgbW9kZWwuaW50ZXJuYWxGb3JtYXQgPSAwO1xuICAgIG1vZGVsLm9wZW5HTERhdGFUeXBlID0gMDtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmdldERlZmF1bHREYXRhVHlwZSA9ICh2dGtTY2FsYXJUeXBlKSA9PiB7XG4gICAgLy8gRE9OJ1QgREVBTCB3aXRoIFZUS19DSEFSIGFzIHRoaXMgaXMgcGxhdGZvcm0gZGVwZW5kZW50LlxuICAgIGlmIChtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0V2ViZ2wyKCkpIHtcbiAgICAgIHN3aXRjaCAodnRrU2NhbGFyVHlwZSkge1xuICAgICAgICAvLyBjYXNlIFZ0a0RhdGFUeXBlcy5TSUdORURfQ0hBUjpcbiAgICAgICAgLy8gICByZXR1cm4gbW9kZWwuY29udGV4dC5CWVRFO1xuICAgICAgICBjYXNlIFZ0a0RhdGFUeXBlcy5VTlNJR05FRF9DSEFSOlxuICAgICAgICAgIHJldHVybiBtb2RlbC5jb250ZXh0LlVOU0lHTkVEX0JZVEU7XG4gICAgICAgIC8vIGNhc2UgVnRrRGF0YVR5cGVzLlNIT1JUOlxuICAgICAgICAvLyAgIHJldHVybiBtb2RlbC5jb250ZXh0LlNIT1JUO1xuICAgICAgICAvLyBjYXNlIFZ0a0RhdGFUeXBlcy5VTlNJR05FRF9TSE9SVDpcbiAgICAgICAgLy8gICByZXR1cm4gbW9kZWwuY29udGV4dC5VTlNJR05FRF9TSE9SVDtcbiAgICAgICAgLy8gY2FzZSBWdGtEYXRhVHlwZXMuSU5UOlxuICAgICAgICAvLyAgIHJldHVybiBtb2RlbC5jb250ZXh0LklOVDtcbiAgICAgICAgLy8gY2FzZSBWdGtEYXRhVHlwZXMuVU5TSUdORURfSU5UOlxuICAgICAgICAvLyAgIHJldHVybiBtb2RlbC5jb250ZXh0LlVOU0lHTkVEX0lOVDtcbiAgICAgICAgY2FzZSBWdGtEYXRhVHlwZXMuRkxPQVQ6XG4gICAgICAgIGNhc2UgVnRrRGF0YVR5cGVzLlZPSUQ6IC8vIHVzZWQgZm9yIGRlcHRoIGNvbXBvbmVudCB0ZXh0dXJlcy5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5GTE9BVDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZ0a1NjYWxhclR5cGUpIHtcbiAgICAgIC8vIGNhc2UgVnRrRGF0YVR5cGVzLlNJR05FRF9DSEFSOlxuICAgICAgLy8gICByZXR1cm4gbW9kZWwuY29udGV4dC5CWVRFO1xuICAgICAgY2FzZSBWdGtEYXRhVHlwZXMuVU5TSUdORURfQ0hBUjpcbiAgICAgICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuVU5TSUdORURfQllURTtcbiAgICAgIC8vIGNhc2UgVnRrRGF0YVR5cGVzLlNIT1JUOlxuICAgICAgLy8gICByZXR1cm4gbW9kZWwuY29udGV4dC5TSE9SVDtcbiAgICAgIC8vIGNhc2UgVnRrRGF0YVR5cGVzLlVOU0lHTkVEX1NIT1JUOlxuICAgICAgLy8gICByZXR1cm4gbW9kZWwuY29udGV4dC5VTlNJR05FRF9TSE9SVDtcbiAgICAgIC8vIGNhc2UgVnRrRGF0YVR5cGVzLklOVDpcbiAgICAgIC8vICAgcmV0dXJuIG1vZGVsLmNvbnRleHQuSU5UO1xuICAgICAgLy8gY2FzZSBWdGtEYXRhVHlwZXMuVU5TSUdORURfSU5UOlxuICAgICAgLy8gICByZXR1cm4gbW9kZWwuY29udGV4dC5VTlNJR05FRF9JTlQ7XG4gICAgICBjYXNlIFZ0a0RhdGFUeXBlcy5GTE9BVDpcbiAgICAgIGNhc2UgVnRrRGF0YVR5cGVzLlZPSUQ6IC8vIHVzZWQgZm9yIGRlcHRoIGNvbXBvbmVudCB0ZXh0dXJlcy5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBtb2RlbC5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSAmJlxuICAgICAgICAgIG1vZGVsLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5GTE9BVDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5VTlNJR05FRF9CWVRFO1xuICAgIH1cbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmdldE9wZW5HTERhdGFUeXBlID0gKHZ0a1NjYWxhclR5cGUpID0+IHtcbiAgICBtb2RlbC5vcGVuR0xEYXRhVHlwZSA9IHB1YmxpY0FQSS5nZXREZWZhdWx0RGF0YVR5cGUodnRrU2NhbGFyVHlwZSk7XG4gICAgcmV0dXJuIG1vZGVsLm9wZW5HTERhdGFUeXBlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRTaGlmdEFuZFNjYWxlID0gKCkgPT4ge1xuICAgIGxldCBzaGlmdCA9IDAuMDtcbiAgICBsZXQgc2NhbGUgPSAxLjA7XG5cbiAgICAvLyBmb3IgYWxsIGZsb2F0IHR5cGUgaW50ZXJuYWwgZm9ybWF0c1xuICAgIHN3aXRjaCAobW9kZWwub3BlbkdMRGF0YVR5cGUpIHtcbiAgICAgIGNhc2UgbW9kZWwuY29udGV4dC5CWVRFOlxuICAgICAgICBzY2FsZSA9IDEyNy41O1xuICAgICAgICBzaGlmdCA9IHNjYWxlIC0gMTI4LjA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBtb2RlbC5jb250ZXh0LlVOU0lHTkVEX0JZVEU6XG4gICAgICAgIHNjYWxlID0gMjU1LjA7XG4gICAgICAgIHNoaWZ0ID0gMC4wO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbW9kZWwuY29udGV4dC5TSE9SVDpcbiAgICAgICAgc2NhbGUgPSAzMjc2Ny41O1xuICAgICAgICBzaGlmdCA9IHNjYWxlIC0gMzI3NjguMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG1vZGVsLmNvbnRleHQuVU5TSUdORURfU0hPUlQ6XG4gICAgICAgIHNjYWxlID0gNjU1MzYuMDtcbiAgICAgICAgc2hpZnQgPSAwLjA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBtb2RlbC5jb250ZXh0LklOVDpcbiAgICAgICAgc2NhbGUgPSAyMTQ3NDgzNjQ3LjU7XG4gICAgICAgIHNoaWZ0ID0gc2NhbGUgLSAyMTQ3NDgzNjQ4LjA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBtb2RlbC5jb250ZXh0LlVOU0lHTkVEX0lOVDpcbiAgICAgICAgc2NhbGUgPSA0Mjk0OTY3Mjk1LjA7XG4gICAgICAgIHNoaWZ0ID0gMC4wO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgbW9kZWwuY29udGV4dC5GTE9BVDpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4geyBzaGlmdCwgc2NhbGUgfTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmdldE9wZW5HTEZpbHRlck1vZGUgPSAoZW1vZGUpID0+IHtcbiAgICBzd2l0Y2ggKGVtb2RlKSB7XG4gICAgICBjYXNlIEZpbHRlci5ORUFSRVNUOlxuICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5ORUFSRVNUO1xuICAgICAgY2FzZSBGaWx0ZXIuTElORUFSOlxuICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5MSU5FQVI7XG4gICAgICBjYXNlIEZpbHRlci5ORUFSRVNUX01JUE1BUF9ORUFSRVNUOlxuICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO1xuICAgICAgY2FzZSBGaWx0ZXIuTkVBUkVTVF9NSVBNQVBfTElORUFSOlxuICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XG4gICAgICBjYXNlIEZpbHRlci5MSU5FQVJfTUlQTUFQX05FQVJFU1Q6XG4gICAgICAgIHJldHVybiBtb2RlbC5jb250ZXh0LkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcbiAgICAgIGNhc2UgRmlsdGVyLkxJTkVBUl9NSVBNQVBfTElORUFSOlxuICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBtb2RlbC5jb250ZXh0Lk5FQVJFU1Q7XG4gICAgfVxuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuZ2V0T3BlbkdMV3JhcE1vZGUgPSAodnRrdHlwZSkgPT4ge1xuICAgIHN3aXRjaCAodnRrdHlwZSkge1xuICAgICAgY2FzZSBXcmFwLkNMQU1QX1RPX0VER0U6XG4gICAgICAgIHJldHVybiBtb2RlbC5jb250ZXh0LkNMQU1QX1RPX0VER0U7XG4gICAgICBjYXNlIFdyYXAuUkVQRUFUOlxuICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5SRVBFQVQ7XG4gICAgICBjYXNlIFdyYXAuTUlSUk9SRURfUkVQRUFUOlxuICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5NSVJST1JFRF9SRVBFQVQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbW9kZWwuY29udGV4dC5DTEFNUF9UT19FREdFO1xuICAgIH1cbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZnVuY3Rpb24gdXBkYXRlQXJyYXlEYXRhVHlwZShkYXRhVHlwZSwgZGF0YSkge1xuICAgIGNvbnN0IHBpeERhdGEgPSBbXTtcbiAgICAvLyBpZiB0aGUgb3BlbmdsIGRhdGEgdHlwZSBpcyBmbG9hdFxuICAgIC8vIHRoZW4gdGhlIGRhdGEgYXJyYXkgbXVzdCBiZSBmbG9hdFxuICAgIGlmIChcbiAgICAgIGRhdGFUeXBlICE9PSBWdGtEYXRhVHlwZXMuRkxPQVQgJiZcbiAgICAgIG1vZGVsLm9wZW5HTERhdGFUeXBlID09PSBtb2RlbC5jb250ZXh0LkZMT0FUXG4gICAgKSB7XG4gICAgICBjb25zdCBwaXhDb3VudCA9IG1vZGVsLndpZHRoICogbW9kZWwuaGVpZ2h0ICogbW9kZWwuY29tcG9uZW50cztcbiAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGRhdGEubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBjb25zdCBuZXdBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkocGl4Q291bnQpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBpeENvdW50OyBpKyspIHtcbiAgICAgICAgICBuZXdBcnJheVtpXSA9IGRhdGFbaWR4XVtpXTtcbiAgICAgICAgfVxuICAgICAgICBwaXhEYXRhLnB1c2gobmV3QXJyYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIHRoZSBvcGVuZ2wgZGF0YSB0eXBlIGlzIHVieXRlXG4gICAgLy8gdGhlbiB0aGUgZGF0YSBhcnJheSBtdXN0IGJlIHU4LCB3ZSBjdXJyZW50bHkgc2ltcGx5IHRydW5jYXRlIHRoZSBkYXRhXG4gICAgaWYgKFxuICAgICAgZGF0YVR5cGUgIT09IFZ0a0RhdGFUeXBlcy5VTlNJR05FRF9DSEFSICYmXG4gICAgICBtb2RlbC5vcGVuR0xEYXRhVHlwZSA9PT0gbW9kZWwuY29udGV4dC5VTlNJR05FRF9CWVRFXG4gICAgKSB7XG4gICAgICBjb25zdCBwaXhDb3VudCA9IG1vZGVsLndpZHRoICogbW9kZWwuaGVpZ2h0ICogbW9kZWwuY29tcG9uZW50cztcbiAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGRhdGEubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBjb25zdCBuZXdBcnJheSA9IG5ldyBVaW50OEFycmF5KHBpeENvdW50KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaXhDb3VudDsgaSsrKSB7XG4gICAgICAgICAgbmV3QXJyYXlbaV0gPSBkYXRhW2lkeF1baV07XG4gICAgICAgIH1cbiAgICAgICAgcGl4RGF0YS5wdXNoKG5ld0FycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGUgb3V0cHV0IGhhcyB0byBiZSBmaWxsZWRcbiAgICBpZiAocGl4RGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBwaXhEYXRhLnB1c2goZGF0YVtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBpeERhdGE7XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgZnVuY3Rpb24gc2NhbGVUZXh0dXJlVG9IaWdoZXN0UG93ZXJPZlR3byhkYXRhKSB7XG4gICAgaWYgKG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRXZWJnbDIoKSkge1xuICAgICAgLy8gTm8gbmVlZCBpZiB3ZWJHTDJcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjb25zdCBwaXhEYXRhID0gW107XG4gICAgY29uc3Qgd2lkdGggPSBtb2RlbC53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBtb2RlbC5oZWlnaHQ7XG4gICAgY29uc3QgbnVtQ29tcHMgPSBtb2RlbC5jb21wb25lbnRzO1xuICAgIGlmIChcbiAgICAgIGRhdGEgJiZcbiAgICAgICghdnRrTWF0aC5pc1Bvd2VyT2ZUd28od2lkdGgpIHx8ICF2dGtNYXRoLmlzUG93ZXJPZlR3byhoZWlnaHQpKVxuICAgICkge1xuICAgICAgLy8gU2NhbGUgdXAgdGhlIHRleHR1cmUgdG8gdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiB0d28gZGltZW5zaW9ucy5cbiAgICAgIGNvbnN0IG5ld1dpZHRoID0gdnRrTWF0aC5uZWFyZXN0UG93ZXJPZlR3byh3aWR0aCk7XG4gICAgICBjb25zdCBuZXdIZWlnaHQgPSB2dGtNYXRoLm5lYXJlc3RQb3dlck9mVHdvKGhlaWdodCk7XG4gICAgICBjb25zdCBwaXhDb3VudCA9IG5ld1dpZHRoICogbmV3SGVpZ2h0ICogbW9kZWwuY29tcG9uZW50cztcbiAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGRhdGEubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAoZGF0YVtpZHhdICE9PSBudWxsKSB7XG4gICAgICAgICAgbGV0IG5ld0FycmF5ID0gbnVsbDtcbiAgICAgICAgICBzd2l0Y2ggKG1vZGVsLm9wZW5HTERhdGFUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIG1vZGVsLmNvbnRleHQuRkxPQVQ6XG4gICAgICAgICAgICAgIG5ld0FycmF5ID0gbmV3IEZsb2F0MzJBcnJheShwaXhDb3VudCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhc2UgbW9kZWwuY29udGV4dC5VTlNJR05FRF9CWVRFOlxuICAgICAgICAgICAgICBuZXdBcnJheSA9IG5ldyBVaW50OEFycmF5KHBpeENvdW50KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGpGYWN0b3IgPSBoZWlnaHQgLyBuZXdIZWlnaHQ7XG4gICAgICAgICAgY29uc3QgaUZhY3RvciA9IHdpZHRoIC8gbmV3V2lkdGg7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuZXdIZWlnaHQ7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgam9mZiA9IGogKiBuZXdXaWR0aCAqIG51bUNvbXBzO1xuICAgICAgICAgICAgY29uc3QgamlkeCA9IGogKiBqRmFjdG9yO1xuICAgICAgICAgICAgbGV0IGpsb3cgPSBNYXRoLmZsb29yKGppZHgpO1xuICAgICAgICAgICAgbGV0IGpoaSA9IE1hdGguY2VpbChqaWR4KTtcbiAgICAgICAgICAgIGlmIChqaGkgPj0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgIGpoaSA9IGhlaWdodCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBqbWl4ID0gamlkeCAtIGpsb3c7XG4gICAgICAgICAgICBjb25zdCBqbWl4MSA9IDEuMCAtIGptaXg7XG4gICAgICAgICAgICBqbG93ID0gamxvdyAqIHdpZHRoICogbnVtQ29tcHM7XG4gICAgICAgICAgICBqaGkgPSBqaGkgKiB3aWR0aCAqIG51bUNvbXBzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXdXaWR0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGlvZmYgPSBpICogbnVtQ29tcHM7XG4gICAgICAgICAgICAgIGNvbnN0IGlpZHggPSBpICogaUZhY3RvcjtcbiAgICAgICAgICAgICAgbGV0IGlsb3cgPSBNYXRoLmZsb29yKGlpZHgpO1xuICAgICAgICAgICAgICBsZXQgaWhpID0gTWF0aC5jZWlsKGlpZHgpO1xuICAgICAgICAgICAgICBpZiAoaWhpID49IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgaWhpID0gd2lkdGggLSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IGltaXggPSBpaWR4IC0gaWxvdztcbiAgICAgICAgICAgICAgaWxvdyAqPSBudW1Db21wcztcbiAgICAgICAgICAgICAgaWhpICo9IG51bUNvbXBzO1xuICAgICAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IG51bUNvbXBzOyBjKyspIHtcbiAgICAgICAgICAgICAgICBuZXdBcnJheVtqb2ZmICsgaW9mZiArIGNdID1cbiAgICAgICAgICAgICAgICAgIGRhdGFbaWR4XVtqbG93ICsgaWxvdyArIGNdICogam1peDEgKiAoMS4wIC0gaW1peCkgK1xuICAgICAgICAgICAgICAgICAgZGF0YVtpZHhdW2psb3cgKyBpaGkgKyBjXSAqIGptaXgxICogaW1peCArXG4gICAgICAgICAgICAgICAgICBkYXRhW2lkeF1bamhpICsgaWxvdyArIGNdICogam1peCAqICgxLjAgLSBpbWl4KSArXG4gICAgICAgICAgICAgICAgICBkYXRhW2lkeF1bamhpICsgaWhpICsgY10gKiBqbWl4ICogaW1peDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwaXhEYXRhLnB1c2gobmV3QXJyYXkpO1xuICAgICAgICAgIG1vZGVsLndpZHRoID0gbmV3V2lkdGg7XG4gICAgICAgICAgbW9kZWwuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBpeERhdGEucHVzaChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZSBvdXRwdXQgaGFzIHRvIGJlIGZpbGxlZFxuICAgIGlmIChwaXhEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBpeERhdGEucHVzaChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGl4RGF0YTtcbiAgfVxuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuY3JlYXRlMkRGcm9tUmF3ID0gKHdpZHRoLCBoZWlnaHQsIG51bUNvbXBzLCBkYXRhVHlwZSwgZGF0YSkgPT4ge1xuICAgIC8vIE5vdyBkZXRlcm1pbmUgdGhlIHRleHR1cmUgcGFyYW1ldGVycyB1c2luZyB0aGUgYXJndW1lbnRzLlxuICAgIHB1YmxpY0FQSS5nZXRPcGVuR0xEYXRhVHlwZShkYXRhVHlwZSk7XG4gICAgcHVibGljQVBJLmdldEludGVybmFsRm9ybWF0KGRhdGFUeXBlLCBudW1Db21wcyk7XG4gICAgcHVibGljQVBJLmdldEZvcm1hdChkYXRhVHlwZSwgbnVtQ29tcHMpO1xuXG4gICAgaWYgKCFtb2RlbC5pbnRlcm5hbEZvcm1hdCB8fCAhbW9kZWwuZm9ybWF0IHx8ICFtb2RlbC5vcGVuR0xEYXRhVHlwZSkge1xuICAgICAgdnRrRXJyb3JNYWNybygnRmFpbGVkIHRvIGRldGVybWluZSB0ZXh0dXJlIHBhcmFtZXRlcnMuJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbW9kZWwudGFyZ2V0ID0gbW9kZWwuY29udGV4dC5URVhUVVJFXzJEO1xuICAgIG1vZGVsLmNvbXBvbmVudHMgPSBudW1Db21wcztcbiAgICBtb2RlbC53aWR0aCA9IHdpZHRoO1xuICAgIG1vZGVsLmhlaWdodCA9IGhlaWdodDtcbiAgICBtb2RlbC5kZXB0aCA9IDE7XG4gICAgbW9kZWwubnVtYmVyT2ZEaW1lbnNpb25zID0gMjtcbiAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuYWN0aXZhdGVUZXh0dXJlKHB1YmxpY0FQSSk7XG4gICAgcHVibGljQVBJLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBwdWJsaWNBUEkuYmluZCgpO1xuXG4gICAgLy8gQ3JlYXRlIGFuIGFycmF5IG9mIHRleHR1cmUgd2l0aCBvbmUgdGV4dHVyZVxuICAgIGNvbnN0IGRhdGFBcnJheSA9IFtkYXRhXTtcbiAgICBjb25zdCBwaXhEYXRhID0gdXBkYXRlQXJyYXlEYXRhVHlwZShkYXRhVHlwZSwgZGF0YUFycmF5KTtcbiAgICBjb25zdCBzY2FsZWREYXRhID0gc2NhbGVUZXh0dXJlVG9IaWdoZXN0UG93ZXJPZlR3byhwaXhEYXRhKTtcblxuICAgIC8vIFNvdXJjZSB0ZXh0dXJlIGRhdGEgZnJvbSB0aGUgUEJPLlxuICAgIC8vIG1vZGVsLmNvbnRleHQucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG4gICAgbW9kZWwuY29udGV4dC5waXhlbFN0b3JlaShtb2RlbC5jb250ZXh0LlVOUEFDS19BTElHTk1FTlQsIDEpO1xuXG4gICAgbW9kZWwuY29udGV4dC50ZXhJbWFnZTJEKFxuICAgICAgbW9kZWwudGFyZ2V0LFxuICAgICAgMCxcbiAgICAgIG1vZGVsLmludGVybmFsRm9ybWF0LFxuICAgICAgbW9kZWwud2lkdGgsXG4gICAgICBtb2RlbC5oZWlnaHQsXG4gICAgICAwLFxuICAgICAgbW9kZWwuZm9ybWF0LFxuICAgICAgbW9kZWwub3BlbkdMRGF0YVR5cGUsXG4gICAgICBzY2FsZWREYXRhWzBdXG4gICAgKTtcblxuICAgIGlmIChtb2RlbC5nZW5lcmF0ZU1pcG1hcCkge1xuICAgICAgbW9kZWwuY29udGV4dC5nZW5lcmF0ZU1pcG1hcChtb2RlbC50YXJnZXQpO1xuICAgIH1cblxuICAgIHB1YmxpY0FQSS5kZWFjdGl2YXRlKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5jcmVhdGVDdWJlRnJvbVJhdyA9ICh3aWR0aCwgaGVpZ2h0LCBudW1Db21wcywgZGF0YVR5cGUsIGRhdGEpID0+IHtcbiAgICAvLyBOb3cgZGV0ZXJtaW5lIHRoZSB0ZXh0dXJlIHBhcmFtZXRlcnMgdXNpbmcgdGhlIGFyZ3VtZW50cy5cbiAgICBwdWJsaWNBUEkuZ2V0T3BlbkdMRGF0YVR5cGUoZGF0YVR5cGUpO1xuICAgIHB1YmxpY0FQSS5nZXRJbnRlcm5hbEZvcm1hdChkYXRhVHlwZSwgbnVtQ29tcHMpO1xuICAgIHB1YmxpY0FQSS5nZXRGb3JtYXQoZGF0YVR5cGUsIG51bUNvbXBzKTtcblxuICAgIGlmICghbW9kZWwuaW50ZXJuYWxGb3JtYXQgfHwgIW1vZGVsLmZvcm1hdCB8fCAhbW9kZWwub3BlbkdMRGF0YVR5cGUpIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oJ0ZhaWxlZCB0byBkZXRlcm1pbmUgdGV4dHVyZSBwYXJhbWV0ZXJzLicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1vZGVsLnRhcmdldCA9IG1vZGVsLmNvbnRleHQuVEVYVFVSRV9DVUJFX01BUDtcbiAgICBtb2RlbC5jb21wb25lbnRzID0gbnVtQ29tcHM7XG4gICAgbW9kZWwud2lkdGggPSB3aWR0aDtcbiAgICBtb2RlbC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgbW9kZWwuZGVwdGggPSAxO1xuICAgIG1vZGVsLm51bWJlck9mRGltZW5zaW9ucyA9IDI7XG4gICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmFjdGl2YXRlVGV4dHVyZShwdWJsaWNBUEkpO1xuICAgIG1vZGVsLm1heExldmVsID0gZGF0YS5sZW5ndGggLyA2IC0gMTtcbiAgICBwdWJsaWNBUEkuY3JlYXRlVGV4dHVyZSgpO1xuICAgIHB1YmxpY0FQSS5iaW5kKCk7XG5cbiAgICBjb25zdCBwaXhEYXRhID0gdXBkYXRlQXJyYXlEYXRhVHlwZShkYXRhVHlwZSwgZGF0YSk7XG4gICAgY29uc3Qgc2NhbGVkRGF0YSA9IHNjYWxlVGV4dHVyZVRvSGlnaGVzdFBvd2VyT2ZUd28ocGl4RGF0YSk7XG5cbiAgICAvLyBpbnZlcnQgdGhlIGRhdGEgYmVjYXVzZSBvcGVuZ2wgaXMgbWVzc2VkIHVwIHdpdGggY3ViZSBtYXBzXG4gICAgLy8gYW5kIHVzZXMgdGhlIG9sZCByZW5kZXJtYW4gc3RhbmRhcmQgd2l0aCBZIGdvaW5nIGRvd25cbiAgICAvLyBldmVuIHRob3VnaCBpdCBpcyBjb21wbGV0ZWx5IGF0IG9kZHMgd2l0aCBPcGVuR0wgc3RhbmRhcmRzXG4gICAgY29uc3QgaW52ZXJ0ZWREYXRhID0gW107XG4gICAgbGV0IHdpZHRoTGV2ZWwgPSBtb2RlbC53aWR0aDtcbiAgICBsZXQgaGVpZ2h0TGV2ZWwgPSBtb2RlbC5oZWlnaHQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzY2FsZWREYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSAlIDYgPT09IDAgJiYgaSAhPT0gMCkge1xuICAgICAgICB3aWR0aExldmVsIC89IDI7XG4gICAgICAgIGhlaWdodExldmVsIC89IDI7XG4gICAgICB9XG4gICAgICBpbnZlcnRlZERhdGFbaV0gPSBuZXcgd2luZG93W2RhdGFUeXBlXShcbiAgICAgICAgaGVpZ2h0TGV2ZWwgKiB3aWR0aExldmVsICogbW9kZWwuY29tcG9uZW50c1xuICAgICAgKTtcbiAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0TGV2ZWw7ICsreSkge1xuICAgICAgICBjb25zdCByb3cxID0geSAqIHdpZHRoTGV2ZWwgKiBtb2RlbC5jb21wb25lbnRzO1xuICAgICAgICBjb25zdCByb3cyID0gKGhlaWdodExldmVsIC0geSAtIDEpICogd2lkdGhMZXZlbCAqIG1vZGVsLmNvbXBvbmVudHM7XG4gICAgICAgIGludmVydGVkRGF0YVtpXS5zZXQoXG4gICAgICAgICAgc2NhbGVkRGF0YVtpXS5zbGljZShyb3cyLCByb3cyICsgd2lkdGhMZXZlbCAqIG1vZGVsLmNvbXBvbmVudHMpLFxuICAgICAgICAgIHJvdzFcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb3VyY2UgdGV4dHVyZSBkYXRhIGZyb20gdGhlIFBCTy5cbiAgICBtb2RlbC5jb250ZXh0LnBpeGVsU3RvcmVpKG1vZGVsLmNvbnRleHQuVU5QQUNLX0FMSUdOTUVOVCwgMSk7XG5cbiAgICAvLyBXZSBnZXQgdGhlIDYgaW1hZ2VzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgIC8vIEZvciBlYWNoIG1pcG1hcCBsZXZlbFxuICAgICAgbGV0IGogPSAwO1xuICAgICAgbGV0IHcgPSBtb2RlbC53aWR0aDtcbiAgICAgIGxldCBoID0gbW9kZWwuaGVpZ2h0O1xuICAgICAgd2hpbGUgKHcgPj0gMSAmJiBoID49IDEpIHtcbiAgICAgICAgLy8gSW4gd2ViZ2wgMSwgYWxsIGxldmVscyBuZWVkIHRvIGJlIGRlZmluZWQuIFNvIGlmIHRoZSBsYXRlc3QgbGV2ZWwgc2l6ZSBpc1xuICAgICAgICAvLyA4eDgsIHdlIGhhdmUgdG8gYWRkIDMgbW9yZSBudWxsIHRleHR1cmVzICg0eDQsIDJ4MiwgMXgxKVxuICAgICAgICAvLyBJbiB3ZWJnbCAyLCB0aGUgYXR0cmlidXRlIG1heExldmVsIHdpbGwgYmUgdXNlLlxuICAgICAgICBsZXQgdGVtcERhdGEgPSBudWxsO1xuICAgICAgICBpZiAoaiA8PSBtb2RlbC5tYXhMZXZlbCkge1xuICAgICAgICAgIHRlbXBEYXRhID0gaW52ZXJ0ZWREYXRhWzYgKiBqICsgaV07XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuY29udGV4dC50ZXhJbWFnZTJEKFxuICAgICAgICAgIG1vZGVsLmNvbnRleHQuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSxcbiAgICAgICAgICBqLFxuICAgICAgICAgIG1vZGVsLmludGVybmFsRm9ybWF0LFxuICAgICAgICAgIHcsXG4gICAgICAgICAgaCxcbiAgICAgICAgICAwLFxuICAgICAgICAgIG1vZGVsLmZvcm1hdCxcbiAgICAgICAgICBtb2RlbC5vcGVuR0xEYXRhVHlwZSxcbiAgICAgICAgICB0ZW1wRGF0YVxuICAgICAgICApO1xuICAgICAgICBqKys7XG4gICAgICAgIHcgLz0gMjtcbiAgICAgICAgaCAvPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGdlbmVyYXRlTWlwbWFwIG11c3Qgbm90IGJlIGNhbGxlZCBoZXJlIGJlY2F1c2Ugd2UgbWFudWFsbHkgdXBsb2FkIGFsbCBsZXZlbHNcbiAgICAvLyBpZiBpdCBpcyBjYWxsZWQsIGFsbCBsZXZlbHMgd2lsbCBiZSBvdmVyd3JpdHRlblxuXG4gICAgcHVibGljQVBJLmRlYWN0aXZhdGUoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmNyZWF0ZURlcHRoRnJvbVJhdyA9ICh3aWR0aCwgaGVpZ2h0LCBkYXRhVHlwZSwgZGF0YSkgPT4ge1xuICAgIC8vIE5vdyBkZXRlcm1pbmUgdGhlIHRleHR1cmUgcGFyYW1ldGVycyB1c2luZyB0aGUgYXJndW1lbnRzLlxuICAgIHB1YmxpY0FQSS5nZXRPcGVuR0xEYXRhVHlwZShkYXRhVHlwZSk7XG4gICAgbW9kZWwuZm9ybWF0ID0gbW9kZWwuY29udGV4dC5ERVBUSF9DT01QT05FTlQ7XG4gICAgaWYgKG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRXZWJnbDIoKSkge1xuICAgICAgaWYgKGRhdGFUeXBlID09PSBWdGtEYXRhVHlwZXMuRkxPQVQpIHtcbiAgICAgICAgbW9kZWwuaW50ZXJuYWxGb3JtYXQgPSBtb2RlbC5jb250ZXh0LkRFUFRIX0NPTVBPTkVOVDMyRjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGVsLmludGVybmFsRm9ybWF0ID0gbW9kZWwuY29udGV4dC5ERVBUSF9DT01QT05FTlQxNjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWwuaW50ZXJuYWxGb3JtYXQgPSBtb2RlbC5jb250ZXh0LkRFUFRIX0NPTVBPTkVOVDtcbiAgICB9XG5cbiAgICBpZiAoIW1vZGVsLmludGVybmFsRm9ybWF0IHx8ICFtb2RlbC5mb3JtYXQgfHwgIW1vZGVsLm9wZW5HTERhdGFUeXBlKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKCdGYWlsZWQgdG8gZGV0ZXJtaW5lIHRleHR1cmUgcGFyYW1ldGVycy4nKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBtb2RlbC50YXJnZXQgPSBtb2RlbC5jb250ZXh0LlRFWFRVUkVfMkQ7XG4gICAgbW9kZWwuY29tcG9uZW50cyA9IDE7XG4gICAgbW9kZWwud2lkdGggPSB3aWR0aDtcbiAgICBtb2RlbC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgbW9kZWwuZGVwdGggPSAxO1xuICAgIG1vZGVsLm51bWJlck9mRGltZW5zaW9ucyA9IDI7XG4gICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmFjdGl2YXRlVGV4dHVyZShwdWJsaWNBUEkpO1xuICAgIHB1YmxpY0FQSS5jcmVhdGVUZXh0dXJlKCk7XG4gICAgcHVibGljQVBJLmJpbmQoKTtcblxuICAgIC8vIFNvdXJjZSB0ZXh0dXJlIGRhdGEgZnJvbSB0aGUgUEJPLlxuICAgIC8vIG1vZGVsLmNvbnRleHQucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG4gICAgbW9kZWwuY29udGV4dC5waXhlbFN0b3JlaShtb2RlbC5jb250ZXh0LlVOUEFDS19BTElHTk1FTlQsIDEpO1xuXG4gICAgbW9kZWwuY29udGV4dC50ZXhJbWFnZTJEKFxuICAgICAgbW9kZWwudGFyZ2V0LFxuICAgICAgMCxcbiAgICAgIG1vZGVsLmludGVybmFsRm9ybWF0LFxuICAgICAgbW9kZWwud2lkdGgsXG4gICAgICBtb2RlbC5oZWlnaHQsXG4gICAgICAwLFxuICAgICAgbW9kZWwuZm9ybWF0LFxuICAgICAgbW9kZWwub3BlbkdMRGF0YVR5cGUsXG4gICAgICBkYXRhXG4gICAgKTtcblxuICAgIGlmIChtb2RlbC5nZW5lcmF0ZU1pcG1hcCkge1xuICAgICAgbW9kZWwuY29udGV4dC5nZW5lcmF0ZU1pcG1hcChtb2RlbC50YXJnZXQpO1xuICAgIH1cblxuICAgIHB1YmxpY0FQSS5kZWFjdGl2YXRlKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5jcmVhdGUyREZyb21JbWFnZSA9IChpbWFnZSkgPT4ge1xuICAgIC8vIE5vdyBkZXRlcm1pbmUgdGhlIHRleHR1cmUgcGFyYW1ldGVycyB1c2luZyB0aGUgYXJndW1lbnRzLlxuICAgIHB1YmxpY0FQSS5nZXRPcGVuR0xEYXRhVHlwZShWdGtEYXRhVHlwZXMuVU5TSUdORURfQ0hBUik7XG4gICAgcHVibGljQVBJLmdldEludGVybmFsRm9ybWF0KFZ0a0RhdGFUeXBlcy5VTlNJR05FRF9DSEFSLCA0KTtcbiAgICBwdWJsaWNBUEkuZ2V0Rm9ybWF0KFZ0a0RhdGFUeXBlcy5VTlNJR05FRF9DSEFSLCA0KTtcblxuICAgIGlmICghbW9kZWwuaW50ZXJuYWxGb3JtYXQgfHwgIW1vZGVsLmZvcm1hdCB8fCAhbW9kZWwub3BlbkdMRGF0YVR5cGUpIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oJ0ZhaWxlZCB0byBkZXRlcm1pbmUgdGV4dHVyZSBwYXJhbWV0ZXJzLicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1vZGVsLnRhcmdldCA9IG1vZGVsLmNvbnRleHQuVEVYVFVSRV8yRDtcbiAgICBtb2RlbC5jb21wb25lbnRzID0gNDtcbiAgICBtb2RlbC53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIG1vZGVsLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICBtb2RlbC5kZXB0aCA9IDE7XG4gICAgbW9kZWwubnVtYmVyT2ZEaW1lbnNpb25zID0gMjtcbiAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuYWN0aXZhdGVUZXh0dXJlKHB1YmxpY0FQSSk7XG4gICAgcHVibGljQVBJLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBwdWJsaWNBUEkuYmluZCgpO1xuXG4gICAgLy8gU291cmNlIHRleHR1cmUgZGF0YSBmcm9tIHRoZSBQQk8uXG4gICAgLy8gbW9kZWwuY29udGV4dC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcbiAgICBtb2RlbC5jb250ZXh0LnBpeGVsU3RvcmVpKG1vZGVsLmNvbnRleHQuVU5QQUNLX0FMSUdOTUVOVCwgMSk7XG5cbiAgICAvLyBTY2FsZSB1cCB0aGUgdGV4dHVyZSB0byB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIHR3byBkaW1lbnNpb25zIChpZiBuZWVkZWQpIGFuZCBmbGlwIHkuXG4gICAgY29uc3QgbmVlZE5lYXJlc3RQb3dlck9mVHdvID1cbiAgICAgICF2dGtNYXRoLmlzUG93ZXJPZlR3byhpbWFnZS53aWR0aCkgfHwgIXZ0a01hdGguaXNQb3dlck9mVHdvKGltYWdlLmhlaWdodCk7XG4gICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gbmVlZE5lYXJlc3RQb3dlck9mVHdvXG4gICAgICA/IHZ0a01hdGgubmVhcmVzdFBvd2VyT2ZUd28oaW1hZ2Uud2lkdGgpXG4gICAgICA6IGltYWdlLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBuZWVkTmVhcmVzdFBvd2VyT2ZUd29cbiAgICAgID8gdnRrTWF0aC5uZWFyZXN0UG93ZXJPZlR3byhpbWFnZS5oZWlnaHQpXG4gICAgICA6IGltYWdlLmhlaWdodDtcbiAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjdHgudHJhbnNsYXRlKDAsIGNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgY3R4LmRyYXdJbWFnZShcbiAgICAgIGltYWdlLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICBpbWFnZS53aWR0aCxcbiAgICAgIGltYWdlLmhlaWdodCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgY2FudmFzLndpZHRoLFxuICAgICAgY2FudmFzLmhlaWdodFxuICAgICk7XG4gICAgLy8gSW4gQ2hyb21lIDY5IG9uIFdpbmRvd3MgYW5kIFVidW50dSwgdGhlcmUgaXMgYSBidWcgdGhhdCBwcmV2ZW50cyBzb21lXG4gICAgLy8gY2FudmFzZXMgZnJvbSB3b3JraW5nIHByb3Blcmx5IHdpdGggd2ViR0wgdGV4dHVyZXMuICBCeSBnZXR0aW5nIGFueVxuICAgIC8vIGltYWdlIGRhdGEgZnJvbSB0aGUgY2FudmFzLCB0aGlzIHdvcmtzIGFyb3VuZCB0aGUgYnVnLiAgU2VlXG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODk2MzA3XG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lLzY5JykgPj0gMCkge1xuICAgICAgY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKTtcbiAgICB9XG4gICAgY29uc3Qgc2FmZUltYWdlID0gY2FudmFzO1xuXG4gICAgbW9kZWwuY29udGV4dC50ZXhJbWFnZTJEKFxuICAgICAgbW9kZWwudGFyZ2V0LFxuICAgICAgMCxcbiAgICAgIG1vZGVsLmludGVybmFsRm9ybWF0LFxuICAgICAgbW9kZWwuZm9ybWF0LFxuICAgICAgbW9kZWwub3BlbkdMRGF0YVR5cGUsXG4gICAgICBzYWZlSW1hZ2VcbiAgICApO1xuXG4gICAgaWYgKG1vZGVsLmdlbmVyYXRlTWlwbWFwKSB7XG4gICAgICBtb2RlbC5jb250ZXh0LmdlbmVyYXRlTWlwbWFwKG1vZGVsLnRhcmdldCk7XG4gICAgfVxuXG4gICAgcHVibGljQVBJLmRlYWN0aXZhdGUoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgcHVibGljQVBJLmNyZWF0ZTNERnJvbVJhdyA9IChcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgZGVwdGgsXG4gICAgbnVtQ29tcHMsXG4gICAgZGF0YVR5cGUsXG4gICAgZGF0YVxuICApID0+IHtcbiAgICAvLyBOb3cgZGV0ZXJtaW5lIHRoZSB0ZXh0dXJlIHBhcmFtZXRlcnMgdXNpbmcgdGhlIGFyZ3VtZW50cy5cbiAgICBwdWJsaWNBUEkuZ2V0T3BlbkdMRGF0YVR5cGUoZGF0YVR5cGUpO1xuICAgIHB1YmxpY0FQSS5nZXRJbnRlcm5hbEZvcm1hdChkYXRhVHlwZSwgbnVtQ29tcHMpO1xuICAgIHB1YmxpY0FQSS5nZXRGb3JtYXQoZGF0YVR5cGUsIG51bUNvbXBzKTtcblxuICAgIGlmICghbW9kZWwuaW50ZXJuYWxGb3JtYXQgfHwgIW1vZGVsLmZvcm1hdCB8fCAhbW9kZWwub3BlbkdMRGF0YVR5cGUpIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oJ0ZhaWxlZCB0byBkZXRlcm1pbmUgdGV4dHVyZSBwYXJhbWV0ZXJzLicpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG1vZGVsLnRhcmdldCA9IG1vZGVsLmNvbnRleHQuVEVYVFVSRV8zRDtcbiAgICBtb2RlbC5jb21wb25lbnRzID0gbnVtQ29tcHM7XG4gICAgbW9kZWwud2lkdGggPSB3aWR0aDtcbiAgICBtb2RlbC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgbW9kZWwuZGVwdGggPSBkZXB0aDtcbiAgICBtb2RlbC5udW1iZXJPZkRpbWVuc2lvbnMgPSAzO1xuICAgIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5hY3RpdmF0ZVRleHR1cmUocHVibGljQVBJKTtcbiAgICBwdWJsaWNBUEkuY3JlYXRlVGV4dHVyZSgpO1xuICAgIHB1YmxpY0FQSS5iaW5kKCk7XG5cbiAgICAvLyBTb3VyY2UgdGV4dHVyZSBkYXRhIGZyb20gdGhlIFBCTy5cbiAgICAvLyBtb2RlbC5jb250ZXh0LnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuICAgIC8vIG1vZGVsLmNvbnRleHQucGl4ZWxTdG9yZWkobW9kZWwuY29udGV4dC5VTlBBQ0tfQUxJR05NRU5ULCAxKTtcblxuICAgIG1vZGVsLmNvbnRleHQudGV4SW1hZ2UzRChcbiAgICAgIG1vZGVsLnRhcmdldCxcbiAgICAgIDAsXG4gICAgICBtb2RlbC5pbnRlcm5hbEZvcm1hdCxcbiAgICAgIG1vZGVsLndpZHRoLFxuICAgICAgbW9kZWwuaGVpZ2h0LFxuICAgICAgbW9kZWwuZGVwdGgsXG4gICAgICAwLFxuICAgICAgbW9kZWwuZm9ybWF0LFxuICAgICAgbW9kZWwub3BlbkdMRGF0YVR5cGUsXG4gICAgICBkYXRhXG4gICAgKTtcblxuICAgIGlmIChtb2RlbC5nZW5lcmF0ZU1pcG1hcCkge1xuICAgICAgbW9kZWwuY29udGV4dC5nZW5lcmF0ZU1pcG1hcChtb2RlbC50YXJnZXQpO1xuICAgIH1cblxuICAgIHB1YmxpY0FQSS5kZWFjdGl2YXRlKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgZnVuY3Rpb24gY29tcHV0ZVNjYWxlT2Zmc2V0cyhudW1Db21wcywgbnVtUGl4ZWxzSW4sIGRhdGEpIHtcbiAgICAvLyBjb21wdXRlIG1pbiBhbmQgbWF4IHZhbHVlcyBwZXIgY29tcG9uZW50XG4gICAgY29uc3QgbWluID0gW107XG4gICAgY29uc3QgbWF4ID0gW107XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBudW1Db21wczsgKytjKSB7XG4gICAgICBtaW5bY10gPSBkYXRhW2NdO1xuICAgICAgbWF4W2NdID0gZGF0YVtjXTtcbiAgICB9XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBpeGVsc0luOyArK2kpIHtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgbnVtQ29tcHM7ICsrYykge1xuICAgICAgICBpZiAoZGF0YVtjb3VudF0gPCBtaW5bY10pIHtcbiAgICAgICAgICBtaW5bY10gPSBkYXRhW2NvdW50XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVtjb3VudF0gPiBtYXhbY10pIHtcbiAgICAgICAgICBtYXhbY10gPSBkYXRhW2NvdW50XTtcbiAgICAgICAgfVxuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvZmZzZXQgPSBbXTtcbiAgICBjb25zdCBzY2FsZSA9IFtdO1xuICAgIGZvciAobGV0IGMgPSAwOyBjIDwgbnVtQ29tcHM7ICsrYykge1xuICAgICAgaWYgKG1pbltjXSA9PT0gbWF4W2NdKSB7XG4gICAgICAgIG1heFtjXSA9IG1pbltjXSArIDEuMDtcbiAgICAgIH1cbiAgICAgIG9mZnNldFtjXSA9IG1pbltjXTtcbiAgICAgIHNjYWxlW2NdID0gbWF4W2NdIC0gbWluW2NdO1xuICAgIH1cbiAgICByZXR1cm4geyBzY2FsZSwgb2Zmc2V0IH07XG4gIH1cblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gVGhpcyBtZXRob2Qgc2ltdWxhdGVzIGEgM0QgdGV4dHVyZSB1c2luZyAyRFxuICBwdWJsaWNBUEkuY3JlYXRlM0RGaWx0ZXJhYmxlRnJvbVJhdyA9IChcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgZGVwdGgsXG4gICAgbnVtQ29tcHMsXG4gICAgZGF0YVR5cGUsXG4gICAgZGF0YVxuICApID0+IHtcbiAgICBjb25zdCBudW1QaXhlbHNJbiA9IHdpZHRoICogaGVpZ2h0ICogZGVwdGg7XG5cbiAgICAvLyBpbml0aWFsaXplIG9mZnNldC9zY2FsZVxuICAgIGNvbnN0IG9mZnNldCA9IFtdO1xuICAgIGNvbnN0IHNjYWxlID0gW107XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBudW1Db21wczsgKytjKSB7XG4gICAgICBvZmZzZXRbY10gPSAwLjA7XG4gICAgICBzY2FsZVtjXSA9IDEuMDtcbiAgICB9XG5cbiAgICAvLyBzdG9yZSB0aGUgaW5mb3JtYXRpb24sIHdlIHdpbGwgbmVlZCBpdCBsYXRlclxuICAgIC8vIG9mZnNldCBhbmQgc2NhbGUgYXJlIHRoZSBvZmZzZXQgYW5kIHNjYWxlIHJlcXVpcmVkIHRvIGdldFxuICAgIC8vIHRoZSB0ZXh0dXJlIHZhbHVlIGJhY2sgdG8gZGF0YSB2YWx1ZXMgYWxhXG4gICAgLy8gZGF0YSA9IHRleHR1cmUgKiBzY2FsZSArIG9mZnNldFxuICAgIC8vIGFuZCB0ZXh0dXJlID0gKGRhdGEgLSBvZmZzZXQpL3NjYWxlXG4gICAgbW9kZWwudm9sdW1lSW5mbyA9IHsgc2NhbGUsIG9mZnNldCwgd2lkdGgsIGhlaWdodCwgZGVwdGggfTtcblxuICAgIC8vIFdlYkdMMiBwYXRoLCB3ZSBoYXZlIDNkIHRleHR1cmVzIGV0Y1xuICAgIGlmIChtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0V2ViZ2wyKCkpIHtcbiAgICAgIGlmIChkYXRhVHlwZSA9PT0gVnRrRGF0YVR5cGVzLkZMT0FUKSB7XG4gICAgICAgIHJldHVybiBwdWJsaWNBUEkuY3JlYXRlM0RGcm9tUmF3KFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBkZXB0aCxcbiAgICAgICAgICBudW1Db21wcyxcbiAgICAgICAgICBkYXRhVHlwZSxcbiAgICAgICAgICBkYXRhXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YVR5cGUgPT09IFZ0a0RhdGFUeXBlcy5VTlNJR05FRF9DSEFSKSB7XG4gICAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgbnVtQ29tcHM7ICsrYykge1xuICAgICAgICAgIG1vZGVsLnZvbHVtZUluZm8uc2NhbGVbY10gPSAyNTUuMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHVibGljQVBJLmNyZWF0ZTNERnJvbVJhdyhcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgZGVwdGgsXG4gICAgICAgICAgbnVtQ29tcHMsXG4gICAgICAgICAgZGF0YVR5cGUsXG4gICAgICAgICAgZGF0YVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgLy8gb3RoZXJ3aXNlIGNvbnZlcnQgdG8gZmxvYXRcbiAgICAgIGNvbnN0IG5ld0FycmF5ID0gbmV3IEZsb2F0MzJBcnJheShudW1QaXhlbHNJbiAqIG51bUNvbXBzKTtcbiAgICAgIC8vIGNvbXB1dGUgbWluIGFuZCBtYXggdmFsdWVzXG4gICAgICBjb25zdCByZXMgPSBjb21wdXRlU2NhbGVPZmZzZXRzKG51bUNvbXBzLCBudW1QaXhlbHNJbiwgZGF0YSk7XG4gICAgICBtb2RlbC52b2x1bWVJbmZvLm9mZnNldCA9IHJlcy5vZmZzZXQ7XG4gICAgICBtb2RlbC52b2x1bWVJbmZvLnNjYWxlID0gcmVzLnNjYWxlO1xuICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUGl4ZWxzSW47ICsraSkge1xuICAgICAgICBmb3IgKGxldCBuYyA9IDA7IG5jIDwgbnVtQ29tcHM7ICsrbmMpIHtcbiAgICAgICAgICBuZXdBcnJheVtjb3VudF0gPVxuICAgICAgICAgICAgKGRhdGFbY291bnRdIC0gbW9kZWwudm9sdW1lSW5mby5vZmZzZXRbbmNdKSAvXG4gICAgICAgICAgICBtb2RlbC52b2x1bWVJbmZvLnNjYWxlW25jXTtcbiAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVibGljQVBJLmNyZWF0ZTNERnJvbVJhdyhcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgZGVwdGgsXG4gICAgICAgIG51bUNvbXBzLFxuICAgICAgICBWdGtEYXRhVHlwZXMuRkxPQVQsXG4gICAgICAgIG5ld0FycmF5XG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIG5vdCB3ZWJnbDIsIGRlYWwgd2l0aCB3ZWJnbDEsIG5vIDNkIHRleHR1cmVzXG4gICAgLy8gYW5kIG1heWJlIG5vIGZsb2F0IHRleHR1cmVzXG5cbiAgICAvLyBjb21wdXRlIG1pbiBhbmQgbWF4IHZhbHVlc1xuICAgIGNvbnN0IHJlcyA9IGNvbXB1dGVTY2FsZU9mZnNldHMobnVtQ29tcHMsIG51bVBpeGVsc0luLCBkYXRhKTtcblxuICAgIGxldCB2b2xDb3B5RGF0YSA9IChvdXRBcnJheSwgb3V0SWR4LCBpblZhbHVlLCBzbWluLCBzbWF4KSA9PiB7XG4gICAgICBvdXRBcnJheVtvdXRJZHhdID0gaW5WYWx1ZTtcbiAgICB9O1xuICAgIGxldCBkYXRhVHlwZVRvVXNlID0gVnRrRGF0YVR5cGVzLlVOU0lHTkVEX0NIQVI7XG4gICAgLy8gdW5zaWduZWQgY2hhciBnZXRzIHVzZWQgYXMgaXNcbiAgICBpZiAoZGF0YVR5cGUgPT09IFZ0a0RhdGFUeXBlcy5VTlNJR05FRF9DSEFSKSB7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IG51bUNvbXBzOyArK2MpIHtcbiAgICAgICAgcmVzLm9mZnNldFtjXSA9IDAuMDtcbiAgICAgICAgcmVzLnNjYWxlW2NdID0gMjU1LjA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIG1vZGVsLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpICYmXG4gICAgICBtb2RlbC5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJylcbiAgICApIHtcbiAgICAgIC8vIHVzZSBmbG9hdCB0ZXh0dXJlcyBzY2FsZWQgdG8gMC4wIHRvIDEuMFxuICAgICAgZGF0YVR5cGVUb1VzZSA9IFZ0a0RhdGFUeXBlcy5GTE9BVDtcbiAgICAgIHZvbENvcHlEYXRhID0gKG91dEFycmF5LCBvdXRJZHgsIGluVmFsdWUsIHNvZmZzZXQsIHNzY2FsZSkgPT4ge1xuICAgICAgICBvdXRBcnJheVtvdXRJZHhdID0gKGluVmFsdWUgLSBzb2Zmc2V0KSAvIHNzY2FsZTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdvcnN0IGNhc2UsIHNjYWxlIGRhdGEgdG8gdWNoYXJcbiAgICAgIGRhdGFUeXBlVG9Vc2UgPSBWdGtEYXRhVHlwZXMuVU5TSUdORURfQ0hBUjtcbiAgICAgIHZvbENvcHlEYXRhID0gKG91dEFycmF5LCBvdXRJZHgsIGluVmFsdWUsIHNvZmZzZXQsIHNzY2FsZSkgPT4ge1xuICAgICAgICBvdXRBcnJheVtvdXRJZHhdID0gKDI1NS4wICogKGluVmFsdWUgLSBzb2Zmc2V0KSkgLyBzc2NhbGU7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIE5vdyBkZXRlcm1pbmUgdGhlIHRleHR1cmUgcGFyYW1ldGVycyB1c2luZyB0aGUgYXJndW1lbnRzLlxuICAgIHB1YmxpY0FQSS5nZXRPcGVuR0xEYXRhVHlwZShkYXRhVHlwZVRvVXNlKTtcbiAgICBwdWJsaWNBUEkuZ2V0SW50ZXJuYWxGb3JtYXQoZGF0YVR5cGVUb1VzZSwgbnVtQ29tcHMpO1xuICAgIHB1YmxpY0FQSS5nZXRGb3JtYXQoZGF0YVR5cGVUb1VzZSwgbnVtQ29tcHMpO1xuXG4gICAgaWYgKCFtb2RlbC5pbnRlcm5hbEZvcm1hdCB8fCAhbW9kZWwuZm9ybWF0IHx8ICFtb2RlbC5vcGVuR0xEYXRhVHlwZSkge1xuICAgICAgdnRrRXJyb3JNYWNybygnRmFpbGVkIHRvIGRldGVybWluZSB0ZXh0dXJlIHBhcmFtZXRlcnMuJyk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gaGF2ZSB0byBwYWNrIHRoaXMgM0QgdGV4dHVyZSBpbnRvIHBvdCAyRCB0ZXh0dXJlXG4gICAgbW9kZWwudGFyZ2V0ID0gbW9kZWwuY29udGV4dC5URVhUVVJFXzJEO1xuICAgIG1vZGVsLmNvbXBvbmVudHMgPSBudW1Db21wcztcbiAgICBtb2RlbC5kZXB0aCA9IDE7XG4gICAgbW9kZWwubnVtYmVyT2ZEaW1lbnNpb25zID0gMjtcblxuICAgIC8vIE1BWF9URVhUVVJFX1NJWkUgZ2l2ZXMgdGhlIG1heCBkaW1lbnNpb25zIHRoYXQgY2FuIGJlIHN1cHBvcnRlZCBieSB0aGUgR1BVLFxuICAgIC8vIGJ1dCBpdCBkb2Vzbid0IG1lYW4gaXQgd2lsbCBmaXQgaW4gbWVtb3J5LiBJZiB3ZSBoYXZlIHRvIHVzZSBhIGZsb2F0IGRhdGEgdHlwZVxuICAgIC8vIG9yIDQgY29tcG9uZW50cywgdGhlcmUgYXJlIGdvb2QgY2hhbmNlcyB0aGF0IHRoZSB0ZXh0dXJlIHNpemUgd2lsbCBibG93IHVwXG4gICAgLy8gYW5kIGNvdWxkIG5vdCBmaXQgaW4gdGhlIEdQVSBtZW1vcnkuIFVzZSBhIHNtYWxsZXIgdGV4dHVyZSBzaXplIGluIHRoYXQgY2FzZSxcbiAgICAvLyB3aGljaCB3aWxsIGZvcmNlIGEgZG93bnNhbXBsaW5nIG9mIHRoZSBkYXRhc2V0LlxuICAgIC8vIFRoYXQgcHJvYmxlbSBkb2VzIG5vdCBvY2N1ciB3aGVuIHVzaW5nIHdlYkdMMiBzaW5jZSB3ZSBjYW4gcGFjayB0aGUgZGF0YSBpblxuICAgIC8vIGRlbnNlciB0ZXh0dXJlcyBiYXNlZCBvbiBvdXIgZGF0YSB0eXBlLlxuICAgIC8vIFRPRE86IHRyeSB0byBmaXQgaW4gdGhlIGJpZ2dlc3Qgc3VwcG9ydGVkIHRleHR1cmUsIGNhdGNoIHRoZSBnbCBlcnJvciBpZiBpdFxuICAgIC8vIGRvZXMgbm90IGZpeCAoT1VUX09GX01FTU9SWSksIHRoZW4gYXR0ZW1wdCB3aXRoIHNtYWxsZXIgdGV4dHVyZVxuICAgIGxldCBtYXhUZXhEaW0gPSBtb2RlbC5jb250ZXh0LmdldFBhcmFtZXRlcihtb2RlbC5jb250ZXh0Lk1BWF9URVhUVVJFX1NJWkUpO1xuICAgIGlmIChcbiAgICAgIG1heFRleERpbSA+IDQwOTYgJiZcbiAgICAgIChkYXRhVHlwZVRvVXNlID09PSBWdGtEYXRhVHlwZXMuRkxPQVQgfHwgbnVtQ29tcHMgPj0gMylcbiAgICApIHtcbiAgICAgIG1heFRleERpbSA9IDQwOTY7XG4gICAgfVxuXG4gICAgLy8gY29tcHV0ZSBlc3RpbWF0ZSBmb3IgWFkgc3Vic2FtcGxlXG4gICAgbGV0IHhzdHJpZGUgPSAxO1xuICAgIGxldCB5c3RyaWRlID0gMTtcbiAgICBpZiAobnVtUGl4ZWxzSW4gPiBtYXhUZXhEaW0gKiBtYXhUZXhEaW0pIHtcbiAgICAgIHhzdHJpZGUgPSBNYXRoLmNlaWwoTWF0aC5zcXJ0KG51bVBpeGVsc0luIC8gKG1heFRleERpbSAqIG1heFRleERpbSkpKTtcbiAgICAgIHlzdHJpZGUgPSB4c3RyaWRlO1xuICAgIH1cbiAgICBsZXQgdGFyZ2V0V2lkdGggPSBNYXRoLnNxcnQobnVtUGl4ZWxzSW4pIC8geHN0cmlkZTtcbiAgICB0YXJnZXRXaWR0aCA9IHZ0a01hdGgubmVhcmVzdFBvd2VyT2ZUd28odGFyZ2V0V2lkdGgpO1xuICAgIC8vIGRldGVybWluZSBYIHJlcHNcbiAgICBjb25zdCB4cmVwcyA9IE1hdGguZmxvb3IoKHRhcmdldFdpZHRoICogeHN0cmlkZSkgLyB3aWR0aCk7XG4gICAgY29uc3QgeXJlcHMgPSBNYXRoLmNlaWwoZGVwdGggLyB4cmVwcyk7XG4gICAgY29uc3QgdGFyZ2V0SGVpZ2h0ID0gdnRrTWF0aC5uZWFyZXN0UG93ZXJPZlR3bygoaGVpZ2h0ICogeXJlcHMpIC8geXN0cmlkZSk7XG5cbiAgICBtb2RlbC53aWR0aCA9IHRhcmdldFdpZHRoO1xuICAgIG1vZGVsLmhlaWdodCA9IHRhcmdldEhlaWdodDtcbiAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuYWN0aXZhdGVUZXh0dXJlKHB1YmxpY0FQSSk7XG4gICAgcHVibGljQVBJLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBwdWJsaWNBUEkuYmluZCgpO1xuXG4gICAgLy8gc3RvcmUgdGhlIGluZm9ybWF0aW9uLCB3ZSB3aWxsIG5lZWQgaXQgbGF0ZXJcbiAgICBtb2RlbC52b2x1bWVJbmZvLnhyZXBzID0geHJlcHM7XG4gICAgbW9kZWwudm9sdW1lSW5mby55cmVwcyA9IHlyZXBzO1xuICAgIG1vZGVsLnZvbHVtZUluZm8ueHN0cmlkZSA9IHhzdHJpZGU7XG4gICAgbW9kZWwudm9sdW1lSW5mby55c3RyaWRlID0geXN0cmlkZTtcbiAgICBtb2RlbC52b2x1bWVJbmZvLm9mZnNldCA9IHJlcy5vZmZzZXQ7XG4gICAgbW9kZWwudm9sdW1lSW5mby5zY2FsZSA9IHJlcy5zY2FsZTtcblxuICAgIC8vIE9LIHN0dWZmIHRoZSBkYXRhIGludG8gdGhlIDJkIFRFWFRVUkVcblxuICAgIC8vIGZpcnN0IGFsbG9jYXRlIHRoZSBuZXcgdGV4dHVyZVxuICAgIGxldCBuZXdBcnJheTtcbiAgICBjb25zdCBwaXhDb3VudCA9IHRhcmdldFdpZHRoICogdGFyZ2V0SGVpZ2h0ICogbnVtQ29tcHM7XG4gICAgaWYgKGRhdGFUeXBlVG9Vc2UgPT09IFZ0a0RhdGFUeXBlcy5GTE9BVCkge1xuICAgICAgbmV3QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHBpeENvdW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3QXJyYXkgPSBuZXcgVWludDhBcnJheShwaXhDb3VudCk7XG4gICAgfVxuXG4gICAgLy8gdGhlbiBzdHVmZiB0aGUgZGF0YSBpbnRvIGl0LCBub3RoaW5nIGZhbmN5IHJpZ2h0IG5vd1xuICAgIC8vIGZvciBzdHJpZGVcbiAgICBsZXQgb3V0SWR4ID0gMDtcblxuICAgIGNvbnN0IHRpbGVXaWR0aCA9IE1hdGguZmxvb3Iod2lkdGggLyB4c3RyaWRlKTtcbiAgICBjb25zdCB0aWxlSGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQgLyB5c3RyaWRlKTtcblxuICAgIGZvciAobGV0IHlSZXAgPSAwOyB5UmVwIDwgeXJlcHM7IHlSZXArKykge1xuICAgICAgY29uc3QgeHJlcHNUaGlzUm93ID0gTWF0aC5taW4oeHJlcHMsIGRlcHRoIC0geVJlcCAqIHhyZXBzKTtcbiAgICAgIGNvbnN0IG91dFhDb250SW5jciA9XG4gICAgICAgIG51bUNvbXBzICogKG1vZGVsLndpZHRoIC0geHJlcHNUaGlzUm93ICogTWF0aC5mbG9vcih3aWR0aCAvIHhzdHJpZGUpKTtcbiAgICAgIGZvciAobGV0IHRpbGVZID0gMDsgdGlsZVkgPCB0aWxlSGVpZ2h0OyB0aWxlWSsrKSB7XG4gICAgICAgIGZvciAobGV0IHhSZXAgPSAwOyB4UmVwIDwgeHJlcHNUaGlzUm93OyB4UmVwKyspIHtcbiAgICAgICAgICBjb25zdCBpbk9mZnNldCA9XG4gICAgICAgICAgICBudW1Db21wcyAqXG4gICAgICAgICAgICAoKHlSZXAgKiB4cmVwcyArIHhSZXApICogd2lkdGggKiBoZWlnaHQgKyB5c3RyaWRlICogdGlsZVkgKiB3aWR0aCk7XG5cbiAgICAgICAgICBmb3IgKGxldCB0aWxlWCA9IDA7IHRpbGVYIDwgdGlsZVdpZHRoOyB0aWxlWCsrKSB7XG4gICAgICAgICAgICAvLyBjb3B5IHZhbHVlXG4gICAgICAgICAgICBmb3IgKGxldCBuYyA9IDA7IG5jIDwgbnVtQ29tcHM7IG5jKyspIHtcbiAgICAgICAgICAgICAgdm9sQ29weURhdGEoXG4gICAgICAgICAgICAgICAgbmV3QXJyYXksXG4gICAgICAgICAgICAgICAgb3V0SWR4LFxuICAgICAgICAgICAgICAgIGRhdGFbaW5PZmZzZXQgKyB4c3RyaWRlICogdGlsZVggKiBudW1Db21wcyArIG5jXSxcbiAgICAgICAgICAgICAgICByZXMub2Zmc2V0W25jXSxcbiAgICAgICAgICAgICAgICByZXMuc2NhbGVbbmNdXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIG91dElkeCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvdXRJZHggKz0gb3V0WENvbnRJbmNyO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNvdXJjZSB0ZXh0dXJlIGRhdGEgZnJvbSB0aGUgUEJPLlxuICAgIC8vIG1vZGVsLmNvbnRleHQucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG4gICAgbW9kZWwuY29udGV4dC5waXhlbFN0b3JlaShtb2RlbC5jb250ZXh0LlVOUEFDS19BTElHTk1FTlQsIDEpO1xuXG4gICAgbW9kZWwuY29udGV4dC50ZXhJbWFnZTJEKFxuICAgICAgbW9kZWwudGFyZ2V0LFxuICAgICAgMCxcbiAgICAgIG1vZGVsLmludGVybmFsRm9ybWF0LFxuICAgICAgbW9kZWwud2lkdGgsXG4gICAgICBtb2RlbC5oZWlnaHQsXG4gICAgICAwLFxuICAgICAgbW9kZWwuZm9ybWF0LFxuICAgICAgbW9kZWwub3BlbkdMRGF0YVR5cGUsXG4gICAgICBuZXdBcnJheVxuICAgICk7XG5cbiAgICBwdWJsaWNBUEkuZGVhY3RpdmF0ZSgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRPcGVuR0xSZW5kZXJXaW5kb3cgPSAocncpID0+IHtcbiAgICBpZiAobW9kZWwub3BlbkdMUmVuZGVyV2luZG93ID09PSBydykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwdWJsaWNBUEkucmVsZWFzZUdyYXBoaWNzUmVzb3VyY2VzKCk7XG4gICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93ID0gcnc7XG4gICAgbW9kZWwuY29udGV4dCA9IG51bGw7XG4gICAgaWYgKHJ3KSB7XG4gICAgICBtb2RlbC5jb250ZXh0ID0gbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldENvbnRleHQoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIHB1YmxpY0FQSS5nZXRNYXhpbXVtVGV4dHVyZVNpemUgPSAoY3R4KSA9PiB7XG4gICAgaWYgKGN0eCAmJiBjdHguaXNDdXJyZW50KCkpIHtcbiAgICAgIHJldHVybiBjdHguZ2V0SW50ZWdlcnYoY3R4Lk1BWF9URVhUVVJFX1NJWkUpO1xuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIG9wZW5HTFJlbmRlcldpbmRvdzogbnVsbCxcbiAgY29udGV4dDogbnVsbCxcbiAgaGFuZGxlOiAwLFxuICBzZW5kUGFyYW1ldGVyc1RpbWU6IG51bGwsXG4gIHRleHR1cmVCdWlsZFRpbWU6IG51bGwsXG4gIG51bWJlck9mRGltZW5zaW9uczogMCxcbiAgdGFyZ2V0OiAwLFxuICBmb3JtYXQ6IDAsXG4gIG9wZW5HTERhdGFUeXBlOiAwLFxuICBjb21wb25lbnRzOiAwLFxuICB3aWR0aDogMCxcbiAgaGVpZ2h0OiAwLFxuICBkZXB0aDogMCxcbiAgYXV0b1BhcmFtZXRlcnM6IHRydWUsXG4gIHdyYXBTOiBXcmFwLkNMQU1QX1RPX0VER0UsXG4gIHdyYXBUOiBXcmFwLkNMQU1QX1RPX0VER0UsXG4gIHdyYXBSOiBXcmFwLkNMQU1QX1RPX0VER0UsXG4gIG1pbmlmaWNhdGlvbkZpbHRlcjogRmlsdGVyLk5FQVJFU1QsXG4gIG1hZ25pZmljYXRpb25GaWx0ZXI6IEZpbHRlci5ORUFSRVNULFxuICBtaW5MT0Q6IC0xMDAwLjAsXG4gIG1heExPRDogMTAwMC4wLFxuICBiYXNlTGV2ZWw6IDAsXG4gIG1heExldmVsOiAxMDAwLFxuICBnZW5lcmF0ZU1pcG1hcDogZmFsc2UsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBJbmhlcml0YW5jZVxuICB2dGtWaWV3Tm9kZS5leHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyk7XG5cbiAgbW9kZWwuc2VuZFBhcmFtZXRlcnNUaW1lID0ge307XG4gIG1hY3JvLm9iaihtb2RlbC5zZW5kUGFyYW1ldGVyc1RpbWUsIHsgbXRpbWU6IDAgfSk7XG5cbiAgbW9kZWwudGV4dHVyZUJ1aWxkVGltZSA9IHt9O1xuICBtYWNyby5vYmoobW9kZWwudGV4dHVyZUJ1aWxkVGltZSwgeyBtdGltZTogMCB9KTtcblxuICAvLyBCdWlsZCBWVEsgQVBJXG4gIG1hY3JvLnNldChwdWJsaWNBUEksIG1vZGVsLCBbJ2Zvcm1hdCcsICdvcGVuR0xEYXRhVHlwZSddKTtcblxuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgW1xuICAgICdrZXlNYXRyaXhUaW1lJyxcbiAgICAnbWluaWZpY2F0aW9uRmlsdGVyJyxcbiAgICAnbWFnbmlmaWNhdGlvbkZpbHRlcicsXG4gICAgJ3dyYXBTJyxcbiAgICAnd3JhcFQnLFxuICAgICd3cmFwUicsXG4gICAgJ2dlbmVyYXRlTWlwbWFwJyxcbiAgXSk7XG5cbiAgbWFjcm8uZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIFtcbiAgICAnd2lkdGgnLFxuICAgICdoZWlnaHQnLFxuICAgICd2b2x1bWVJbmZvJyxcbiAgICAnY29tcG9uZW50cycsXG4gICAgJ2hhbmRsZScsXG4gICAgJ3RhcmdldCcsXG4gIF0pO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIHZ0a09wZW5HTFRleHR1cmUocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrT3BlbkdMVGV4dHVyZScpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCwgLi4uQ29uc3RhbnRzIH07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuXG5jb25zdCB7IHZ0a0Vycm9yTWFjcm8gfSA9IG1hY3JvO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtPcGVuR0xUZXh0dXJlVW5pdE1hbmFnZXIgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtPcGVuR0xUZXh0dXJlVW5pdE1hbmFnZXIocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtPcGVuR0xUZXh0dXJlVW5pdE1hbmFnZXInKTtcblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIERlc2NyaXB0aW9uOlxuICAvLyBEZWxldGUgdGhlIGFsbG9jYXRpb24gdGFibGUgYW5kIGNoZWNrIGlmIGl0IGlzIG5vdCBjYWxsZWQgYmVmb3JlXG4gIC8vIGFsbCB0aGUgdGV4dHVyZSB1bml0cyBoYXZlIGJlZW4gcmVsZWFzZWQuXG4gIHB1YmxpY0FQSS5kZWxldGVUYWJsZSA9ICgpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsLm51bWJlck9mVGV4dHVyZVVuaXRzOyArK2kpIHtcbiAgICAgIGlmIChtb2RlbC50ZXh0dXJlVW5pdHNbaV0gPT09IHRydWUpIHtcbiAgICAgICAgdnRrRXJyb3JNYWNybygnc29tZSB0ZXh0dXJlIHVuaXRzICB3ZXJlIG5vdCBwcm9wZXJseSByZWxlYXNlZCcpO1xuICAgICAgfVxuICAgIH1cbiAgICBtb2RlbC50ZXh0dXJlVW5pdHMgPSBbXTtcbiAgICBtb2RlbC5udW1iZXJPZlRleHR1cmVVbml0cyA9IDA7XG4gIH07XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICBwdWJsaWNBUEkuc2V0Q29udGV4dCA9IChjdHgpID0+IHtcbiAgICBpZiAobW9kZWwuY29udGV4dCAhPT0gY3R4KSB7XG4gICAgICBpZiAobW9kZWwuY29udGV4dCAhPT0gMCkge1xuICAgICAgICBwdWJsaWNBUEkuZGVsZXRlVGFibGUoKTtcbiAgICAgIH1cbiAgICAgIG1vZGVsLmNvbnRleHQgPSBjdHg7XG4gICAgICBpZiAobW9kZWwuY29udGV4dCkge1xuICAgICAgICBtb2RlbC5udW1iZXJPZlRleHR1cmVVbml0cyA9IGN0eC5nZXRQYXJhbWV0ZXIoXG4gICAgICAgICAgY3R4Lk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTXG4gICAgICAgICk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kZWwubnVtYmVyT2ZUZXh0dXJlVW5pdHM7ICsraSkge1xuICAgICAgICAgIG1vZGVsLnRleHR1cmVVbml0c1tpXSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBEZXNjcmlwdGlvbjpcbiAgLy8gUmVzZXJ2ZSBhIHRleHR1cmUgdW5pdC4gSXQgcmV0dXJucyBpdHMgbnVtYmVyLlxuICAvLyBJdCByZXR1cm5zIC0xIGlmIHRoZSBhbGxvY2F0aW9uIGZhaWxlZCAoYmVjYXVzZSB0aGVyZSBhcmUgbm8gbW9yZVxuICAvLyB0ZXh0dXJlIHVuaXRzIGxlZnQpLlxuICAvLyBcXHBvc3QgdmFsaWRfcmVzdWx0OiByZXN1bHQ9PS0xIHx8IHJlc3VsdD49MCAmJiByZXN1bHQ8dGhpcy0+R2V0TnVtYmVyT2ZUZXh0dXJlVW5pdHMoKSlcbiAgLy8gXFxwb3N0IGFsbG9jYXRlZDogcmVzdWx0PT0tMSB8fCB0aGlzLT5Jc0FsbG9jYXRlZChyZXN1bHQpXG4gIHB1YmxpY0FQSS5hbGxvY2F0ZSA9ICgpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsLm51bWJlck9mVGV4dHVyZVVuaXRzOyBpKyspIHtcbiAgICAgIGlmICghcHVibGljQVBJLmlzQWxsb2NhdGVkKGkpKSB7XG4gICAgICAgIG1vZGVsLnRleHR1cmVVbml0c1tpXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH07XG5cbiAgcHVibGljQVBJLmFsbG9jYXRlVW5pdCA9ICh1bml0KSA9PiB7XG4gICAgaWYgKHB1YmxpY0FQSS5pc0FsbG9jYXRlZCh1bml0KSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIG1vZGVsLnRleHR1cmVVbml0c1t1bml0XSA9IHRydWU7XG4gICAgcmV0dXJuIHVuaXQ7XG4gIH07XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBEZXNjcmlwdGlvbjpcbiAgLy8gVGVsbCBpZiB0ZXh0dXJlIHVuaXQgYHRleHR1cmVVbml0SWQnIGlzIGFscmVhZHkgYWxsb2NhdGVkLlxuICAvLyBcXHByZSB2YWxpZF9pZF9yYW5nZSA6IHRleHR1cmVVbml0SWQ+PTAgJiYgdGV4dHVyZVVuaXRJZDx0aGlzLT5HZXROdW1iZXJPZlRleHR1cmVVbml0cygpXG4gIHB1YmxpY0FQSS5pc0FsbG9jYXRlZCA9ICh0ZXh0dXJlVW5pdElkKSA9PiBtb2RlbC50ZXh0dXJlVW5pdHNbdGV4dHVyZVVuaXRJZF07XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBEZXNjcmlwdGlvbjpcbiAgLy8gUmVsZWFzZSBhIHRleHR1cmUgdW5pdC5cbiAgLy8gXFxwcmUgdmFsaWRfaWQ6IHRleHR1cmVVbml0SWQ+PTAgJiYgdGV4dHVyZVVuaXRJZDx0aGlzLT5HZXROdW1iZXJPZlRleHR1cmVVbml0cygpXG4gIC8vIFxccHJlIGFsbG9jYXRlZF9pZDogdGhpcy0+SXNBbGxvY2F0ZWQodGV4dHVyZVVuaXRJZClcbiAgcHVibGljQVBJLmZyZWUgPSAodmFsKSA9PiB7XG4gICAgbW9kZWwudGV4dHVyZVVuaXRzW3ZhbF0gPSBmYWxzZTtcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIGNvbnRleHQ6IG51bGwsXG4gIG51bWJlck9mVGV4dHVyZVVuaXRzOiAwLFxuICB0ZXh0dXJlVW5pdHM6IDAsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICBtYWNyby5vYmoocHVibGljQVBJLCBtb2RlbCk7XG5cbiAgbW9kZWwudGV4dHVyZVVuaXRzID0gW107XG5cbiAgLy8gQnVpbGQgVlRLIEFQSVxuICBtYWNyby5nZXQocHVibGljQVBJLCBtb2RlbCwgWydudW1iZXJPZlRleHR1cmVVbml0cyddKTtcblxuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgWydjb250ZXh0J10pO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIHZ0a09wZW5HTFRleHR1cmVVbml0TWFuYWdlcihwdWJsaWNBUEksIG1vZGVsKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShcbiAgZXh0ZW5kLFxuICAndnRrT3BlbkdMVGV4dHVyZVVuaXRNYW5hZ2VyJ1xuKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgeyBPYmplY3RUeXBlIH0gZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9CdWZmZXJPYmplY3QvQ29uc3RhbnRzJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrT3BlbkdMVmVydGV4QXJyYXlPYmplY3QgbWV0aG9kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiB2dGtPcGVuR0xWZXJ0ZXhBcnJheU9iamVjdChwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a09wZW5HTFZlcnRleEFycmF5T2JqZWN0Jyk7XG5cbiAgLy8gUHVibGljIEFQSSBtZXRob2RzXG4gIHB1YmxpY0FQSS5leHBvc2VkTWV0aG9kID0gKCkgPT4ge1xuICAgIC8vIFRoaXMgaXMgYSBwdWJsaWNseSBleHBvc2VkIG1ldGhvZCBvZiB0aGlzIG9iamVjdFxuICB9O1xuXG4gIHB1YmxpY0FQSS5pbml0aWFsaXplID0gKCkgPT4ge1xuICAgIG1vZGVsLmluc3RhbmNpbmdFeHRlbnNpb24gPSBudWxsO1xuICAgIGlmICghbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldFdlYmdsMigpKSB7XG4gICAgICBtb2RlbC5pbnN0YW5jaW5nRXh0ZW5zaW9uID0gbW9kZWwuY29udGV4dC5nZXRFeHRlbnNpb24oXG4gICAgICAgICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJ1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgIW1vZGVsLmZvcmNlRW11bGF0aW9uICYmXG4gICAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cgJiZcbiAgICAgIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRXZWJnbDIoKVxuICAgICkge1xuICAgICAgbW9kZWwuZXh0ZW5zaW9uID0gbnVsbDtcbiAgICAgIG1vZGVsLnN1cHBvcnRlZCA9IHRydWU7XG4gICAgICBtb2RlbC5oYW5kbGVWQU8gPSBtb2RlbC5jb250ZXh0LmNyZWF0ZVZlcnRleEFycmF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsLmV4dGVuc2lvbiA9IG1vZGVsLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcpO1xuICAgICAgLy8gU3RhcnQgc2V0dGluZyB1cCBWQU9cbiAgICAgIGlmICghbW9kZWwuZm9yY2VFbXVsYXRpb24gJiYgbW9kZWwuZXh0ZW5zaW9uKSB7XG4gICAgICAgIG1vZGVsLnN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIG1vZGVsLmhhbmRsZVZBTyA9IG1vZGVsLmV4dGVuc2lvbi5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWwuc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5pc1JlYWR5ID0gKCkgPT5cbiAgICAvLyBXZSBlaXRoZXIgcHJvYmVkIGFuZCBhbGxvY2F0ZWQgYSBWQU8sIG9yIGFyZSBmYWxsaW5nIGJhY2sgYXMgdGhlIGN1cnJlbnRcbiAgICAvLyBoYXJkd2FyZSBkb2VzIG5vdCBzdXBwb3J0IFZBT3MuXG4gICAgbW9kZWwuaGFuZGxlVkFPICE9PSAwIHx8IG1vZGVsLnN1cHBvcnRlZCA9PT0gZmFsc2U7XG5cbiAgcHVibGljQVBJLmJpbmQgPSAoKSA9PiB7XG4gICAgLy8gRWl0aGVyIHNpbXBseSBiaW5kIHRoZSBWQU8sIG9yIGVtdWxhdGUgYmVoYXZpb3IgYnkgYmluZGluZyBhbGwgYXR0cmlidXRlcy5cbiAgICBpZiAoIXB1YmxpY0FQSS5pc1JlYWR5KCkpIHtcbiAgICAgIHB1YmxpY0FQSS5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIGlmIChwdWJsaWNBUEkuaXNSZWFkeSgpICYmIG1vZGVsLnN1cHBvcnRlZCkge1xuICAgICAgaWYgKG1vZGVsLmV4dGVuc2lvbikge1xuICAgICAgICBtb2RlbC5leHRlbnNpb24uYmluZFZlcnRleEFycmF5T0VTKG1vZGVsLmhhbmRsZVZBTyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbC5jb250ZXh0LmJpbmRWZXJ0ZXhBcnJheShtb2RlbC5oYW5kbGVWQU8pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHVibGljQVBJLmlzUmVhZHkoKSkge1xuICAgICAgY29uc3QgZ2wgPSBtb2RlbC5jb250ZXh0O1xuICAgICAgZm9yIChsZXQgaWJ1ZmYgPSAwOyBpYnVmZiA8IG1vZGVsLmJ1ZmZlcnMubGVuZ3RoOyArK2lidWZmKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBtb2RlbC5idWZmZXJzW2lidWZmXTtcbiAgICAgICAgbW9kZWwuY29udGV4dC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZi5idWZmZXIpO1xuICAgICAgICBmb3IgKGxldCBpYXR0ID0gMDsgaWF0dCA8IGJ1ZmYuYXR0cmlidXRlcy5sZW5ndGg7ICsraWF0dCkge1xuICAgICAgICAgIGNvbnN0IGF0dHJJdCA9IGJ1ZmYuYXR0cmlidXRlc1tpYXR0XTtcbiAgICAgICAgICBjb25zdCBtYXRyaXhDb3VudCA9IGF0dHJJdC5pc01hdHJpeCA/IGF0dHJJdC5zaXplIDogMTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdHJpeENvdW50OyArK2kpIHtcbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJJdC5pbmRleCArIGkpO1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgICAgICAgYXR0ckl0LmluZGV4ICsgaSxcbiAgICAgICAgICAgICAgYXR0ckl0LnNpemUsXG4gICAgICAgICAgICAgIGF0dHJJdC50eXBlLFxuICAgICAgICAgICAgICBhdHRySXQubm9ybWFsaXplLFxuICAgICAgICAgICAgICBhdHRySXQuc3RyaWRlLFxuICAgICAgICAgICAgICBhdHRySXQub2Zmc2V0ICsgKGF0dHJJdC5zdHJpZGUgKiBpKSAvIGF0dHJJdC5zaXplXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGF0dHJJdC5kaXZpc29yID4gMCkge1xuICAgICAgICAgICAgICBpZiAobW9kZWwuaW5zdGFuY2luZ0V4dGVuc2lvbikge1xuICAgICAgICAgICAgICAgIG1vZGVsLmluc3RhbmNpbmdFeHRlbnNpb24udmVydGV4QXR0cmliRGl2aXNvckFOR0xFKFxuICAgICAgICAgICAgICAgICAgYXR0ckl0LmluZGV4ICsgaSxcbiAgICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0ckl0LmluZGV4ICsgaSwgMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLnJlbGVhc2UgPSAoKSA9PiB7XG4gICAgLy8gRWl0aGVyIHNpbXBseSByZWxlYXNlIHRoZSBWQU8sIG9yIGVtdWxhdGUgYmVoYXZpb3IgYnkgcmVsZWFzaW5nIGFsbCBhdHRyaWJ1dGVzLlxuICAgIGlmIChwdWJsaWNBUEkuaXNSZWFkeSgpICYmIG1vZGVsLnN1cHBvcnRlZCkge1xuICAgICAgaWYgKG1vZGVsLmV4dGVuc2lvbikge1xuICAgICAgICBtb2RlbC5leHRlbnNpb24uYmluZFZlcnRleEFycmF5T0VTKG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWwuY29udGV4dC5iaW5kVmVydGV4QXJyYXkobnVsbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwdWJsaWNBUEkuaXNSZWFkeSgpKSB7XG4gICAgICBjb25zdCBnbCA9IG1vZGVsLmNvbnRleHQ7XG4gICAgICBmb3IgKGxldCBpYnVmZiA9IDA7IGlidWZmIDwgbW9kZWwuYnVmZmVycy5sZW5ndGg7ICsraWJ1ZmYpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IG1vZGVsLmJ1ZmZlcnNbaWJ1ZmZdO1xuICAgICAgICBtb2RlbC5jb250ZXh0LmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmLmJ1ZmZlcik7XG4gICAgICAgIGZvciAobGV0IGlhdHQgPSAwOyBpYXR0IDwgYnVmZi5hdHRyaWJ1dGVzLmxlbmd0aDsgKytpYXR0KSB7XG4gICAgICAgICAgY29uc3QgYXR0ckl0ID0gYnVmZi5hdHRyaWJ1dGVzW2lhdHRdO1xuICAgICAgICAgIGNvbnN0IG1hdHJpeENvdW50ID0gYXR0ckl0LmlzTWF0cml4ID8gYXR0ckl0LnNpemUgOiAxO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4Q291bnQ7ICsraSkge1xuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0ckl0LmluZGV4ICsgaSk7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgICAgICAgICBhdHRySXQuaW5kZXggKyBpLFxuICAgICAgICAgICAgICBhdHRySXQuc2l6ZSxcbiAgICAgICAgICAgICAgYXR0ckl0LnR5cGUsXG4gICAgICAgICAgICAgIGF0dHJJdC5ub3JtYWxpemUsXG4gICAgICAgICAgICAgIGF0dHJJdC5zdHJpZGUsXG4gICAgICAgICAgICAgIGF0dHJJdC5vZmZzZXQgKyAoYXR0ckl0LnN0cmlkZSAqIGkpIC8gYXR0ckl0LnNpemVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoYXR0ckl0LmRpdmlzb3IgPiAwKSB7XG4gICAgICAgICAgICAgIGlmIChtb2RlbC5pbnN0YW5jaW5nRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuaW5zdGFuY2luZ0V4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoXG4gICAgICAgICAgICAgICAgICBhdHRySXQuaW5kZXggKyBpLFxuICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRySXQuaW5kZXggKyBpLCAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGF0dHJJdC5pbmRleCArIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuc2hhZGVyUHJvZ3JhbUNoYW5nZWQgPSAoKSA9PiB7XG4gICAgcHVibGljQVBJLnJlbGVhc2UoKTtcbiAgICBpZiAobW9kZWwuaGFuZGxlVkFPKSB7XG4gICAgICBpZiAobW9kZWwuZXh0ZW5zaW9uKSB7XG4gICAgICAgIG1vZGVsLmV4dGVuc2lvbi5kZWxldGVWZXJ0ZXhBcnJheU9FUyhtb2RlbC5oYW5kbGVWQU8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kZWwuY29udGV4dC5kZWxldGVWZXJ0ZXhBcnJheShtb2RlbC5oYW5kbGVWQU8pO1xuICAgICAgfVxuICAgIH1cbiAgICBtb2RlbC5oYW5kbGVWQU8gPSAwO1xuICAgIG1vZGVsLmhhbmRsZVByb2dyYW0gPSAwO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZWxlYXNlR3JhcGhpY3NSZXNvdXJjZXMgPSAoKSA9PiB7XG4gICAgcHVibGljQVBJLnNoYWRlclByb2dyYW1DaGFuZ2VkKCk7XG4gICAgaWYgKG1vZGVsLmhhbmRsZVZBTykge1xuICAgICAgaWYgKG1vZGVsLmV4dGVuc2lvbikge1xuICAgICAgICBtb2RlbC5leHRlbnNpb24uZGVsZXRlVmVydGV4QXJyYXlPRVMobW9kZWwuaGFuZGxlVkFPKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1vZGVsLmNvbnRleHQuZGVsZXRlVmVydGV4QXJyYXkobW9kZWwuaGFuZGxlVkFPKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbW9kZWwuaGFuZGxlVkFPID0gMDtcbiAgICBtb2RlbC5zdXBwb3J0ZWQgPSB0cnVlO1xuICAgIG1vZGVsLmhhbmRsZVByb2dyYW0gPSAwO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5hZGRBdHRyaWJ1dGVBcnJheSA9IChcbiAgICBwcm9ncmFtLFxuICAgIGJ1ZmZlcixcbiAgICBuYW1lLFxuICAgIG9mZnNldCxcbiAgICBzdHJpZGUsXG4gICAgZWxlbWVudFR5cGUsXG4gICAgZWxlbWVudFR1cGxlU2l6ZSxcbiAgICBub3JtYWxpemVcbiAgKSA9PlxuICAgIHB1YmxpY0FQSS5hZGRBdHRyaWJ1dGVBcnJheVdpdGhEaXZpc29yKFxuICAgICAgcHJvZ3JhbSxcbiAgICAgIGJ1ZmZlcixcbiAgICAgIG5hbWUsXG4gICAgICBvZmZzZXQsXG4gICAgICBzdHJpZGUsXG4gICAgICBlbGVtZW50VHlwZSxcbiAgICAgIGVsZW1lbnRUdXBsZVNpemUsXG4gICAgICBub3JtYWxpemUsXG4gICAgICAwLFxuICAgICAgZmFsc2VcbiAgICApO1xuXG4gIHB1YmxpY0FQSS5hZGRBdHRyaWJ1dGVBcnJheVdpdGhEaXZpc29yID0gKFxuICAgIHByb2dyYW0sXG4gICAgYnVmZmVyLFxuICAgIG5hbWUsXG4gICAgb2Zmc2V0LFxuICAgIHN0cmlkZSxcbiAgICBlbGVtZW50VHlwZSxcbiAgICBlbGVtZW50VHVwbGVTaXplLFxuICAgIG5vcm1hbGl6ZSxcbiAgICBkaXZpc29yLFxuICAgIGlzTWF0cml4XG4gICkgPT4ge1xuICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSBwcm9ncmFtIGlzIGJvdW5kLCBhbmQgdGhlIGJ1ZmZlciBpcyB2YWxpZC5cbiAgICBpZiAoXG4gICAgICAhcHJvZ3JhbS5pc0JvdW5kKCkgfHxcbiAgICAgIGJ1ZmZlci5nZXRIYW5kbGUoKSA9PT0gMCB8fFxuICAgICAgYnVmZmVyLmdldFR5cGUoKSAhPT0gT2JqZWN0VHlwZS5BUlJBWV9CVUZGRVJcbiAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGluaXRpYWxpemF0aW9uIGlmIG5lY2Vzc2FyeSwgZW5zdXJlIHByb2dyYW0gbWF0Y2hlcyBWQU9zLlxuICAgIGlmIChtb2RlbC5oYW5kbGVQcm9ncmFtID09PSAwKSB7XG4gICAgICBtb2RlbC5oYW5kbGVQcm9ncmFtID0gcHJvZ3JhbS5nZXRIYW5kbGUoKTtcbiAgICB9XG4gICAgaWYgKCFwdWJsaWNBUEkuaXNSZWFkeSgpKSB7XG4gICAgICBwdWJsaWNBUEkuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICBpZiAoIXB1YmxpY0FQSS5pc1JlYWR5KCkgfHwgbW9kZWwuaGFuZGxlUHJvZ3JhbSAhPT0gcHJvZ3JhbS5nZXRIYW5kbGUoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGdsID0gbW9kZWwuY29udGV4dDtcblxuICAgIGNvbnN0IGF0dHJpYnMgPSB7fTtcbiAgICBhdHRyaWJzLm5hbWUgPSBuYW1lO1xuICAgIGF0dHJpYnMuaW5kZXggPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihtb2RlbC5oYW5kbGVQcm9ncmFtLCBuYW1lKTtcbiAgICBhdHRyaWJzLm9mZnNldCA9IG9mZnNldDtcbiAgICBhdHRyaWJzLnN0cmlkZSA9IHN0cmlkZTtcbiAgICBhdHRyaWJzLnR5cGUgPSBlbGVtZW50VHlwZTtcbiAgICBhdHRyaWJzLnNpemUgPSBlbGVtZW50VHVwbGVTaXplO1xuICAgIGF0dHJpYnMubm9ybWFsaXplID0gbm9ybWFsaXplO1xuICAgIGF0dHJpYnMuaXNNYXRyaXggPSBpc01hdHJpeDtcbiAgICBhdHRyaWJzLmRpdmlzb3IgPSBkaXZpc29yO1xuXG4gICAgaWYgKGF0dHJpYnMuSW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIG1ha2UgdGhlIGNhbGwgYXMgZXZlbiB0aGUgZmlyc3QgdXNlIHdhbnRzIHRoZSBhdHRyaWIgcG9pbnRlciBzZXR0aW5nXG4gICAgLy8gdXAgd2hlbiB3ZSBhcmUgZW11bGF0aW5nLlxuICAgIGJ1ZmZlci5iaW5kKCk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoYXR0cmlicy5pbmRleCk7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgIGF0dHJpYnMuaW5kZXgsXG4gICAgICBhdHRyaWJzLnNpemUsXG4gICAgICBhdHRyaWJzLnR5cGUsXG4gICAgICBhdHRyaWJzLm5vcm1hbGl6ZSxcbiAgICAgIGF0dHJpYnMuc3RyaWRlLFxuICAgICAgYXR0cmlicy5vZmZzZXRcbiAgICApO1xuXG4gICAgaWYgKGRpdmlzb3IgPiAwKSB7XG4gICAgICBpZiAobW9kZWwuaW5zdGFuY2luZ0V4dGVuc2lvbikge1xuICAgICAgICBtb2RlbC5pbnN0YW5jaW5nRXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShhdHRyaWJzLmluZGV4LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoYXR0cmlicy5pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cmlicy5idWZmZXIgPSBidWZmZXIuZ2V0SGFuZGxlKCk7XG5cbiAgICAvLyBJZiB2ZXJ0ZXggYXJyYXkgb2JqZWN0cyBhcmUgbm90IHN1cHBvcnRlZCB0aGVuIGJ1aWxkIHVwIG91ciBsaXN0LlxuICAgIGlmICghbW9kZWwuc3VwcG9ydGVkKSB7XG4gICAgICAvLyBmaW5kIHRoZSBidWZmZXJcbiAgICAgIGxldCBidWZmRm91bmQgPSBmYWxzZTtcbiAgICAgIGZvciAobGV0IGlidWZmID0gMDsgaWJ1ZmYgPCBtb2RlbC5idWZmZXJzLmxlbmd0aDsgKytpYnVmZikge1xuICAgICAgICBjb25zdCBidWZmID0gbW9kZWwuYnVmZmVyc1tpYnVmZl07XG4gICAgICAgIGlmIChidWZmLmJ1ZmZlciA9PT0gYXR0cmlicy5idWZmZXIpIHtcbiAgICAgICAgICBidWZmRm91bmQgPSB0cnVlO1xuICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGZvciAobGV0IGlhdHQgPSAwOyBpYXR0IDwgYnVmZi5hdHRyaWJ1dGVzLmxlbmd0aDsgKytpYXR0KSB7XG4gICAgICAgICAgICBjb25zdCBhdHRySXQgPSBidWZmLmF0dHJpYnV0ZXNbaWF0dF07XG4gICAgICAgICAgICBpZiAoYXR0ckl0Lm5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICBidWZmLmF0dHJpYnV0ZXNbaWF0dF0gPSBhdHRyaWJzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgICBidWZmLmF0dHJpYnV0ZXMucHVzaChhdHRyaWJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghYnVmZkZvdW5kKSB7XG4gICAgICAgIG1vZGVsLmJ1ZmZlcnMucHVzaCh7IGJ1ZmZlcjogYXR0cmlicy5idWZmZXIsIGF0dHJpYnV0ZXM6IFthdHRyaWJzXSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgcHVibGljQVBJLmFkZEF0dHJpYnV0ZU1hdHJpeFdpdGhEaXZpc29yID0gKFxuICAgIHByb2dyYW0sXG4gICAgYnVmZmVyLFxuICAgIG5hbWUsXG4gICAgb2Zmc2V0LFxuICAgIHN0cmlkZSxcbiAgICBlbGVtZW50VHlwZSxcbiAgICBlbGVtZW50VHVwbGVTaXplLFxuICAgIG5vcm1hbGl6ZSxcbiAgICBkaXZpc29yXG4gICkgPT4ge1xuICAgIC8vIGJpbmQgdGhlIGZpcnN0IHJvdyBvZiB2YWx1ZXNcbiAgICBjb25zdCByZXN1bHQgPSBwdWJsaWNBUEkuYWRkQXR0cmlidXRlQXJyYXlXaXRoRGl2aXNvcihcbiAgICAgIHByb2dyYW0sXG4gICAgICBidWZmZXIsXG4gICAgICBuYW1lLFxuICAgICAgb2Zmc2V0LFxuICAgICAgc3RyaWRlLFxuICAgICAgZWxlbWVudFR5cGUsXG4gICAgICBlbGVtZW50VHVwbGVTaXplLFxuICAgICAgbm9ybWFsaXplLFxuICAgICAgZGl2aXNvcixcbiAgICAgIHRydWVcbiAgICApO1xuXG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgY29uc3QgZ2wgPSBtb2RlbC5jb250ZXh0O1xuXG4gICAgY29uc3QgaW5kZXggPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihtb2RlbC5oYW5kbGVQcm9ncmFtLCBuYW1lKTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZWxlbWVudFR1cGxlU2l6ZTsgaSsrKSB7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShpbmRleCArIGkpO1xuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihcbiAgICAgICAgaW5kZXggKyBpLFxuICAgICAgICBlbGVtZW50VHVwbGVTaXplLFxuICAgICAgICBlbGVtZW50VHlwZSxcbiAgICAgICAgbm9ybWFsaXplLFxuICAgICAgICBzdHJpZGUsXG4gICAgICAgIG9mZnNldCArIChzdHJpZGUgKiBpKSAvIGVsZW1lbnRUdXBsZVNpemVcbiAgICAgICk7XG4gICAgICBpZiAoZGl2aXNvciA+IDApIHtcbiAgICAgICAgaWYgKG1vZGVsLmluc3RhbmNpbmdFeHRlbnNpb24pIHtcbiAgICAgICAgICBtb2RlbC5pbnN0YW5jaW5nRXh0ZW5zaW9uLnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShpbmRleCArIGksIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IoaW5kZXggKyBpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZW1vdmVBdHRyaWJ1dGVBcnJheSA9IChuYW1lKSA9PiB7XG4gICAgaWYgKCFwdWJsaWNBUEkuaXNSZWFkeSgpIHx8IG1vZGVsLmhhbmRsZVByb2dyYW0gPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIHJlYWwgVkFPcyBmaW5kIHRoZSBlbnRyeSBhbmQgcmVtb3ZlIGl0IHRvby5cbiAgICBpZiAoIW1vZGVsLnN1cHBvcnRlZCkge1xuICAgICAgZm9yIChsZXQgaWJ1ZmYgPSAwOyBpYnVmZiA8IG1vZGVsLmJ1ZmZlcnMubGVuZ3RoOyArK2lidWZmKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBtb2RlbC5idWZmZXJzW2lidWZmXTtcbiAgICAgICAgZm9yIChsZXQgaWF0dCA9IDA7IGlhdHQgPCBidWZmLmF0dHJpYnV0ZXMubGVuZ3RoOyArK2lhdHQpIHtcbiAgICAgICAgICBjb25zdCBhdHRySXQgPSBidWZmLmF0dHJpYnV0ZXNbaWF0dF07XG4gICAgICAgICAgaWYgKGF0dHJJdC5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICBidWZmLmF0dHJpYnV0ZXMuc3BsaWNlKGlhdHQsIDEpO1xuICAgICAgICAgICAgaWYgKCFidWZmLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1vZGVsLmJ1ZmZlcnMuc3BsaWNlKGlidWZmLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRPcGVuR0xSZW5kZXJXaW5kb3cgPSAocncpID0+IHtcbiAgICBpZiAobW9kZWwub3BlbkdMUmVuZGVyV2luZG93ID09PSBydykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwdWJsaWNBUEkucmVsZWFzZUdyYXBoaWNzUmVzb3VyY2VzKCk7XG4gICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93ID0gcnc7XG4gICAgbW9kZWwuY29udGV4dCA9IG51bGw7XG4gICAgaWYgKHJ3KSB7XG4gICAgICBtb2RlbC5jb250ZXh0ID0gbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldENvbnRleHQoKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBmb3JjZUVtdWxhdGlvbjogZmFsc2UsXG4gIGhhbmRsZVZBTzogMCxcbiAgaGFuZGxlUHJvZ3JhbTogMCxcbiAgc3VwcG9ydGVkOiB0cnVlLFxuICBidWZmZXJzOiBudWxsLFxuICBjb250ZXh0OiBudWxsLFxuICBvcGVuR0xSZW5kZXJXaW5kb3c6IG51bGwsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBJbnRlcm5hbCBvYmplY3RzIGluaXRpYWxpemF0aW9uXG4gIG1vZGVsLmJ1ZmZlcnMgPSBbXTtcblxuICAvLyBPYmplY3QgbWV0aG9kc1xuICBtYWNyby5vYmoocHVibGljQVBJLCBtb2RlbCk7XG5cbiAgLy8gQ3JlYXRlIGdldC1vbmx5IG1hY3Jvc1xuICBtYWNyby5nZXQocHVibGljQVBJLCBtb2RlbCwgWydzdXBwb3J0ZWQnXSk7XG5cbiAgLy8gQ3JlYXRlIGdldC1zZXQgbWFjcm9zXG4gIG1hY3JvLnNldEdldChwdWJsaWNBUEksIG1vZGVsLCBbJ2ZvcmNlRW11bGF0aW9uJ10pO1xuXG4gIC8vIEZvciBtb3JlIG1hY3JvIG1ldGhvZHMsIHNlZSBcIlNvdXJjZXMvbWFjcm8uanNcIlxuXG4gIC8vIE9iamVjdCBzcGVjaWZpYyBtZXRob2RzXG4gIHZ0a09wZW5HTFZlcnRleEFycmF5T2JqZWN0KHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKFxuICBleHRlbmQsXG4gICd2dGtPcGVuR0xWZXJ0ZXhBcnJheU9iamVjdCdcbik7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kIH07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0IHZ0a0dlbmVyaWNXaWRnZXRSZXByZXNlbnRhdGlvbiBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvU2NlbmVHcmFwaC9HZW5lcmljV2lkZ2V0UmVwcmVzZW50YXRpb24nO1xuaW1wb3J0IHZ0a09wZW5HTEFjdG9yIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvQWN0b3InO1xuaW1wb3J0IHZ0a09wZW5HTEFjdG9yMkQgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9BY3RvcjJEJztcbmltcG9ydCB2dGtPcGVuR0xDYW1lcmEgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9DYW1lcmEnO1xuaW1wb3J0IHZ0a09wZW5HTEdseXBoM0RNYXBwZXIgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9HbHlwaDNETWFwcGVyJztcbmltcG9ydCB2dGtPcGVuR0xJbWFnZU1hcHBlciBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML0ltYWdlTWFwcGVyJztcbmltcG9ydCB2dGtPcGVuR0xJbWFnZVNsaWNlIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvSW1hZ2VTbGljZSc7XG5pbXBvcnQgdnRrT3BlbkdMUGl4ZWxTcGFjZUNhbGxiYWNrTWFwcGVyIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvUGl4ZWxTcGFjZUNhbGxiYWNrTWFwcGVyJztcbmltcG9ydCB2dGtPcGVuR0xQb2x5RGF0YU1hcHBlciBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1BvbHlEYXRhTWFwcGVyJztcbmltcG9ydCB2dGtPcGVuR0xSZW5kZXJlciBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1JlbmRlcmVyJztcbmltcG9ydCB2dGtPcGVuR0xTa3lib3ggZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9Ta3lib3gnO1xuaW1wb3J0IHZ0a09wZW5HTFNwaGVyZU1hcHBlciBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1NwaGVyZU1hcHBlcic7XG5pbXBvcnQgdnRrT3BlbkdMU3RpY2tNYXBwZXIgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9TdGlja01hcHBlcic7XG5pbXBvcnQgdnRrT3BlbkdMVGV4dHVyZSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1RleHR1cmUnO1xuaW1wb3J0IHZ0a09wZW5HTFZvbHVtZSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1ZvbHVtZSc7XG5pbXBvcnQgdnRrT3BlbkdMVm9sdW1lTWFwcGVyIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvVm9sdW1lTWFwcGVyJztcbmltcG9ydCB2dGtWaWV3Tm9kZUZhY3RvcnkgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL1NjZW5lR3JhcGgvVmlld05vZGVGYWN0b3J5JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrT3BlbkdMVmlld05vZGVGYWN0b3J5IG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrT3BlbkdMVmlld05vZGVGYWN0b3J5KHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrT3BlbkdMVmlld05vZGVGYWN0b3J5Jyk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge307XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEluaGVyaXRhbmNlXG4gIHZ0a1ZpZXdOb2RlRmFjdG9yeS5leHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gT2JqZWN0IG1ldGhvZHNcbiAgdnRrT3BlbkdMVmlld05vZGVGYWN0b3J5KHB1YmxpY0FQSSwgbW9kZWwpO1xuXG4gIC8vIEluaXRpYWxpemF0aW9uXG4gIHB1YmxpY0FQSS5yZWdpc3Rlck92ZXJyaWRlKCd2dGtBY3RvcicsIHZ0a09wZW5HTEFjdG9yLm5ld0luc3RhbmNlKTtcbiAgcHVibGljQVBJLnJlZ2lzdGVyT3ZlcnJpZGUoJ3Z0a0FjdG9yMkQnLCB2dGtPcGVuR0xBY3RvcjJELm5ld0luc3RhbmNlKTtcbiAgcHVibGljQVBJLnJlZ2lzdGVyT3ZlcnJpZGUoJ3Z0a0NhbWVyYScsIHZ0a09wZW5HTENhbWVyYS5uZXdJbnN0YW5jZSk7XG4gIHB1YmxpY0FQSS5yZWdpc3Rlck92ZXJyaWRlKFxuICAgICd2dGtHbHlwaDNETWFwcGVyJyxcbiAgICB2dGtPcGVuR0xHbHlwaDNETWFwcGVyLm5ld0luc3RhbmNlXG4gICk7XG4gIHB1YmxpY0FQSS5yZWdpc3Rlck92ZXJyaWRlKFxuICAgICd2dGtJbWFnZU1hcHBlcicsXG4gICAgdnRrT3BlbkdMSW1hZ2VNYXBwZXIubmV3SW5zdGFuY2VcbiAgKTtcbiAgcHVibGljQVBJLnJlZ2lzdGVyT3ZlcnJpZGUoJ3Z0a0ltYWdlU2xpY2UnLCB2dGtPcGVuR0xJbWFnZVNsaWNlLm5ld0luc3RhbmNlKTtcbiAgcHVibGljQVBJLnJlZ2lzdGVyT3ZlcnJpZGUoJ3Z0a01hcHBlcicsIHZ0a09wZW5HTFBvbHlEYXRhTWFwcGVyLm5ld0luc3RhbmNlKTtcbiAgcHVibGljQVBJLnJlZ2lzdGVyT3ZlcnJpZGUoXG4gICAgJ3Z0a1BpeGVsU3BhY2VDYWxsYmFja01hcHBlcicsXG4gICAgdnRrT3BlbkdMUGl4ZWxTcGFjZUNhbGxiYWNrTWFwcGVyLm5ld0luc3RhbmNlXG4gICk7XG4gIHB1YmxpY0FQSS5yZWdpc3Rlck92ZXJyaWRlKCd2dGtSZW5kZXJlcicsIHZ0a09wZW5HTFJlbmRlcmVyLm5ld0luc3RhbmNlKTtcbiAgcHVibGljQVBJLnJlZ2lzdGVyT3ZlcnJpZGUoJ3Z0a1NreWJveCcsIHZ0a09wZW5HTFNreWJveC5uZXdJbnN0YW5jZSk7XG4gIHB1YmxpY0FQSS5yZWdpc3Rlck92ZXJyaWRlKFxuICAgICd2dGtTcGhlcmVNYXBwZXInLFxuICAgIHZ0a09wZW5HTFNwaGVyZU1hcHBlci5uZXdJbnN0YW5jZVxuICApO1xuICBwdWJsaWNBUEkucmVnaXN0ZXJPdmVycmlkZShcbiAgICAndnRrU3RpY2tNYXBwZXInLFxuICAgIHZ0a09wZW5HTFN0aWNrTWFwcGVyLm5ld0luc3RhbmNlXG4gICk7XG4gIHB1YmxpY0FQSS5yZWdpc3Rlck92ZXJyaWRlKCd2dGtUZXh0dXJlJywgdnRrT3BlbkdMVGV4dHVyZS5uZXdJbnN0YW5jZSk7XG4gIHB1YmxpY0FQSS5yZWdpc3Rlck92ZXJyaWRlKCd2dGtWb2x1bWUnLCB2dGtPcGVuR0xWb2x1bWUubmV3SW5zdGFuY2UpO1xuICBwdWJsaWNBUEkucmVnaXN0ZXJPdmVycmlkZShcbiAgICAndnRrVm9sdW1lTWFwcGVyJyxcbiAgICB2dGtPcGVuR0xWb2x1bWVNYXBwZXIubmV3SW5zdGFuY2VcbiAgKTtcbiAgcHVibGljQVBJLnJlZ2lzdGVyT3ZlcnJpZGUoXG4gICAgJ3Z0a1dpZGdldFJlcHJlc2VudGF0aW9uJyxcbiAgICB2dGtHZW5lcmljV2lkZ2V0UmVwcmVzZW50YXRpb24ubmV3SW5zdGFuY2VcbiAgKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgY29uc3QgbmV3SW5zdGFuY2UgPSBtYWNyby5uZXdJbnN0YW5jZShcbiAgZXh0ZW5kLFxuICAndnRrT3BlbkdMVmlld05vZGVGYWN0b3J5J1xuKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQgfTtcbiIsImltcG9ydCB7IG1hdDMsIG1hdDQgfSBmcm9tICdnbC1tYXRyaXgnO1xuXG5pbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuaW1wb3J0IHZ0a1ZpZXdOb2RlIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9TY2VuZUdyYXBoL1ZpZXdOb2RlJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gdnRrT3BlbkdMVm9sdW1lIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrT3BlbkdMVm9sdW1lKHB1YmxpY0FQSSwgbW9kZWwpIHtcbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrT3BlbkdMVm9sdW1lJyk7XG5cbiAgLy8gQnVpbGRzIG15c2VsZi5cbiAgcHVibGljQVBJLmJ1aWxkUGFzcyA9IChwcmVwYXNzKSA9PiB7XG4gICAgaWYgKCFtb2RlbC5yZW5kZXJhYmxlIHx8ICFtb2RlbC5yZW5kZXJhYmxlLmdldFZpc2liaWxpdHkoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJlcGFzcykge1xuICAgICAgbW9kZWwub3BlbkdMUmVuZGVyZXIgPSBwdWJsaWNBUEkuZ2V0Rmlyc3RBbmNlc3Rvck9mVHlwZShcbiAgICAgICAgJ3Z0a09wZW5HTFJlbmRlcmVyJ1xuICAgICAgKTtcbiAgICAgIHB1YmxpY0FQSS5wcmVwYXJlTm9kZXMoKTtcbiAgICAgIHB1YmxpY0FQSS5hZGRNaXNzaW5nTm9kZShtb2RlbC5yZW5kZXJhYmxlLmdldE1hcHBlcigpKTtcbiAgICAgIHB1YmxpY0FQSS5yZW1vdmVVbnVzZWROb2RlcygpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkucXVlcnlQYXNzID0gKHByZXBhc3MsIHJlbmRlclBhc3MpID0+IHtcbiAgICBpZiAocHJlcGFzcykge1xuICAgICAgaWYgKCFtb2RlbC5yZW5kZXJhYmxlIHx8ICFtb2RlbC5yZW5kZXJhYmxlLmdldFZpc2liaWxpdHkoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZW5kZXJQYXNzLmluY3JlbWVudFZvbHVtZUNvdW50KCk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS50cmF2ZXJzZVZvbHVtZVBhc3MgPSAocmVuZGVyUGFzcykgPT4ge1xuICAgIGlmIChcbiAgICAgICFtb2RlbC5yZW5kZXJhYmxlIHx8XG4gICAgICAhbW9kZWwucmVuZGVyYWJsZS5nZXRWaXNpYmlsaXR5KCkgfHxcbiAgICAgIChtb2RlbC5vcGVuR0xSZW5kZXJlci5nZXRTZWxlY3RvcigpICYmICFtb2RlbC5yZW5kZXJhYmxlLmdldFBpY2thYmxlKCkpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHVibGljQVBJLmFwcGx5KHJlbmRlclBhc3MsIHRydWUpO1xuXG4gICAgbW9kZWwuY2hpbGRyZW5bMF0udHJhdmVyc2UocmVuZGVyUGFzcyk7XG5cbiAgICBwdWJsaWNBUEkuYXBwbHkocmVuZGVyUGFzcywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJlbmRlcnMgbXlzZWxmXG4gIHB1YmxpY0FQSS52b2x1bWVQYXNzID0gKHByZXBhc3MpID0+IHtcbiAgICBpZiAoIW1vZGVsLnJlbmRlcmFibGUgfHwgIW1vZGVsLnJlbmRlcmFibGUuZ2V0VmlzaWJpbGl0eSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwcmVwYXNzKSB7XG4gICAgICBtb2RlbC5jb250ZXh0ID0gcHVibGljQVBJXG4gICAgICAgIC5nZXRGaXJzdEFuY2VzdG9yT2ZUeXBlKCd2dGtPcGVuR0xSZW5kZXJXaW5kb3cnKVxuICAgICAgICAuZ2V0Q29udGV4dCgpO1xuICAgICAgbW9kZWwuY29udGV4dC5kZXB0aE1hc2soZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbC5jb250ZXh0LmRlcHRoTWFzayh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmdldEtleU1hdHJpY2VzID0gKCkgPT4ge1xuICAgIC8vIGhhcyB0aGUgYWN0b3IgY2hhbmdlZD9cbiAgICBpZiAobW9kZWwucmVuZGVyYWJsZS5nZXRNVGltZSgpID4gbW9kZWwua2V5TWF0cml4VGltZS5nZXRNVGltZSgpKSB7XG4gICAgICBtb2RlbC5yZW5kZXJhYmxlLmNvbXB1dGVNYXRyaXgoKTtcbiAgICAgIG1hdDQuY29weShtb2RlbC5NQ1dDTWF0cml4LCBtb2RlbC5yZW5kZXJhYmxlLmdldE1hdHJpeCgpKTtcbiAgICAgIG1hdDQudHJhbnNwb3NlKG1vZGVsLk1DV0NNYXRyaXgsIG1vZGVsLk1DV0NNYXRyaXgpO1xuXG4gICAgICBpZiAobW9kZWwucmVuZGVyYWJsZS5nZXRJc0lkZW50aXR5KCkpIHtcbiAgICAgICAgbWF0My5pZGVudGl0eShtb2RlbC5ub3JtYWxNYXRyaXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0My5mcm9tTWF0NChtb2RlbC5ub3JtYWxNYXRyaXgsIG1vZGVsLk1DV0NNYXRyaXgpO1xuICAgICAgICBtYXQzLmludmVydChtb2RlbC5ub3JtYWxNYXRyaXgsIG1vZGVsLm5vcm1hbE1hdHJpeCk7XG4gICAgICB9XG4gICAgICBtb2RlbC5rZXlNYXRyaXhUaW1lLm1vZGlmaWVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbWN3YzogbW9kZWwuTUNXQ01hdHJpeCwgbm9ybWFsTWF0cml4OiBtb2RlbC5ub3JtYWxNYXRyaXggfTtcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT2JqZWN0IGZhY3Rvcnlcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuY29uc3QgREVGQVVMVF9WQUxVRVMgPSB7XG4gIC8vIGNvbnRleHQ6IG51bGwsXG4gIC8vIGtleU1hdHJpeFRpbWU6IG51bGwsXG4gIC8vIG5vcm1hbE1hdHJpeDogbnVsbCxcbiAgLy8gTUNXQ01hdHJpeDogbnVsbCxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEluaGVyaXRhbmNlXG4gIHZ0a1ZpZXdOb2RlLmV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzKTtcblxuICBtb2RlbC5rZXlNYXRyaXhUaW1lID0ge307XG4gIG1hY3JvLm9iaihtb2RlbC5rZXlNYXRyaXhUaW1lLCB7IG10aW1lOiAwIH0pO1xuICBtb2RlbC5ub3JtYWxNYXRyaXggPSBtYXQzLmNyZWF0ZSgpO1xuICBtb2RlbC5NQ1dDTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcblxuICAvLyBCdWlsZCBWVEsgQVBJXG4gIG1hY3JvLnNldEdldChwdWJsaWNBUEksIG1vZGVsLCBbJ2NvbnRleHQnXSk7XG5cbiAgLy8gT2JqZWN0IG1ldGhvZHNcbiAgdnRrT3BlbkdMVm9sdW1lKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a09wZW5HTFZvbHVtZScpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCB9O1xuIiwiaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcbmltcG9ydCB7IHZlYzMsIG1hdDMsIG1hdDQgfSBmcm9tICdnbC1tYXRyaXgnO1xuLy8gaW1wb3J0IHZ0a0JvdW5kaW5nQm94ICAgICAgIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0NvbW1vbi9EYXRhTW9kZWwvQm91bmRpbmdCb3gnO1xuaW1wb3J0IHZ0a0RhdGFBcnJheSBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9EYXRhQXJyYXknO1xuaW1wb3J0IHsgVnRrRGF0YVR5cGVzIH0gZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvRGF0YUFycmF5L0NvbnN0YW50cyc7XG5pbXBvcnQgdnRrSGVscGVyIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvSGVscGVyJztcbmltcG9ydCAqIGFzIHZ0a01hdGggZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0NvcmUvTWF0aCc7XG5pbXBvcnQgdnRrT3BlbkdMRnJhbWVidWZmZXIgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9GcmFtZWJ1ZmZlcic7XG5pbXBvcnQgdnRrT3BlbkdMVGV4dHVyZSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1RleHR1cmUnO1xuaW1wb3J0IHZ0a1NoYWRlclByb2dyYW0gZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9TaGFkZXJQcm9ncmFtJztcbmltcG9ydCB2dGtWZXJ0ZXhBcnJheU9iamVjdCBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1ZlcnRleEFycmF5T2JqZWN0JztcbmltcG9ydCB2dGtWaWV3Tm9kZSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvU2NlbmVHcmFwaC9WaWV3Tm9kZSc7XG5pbXBvcnQgeyBSZXByZXNlbnRhdGlvbiB9IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL1Byb3BlcnR5L0NvbnN0YW50cyc7XG5pbXBvcnQge1xuICBXcmFwLFxuICBGaWx0ZXIsXG59IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9PcGVuR0wvVGV4dHVyZS9Db25zdGFudHMnO1xuaW1wb3J0IHtcbiAgSW50ZXJwb2xhdGlvblR5cGUsXG4gIE9wYWNpdHlNb2RlLFxufSBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9Wb2x1bWVQcm9wZXJ0eS9Db25zdGFudHMnO1xuaW1wb3J0IHsgQmxlbmRNb2RlIH0gZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvVm9sdW1lTWFwcGVyL0NvbnN0YW50cyc7XG5cbmltcG9ydCB2dGtWb2x1bWVWUyBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML2dsc2wvdnRrVm9sdW1lVlMuZ2xzbCc7XG5pbXBvcnQgdnRrVm9sdW1lRlMgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL09wZW5HTC9nbHNsL3Z0a1ZvbHVtZUZTLmdsc2wnO1xuXG5jb25zdCB7IHZ0a1dhcm5pbmdNYWNybywgdnRrRXJyb3JNYWNybyB9ID0gbWFjcm87XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a09wZW5HTFZvbHVtZU1hcHBlciBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a09wZW5HTFZvbHVtZU1hcHBlcihwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a09wZW5HTFZvbHVtZU1hcHBlcicpO1xuXG4gIHB1YmxpY0FQSS5idWlsZFBhc3MgPSAoKSA9PiB7XG4gICAgbW9kZWwuekJ1ZmZlclRleHR1cmUgPSBudWxsO1xuICB9O1xuXG4gIC8vIG9oaCBzb21lb25lIGlzIGRvaW5nIGEgemJ1ZmZlciBwYXNzLCB1c2UgdGhhdCBmb3JcbiAgLy8gaW50ZXJtaXhlZCB2b2x1bWUgcmVuZGVyaW5nXG4gIHB1YmxpY0FQSS5vcGFxdWVaQnVmZmVyUGFzcyA9IChwcmVwYXNzLCByZW5kZXJQYXNzKSA9PiB7XG4gICAgaWYgKHByZXBhc3MpIHtcbiAgICAgIGNvbnN0IHpidCA9IHJlbmRlclBhc3MuZ2V0WkJ1ZmZlclRleHR1cmUoKTtcbiAgICAgIGlmICh6YnQgIT09IG1vZGVsLnpCdWZmZXJUZXh0dXJlKSB7XG4gICAgICAgIG1vZGVsLnpCdWZmZXJUZXh0dXJlID0gemJ0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBSZW5kZXJzIG15c2VsZlxuICBwdWJsaWNBUEkudm9sdW1lUGFzcyA9IChwcmVwYXNzLCByZW5kZXJQYXNzKSA9PiB7XG4gICAgaWYgKHByZXBhc3MpIHtcbiAgICAgIG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyA9IHB1YmxpY0FQSS5nZXRGaXJzdEFuY2VzdG9yT2ZUeXBlKFxuICAgICAgICAndnRrT3BlbkdMUmVuZGVyV2luZG93J1xuICAgICAgKTtcbiAgICAgIG1vZGVsLmNvbnRleHQgPSBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0Q29udGV4dCgpO1xuICAgICAgbW9kZWwudHJpcy5zZXRPcGVuR0xSZW5kZXJXaW5kb3cobW9kZWwub3BlbkdMUmVuZGVyV2luZG93KTtcbiAgICAgIG1vZGVsLmppdHRlclRleHR1cmUuc2V0T3BlbkdMUmVuZGVyV2luZG93KG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyk7XG4gICAgICBtb2RlbC5mcmFtZWJ1ZmZlci5zZXRPcGVuR0xSZW5kZXJXaW5kb3cobW9kZWwub3BlbkdMUmVuZGVyV2luZG93KTtcblxuICAgICAgLy8gUGVyIENvbXBvbmVudD9cbiAgICAgIG1vZGVsLnNjYWxhclRleHR1cmUuc2V0T3BlbkdMUmVuZGVyV2luZG93KG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyk7XG4gICAgICBtb2RlbC5jb2xvclRleHR1cmUuc2V0T3BlbkdMUmVuZGVyV2luZG93KG1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdyk7XG4gICAgICBtb2RlbC5vcGFjaXR5VGV4dHVyZS5zZXRPcGVuR0xSZW5kZXJXaW5kb3cobW9kZWwub3BlbkdMUmVuZGVyV2luZG93KTtcblxuICAgICAgbW9kZWwub3BlbkdMVm9sdW1lID0gcHVibGljQVBJLmdldEZpcnN0QW5jZXN0b3JPZlR5cGUoJ3Z0a09wZW5HTFZvbHVtZScpO1xuICAgICAgY29uc3QgYWN0b3IgPSBtb2RlbC5vcGVuR0xWb2x1bWUuZ2V0UmVuZGVyYWJsZSgpO1xuICAgICAgbW9kZWwub3BlbkdMUmVuZGVyZXIgPSBwdWJsaWNBUEkuZ2V0Rmlyc3RBbmNlc3Rvck9mVHlwZShcbiAgICAgICAgJ3Z0a09wZW5HTFJlbmRlcmVyJ1xuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlbiA9IG1vZGVsLm9wZW5HTFJlbmRlcmVyLmdldFJlbmRlcmFibGUoKTtcbiAgICAgIG1vZGVsLm9wZW5HTENhbWVyYSA9IG1vZGVsLm9wZW5HTFJlbmRlcmVyLmdldFZpZXdOb2RlRm9yKFxuICAgICAgICByZW4uZ2V0QWN0aXZlQ2FtZXJhKClcbiAgICAgICk7XG4gICAgICBwdWJsaWNBUEkucmVuZGVyUGllY2UocmVuLCBhY3Rvcik7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5idWlsZFNoYWRlcnMgPSAoc2hhZGVycywgcmVuLCBhY3RvcikgPT4ge1xuICAgIHB1YmxpY0FQSS5nZXRTaGFkZXJUZW1wbGF0ZShzaGFkZXJzLCByZW4sIGFjdG9yKTtcbiAgICBwdWJsaWNBUEkucmVwbGFjZVNoYWRlclZhbHVlcyhzaGFkZXJzLCByZW4sIGFjdG9yKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0U2hhZGVyVGVtcGxhdGUgPSAoc2hhZGVycywgcmVuLCBhY3RvcikgPT4ge1xuICAgIHNoYWRlcnMuVmVydGV4ID0gdnRrVm9sdW1lVlM7XG4gICAgc2hhZGVycy5GcmFnbWVudCA9IHZ0a1ZvbHVtZUZTO1xuICAgIHNoYWRlcnMuR2VvbWV0cnkgPSAnJztcbiAgfTtcblxuICBwdWJsaWNBUEkucmVwbGFjZVNoYWRlclZhbHVlcyA9IChzaGFkZXJzLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgbGV0IEZTU291cmNlID0gc2hhZGVycy5GcmFnbWVudDtcblxuICAgIC8vIGRlZmluZSBzb21lIHZhbHVlcyBpbiB0aGUgc2hhZGVyXG4gICAgY29uc3QgaVR5cGUgPSBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldEludGVycG9sYXRpb25UeXBlKCk7XG4gICAgaWYgKGlUeXBlID09PSBJbnRlcnBvbGF0aW9uVHlwZS5MSU5FQVIpIHtcbiAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgJy8vVlRLOjpUcmlsaW5lYXJPbicsXG4gICAgICAgICcjZGVmaW5lIHZ0a1RyaWxpbmVhck9uJ1xuICAgICAgKS5yZXN1bHQ7XG4gICAgfVxuXG4gICAgY29uc3QgdnRrSW1hZ2VMYWJlbE91dGxpbmUgPSBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldFVzZUxhYmVsT3V0bGluZSgpO1xuICAgIGlmICh2dGtJbWFnZUxhYmVsT3V0bGluZSA9PT0gdHJ1ZSkge1xuICAgICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICAgIEZTU291cmNlLFxuICAgICAgICAnLy9WVEs6OkltYWdlTGFiZWxPdXRsaW5lT24nLFxuICAgICAgICAnI2RlZmluZSB2dGtJbWFnZUxhYmVsT3V0bGluZU9uJ1xuICAgICAgKS5yZXN1bHQ7XG4gICAgfVxuXG4gICAgY29uc3QgbnVtQ29tcCA9IG1vZGVsLnNjYWxhclRleHR1cmUuZ2V0Q29tcG9uZW50cygpO1xuICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgRlNTb3VyY2UsXG4gICAgICAnLy9WVEs6Ok51bUNvbXBvbmVudHMnLFxuICAgICAgYCNkZWZpbmUgdnRrTnVtQ29tcG9uZW50cyAke251bUNvbXB9YFxuICAgICkucmVzdWx0O1xuXG4gICAgY29uc3QgaUNvbXBzID0gYWN0b3IuZ2V0UHJvcGVydHkoKS5nZXRJbmRlcGVuZGVudENvbXBvbmVudHMoKTtcbiAgICBpZiAoaUNvbXBzKSB7XG4gICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgRlNTb3VyY2UsXG4gICAgICAgICcvL1ZUSzo6SW5kZXBlbmRlbnRDb21wb25lbnRzT24nLFxuICAgICAgICAnI2RlZmluZSB2dGtJbmRlcGVuZGVudENvbXBvbmVudHNPbidcbiAgICAgICkucmVzdWx0O1xuXG4gICAgICAvLyBEZWZpbmUgYW55IHByb3BvcnRpb25hbCBjb21wb25lbnRzXG4gICAgICBjb25zdCBwcm9wb3J0aW9uYWxDb21wb25lbnRzID0gW107XG4gICAgICBmb3IgKGxldCBuYyA9IDA7IG5jIDwgbnVtQ29tcDsgbmMrKykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgYWN0b3IuZ2V0UHJvcGVydHkoKS5nZXRPcGFjaXR5TW9kZShuYykgPT09IE9wYWNpdHlNb2RlLlBST1BPUlRJT05BTFxuICAgICAgICApIHtcbiAgICAgICAgICBwcm9wb3J0aW9uYWxDb21wb25lbnRzLnB1c2goYCNkZWZpbmUgdnRrQ29tcG9uZW50JHtuY31Qcm9wb3J0aW9uYWxgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvcG9ydGlvbmFsQ29tcG9uZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICAgIEZTU291cmNlLFxuICAgICAgICAgICcvL1ZUSzo6dnRrUHJvcG9ydGlvbmFsQ29tcG9uZW50cycsXG4gICAgICAgICAgcHJvcG9ydGlvbmFsQ29tcG9uZW50cy5qb2luKCdcXG4nKVxuICAgICAgICApLnJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXZWJHTCBvbmx5IHN1cHBvcnRzIGxvb3BzIG92ZXIgY29uc3RhbnRzXG4gICAgLy8gYW5kIGRvZXMgbm90IHN1cHBvcnQgd2hpbGUgbG9vcHMgc28gd2VcbiAgICAvLyBoYXZlIHRvIGhhcmQgY29kZSBob3cgbWFueSBzdGVwcy9zYW1wbGVzIHRvIHRha2VcbiAgICAvLyBXZSBkbyBhIGJyZWFrIHNvIG1vc3Qgc3lzdGVtcyB3aWxsIGdyYWNlZnVsbHlcbiAgICAvLyBlYXJseSB0ZXJtaW5hdGUsIGJ1dCBpdCBpcyBhbHdheXMgcG9zc2libGVcbiAgICAvLyBhIHN5c3RlbSB3aWxsIGV4ZWN1dGUgZXZlcnkgc3RlcCByZWdhcmRsZXNzXG4gICAgY29uc3QgZXh0ID0gbW9kZWwuY3VycmVudElucHV0LmdldEV4dGVudCgpO1xuICAgIGNvbnN0IHNwYyA9IG1vZGVsLmN1cnJlbnRJbnB1dC5nZXRTcGFjaW5nKCk7XG4gICAgY29uc3QgdnNpemUgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIHZlYzMuc2V0KFxuICAgICAgdnNpemUsXG4gICAgICAoZXh0WzFdIC0gZXh0WzBdKSAqIHNwY1swXSxcbiAgICAgIChleHRbM10gLSBleHRbMl0pICogc3BjWzFdLFxuICAgICAgKGV4dFs1XSAtIGV4dFs0XSkgKiBzcGNbMl1cbiAgICApO1xuXG4gICAgY29uc3QgbWF4U2FtcGxlcyA9XG4gICAgICB2ZWMzLmxlbmd0aCh2c2l6ZSkgLyBtb2RlbC5yZW5kZXJhYmxlLmdldFNhbXBsZURpc3RhbmNlKCk7XG5cbiAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgIEZTU291cmNlLFxuICAgICAgJy8vVlRLOjpNYXhpbXVtU2FtcGxlc1ZhbHVlJyxcbiAgICAgIGAke01hdGguY2VpbChtYXhTYW1wbGVzKX1gXG4gICAgKS5yZXN1bHQ7XG5cbiAgICAvLyBzZXQgbGlnaHQgY29tcGxleGl0eVxuICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgRlNTb3VyY2UsXG4gICAgICAnLy9WVEs6OkxpZ2h0Q29tcGxleGl0eScsXG4gICAgICBgI2RlZmluZSB2dGtMaWdodENvbXBsZXhpdHkgJHttb2RlbC5sYXN0TGlnaHRDb21wbGV4aXR5fWBcbiAgICApLnJlc3VsdDtcblxuICAgIC8vIGlmIHVzaW5nIGdyYWRpZW50IG9wYWNpdHkgZGVmaW5lIHRoYXRcbiAgICBtb2RlbC5nb3BhY2l0eSA9IGFjdG9yLmdldFByb3BlcnR5KCkuZ2V0VXNlR3JhZGllbnRPcGFjaXR5KDApO1xuICAgIGZvciAobGV0IG5jID0gMTsgaUNvbXBzICYmICFtb2RlbC5nb3BhY2l0eSAmJiBuYyA8IG51bUNvbXA7ICsrbmMpIHtcbiAgICAgIGlmIChhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldFVzZUdyYWRpZW50T3BhY2l0eShuYykpIHtcbiAgICAgICAgbW9kZWwuZ29wYWNpdHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobW9kZWwuZ29wYWNpdHkpIHtcbiAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgJy8vVlRLOjpHcmFkaWVudE9wYWNpdHlPbicsXG4gICAgICAgICcjZGVmaW5lIHZ0a0dyYWRpZW50T3BhY2l0eU9uJ1xuICAgICAgKS5yZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBhIHp0ZXh0dXJlIHRoZW4gZGVjbGFyZSBpdCBhbmQgdXNlIGl0XG4gICAgaWYgKG1vZGVsLnpCdWZmZXJUZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShGU1NvdXJjZSwgJy8vVlRLOjpaQnVmZmVyOjpEZWMnLCBbXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB6QnVmZmVyVGV4dHVyZTsnLFxuICAgICAgICAndW5pZm9ybSBmbG9hdCB2cFdpZHRoOycsXG4gICAgICAgICd1bmlmb3JtIGZsb2F0IHZwSGVpZ2h0OycsXG4gICAgICBdKS5yZXN1bHQ7XG4gICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShGU1NvdXJjZSwgJy8vVlRLOjpaQnVmZmVyOjpJbXBsJywgW1xuICAgICAgICAndmVjNCBkZXB0aFZlYyA9IHRleHR1cmUyRCh6QnVmZmVyVGV4dHVyZSwgdmVjMihnbF9GcmFnQ29vcmQueCAvIHZwV2lkdGgsIGdsX0ZyYWdDb29yZC55L3ZwSGVpZ2h0KSk7JyxcbiAgICAgICAgJ2Zsb2F0IHpkZXB0aCA9IChkZXB0aFZlYy5yKjI1Ni4wICsgZGVwdGhWZWMuZykvMjU3LjA7JyxcbiAgICAgICAgJ3pkZXB0aCA9IHpkZXB0aCAqIDIuMCAtIDEuMDsnLFxuICAgICAgICAnemRlcHRoID0gLTIuMCAqIGNhbUZhciAqIGNhbU5lYXIgLyAoemRlcHRoKihjYW1GYXItY2FtTmVhciktKGNhbUZhcitjYW1OZWFyKSkgLSBjYW1OZWFyOycsXG4gICAgICAgICd6ZGVwdGggPSAtemRlcHRoL3JheURpci56OycsXG4gICAgICAgICdkaXN0cy55ID0gbWluKHpkZXB0aCxkaXN0cy55KTsnLFxuICAgICAgXSkucmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgQmxlbmRNb2RlIGFwcHJvYWNoXG4gICAgRlNTb3VyY2UgPSB2dGtTaGFkZXJQcm9ncmFtLnN1YnN0aXR1dGUoXG4gICAgICBGU1NvdXJjZSxcbiAgICAgICcvL1ZUSzo6QmxlbmRNb2RlJyxcbiAgICAgIGAke21vZGVsLnJlbmRlcmFibGUuZ2V0QmxlbmRNb2RlKCl9YFxuICAgICkucmVzdWx0O1xuXG4gICAgY29uc3QgYXZlcmFnZUlQU2NhbGFyUmFuZ2UgPSBtb2RlbC5yZW5kZXJhYmxlLmdldEF2ZXJhZ2VJUFNjYWxhclJhbmdlKCk7XG5cbiAgICAvLyBUT0RPOiBBZGRpbmcgdGhlIC4wIGF0IHRoZSBlbmQgZmVlbHMgaGFja3lcbiAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgIEZTU291cmNlLFxuICAgICAgJy8vVlRLOjpBdmVyYWdlSVBTY2FsYXJSYW5nZU1pbicsXG4gICAgICBgJHthdmVyYWdlSVBTY2FsYXJSYW5nZVswXX0uMGBcbiAgICApLnJlc3VsdDtcblxuICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgRlNTb3VyY2UsXG4gICAgICAnLy9WVEs6OkF2ZXJhZ2VJUFNjYWxhclJhbmdlTWF4JyxcbiAgICAgIGAke2F2ZXJhZ2VJUFNjYWxhclJhbmdlWzFdfS4wYFxuICAgICkucmVzdWx0O1xuXG4gICAgc2hhZGVycy5GcmFnbWVudCA9IEZTU291cmNlO1xuXG4gICAgcHVibGljQVBJLnJlcGxhY2VTaGFkZXJMaWdodChzaGFkZXJzLCByZW4sIGFjdG9yKTtcbiAgfTtcblxuICBwdWJsaWNBUEkucmVwbGFjZVNoYWRlckxpZ2h0ID0gKHNoYWRlcnMsIHJlbiwgYWN0b3IpID0+IHtcbiAgICBsZXQgRlNTb3VyY2UgPSBzaGFkZXJzLkZyYWdtZW50O1xuXG4gICAgLy8gY2hlY2sgZm9yIHNoYWRvdyBtYXBzXG4gICAgY29uc3Qgc2hhZG93RmFjdG9yID0gJyc7XG5cbiAgICBzd2l0Y2ggKG1vZGVsLmxhc3RMaWdodENvbXBsZXhpdHkpIHtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICBjYXNlIDA6IC8vIG5vIGxpZ2h0aW5nLCB0Y29sb3IgaXMgZmluZSBhcyBpc1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxOiAvLyBoZWFkbGlnaHRcbiAgICAgIGNhc2UgMjogLy8gbGlnaHQga2l0XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgLy8gcG9zaXRpb25hbCBub3QgaW1wbGVtZW50ZWQgZmFsbGJhY2sgdG8gZGlyZWN0aW9uYWxcbiAgICAgICAgbGV0IGxpZ2h0TnVtID0gMDtcbiAgICAgICAgcmVuLmdldExpZ2h0cygpLmZvckVhY2goKGxpZ2h0KSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdHVzID0gbGlnaHQuZ2V0U3dpdGNoKCk7XG4gICAgICAgICAgaWYgKHN0YXR1cyA+IDApIHtcbiAgICAgICAgICAgIEZTU291cmNlID0gdnRrU2hhZGVyUHJvZ3JhbS5zdWJzdGl0dXRlKFxuICAgICAgICAgICAgICBGU1NvdXJjZSxcbiAgICAgICAgICAgICAgJy8vVlRLOjpMaWdodDo6RGVjJyxcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIC8vIGludGVuc2l0eSB3ZWlnaHRlZCBjb2xvclxuICAgICAgICAgICAgICAgIGB1bmlmb3JtIHZlYzMgbGlnaHRDb2xvciR7bGlnaHROdW19O2AsXG4gICAgICAgICAgICAgICAgYHVuaWZvcm0gdmVjMyBsaWdodERpcmVjdGlvblZDJHtsaWdodE51bX07IC8vIG5vcm1hbGl6ZWRgLFxuICAgICAgICAgICAgICAgIGB1bmlmb3JtIHZlYzMgbGlnaHRIYWxmQW5nbGVWQyR7bGlnaHROdW19OyAvLyBub3JtYWxpemVkYCxcbiAgICAgICAgICAgICAgICAnLy9WVEs6OkxpZ2h0OjpEZWMnLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKS5yZXN1bHQ7XG4gICAgICAgICAgICBGU1NvdXJjZSA9IHZ0a1NoYWRlclByb2dyYW0uc3Vic3RpdHV0ZShcbiAgICAgICAgICAgICAgRlNTb3VyY2UsXG4gICAgICAgICAgICAgICcvL1ZUSzo6TGlnaHQ6OkltcGwnLFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGAgIGZsb2F0IGRmID0gbWF4KDAuMCwgZG90KG5vcm1hbC5yZ2IsIC1saWdodERpcmVjdGlvblZDJHtsaWdodE51bX0pKTtgLFxuICAgICAgICAgICAgICAgIGAgIGZsb2F0IGRmID0gYWJzKGRvdChub3JtYWwucmdiLCAtbGlnaHREaXJlY3Rpb25WQyR7bGlnaHROdW19KSk7YCxcbiAgICAgICAgICAgICAgICBgICBkaWZmdXNlICs9ICgoZGYke3NoYWRvd0ZhY3Rvcn0pICogbGlnaHRDb2xvciR7bGlnaHROdW19KTtgLFxuICAgICAgICAgICAgICAgIC8vICcgIGlmIChkZiA+IDAuMCknLFxuICAgICAgICAgICAgICAgIC8vICcgICAgeycsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgIGAgICAgZmxvYXQgc2YgPSBwb3coIG1heCgwLjAsIGRvdChsaWdodEhhbGZBbmdsZVdDJHtsaWdodE51bX0sbm9ybWFsLnJnYikpLCBzcGVjdWxhclBvd2VyKTtgLFxuICAgICAgICAgICAgICAgIGAgICAgZmxvYXQgc2YgPSBwb3coIGFicyhkb3QobGlnaHRIYWxmQW5nbGVWQyR7bGlnaHROdW19LG5vcm1hbC5yZ2IpKSwgdlNwZWN1bGFyUG93ZXIpO2AsXG4gICAgICAgICAgICAgICAgYCAgICBzcGVjdWxhciArPSAoKHNmJHtzaGFkb3dGYWN0b3J9KSAqIGxpZ2h0Q29sb3Ike2xpZ2h0TnVtfSk7YCxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgJyAgICB9JyxcbiAgICAgICAgICAgICAgICAnICAvL1ZUSzo6TGlnaHQ6OkltcGwnLFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBmYWxzZVxuICAgICAgICAgICAgKS5yZXN1bHQ7XG4gICAgICAgICAgICBsaWdodE51bSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2hhZGVycy5GcmFnbWVudCA9IEZTU291cmNlO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXROZWVkVG9SZWJ1aWxkU2hhZGVycyA9IChjZWxsQk8sIHJlbiwgYWN0b3IpID0+IHtcbiAgICAvLyBkbyB3ZSBuZWVkIGxpZ2h0aW5nP1xuICAgIGxldCBsaWdodENvbXBsZXhpdHkgPSAwO1xuICAgIGlmIChcbiAgICAgIGFjdG9yLmdldFByb3BlcnR5KCkuZ2V0U2hhZGUoKSAmJlxuICAgICAgbW9kZWwucmVuZGVyYWJsZS5nZXRCbGVuZE1vZGUoKSA9PT0gQmxlbmRNb2RlLkNPTVBPU0lURV9CTEVORFxuICAgICkge1xuICAgICAgLy8gY29uc2lkZXIgdGhlIGxpZ2h0aW5nIGNvbXBsZXhpdHkgdG8gZGV0ZXJtaW5lIHdoaWNoIGNhc2UgYXBwbGllc1xuICAgICAgLy8gc2ltcGxlIGhlYWRsaWdodCwgTGlnaHQgS2l0LCB0aGUgd2hvbGUgZmVhdHVyZSBzZXQgb2YgVlRLXG4gICAgICBsaWdodENvbXBsZXhpdHkgPSAwO1xuICAgICAgbW9kZWwubnVtYmVyT2ZMaWdodHMgPSAwO1xuXG4gICAgICByZW4uZ2V0TGlnaHRzKCkuZm9yRWFjaCgobGlnaHQpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbGlnaHQuZ2V0U3dpdGNoKCk7XG4gICAgICAgIGlmIChzdGF0dXMgPiAwKSB7XG4gICAgICAgICAgbW9kZWwubnVtYmVyT2ZMaWdodHMrKztcbiAgICAgICAgICBpZiAobGlnaHRDb21wbGV4aXR5ID09PSAwKSB7XG4gICAgICAgICAgICBsaWdodENvbXBsZXhpdHkgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBsaWdodENvbXBsZXhpdHkgPT09IDEgJiZcbiAgICAgICAgICAobW9kZWwubnVtYmVyT2ZMaWdodHMgPiAxIHx8XG4gICAgICAgICAgICBsaWdodC5nZXRJbnRlbnNpdHkoKSAhPT0gMS4wIHx8XG4gICAgICAgICAgICAhbGlnaHQubGlnaHRUeXBlSXNIZWFkTGlnaHQoKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgbGlnaHRDb21wbGV4aXR5ID0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlnaHRDb21wbGV4aXR5IDwgMyAmJiBsaWdodC5nZXRQb3NpdGlvbmFsKCkpIHtcbiAgICAgICAgICBsaWdodENvbXBsZXhpdHkgPSAzO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgbmVlZFJlYnVpbGQgPSBmYWxzZTtcbiAgICBpZiAobW9kZWwubGFzdExpZ2h0Q29tcGxleGl0eSAhPT0gbGlnaHRDb21wbGV4aXR5KSB7XG4gICAgICBtb2RlbC5sYXN0TGlnaHRDb21wbGV4aXR5ID0gbGlnaHRDb21wbGV4aXR5O1xuICAgICAgbmVlZFJlYnVpbGQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIGhhcyBzb21ldGhpbmcgY2hhbmdlZCB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgdG8gcmVjcmVhdGUgdGhlIHNoYWRlcj9cbiAgICBpZiAoXG4gICAgICBjZWxsQk8uZ2V0UHJvZ3JhbSgpID09PSAwIHx8XG4gICAgICBuZWVkUmVidWlsZCB8fFxuICAgICAgbW9kZWwubGFzdEhhdmVTZWVuRGVwdGhSZXF1ZXN0ICE9PSBtb2RlbC5oYXZlU2VlbkRlcHRoUmVxdWVzdCB8fFxuICAgICAgISFtb2RlbC5sYXN0WkJ1ZmZlclRleHR1cmUgIT09ICEhbW9kZWwuekJ1ZmZlclRleHR1cmUgfHxcbiAgICAgIGNlbGxCTy5nZXRTaGFkZXJTb3VyY2VUaW1lKCkuZ2V0TVRpbWUoKSA8IHB1YmxpY0FQSS5nZXRNVGltZSgpIHx8XG4gICAgICBjZWxsQk8uZ2V0U2hhZGVyU291cmNlVGltZSgpLmdldE1UaW1lKCkgPCBhY3Rvci5nZXRNVGltZSgpIHx8XG4gICAgICBjZWxsQk8uZ2V0U2hhZGVyU291cmNlVGltZSgpLmdldE1UaW1lKCkgPCBtb2RlbC5yZW5kZXJhYmxlLmdldE1UaW1lKCkgfHxcbiAgICAgIGNlbGxCTy5nZXRTaGFkZXJTb3VyY2VUaW1lKCkuZ2V0TVRpbWUoKSA8IG1vZGVsLmN1cnJlbnRJbnB1dC5nZXRNVGltZSgpXG4gICAgKSB7XG4gICAgICBtb2RlbC5sYXN0WkJ1ZmZlclRleHR1cmUgPSBtb2RlbC56QnVmZmVyVGV4dHVyZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBwdWJsaWNBUEkudXBkYXRlU2hhZGVycyA9IChjZWxsQk8sIHJlbiwgYWN0b3IpID0+IHtcbiAgICBtb2RlbC5sYXN0Qm91bmRCTyA9IGNlbGxCTztcblxuICAgIC8vIGhhcyBzb21ldGhpbmcgY2hhbmdlZCB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgdG8gcmVjcmVhdGUgdGhlIHNoYWRlcj9cbiAgICBpZiAocHVibGljQVBJLmdldE5lZWRUb1JlYnVpbGRTaGFkZXJzKGNlbGxCTywgcmVuLCBhY3RvcikpIHtcbiAgICAgIGNvbnN0IHNoYWRlcnMgPSB7IFZlcnRleDogbnVsbCwgRnJhZ21lbnQ6IG51bGwsIEdlb21ldHJ5OiBudWxsIH07XG5cbiAgICAgIHB1YmxpY0FQSS5idWlsZFNoYWRlcnMoc2hhZGVycywgcmVuLCBhY3Rvcik7XG5cbiAgICAgIC8vIGNvbXBpbGUgYW5kIGJpbmQgdGhlIHByb2dyYW0gaWYgbmVlZGVkXG4gICAgICBjb25zdCBuZXdTaGFkZXIgPSBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3dcbiAgICAgICAgLmdldFNoYWRlckNhY2hlKClcbiAgICAgICAgLnJlYWR5U2hhZGVyUHJvZ3JhbUFycmF5KFxuICAgICAgICAgIHNoYWRlcnMuVmVydGV4LFxuICAgICAgICAgIHNoYWRlcnMuRnJhZ21lbnQsXG4gICAgICAgICAgc2hhZGVycy5HZW9tZXRyeVxuICAgICAgICApO1xuXG4gICAgICAvLyBpZiB0aGUgc2hhZGVyIGNoYW5nZWQgcmVpbml0aWFsaXplIHRoZSBWQU9cbiAgICAgIGlmIChuZXdTaGFkZXIgIT09IGNlbGxCTy5nZXRQcm9ncmFtKCkpIHtcbiAgICAgICAgY2VsbEJPLnNldFByb2dyYW0obmV3U2hhZGVyKTtcbiAgICAgICAgLy8gcmVzZXQgdGhlIFZBTyBhcyB0aGUgc2hhZGVyIGhhcyBjaGFuZ2VkXG4gICAgICAgIGNlbGxCTy5nZXRWQU8oKS5yZWxlYXNlR3JhcGhpY3NSZXNvdXJjZXMoKTtcbiAgICAgIH1cblxuICAgICAgY2VsbEJPLmdldFNoYWRlclNvdXJjZVRpbWUoKS5tb2RpZmllZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3dcbiAgICAgICAgLmdldFNoYWRlckNhY2hlKClcbiAgICAgICAgLnJlYWR5U2hhZGVyUHJvZ3JhbShjZWxsQk8uZ2V0UHJvZ3JhbSgpKTtcbiAgICB9XG5cbiAgICBjZWxsQk8uZ2V0VkFPKCkuYmluZCgpO1xuICAgIHB1YmxpY0FQSS5zZXRNYXBwZXJTaGFkZXJQYXJhbWV0ZXJzKGNlbGxCTywgcmVuLCBhY3Rvcik7XG4gICAgcHVibGljQVBJLnNldENhbWVyYVNoYWRlclBhcmFtZXRlcnMoY2VsbEJPLCByZW4sIGFjdG9yKTtcbiAgICBwdWJsaWNBUEkuc2V0UHJvcGVydHlTaGFkZXJQYXJhbWV0ZXJzKGNlbGxCTywgcmVuLCBhY3Rvcik7XG4gIH07XG5cbiAgcHVibGljQVBJLnNldE1hcHBlclNoYWRlclBhcmFtZXRlcnMgPSAoY2VsbEJPLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgLy8gTm93IHRvIHVwZGF0ZSB0aGUgVkFPIHRvbywgaWYgbmVjZXNzYXJ5LlxuICAgIGNvbnN0IHByb2dyYW0gPSBjZWxsQk8uZ2V0UHJvZ3JhbSgpO1xuXG4gICAgaWYgKFxuICAgICAgY2VsbEJPLmdldENBQk8oKS5nZXRFbGVtZW50Q291bnQoKSAmJlxuICAgICAgKG1vZGVsLlZCT0J1aWxkVGltZS5nZXRNVGltZSgpID5cbiAgICAgICAgY2VsbEJPLmdldEF0dHJpYnV0ZVVwZGF0ZVRpbWUoKS5nZXRNVGltZSgpIHx8XG4gICAgICAgIGNlbGxCTy5nZXRTaGFkZXJTb3VyY2VUaW1lKCkuZ2V0TVRpbWUoKSA+XG4gICAgICAgICAgY2VsbEJPLmdldEF0dHJpYnV0ZVVwZGF0ZVRpbWUoKS5nZXRNVGltZSgpKVxuICAgICkge1xuICAgICAgaWYgKHByb2dyYW0uaXNBdHRyaWJ1dGVVc2VkKCd2ZXJ0ZXhEQycpKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhY2VsbEJPXG4gICAgICAgICAgICAuZ2V0VkFPKClcbiAgICAgICAgICAgIC5hZGRBdHRyaWJ1dGVBcnJheShcbiAgICAgICAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgICAgICAgY2VsbEJPLmdldENBQk8oKSxcbiAgICAgICAgICAgICAgJ3ZlcnRleERDJyxcbiAgICAgICAgICAgICAgY2VsbEJPLmdldENBQk8oKS5nZXRWZXJ0ZXhPZmZzZXQoKSxcbiAgICAgICAgICAgICAgY2VsbEJPLmdldENBQk8oKS5nZXRTdHJpZGUoKSxcbiAgICAgICAgICAgICAgbW9kZWwuY29udGV4dC5GTE9BVCxcbiAgICAgICAgICAgICAgMyxcbiAgICAgICAgICAgICAgbW9kZWwuY29udGV4dC5GQUxTRVxuICAgICAgICAgICAgKVxuICAgICAgICApIHtcbiAgICAgICAgICB2dGtFcnJvck1hY3JvKCdFcnJvciBzZXR0aW5nIHZlcnRleERDIGluIHNoYWRlciBWQU8uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNlbGxCTy5nZXRBdHRyaWJ1dGVVcGRhdGVUaW1lKCkubW9kaWZpZWQoKTtcbiAgICB9XG5cbiAgICBwcm9ncmFtLnNldFVuaWZvcm1pKCd0ZXh0dXJlMScsIG1vZGVsLnNjYWxhclRleHR1cmUuZ2V0VGV4dHVyZVVuaXQoKSk7XG4gICAgcHJvZ3JhbS5zZXRVbmlmb3JtZignc2FtcGxlRGlzdGFuY2UnLCBtb2RlbC5yZW5kZXJhYmxlLmdldFNhbXBsZURpc3RhbmNlKCkpO1xuXG4gICAgLy8gaWYgd2UgaGF2ZSBhIHpidWZmZXIgdGV4dHVyZSB0aGVuIHNldCBpdFxuICAgIGlmIChtb2RlbC56QnVmZmVyVGV4dHVyZSAhPT0gbnVsbCkge1xuICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtaShcbiAgICAgICAgJ3pCdWZmZXJUZXh0dXJlJyxcbiAgICAgICAgbW9kZWwuekJ1ZmZlclRleHR1cmUuZ2V0VGV4dHVyZVVuaXQoKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHNpemUgPSBwdWJsaWNBUEkuZ2V0UmVuZGVyVGFyZ2V0U2l6ZSgpO1xuICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtZigndnBXaWR0aCcsIHNpemVbMF0pO1xuICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtZigndnBIZWlnaHQnLCBzaXplWzFdKTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLnNldENhbWVyYVNoYWRlclBhcmFtZXRlcnMgPSAoY2VsbEJPLCByZW4sIGFjdG9yKSA9PiB7XG4gICAgLy8gLy8gW1dNVlBdQyA9PSB7d29ybGQsIG1vZGVsLCB2aWV3LCBwcm9qZWN0aW9ufSBjb29yZGluYXRlc1xuICAgIC8vIC8vIEUuZy4sIFdDUEMgPT0gd29ybGQgdG8gcHJvamVjdGlvbiBjb29yZGluYXRlIHRyYW5zZm9ybWF0aW9uXG4gICAgY29uc3Qga2V5TWF0cyA9IG1vZGVsLm9wZW5HTENhbWVyYS5nZXRLZXlNYXRyaWNlcyhyZW4pO1xuICAgIGNvbnN0IGFjdE1hdHMgPSBtb2RlbC5vcGVuR0xWb2x1bWUuZ2V0S2V5TWF0cmljZXMoKTtcblxuICAgIG1hdDQubXVsdGlwbHkobW9kZWwubW9kZWxUb1ZpZXcsIGtleU1hdHMud2N2YywgYWN0TWF0cy5tY3djKTtcblxuICAgIGNvbnN0IHByb2dyYW0gPSBjZWxsQk8uZ2V0UHJvZ3JhbSgpO1xuXG4gICAgY29uc3QgY2FtID0gbW9kZWwub3BlbkdMQ2FtZXJhLmdldFJlbmRlcmFibGUoKTtcbiAgICBjb25zdCBjcmFuZ2UgPSBjYW0uZ2V0Q2xpcHBpbmdSYW5nZSgpO1xuICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoJ2NhbVRoaWNrJywgY3JhbmdlWzFdIC0gY3JhbmdlWzBdKTtcbiAgICBwcm9ncmFtLnNldFVuaWZvcm1mKCdjYW1OZWFyJywgY3JhbmdlWzBdKTtcbiAgICBwcm9ncmFtLnNldFVuaWZvcm1mKCdjYW1GYXInLCBjcmFuZ2VbMV0pO1xuXG4gICAgY29uc3QgYm91bmRzID0gbW9kZWwuY3VycmVudElucHV0LmdldEJvdW5kcygpO1xuICAgIGNvbnN0IGRpbXMgPSBtb2RlbC5jdXJyZW50SW5wdXQuZ2V0RGltZW5zaW9ucygpO1xuXG4gICAgLy8gY29tcHV0ZSB0aGUgdmlld3BvcnQgYm91bmRzIG9mIHRoZSB2b2x1bWVcbiAgICAvLyB3ZSB3aWxsIG9ubHkgcmVuZGVyIHRob3NlIGZyYWdtZW50cy5cbiAgICBjb25zdCBwb3MgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIGNvbnN0IGRpciA9IHZlYzMuY3JlYXRlKCk7XG4gICAgbGV0IGRjeG1pbiA9IDEuMDtcbiAgICBsZXQgZGN4bWF4ID0gLTEuMDtcbiAgICBsZXQgZGN5bWluID0gMS4wO1xuICAgIGxldCBkY3ltYXggPSAtMS4wO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyArK2kpIHtcbiAgICAgIHZlYzMuc2V0KFxuICAgICAgICBwb3MsXG4gICAgICAgIGJvdW5kc1tpICUgMl0sXG4gICAgICAgIGJvdW5kc1syICsgKE1hdGguZmxvb3IoaSAvIDIpICUgMildLFxuICAgICAgICBib3VuZHNbNCArIE1hdGguZmxvb3IoaSAvIDQpXVxuICAgICAgKTtcbiAgICAgIHZlYzMudHJhbnNmb3JtTWF0NChwb3MsIHBvcywgbW9kZWwubW9kZWxUb1ZpZXcpO1xuICAgICAgaWYgKCFjYW0uZ2V0UGFyYWxsZWxQcm9qZWN0aW9uKCkpIHtcbiAgICAgICAgdmVjMy5ub3JtYWxpemUoZGlyLCBwb3MpO1xuXG4gICAgICAgIC8vIG5vdyBmaW5kIHRoZSBwcm9qZWN0aW9uIG9mIHRoaXMgcG9pbnQgb250byBhXG4gICAgICAgIC8vIG5lYXJaIGRpc3RhbmNlIHBsYW5lLiBTaW5jZSB0aGUgY2FtZXJhIGlzIGF0IDAsMCwwXG4gICAgICAgIC8vIGluIFZDIHRoZSByYXkgaXMganVzdCB0KnBvcyBhbmRcbiAgICAgICAgLy8gdCBpcyAtbmVhclovZGlyLnpcbiAgICAgICAgLy8gaW50ZXJzZWN0aW9uIGJlY29tZXMgcG9zLngvcG9zLnpcbiAgICAgICAgY29uc3QgdCA9IC1jcmFuZ2VbMF0gLyBwb3NbMl07XG4gICAgICAgIHZlYzMuc2NhbGUocG9zLCBkaXIsIHQpO1xuICAgICAgfVxuICAgICAgLy8gbm93IGNvbnZlcnQgdG8gRENcbiAgICAgIHZlYzMudHJhbnNmb3JtTWF0NChwb3MsIHBvcywga2V5TWF0cy52Y3BjKTtcblxuICAgICAgZGN4bWluID0gTWF0aC5taW4ocG9zWzBdLCBkY3htaW4pO1xuICAgICAgZGN4bWF4ID0gTWF0aC5tYXgocG9zWzBdLCBkY3htYXgpO1xuICAgICAgZGN5bWluID0gTWF0aC5taW4ocG9zWzFdLCBkY3ltaW4pO1xuICAgICAgZGN5bWF4ID0gTWF0aC5tYXgocG9zWzFdLCBkY3ltYXgpO1xuICAgIH1cblxuICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoJ2RjeG1pbicsIGRjeG1pbik7XG4gICAgcHJvZ3JhbS5zZXRVbmlmb3JtZignZGN4bWF4JywgZGN4bWF4KTtcbiAgICBwcm9ncmFtLnNldFVuaWZvcm1mKCdkY3ltaW4nLCBkY3ltaW4pO1xuICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoJ2RjeW1heCcsIGRjeW1heCk7XG5cbiAgICBpZiAocHJvZ3JhbS5pc1VuaWZvcm1Vc2VkKCdjYW1lcmFQYXJhbGxlbCcpKSB7XG4gICAgICBwcm9ncmFtLnNldFVuaWZvcm1pKCdjYW1lcmFQYXJhbGxlbCcsIGNhbS5nZXRQYXJhbGxlbFByb2plY3Rpb24oKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZXh0ID0gbW9kZWwuY3VycmVudElucHV0LmdldEV4dGVudCgpO1xuICAgIGNvbnN0IHNwYyA9IG1vZGVsLmN1cnJlbnRJbnB1dC5nZXRTcGFjaW5nKCk7XG4gICAgY29uc3QgdnNpemUgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgIHZlYzMuc2V0KFxuICAgICAgdnNpemUsXG4gICAgICAoZXh0WzFdIC0gZXh0WzBdICsgMSkgKiBzcGNbMF0sXG4gICAgICAoZXh0WzNdIC0gZXh0WzJdICsgMSkgKiBzcGNbMV0sXG4gICAgICAoZXh0WzVdIC0gZXh0WzRdICsgMSkgKiBzcGNbMl1cbiAgICApO1xuICAgIHByb2dyYW0uc2V0VW5pZm9ybTNmKCd2U3BhY2luZycsIHNwY1swXSwgc3BjWzFdLCBzcGNbMl0pO1xuXG4gICAgdmVjMy5zZXQocG9zLCBleHRbMF0sIGV4dFsyXSwgZXh0WzRdKTtcbiAgICBtb2RlbC5jdXJyZW50SW5wdXQuaW5kZXhUb1dvcmxkVmVjMyhwb3MsIHBvcyk7XG5cbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDQocG9zLCBwb3MsIG1vZGVsLm1vZGVsVG9WaWV3KTtcbiAgICBwcm9ncmFtLnNldFVuaWZvcm0zZigndk9yaWdpblZDJywgcG9zWzBdLCBwb3NbMV0sIHBvc1syXSk7XG5cbiAgICAvLyBhcHBseSB0aGUgaW1hZ2UgZGlyZWN0aW9uc1xuICAgIGNvbnN0IGkyd21hdDQgPSBtb2RlbC5jdXJyZW50SW5wdXQuZ2V0SW5kZXhUb1dvcmxkKCk7XG4gICAgbWF0NC5tdWx0aXBseShtb2RlbC5pZHhUb1ZpZXcsIG1vZGVsLm1vZGVsVG9WaWV3LCBpMndtYXQ0KTtcblxuICAgIG1hdDMubXVsdGlwbHkoXG4gICAgICBtb2RlbC5pZHhOb3JtYWxNYXRyaXgsXG4gICAgICBrZXlNYXRzLm5vcm1hbE1hdHJpeCxcbiAgICAgIGFjdE1hdHMubm9ybWFsTWF0cml4XG4gICAgKTtcbiAgICBtYXQzLm11bHRpcGx5KFxuICAgICAgbW9kZWwuaWR4Tm9ybWFsTWF0cml4LFxuICAgICAgbW9kZWwuaWR4Tm9ybWFsTWF0cml4LFxuICAgICAgbW9kZWwuY3VycmVudElucHV0LmdldERpcmVjdGlvbigpXG4gICAgKTtcblxuICAgIGNvbnN0IG1heFNhbXBsZXMgPVxuICAgICAgdmVjMy5sZW5ndGgodnNpemUpIC8gbW9kZWwucmVuZGVyYWJsZS5nZXRTYW1wbGVEaXN0YW5jZSgpO1xuICAgIGlmIChtYXhTYW1wbGVzID4gbW9kZWwucmVuZGVyYWJsZS5nZXRNYXhpbXVtU2FtcGxlc1BlclJheSgpKSB7XG4gICAgICB2dGtXYXJuaW5nTWFjcm8oYFRoZSBudW1iZXIgb2Ygc3RlcHMgcmVxdWlyZWQgJHtNYXRoLmNlaWwoXG4gICAgICAgIG1heFNhbXBsZXNcbiAgICAgICl9IGlzIGxhcmdlciB0aGFuIHRoZVxuICAgICAgICBzcGVjaWZpZWQgbWF4aW11bSBudW1iZXIgb2Ygc3RlcHMgJHttb2RlbC5yZW5kZXJhYmxlLmdldE1heGltdW1TYW1wbGVzUGVyUmF5KCl9LlxuICAgICAgICBQbGVhc2UgZWl0aGVyIGNoYW5nZSB0aGVcbiAgICAgICAgdm9sdW1lTWFwcGVyIHNhbXBsZURpc3RhbmNlIG9yIGl0cyBtYXhpbXVtIG51bWJlciBvZiBzYW1wbGVzLmApO1xuICAgIH1cblxuICAgIGNvbnN0IHZjdG9pamsgPSB2ZWMzLmNyZWF0ZSgpO1xuXG4gICAgdmVjMy5zZXQodmN0b2lqaywgMS4wLCAxLjAsIDEuMCk7XG4gICAgdmVjMy5kaXZpZGUodmN0b2lqaywgdmN0b2lqaywgdnNpemUpO1xuICAgIHByb2dyYW0uc2V0VW5pZm9ybTNmKCd2VkNUb0lKSycsIHZjdG9pamtbMF0sIHZjdG9pamtbMV0sIHZjdG9pamtbMl0pO1xuICAgIHByb2dyYW0uc2V0VW5pZm9ybTNpKCd2b2x1bWVEaW1lbnNpb25zJywgZGltc1swXSwgZGltc1sxXSwgZGltc1syXSk7XG5cbiAgICBpZiAoIW1vZGVsLm9wZW5HTFJlbmRlcldpbmRvdy5nZXRXZWJnbDIoKSkge1xuICAgICAgY29uc3Qgdm9sSW5mbyA9IG1vZGVsLnNjYWxhclRleHR1cmUuZ2V0Vm9sdW1lSW5mbygpO1xuICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtZigndGV4V2lkdGgnLCBtb2RlbC5zY2FsYXJUZXh0dXJlLmdldFdpZHRoKCkpO1xuICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtZigndGV4SGVpZ2h0JywgbW9kZWwuc2NhbGFyVGV4dHVyZS5nZXRIZWlnaHQoKSk7XG4gICAgICBwcm9ncmFtLnNldFVuaWZvcm1pKCd4cmVwcycsIHZvbEluZm8ueHJlcHMpO1xuICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtaSgneHN0cmlkZScsIHZvbEluZm8ueHN0cmlkZSk7XG4gICAgICBwcm9ncmFtLnNldFVuaWZvcm1pKCd5c3RyaWRlJywgdm9sSW5mby55c3RyaWRlKTtcbiAgICB9XG5cbiAgICAvLyBtYXAgbm9ybWFscyB0aHJvdWdoIG5vcm1hbCBtYXRyaXhcbiAgICAvLyB0aGVuIHVzZSBhIHBvaW50IG9uIHRoZSBwbGFuZSB0byBjb21wdXRlIHRoZSBkaXN0YW5jZVxuICAgIGNvbnN0IG5vcm1hbCA9IHZlYzMuY3JlYXRlKCk7XG4gICAgY29uc3QgcG9zMiA9IHZlYzMuY3JlYXRlKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgdmVjMy5zZXQobm9ybWFsLCAxLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgICB2ZWMzLnNldChwb3MyLCBleHRbMV0sIGV4dFszXSwgZXh0WzVdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHZlYzMuc2V0KG5vcm1hbCwgLTEuMCwgMC4wLCAwLjApO1xuICAgICAgICAgIHZlYzMuc2V0KHBvczIsIGV4dFswXSwgZXh0WzJdLCBleHRbNF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdmVjMy5zZXQobm9ybWFsLCAwLjAsIDEuMCwgMC4wKTtcbiAgICAgICAgICB2ZWMzLnNldChwb3MyLCBleHRbMV0sIGV4dFszXSwgZXh0WzVdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHZlYzMuc2V0KG5vcm1hbCwgMC4wLCAtMS4wLCAwLjApO1xuICAgICAgICAgIHZlYzMuc2V0KHBvczIsIGV4dFswXSwgZXh0WzJdLCBleHRbNF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgdmVjMy5zZXQobm9ybWFsLCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgICB2ZWMzLnNldChwb3MyLCBleHRbMV0sIGV4dFszXSwgZXh0WzVdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHZlYzMuc2V0KG5vcm1hbCwgMC4wLCAwLjAsIC0xLjApO1xuICAgICAgICAgIHZlYzMuc2V0KHBvczIsIGV4dFswXSwgZXh0WzJdLCBleHRbNF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdmVjMy50cmFuc2Zvcm1NYXQzKG5vcm1hbCwgbm9ybWFsLCBtb2RlbC5pZHhOb3JtYWxNYXRyaXgpO1xuICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHBvczIsIHBvczIsIG1vZGVsLmlkeFRvVmlldyk7XG4gICAgICBjb25zdCBkaXN0ID0gLTEuMCAqIHZlYzMuZG90KHBvczIsIG5vcm1hbCk7XG5cbiAgICAgIC8vIHdlIGhhdmUgdGhlIHBsYW5lIGluIHZpZXcgY29vcmRpbmF0ZXNcbiAgICAgIC8vIHNwZWNpZnkgdGhlIHBsYW5lcyBpbiB2aWV3IGNvb3JkaW5hdGVzXG4gICAgICBwcm9ncmFtLnNldFVuaWZvcm0zZihgdlBsYW5lTm9ybWFsJHtpfWAsIG5vcm1hbFswXSwgbm9ybWFsWzFdLCBub3JtYWxbMl0pO1xuICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtZihgdlBsYW5lRGlzdGFuY2Uke2l9YCwgZGlzdCk7XG5cbiAgICAgIGlmIChhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldFVzZUxhYmVsT3V0bGluZSgpKSB7XG4gICAgICAgIGNvbnN0IGltYWdlID0gbW9kZWwuY3VycmVudElucHV0O1xuICAgICAgICBjb25zdCB3b3JsZFRvSW5kZXggPSBpbWFnZS5nZXRXb3JsZFRvSW5kZXgoKTtcblxuICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1NYXRyaXgoJ3ZXQ3RvSURYJywgd29ybGRUb0luZGV4KTtcblxuICAgICAgICAvLyBHZXQgdGhlIHByb2plY3Rpb24gY29vcmRpbmF0ZSB0byB3b3JsZCBjb29yZGluYXRlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeC5cbiAgICAgICAgbWF0NC5pbnZlcnQobW9kZWwucHJvamVjdGlvblRvV29ybGQsIGtleU1hdHMud2NwYyk7XG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybU1hdHJpeCgnUENXQ01hdHJpeCcsIG1vZGVsLnByb2plY3Rpb25Ub1dvcmxkKTtcblxuICAgICAgICBjb25zdCBzaXplID0gcHVibGljQVBJLmdldFJlbmRlclRhcmdldFNpemUoKTtcblxuICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1mKCd2cFdpZHRoJywgc2l6ZVswXSk7XG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoJ3ZwSGVpZ2h0Jywgc2l6ZVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWF0NC5pbnZlcnQobW9kZWwucHJvamVjdGlvblRvVmlldywga2V5TWF0cy52Y3BjKTtcbiAgICBwcm9ncmFtLnNldFVuaWZvcm1NYXRyaXgoJ1BDVkNNYXRyaXgnLCBtb2RlbC5wcm9qZWN0aW9uVG9WaWV3KTtcblxuICAgIC8vIGhhbmRsZSBsaWdodGluZyB2YWx1ZXNcbiAgICBzd2l0Y2ggKG1vZGVsLmxhc3RMaWdodENvbXBsZXhpdHkpIHtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICBjYXNlIDA6IC8vIG5vIGxpZ2h0aW5nLCB0Y29sb3IgaXMgZmluZSBhcyBpc1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxOiAvLyBoZWFkbGlnaHRcbiAgICAgIGNhc2UgMjogLy8gbGlnaHQga2l0XG4gICAgICBjYXNlIDM6IHtcbiAgICAgICAgLy8gcG9zaXRpb25hbCBub3QgaW1wbGVtZW50ZWQgZmFsbGJhY2sgdG8gZGlyZWN0aW9uYWxcbiAgICAgICAgLy8gbWF0My50cmFuc3Bvc2Uoa2V5TWF0cy5ub3JtYWxNYXRyaXgsIGtleU1hdHMubm9ybWFsTWF0cml4KTtcbiAgICAgICAgbGV0IGxpZ2h0TnVtID0gMDtcbiAgICAgICAgY29uc3QgbGlnaHRDb2xvciA9IFtdO1xuICAgICAgICByZW4uZ2V0TGlnaHRzKCkuZm9yRWFjaCgobGlnaHQpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGF0dXMgPSBsaWdodC5nZXRTd2l0Y2goKTtcbiAgICAgICAgICBpZiAoc3RhdHVzID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZENvbG9yID0gbGlnaHQuZ2V0Q29sb3IoKTtcbiAgICAgICAgICAgIGNvbnN0IGludGVuc2l0eSA9IGxpZ2h0LmdldEludGVuc2l0eSgpO1xuICAgICAgICAgICAgbGlnaHRDb2xvclswXSA9IGRDb2xvclswXSAqIGludGVuc2l0eTtcbiAgICAgICAgICAgIGxpZ2h0Q29sb3JbMV0gPSBkQ29sb3JbMV0gKiBpbnRlbnNpdHk7XG4gICAgICAgICAgICBsaWdodENvbG9yWzJdID0gZENvbG9yWzJdICogaW50ZW5zaXR5O1xuICAgICAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtM2ZBcnJheShgbGlnaHRDb2xvciR7bGlnaHROdW19YCwgbGlnaHRDb2xvcik7XG4gICAgICAgICAgICBjb25zdCBsZGlyID0gbGlnaHQuZ2V0RGlyZWN0aW9uKCk7XG4gICAgICAgICAgICB2ZWMzLnNldChub3JtYWwsIGxkaXJbMF0sIGxkaXJbMV0sIGxkaXJbMl0pO1xuICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQzKG5vcm1hbCwgbm9ybWFsLCBrZXlNYXRzLm5vcm1hbE1hdHJpeCk7XG4gICAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm0zZihcbiAgICAgICAgICAgICAgYGxpZ2h0RGlyZWN0aW9uVkMke2xpZ2h0TnVtfWAsXG4gICAgICAgICAgICAgIG5vcm1hbFswXSxcbiAgICAgICAgICAgICAgbm9ybWFsWzFdLFxuICAgICAgICAgICAgICBub3JtYWxbMl1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvLyBjYW1lcmEgRE9QIGlzIDAsMCwtMS4wIGluIFZDXG4gICAgICAgICAgICBjb25zdCBoYWxmQW5nbGUgPSBbXG4gICAgICAgICAgICAgIC0wLjUgKiBub3JtYWxbMF0sXG4gICAgICAgICAgICAgIC0wLjUgKiBub3JtYWxbMV0sXG4gICAgICAgICAgICAgIC0wLjUgKiAobm9ybWFsWzJdIC0gMS4wKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm0zZkFycmF5KGBsaWdodEhhbGZBbmdsZVZDJHtsaWdodE51bX1gLCBoYWxmQW5nbGUpO1xuICAgICAgICAgICAgbGlnaHROdW0rKztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBtYXQzLnRyYW5zcG9zZShrZXlNYXRzLm5vcm1hbE1hdHJpeCwga2V5TWF0cy5ub3JtYWxNYXRyaXgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuc2V0UHJvcGVydHlTaGFkZXJQYXJhbWV0ZXJzID0gKGNlbGxCTywgcmVuLCBhY3RvcikgPT4ge1xuICAgIGNvbnN0IHByb2dyYW0gPSBjZWxsQk8uZ2V0UHJvZ3JhbSgpO1xuXG4gICAgcHJvZ3JhbS5zZXRVbmlmb3JtaSgnY3RleHR1cmUnLCBtb2RlbC5jb2xvclRleHR1cmUuZ2V0VGV4dHVyZVVuaXQoKSk7XG4gICAgcHJvZ3JhbS5zZXRVbmlmb3JtaSgnb3RleHR1cmUnLCBtb2RlbC5vcGFjaXR5VGV4dHVyZS5nZXRUZXh0dXJlVW5pdCgpKTtcbiAgICBwcm9ncmFtLnNldFVuaWZvcm1pKCdqdGV4dHVyZScsIG1vZGVsLmppdHRlclRleHR1cmUuZ2V0VGV4dHVyZVVuaXQoKSk7XG5cbiAgICBjb25zdCB2b2xJbmZvID0gbW9kZWwuc2NhbGFyVGV4dHVyZS5nZXRWb2x1bWVJbmZvKCk7XG4gICAgY29uc3QgdnByb3AgPSBhY3Rvci5nZXRQcm9wZXJ0eSgpO1xuXG4gICAgLy8gc2V0IHRoZSBjb21wb25lbnQgbWl4IHdoZW4gaW5kZXBlbmRlbnRcbiAgICBjb25zdCBudW1Db21wID0gbW9kZWwuc2NhbGFyVGV4dHVyZS5nZXRDb21wb25lbnRzKCk7XG4gICAgY29uc3QgaUNvbXBzID0gYWN0b3IuZ2V0UHJvcGVydHkoKS5nZXRJbmRlcGVuZGVudENvbXBvbmVudHMoKTtcbiAgICBpZiAoaUNvbXBzICYmIG51bUNvbXAgPj0gMikge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Db21wOyBpKyspIHtcbiAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtZihcbiAgICAgICAgICBgbWl4JHtpfWAsXG4gICAgICAgICAgYWN0b3IuZ2V0UHJvcGVydHkoKS5nZXRDb21wb25lbnRXZWlnaHQoaSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0aHJlZSBsZXZlbHMgb2Ygc2hpZnQgc2NhbGUgY29tYmluZWQgaW50byBvbmVcbiAgICAvLyBmb3IgcGVyZm9ybWFuY2UgaW4gdGhlIGZyYWdtZW50IHNoYWRlclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ29tcDsgaSsrKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBpQ29tcHMgPyBpIDogMDtcbiAgICAgIGNvbnN0IHNzY2FsZSA9IHZvbEluZm8uc2NhbGVbaV07XG4gICAgICBjb25zdCBvZnVuID0gdnByb3AuZ2V0U2NhbGFyT3BhY2l0eSh0YXJnZXQpO1xuICAgICAgY29uc3Qgb1JhbmdlID0gb2Z1bi5nZXRSYW5nZSgpO1xuICAgICAgY29uc3Qgb3NjYWxlID0gc3NjYWxlIC8gKG9SYW5nZVsxXSAtIG9SYW5nZVswXSk7XG4gICAgICBjb25zdCBvc2hpZnQgPSAodm9sSW5mby5vZmZzZXRbaV0gLSBvUmFuZ2VbMF0pIC8gKG9SYW5nZVsxXSAtIG9SYW5nZVswXSk7XG4gICAgICBwcm9ncmFtLnNldFVuaWZvcm1mKGBvc2hpZnQke2l9YCwgb3NoaWZ0KTtcbiAgICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoYG9zY2FsZSR7aX1gLCBvc2NhbGUpO1xuXG4gICAgICBjb25zdCBjZnVuID0gdnByb3AuZ2V0UkdCVHJhbnNmZXJGdW5jdGlvbih0YXJnZXQpO1xuICAgICAgY29uc3QgY1JhbmdlID0gY2Z1bi5nZXRSYW5nZSgpO1xuICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtZihcbiAgICAgICAgYGNzaGlmdCR7aX1gLFxuICAgICAgICAodm9sSW5mby5vZmZzZXRbaV0gLSBjUmFuZ2VbMF0pIC8gKGNSYW5nZVsxXSAtIGNSYW5nZVswXSlcbiAgICAgICk7XG4gICAgICBwcm9ncmFtLnNldFVuaWZvcm1mKGBjc2NhbGUke2l9YCwgc3NjYWxlIC8gKGNSYW5nZVsxXSAtIGNSYW5nZVswXSkpO1xuICAgIH1cblxuICAgIGlmIChtb2RlbC5nb3BhY2l0eSkge1xuICAgICAgaWYgKGlDb21wcykge1xuICAgICAgICBmb3IgKGxldCBuYyA9IDA7IG5jIDwgbnVtQ29tcDsgKytuYykge1xuICAgICAgICAgIGNvbnN0IHNzY2FsZSA9IHZvbEluZm8uc2NhbGVbbmNdO1xuICAgICAgICAgIGNvbnN0IHVzZUdPID0gdnByb3AuZ2V0VXNlR3JhZGllbnRPcGFjaXR5KG5jKTtcbiAgICAgICAgICBpZiAodXNlR08pIHtcbiAgICAgICAgICAgIGNvbnN0IGdvbWluID0gdnByb3AuZ2V0R3JhZGllbnRPcGFjaXR5TWluaW11bU9wYWNpdHkobmMpO1xuICAgICAgICAgICAgY29uc3QgZ29tYXggPSB2cHJvcC5nZXRHcmFkaWVudE9wYWNpdHlNYXhpbXVtT3BhY2l0eShuYyk7XG4gICAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1mKGBnb21pbiR7bmN9YCwgZ29taW4pO1xuICAgICAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtZihgZ29tYXgke25jfWAsIGdvbWF4KTtcbiAgICAgICAgICAgIGNvbnN0IGdvUmFuZ2UgPSBbXG4gICAgICAgICAgICAgIHZwcm9wLmdldEdyYWRpZW50T3BhY2l0eU1pbmltdW1WYWx1ZShuYyksXG4gICAgICAgICAgICAgIHZwcm9wLmdldEdyYWRpZW50T3BhY2l0eU1heGltdW1WYWx1ZShuYyksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtZihcbiAgICAgICAgICAgICAgYGdvc2NhbGUke25jfWAsXG4gICAgICAgICAgICAgIChzc2NhbGUgKiAoZ29tYXggLSBnb21pbikpIC8gKGdvUmFuZ2VbMV0gLSBnb1JhbmdlWzBdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoXG4gICAgICAgICAgICAgIGBnb3NoaWZ0JHtuY31gLFxuICAgICAgICAgICAgICAoLWdvUmFuZ2VbMF0gKiAoZ29tYXggLSBnb21pbikpIC8gKGdvUmFuZ2VbMV0gLSBnb1JhbmdlWzBdKSArXG4gICAgICAgICAgICAgICAgZ29taW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoYGdvbWluJHtuY31gLCAxLjApO1xuICAgICAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtZihgZ29tYXgke25jfWAsIDEuMCk7XG4gICAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1mKGBnb3NjYWxlJHtuY31gLCAwLjApO1xuICAgICAgICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtZihgZ29zaGlmdCR7bmN9YCwgMS4wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNzY2FsZSA9IHZvbEluZm8uc2NhbGVbbnVtQ29tcCAtIDFdO1xuICAgICAgICBjb25zdCBnb21pbiA9IHZwcm9wLmdldEdyYWRpZW50T3BhY2l0eU1pbmltdW1PcGFjaXR5KDApO1xuICAgICAgICBjb25zdCBnb21heCA9IHZwcm9wLmdldEdyYWRpZW50T3BhY2l0eU1heGltdW1PcGFjaXR5KDApO1xuICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1mKCdnb21pbjAnLCBnb21pbik7XG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoJ2dvbWF4MCcsIGdvbWF4KTtcbiAgICAgICAgY29uc3QgZ29SYW5nZSA9IFtcbiAgICAgICAgICB2cHJvcC5nZXRHcmFkaWVudE9wYWNpdHlNaW5pbXVtVmFsdWUoMCksXG4gICAgICAgICAgdnByb3AuZ2V0R3JhZGllbnRPcGFjaXR5TWF4aW11bVZhbHVlKDApLFxuICAgICAgICBdO1xuICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1mKFxuICAgICAgICAgICdnb3NjYWxlMCcsXG4gICAgICAgICAgKHNzY2FsZSAqIChnb21heCAtIGdvbWluKSkgLyAoZ29SYW5nZVsxXSAtIGdvUmFuZ2VbMF0pXG4gICAgICAgICk7XG4gICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoXG4gICAgICAgICAgJ2dvc2hpZnQwJyxcbiAgICAgICAgICAoLWdvUmFuZ2VbMF0gKiAoZ29tYXggLSBnb21pbikpIC8gKGdvUmFuZ2VbMV0gLSBnb1JhbmdlWzBdKSArIGdvbWluXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdnRrSW1hZ2VMYWJlbE91dGxpbmUgPSBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldFVzZUxhYmVsT3V0bGluZSgpO1xuICAgIGlmICh2dGtJbWFnZUxhYmVsT3V0bGluZSA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3QgbGFiZWxPdXRsaW5lVGhpY2tuZXNzID0gYWN0b3JcbiAgICAgICAgLmdldFByb3BlcnR5KClcbiAgICAgICAgLmdldExhYmVsT3V0bGluZVRoaWNrbmVzcygpO1xuXG4gICAgICBwcm9ncmFtLnNldFVuaWZvcm1pKCdvdXRsaW5lVGhpY2tuZXNzJywgbGFiZWxPdXRsaW5lVGhpY2tuZXNzKTtcbiAgICB9XG5cbiAgICBpZiAobW9kZWwubGFzdExpZ2h0Q29tcGxleGl0eSA+IDApIHtcbiAgICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoJ3ZBbWJpZW50JywgdnByb3AuZ2V0QW1iaWVudCgpKTtcbiAgICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoJ3ZEaWZmdXNlJywgdnByb3AuZ2V0RGlmZnVzZSgpKTtcbiAgICAgIHByb2dyYW0uc2V0VW5pZm9ybWYoJ3ZTcGVjdWxhcicsIHZwcm9wLmdldFNwZWN1bGFyKCkpO1xuICAgICAgcHJvZ3JhbS5zZXRVbmlmb3JtZigndlNwZWN1bGFyUG93ZXInLCB2cHJvcC5nZXRTcGVjdWxhclBvd2VyKCkpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0UmVuZGVyVGFyZ2V0U2l6ZSA9ICgpID0+IHtcbiAgICBpZiAobW9kZWwubGFzdFhZRiA+IDEuNDMpIHtcbiAgICAgIGNvbnN0IHN6ID0gbW9kZWwuZnJhbWVidWZmZXIuZ2V0U2l6ZSgpO1xuICAgICAgcmV0dXJuIFttb2RlbC5mdnBbMF0gKiBzelswXSwgbW9kZWwuZnZwWzFdICogc3pbMV1dO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldEZyYW1lYnVmZmVyU2l6ZSgpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5yZW5kZXJQaWVjZVN0YXJ0ID0gKHJlbiwgYWN0b3IpID0+IHtcbiAgICBpZiAobW9kZWwucmVuZGVyYWJsZS5nZXRBdXRvQWRqdXN0U2FtcGxlRGlzdGFuY2VzKCkpIHtcbiAgICAgIGNvbnN0IHJ3aSA9IHJlbi5nZXRWVEtXaW5kb3coKS5nZXRJbnRlcmFjdG9yKCk7XG4gICAgICBjb25zdCByZnQgPSByd2kuZ2V0TGFzdEZyYW1lVGltZSgpO1xuICAgICAgLy8gY29uc29sZS5sb2coYGxhc3QgZnJhbWUgdGltZSAke01hdGguZmxvb3IoMS4wIC8gcmZ0KX1gKTtcblxuICAgICAgLy8gZnJhbWUgdGltZSBpcyB0eXBpY2FsbHkgZm9yIGEgY291cGxlIGZyYW1lcyBwcmlvclxuICAgICAgLy8gd2hpY2ggbWFrZXMgaXQgbWVzc3ksIHNvIGtlZXAgbG9uZyBydW5uaW5nIGF2ZXJhZ2VzXG4gICAgICAvLyBvZiBmcmFtZSB0aW1lcyBhbmQgcGl4ZWxzIHJlbmRlcmVkXG4gICAgICBtb2RlbC5hdmdGcmFtZVRpbWUgPSAwLjk3ICogbW9kZWwuYXZnRnJhbWVUaW1lICsgMC4wMyAqIHJmdDtcbiAgICAgIG1vZGVsLmF2Z1dpbmRvd0FyZWEgPVxuICAgICAgICAwLjk3ICogbW9kZWwuYXZnV2luZG93QXJlYSArIDAuMDMgLyAobW9kZWwubGFzdFhZRiAqIG1vZGVsLmxhc3RYWUYpO1xuXG4gICAgICBpZiAocmVuLmdldFZUS1dpbmRvdygpLmdldEludGVyYWN0b3IoKS5pc0FuaW1hdGluZygpKSB7XG4gICAgICAgIC8vIGNvbXB1dGUgdGFyZ2V0IHh5IGZhY3RvclxuICAgICAgICBsZXQgdHh5ZiA9IE1hdGguc3FydChcbiAgICAgICAgICAobW9kZWwuYXZnRnJhbWVUaW1lICogcndpLmdldERlc2lyZWRVcGRhdGVSYXRlKCkpIC9cbiAgICAgICAgICAgIG1vZGVsLmF2Z1dpbmRvd0FyZWFcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBsaW1pdCBzdWJzYW1wbGluZyB0byBhIGZhY3RvciBvZiAxMFxuICAgICAgICBpZiAodHh5ZiA+IDEwLjApIHtcbiAgICAgICAgICB0eHlmID0gMTAuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vZGVsLnRhcmdldFhZRiA9IHR4eWY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbC50YXJnZXRYWUYgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgKG1vZGVsLmF2Z0ZyYW1lVGltZSAqIHJ3aS5nZXRTdGlsbFVwZGF0ZVJhdGUoKSkgLyBtb2RlbC5hdmdXaW5kb3dBcmVhXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGhhdmUgc29tZSBpbmVydGlhIHRvIGNoYW5nZSBzdGF0ZXMgYXJvdW5kIDEuNDNcbiAgICAgIGlmIChtb2RlbC50YXJnZXRYWUYgPCAxLjUzICYmIG1vZGVsLnRhcmdldFhZRiA+IDEuMzMpIHtcbiAgICAgICAgbW9kZWwudGFyZ2V0WFlGID0gbW9kZWwubGFzdFhZRjtcbiAgICAgIH1cblxuICAgICAgLy8gYW5kIGFkZCBzb21lIGluZXJ0aWEgdG8gY2hhbmdlIGF0IGFsbFxuICAgICAgaWYgKE1hdGguYWJzKDEuMCAtIG1vZGVsLnRhcmdldFhZRiAvIG1vZGVsLmxhc3RYWUYpIDwgMC4xKSB7XG4gICAgICAgIG1vZGVsLnRhcmdldFhZRiA9IG1vZGVsLmxhc3RYWUY7XG4gICAgICB9XG4gICAgICBtb2RlbC5sYXN0WFlGID0gbW9kZWwudGFyZ2V0WFlGO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2RlbC5sYXN0WFlGID0gbW9kZWwucmVuZGVyYWJsZS5nZXRJbWFnZVNhbXBsZURpc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgLy8gb25seSB1c2UgRkJPIGJleW9uZCB0aGlzIHZhbHVlXG4gICAgaWYgKG1vZGVsLmxhc3RYWUYgPD0gMS40Mykge1xuICAgICAgbW9kZWwubGFzdFhZRiA9IDEuMDtcbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZyhgbGFzdCB0YXJnZXQgICR7bW9kZWwubGFzdFhZRn0gJHttb2RlbC50YXJnZXRYWUZ9YCk7XG4gICAgLy8gY29uc29sZS5sb2coYGF3aW4gYWZ0ICAke21vZGVsLmF2Z1dpbmRvd0FyZWF9ICR7bW9kZWwuYXZnRnJhbWVUaW1lfWApO1xuICAgIGNvbnN0IHh5ZiA9IG1vZGVsLmxhc3RYWUY7XG5cbiAgICBjb25zdCBzaXplID0gbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldEZyYW1lYnVmZmVyU2l6ZSgpO1xuICAgIC8vIGNvbnN0IG5ld1NpemUgPSBbXG4gICAgLy8gICBNYXRoLmZsb29yKChzaXplWzBdIC8geHlmKSArIDAuNSksXG4gICAgLy8gICBNYXRoLmZsb29yKChzaXplWzFdIC8geHlmKSArIDAuNSldO1xuXG4gICAgLy8gY29uc3QgZGlhZyA9IHZ0a0JvdW5kaW5nQm94LmdldERpYWdvbmFsTGVuZ3RoKG1vZGVsLmN1cnJlbnRJbnB1dC5nZXRCb3VuZHMoKSk7XG5cbiAgICAvLyAvLyBzbyB3aGF0IGlzIHRoZSByZXN1bHRpbmcgc2FtcGxlIHNpemUgcm91Z2hseVxuICAgIC8vIGNvbnNvbGUubG9nKGBzYW0gc2l6ZSAke2RpYWcgLyBuZXdTaXplWzBdfSAke2RpYWcgLyBuZXdTaXplWzFdfSAke21vZGVsLnJlbmRlcmFibGUuZ2V0SW1hZ2VTYW1wbGVEaXN0YW5jZSgpfWApO1xuXG4gICAgLy8gLy8gaWYgdGhlIHNhbXBsZSBkaXN0YW5jZSBpcyBnZXR0aW5nIGZhciBmcm9tIHRoZSBpbWFnZSBzYW1wbGUgZGlzdFxuICAgIC8vIGlmICgyLjAgKiBkaWFnIC8gKG5ld1NpemVbMF0gKyBuZXdTaXplWzFdKSA+IDQgKiBtb2RlbC5yZW5kZXJhYmxlLmdldFNhbXBsZURpc3RhbmNlKCkpIHtcbiAgICAvLyAgIG1vZGVsLnJlbmRlcmFibGUuc2V0U2FtcGxlRGlzdGFuY2UoNC4wICogbW9kZWwucmVuZGVyYWJsZS5nZXRTYW1wbGVEaXN0YW5jZSgpKTtcbiAgICAvLyB9XG4gICAgLy8gaWYgKDIuMCAqIGRpYWcgLyAobmV3U2l6ZVswXSArIG5ld1NpemVbMV0pIDwgMC4yNSAqIG1vZGVsLnJlbmRlcmFibGUuZ2V0U2FtcGxlRGlzdGFuY2UoKSkge1xuICAgIC8vICAgbW9kZWwucmVuZGVyYWJsZS5zZXRTYW1wbGVEaXN0YW5jZSgwLjI1ICogbW9kZWwucmVuZGVyYWJsZS5nZXRTYW1wbGVEaXN0YW5jZSgpKTtcbiAgICAvLyB9XG5cbiAgICAvLyBjcmVhdGUvcmVzaXplIGZyYW1lYnVmZmVyIGlmIG5lZWRlZFxuICAgIGlmICh4eWYgPiAxLjQzKSB7XG4gICAgICBtb2RlbC5mcmFtZWJ1ZmZlci5zYXZlQ3VycmVudEJpbmRpbmdzQW5kQnVmZmVycygpO1xuXG4gICAgICBpZiAobW9kZWwuZnJhbWVidWZmZXIuZ2V0R0xGcmFtZWJ1ZmZlcigpID09PSBudWxsKSB7XG4gICAgICAgIG1vZGVsLmZyYW1lYnVmZmVyLmNyZWF0ZShcbiAgICAgICAgICBNYXRoLmZsb29yKHNpemVbMF0gKiAwLjcpLFxuICAgICAgICAgIE1hdGguZmxvb3Ioc2l6ZVsxXSAqIDAuNylcbiAgICAgICAgKTtcbiAgICAgICAgbW9kZWwuZnJhbWVidWZmZXIucG9wdWxhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmJTaXplID0gbW9kZWwuZnJhbWVidWZmZXIuZ2V0U2l6ZSgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZmJTaXplWzBdICE9PSBNYXRoLmZsb29yKHNpemVbMF0gKiAwLjcpIHx8XG4gICAgICAgICAgZmJTaXplWzFdICE9PSBNYXRoLmZsb29yKHNpemVbMV0gKiAwLjcpXG4gICAgICAgICkge1xuICAgICAgICAgIG1vZGVsLmZyYW1lYnVmZmVyLmNyZWF0ZShcbiAgICAgICAgICAgIE1hdGguZmxvb3Ioc2l6ZVswXSAqIDAuNyksXG4gICAgICAgICAgICBNYXRoLmZsb29yKHNpemVbMV0gKiAwLjcpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBtb2RlbC5mcmFtZWJ1ZmZlci5wb3B1bGF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1vZGVsLmZyYW1lYnVmZmVyLmJpbmQoKTtcbiAgICAgIGNvbnN0IGdsID0gbW9kZWwuY29udGV4dDtcbiAgICAgIGdsLmNsZWFyQ29sb3IoMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgZ2wudmlld3BvcnQoMCwgMCwgc2l6ZVswXSAvIHh5Ziwgc2l6ZVsxXSAvIHh5Zik7XG4gICAgICBtb2RlbC5mdnAgPSBbXG4gICAgICAgIE1hdGguZmxvb3Ioc2l6ZVswXSAvIHh5ZikgLyBNYXRoLmZsb29yKHNpemVbMF0gKiAwLjcpLFxuICAgICAgICBNYXRoLmZsb29yKHNpemVbMV0gLyB4eWYpIC8gTWF0aC5mbG9vcihzaXplWzFdICogMC43KSxcbiAgICAgIF07XG4gICAgfVxuICAgIG1vZGVsLmNvbnRleHQuZGlzYWJsZShtb2RlbC5jb250ZXh0LkRFUFRIX1RFU1QpO1xuXG4gICAgLy8gbWFrZSBzdXJlIHRoZSBCT3MgYXJlIHVwIHRvIGRhdGVcbiAgICBwdWJsaWNBUEkudXBkYXRlQnVmZmVyT2JqZWN0cyhyZW4sIGFjdG9yKTtcblxuICAgIC8vIHNldCBpbnRlcnBvbGF0aW9uIG9uIHRoZSB0ZXh0dXJlIGJhc2VkIG9uIHByb3BlcnR5IHNldHRpbmdcbiAgICBjb25zdCBpVHlwZSA9IGFjdG9yLmdldFByb3BlcnR5KCkuZ2V0SW50ZXJwb2xhdGlvblR5cGUoKTtcbiAgICBpZiAoaVR5cGUgPT09IEludGVycG9sYXRpb25UeXBlLk5FQVJFU1QpIHtcbiAgICAgIG1vZGVsLnNjYWxhclRleHR1cmUuc2V0TWluaWZpY2F0aW9uRmlsdGVyKEZpbHRlci5ORUFSRVNUKTtcbiAgICAgIG1vZGVsLnNjYWxhclRleHR1cmUuc2V0TWFnbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTkVBUkVTVCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZGVsLnNjYWxhclRleHR1cmUuc2V0TWluaWZpY2F0aW9uRmlsdGVyKEZpbHRlci5MSU5FQVIpO1xuICAgICAgbW9kZWwuc2NhbGFyVGV4dHVyZS5zZXRNYWduaWZpY2F0aW9uRmlsdGVyKEZpbHRlci5MSU5FQVIpO1xuICAgIH1cblxuICAgIC8vIEJpbmQgdGhlIE9wZW5HTCwgdGhpcyBpcyBzaGFyZWQgYmV0d2VlbiB0aGUgZGlmZmVyZW50IHByaW1pdGl2ZS9jZWxsIHR5cGVzLlxuICAgIG1vZGVsLmxhc3RCb3VuZEJPID0gbnVsbDtcblxuICAgIC8vIGlmIHdlIGhhdmUgYSB6YnVmZmVyIHRleHR1cmUgdGhlbiBhY3RpdmF0ZSBpdFxuICAgIGlmIChtb2RlbC56QnVmZmVyVGV4dHVyZSAhPT0gbnVsbCkge1xuICAgICAgbW9kZWwuekJ1ZmZlclRleHR1cmUuYWN0aXZhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLnJlbmRlclBpZWNlRHJhdyA9IChyZW4sIGFjdG9yKSA9PiB7XG4gICAgY29uc3QgZ2wgPSBtb2RlbC5jb250ZXh0O1xuXG4gICAgLy8gcmVuZGVyIHRoZSB0ZXh0dXJlXG4gICAgbW9kZWwuc2NhbGFyVGV4dHVyZS5hY3RpdmF0ZSgpO1xuICAgIG1vZGVsLm9wYWNpdHlUZXh0dXJlLmFjdGl2YXRlKCk7XG4gICAgbW9kZWwuY29sb3JUZXh0dXJlLmFjdGl2YXRlKCk7XG4gICAgbW9kZWwuaml0dGVyVGV4dHVyZS5hY3RpdmF0ZSgpO1xuXG4gICAgcHVibGljQVBJLnVwZGF0ZVNoYWRlcnMobW9kZWwudHJpcywgcmVuLCBhY3Rvcik7XG5cbiAgICAvLyBGaXJzdCB3ZSBkbyB0aGUgdHJpYW5nbGVzLCB1cGRhdGUgdGhlIHNoYWRlciwgc2V0IHVuaWZvcm1zLCBldGMuXG4gICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCAxMTsgKytpKSB7XG4gICAgLy8gICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgNjYgKiBpLCA2Nik7XG4gICAgLy8gfVxuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCBtb2RlbC50cmlzLmdldENBQk8oKS5nZXRFbGVtZW50Q291bnQoKSk7XG4gICAgbW9kZWwudHJpcy5nZXRWQU8oKS5yZWxlYXNlKCk7XG5cbiAgICBtb2RlbC5zY2FsYXJUZXh0dXJlLmRlYWN0aXZhdGUoKTtcbiAgICBtb2RlbC5jb2xvclRleHR1cmUuZGVhY3RpdmF0ZSgpO1xuICAgIG1vZGVsLm9wYWNpdHlUZXh0dXJlLmRlYWN0aXZhdGUoKTtcbiAgICBtb2RlbC5qaXR0ZXJUZXh0dXJlLmRlYWN0aXZhdGUoKTtcbiAgfTtcblxuICBwdWJsaWNBUEkucmVuZGVyUGllY2VGaW5pc2ggPSAocmVuLCBhY3RvcikgPT4ge1xuICAgIC8vIGlmIHdlIGhhdmUgYSB6YnVmZmVyIHRleHR1cmUgdGhlbiBkZWFjdGl2YXRlIGl0XG4gICAgaWYgKG1vZGVsLnpCdWZmZXJUZXh0dXJlICE9PSBudWxsKSB7XG4gICAgICBtb2RlbC56QnVmZmVyVGV4dHVyZS5kZWFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKG1vZGVsLmxhc3RYWUYgPiAxLjQzKSB7XG4gICAgICAvLyBub3cgY29weSB0aGUgZnJhbWVidWZmZXIgd2l0aCB0aGUgdm9sdW1lIGludG8gdGhlXG4gICAgICAvLyByZWd1bGFyIGJ1ZmZlclxuICAgICAgbW9kZWwuZnJhbWVidWZmZXIucmVzdG9yZVByZXZpb3VzQmluZGluZ3NBbmRCdWZmZXJzKCk7XG5cbiAgICAgIGlmIChtb2RlbC5jb3B5U2hhZGVyID09PSBudWxsKSB7XG4gICAgICAgIG1vZGVsLmNvcHlTaGFkZXIgPSBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3dcbiAgICAgICAgICAuZ2V0U2hhZGVyQ2FjaGUoKVxuICAgICAgICAgIC5yZWFkeVNoYWRlclByb2dyYW1BcnJheShcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgJy8vVlRLOjpTeXN0ZW06OkRlYycsXG4gICAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjNCB2ZXJ0ZXhEQzsnLFxuICAgICAgICAgICAgICAndW5pZm9ybSB2ZWMyIHRmYWN0b3I7JyxcbiAgICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB0Y29vcmQ7JyxcbiAgICAgICAgICAgICAgJ3ZvaWQgbWFpbigpIHsgdGNvb3JkID0gdmVjMih2ZXJ0ZXhEQy54KjAuNSArIDAuNSwgdmVydGV4REMueSowLjUgKyAwLjUpICogdGZhY3RvcjsgZ2xfUG9zaXRpb24gPSB2ZXJ0ZXhEQzsgfScsXG4gICAgICAgICAgICBdLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAnLy9WVEs6OlN5c3RlbTo6RGVjJyxcbiAgICAgICAgICAgICAgJy8vVlRLOjpPdXRwdXQ6OkRlYycsXG4gICAgICAgICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB0ZXh0dXJlMTsnLFxuICAgICAgICAgICAgICAndmFyeWluZyB2ZWMyIHRjb29yZDsnLFxuICAgICAgICAgICAgICAndm9pZCBtYWluKCkgeyBnbF9GcmFnRGF0YVswXSA9IHRleHR1cmUyRCh0ZXh0dXJlMSx0Y29vcmQpOyB9JyxcbiAgICAgICAgICAgIF0uam9pbignXFxuJyksXG4gICAgICAgICAgICAnJ1xuICAgICAgICAgICk7XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBtb2RlbC5jb3B5U2hhZGVyO1xuXG4gICAgICAgIG1vZGVsLmNvcHlWQU8gPSB2dGtWZXJ0ZXhBcnJheU9iamVjdC5uZXdJbnN0YW5jZSgpO1xuICAgICAgICBtb2RlbC5jb3B5VkFPLnNldE9wZW5HTFJlbmRlcldpbmRvdyhtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cpO1xuXG4gICAgICAgIG1vZGVsLnRyaXMuZ2V0Q0FCTygpLmJpbmQoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFtb2RlbC5jb3B5VkFPLmFkZEF0dHJpYnV0ZUFycmF5KFxuICAgICAgICAgICAgcHJvZ3JhbSxcbiAgICAgICAgICAgIG1vZGVsLnRyaXMuZ2V0Q0FCTygpLFxuICAgICAgICAgICAgJ3ZlcnRleERDJyxcbiAgICAgICAgICAgIG1vZGVsLnRyaXMuZ2V0Q0FCTygpLmdldFZlcnRleE9mZnNldCgpLFxuICAgICAgICAgICAgbW9kZWwudHJpcy5nZXRDQUJPKCkuZ2V0U3RyaWRlKCksXG4gICAgICAgICAgICBtb2RlbC5jb250ZXh0LkZMT0FULFxuICAgICAgICAgICAgMyxcbiAgICAgICAgICAgIG1vZGVsLmNvbnRleHQuRkFMU0VcbiAgICAgICAgICApXG4gICAgICAgICkge1xuICAgICAgICAgIHZ0a0Vycm9yTWFjcm8oJ0Vycm9yIHNldHRpbmcgdmVydGV4REMgaW4gY29weSBzaGFkZXIgVkFPLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3dcbiAgICAgICAgICAuZ2V0U2hhZGVyQ2FjaGUoKVxuICAgICAgICAgIC5yZWFkeVNoYWRlclByb2dyYW0obW9kZWwuY29weVNoYWRlcik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpemUgPSBtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cuZ2V0RnJhbWVidWZmZXJTaXplKCk7XG4gICAgICBtb2RlbC5jb250ZXh0LnZpZXdwb3J0KDAsIDAsIHNpemVbMF0sIHNpemVbMV0pO1xuXG4gICAgICAvLyBhY3RpdmF0ZSB0ZXh0dXJlXG4gICAgICBjb25zdCB0ZXggPSBtb2RlbC5mcmFtZWJ1ZmZlci5nZXRDb2xvclRleHR1cmUoKTtcbiAgICAgIHRleC5hY3RpdmF0ZSgpO1xuICAgICAgbW9kZWwuY29weVNoYWRlci5zZXRVbmlmb3JtaSgndGV4dHVyZScsIHRleC5nZXRUZXh0dXJlVW5pdCgpKTtcblxuICAgICAgbW9kZWwuY29weVNoYWRlci5zZXRVbmlmb3JtMmYoJ3RmYWN0b3InLCBtb2RlbC5mdnBbMF0sIG1vZGVsLmZ2cFsxXSk7XG5cbiAgICAgIGNvbnN0IGdsID0gbW9kZWwuY29udGV4dDtcbiAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKFxuICAgICAgICBnbC5PTkUsXG4gICAgICAgIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsXG4gICAgICAgIGdsLk9ORSxcbiAgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQVxuICAgICAgKTtcblxuICAgICAgLy8gcmVuZGVyIHF1YWRcbiAgICAgIG1vZGVsLmNvbnRleHQuZHJhd0FycmF5cyhcbiAgICAgICAgbW9kZWwuY29udGV4dC5UUklBTkdMRVMsXG4gICAgICAgIDAsXG4gICAgICAgIG1vZGVsLnRyaXMuZ2V0Q0FCTygpLmdldEVsZW1lbnRDb3VudCgpXG4gICAgICApO1xuICAgICAgdGV4LmRlYWN0aXZhdGUoKTtcblxuICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoXG4gICAgICAgIGdsLlNSQ19BTFBIQSxcbiAgICAgICAgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSxcbiAgICAgICAgZ2wuT05FLFxuICAgICAgICBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXG4gICAgICApO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkucmVuZGVyUGllY2UgPSAocmVuLCBhY3RvcikgPT4ge1xuICAgIHB1YmxpY0FQSS5pbnZva2VFdmVudCh7IHR5cGU6ICdTdGFydEV2ZW50JyB9KTtcbiAgICBtb2RlbC5yZW5kZXJhYmxlLnVwZGF0ZSgpO1xuICAgIG1vZGVsLmN1cnJlbnRJbnB1dCA9IG1vZGVsLnJlbmRlcmFibGUuZ2V0SW5wdXREYXRhKCk7XG4gICAgcHVibGljQVBJLmludm9rZUV2ZW50KHsgdHlwZTogJ0VuZEV2ZW50JyB9KTtcblxuICAgIGlmICghbW9kZWwuY3VycmVudElucHV0KSB7XG4gICAgICB2dGtFcnJvck1hY3JvKCdObyBpbnB1dCEnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwdWJsaWNBUEkucmVuZGVyUGllY2VTdGFydChyZW4sIGFjdG9yKTtcbiAgICBwdWJsaWNBUEkucmVuZGVyUGllY2VEcmF3KHJlbiwgYWN0b3IpO1xuICAgIHB1YmxpY0FQSS5yZW5kZXJQaWVjZUZpbmlzaChyZW4sIGFjdG9yKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuY29tcHV0ZUJvdW5kcyA9IChyZW4sIGFjdG9yKSA9PiB7XG4gICAgaWYgKCFwdWJsaWNBUEkuZ2V0SW5wdXQoKSkge1xuICAgICAgdnRrTWF0aC51bmluaXRpYWxpemVCb3VuZHMobW9kZWwuQm91bmRzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbW9kZWwuYm91bmRzID0gcHVibGljQVBJLmdldElucHV0KCkuZ2V0Qm91bmRzKCk7XG4gIH07XG5cbiAgcHVibGljQVBJLnVwZGF0ZUJ1ZmZlck9iamVjdHMgPSAocmVuLCBhY3RvcikgPT4ge1xuICAgIC8vIFJlYnVpbGQgYnVmZmVycyBpZiBuZWVkZWRcbiAgICBpZiAocHVibGljQVBJLmdldE5lZWRUb1JlYnVpbGRCdWZmZXJPYmplY3RzKHJlbiwgYWN0b3IpKSB7XG4gICAgICBwdWJsaWNBUEkuYnVpbGRCdWZmZXJPYmplY3RzKHJlbiwgYWN0b3IpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0TmVlZFRvUmVidWlsZEJ1ZmZlck9iamVjdHMgPSAocmVuLCBhY3RvcikgPT4ge1xuICAgIC8vIGZpcnN0IGRvIGEgY29hcnNlIGNoZWNrXG4gICAgaWYgKFxuICAgICAgbW9kZWwuVkJPQnVpbGRUaW1lLmdldE1UaW1lKCkgPCBwdWJsaWNBUEkuZ2V0TVRpbWUoKSB8fFxuICAgICAgbW9kZWwuVkJPQnVpbGRUaW1lLmdldE1UaW1lKCkgPCBhY3Rvci5nZXRNVGltZSgpIHx8XG4gICAgICBtb2RlbC5WQk9CdWlsZFRpbWUuZ2V0TVRpbWUoKSA8IG1vZGVsLnJlbmRlcmFibGUuZ2V0TVRpbWUoKSB8fFxuICAgICAgbW9kZWwuVkJPQnVpbGRUaW1lLmdldE1UaW1lKCkgPCBhY3Rvci5nZXRQcm9wZXJ0eSgpLmdldE1UaW1lKCkgfHxcbiAgICAgIG1vZGVsLlZCT0J1aWxkVGltZS5nZXRNVGltZSgpIDwgbW9kZWwuY3VycmVudElucHV0LmdldE1UaW1lKClcbiAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcHVibGljQVBJLmJ1aWxkQnVmZmVyT2JqZWN0cyA9IChyZW4sIGFjdG9yKSA9PiB7XG4gICAgY29uc3QgaW1hZ2UgPSBtb2RlbC5jdXJyZW50SW5wdXQ7XG5cbiAgICBpZiAoaW1hZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB2cHJvcCA9IGFjdG9yLmdldFByb3BlcnR5KCk7XG5cbiAgICBpZiAoIW1vZGVsLmppdHRlclRleHR1cmUuZ2V0SGFuZGxlKCkpIHtcbiAgICAgIGNvbnN0IG9UYWJsZSA9IG5ldyBVaW50OEFycmF5KDMyICogMzIpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMiAqIDMyOyArK2kpIHtcbiAgICAgICAgb1RhYmxlW2ldID0gMjU1LjAgKiBNYXRoLnJhbmRvbSgpO1xuICAgICAgfVxuICAgICAgbW9kZWwuaml0dGVyVGV4dHVyZS5zZXRNaW5pZmljYXRpb25GaWx0ZXIoRmlsdGVyLkxJTkVBUik7XG4gICAgICBtb2RlbC5qaXR0ZXJUZXh0dXJlLnNldE1hZ25pZmljYXRpb25GaWx0ZXIoRmlsdGVyLkxJTkVBUik7XG4gICAgICBtb2RlbC5qaXR0ZXJUZXh0dXJlLmNyZWF0ZTJERnJvbVJhdyhcbiAgICAgICAgMzIsXG4gICAgICAgIDMyLFxuICAgICAgICAxLFxuICAgICAgICBWdGtEYXRhVHlwZXMuVU5TSUdORURfQ0hBUixcbiAgICAgICAgb1RhYmxlXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG51bUNvbXAgPSBpbWFnZS5nZXRQb2ludERhdGEoKS5nZXRTY2FsYXJzKCkuZ2V0TnVtYmVyT2ZDb21wb25lbnRzKCk7XG4gICAgY29uc3QgaUNvbXBzID0gdnByb3AuZ2V0SW5kZXBlbmRlbnRDb21wb25lbnRzKCk7XG4gICAgY29uc3QgbnVtSUNvbXBzID0gaUNvbXBzID8gbnVtQ29tcCA6IDE7XG5cbiAgICAvLyByZWJ1aWxkIG9wYWNpdHkgdGZ1bj9cbiAgICBsZXQgdG9TdHJpbmcgPSBgJHt2cHJvcC5nZXRNVGltZSgpfWA7XG4gICAgaWYgKG1vZGVsLm9wYWNpdHlUZXh0dXJlU3RyaW5nICE9PSB0b1N0cmluZykge1xuICAgICAgY29uc3Qgb1dpZHRoID0gMTAyNDtcbiAgICAgIGNvbnN0IG9TaXplID0gb1dpZHRoICogMiAqIG51bUlDb21wcztcbiAgICAgIGNvbnN0IG9mVGFibGUgPSBuZXcgRmxvYXQzMkFycmF5KG9TaXplKTtcbiAgICAgIGNvbnN0IHRtcFRhYmxlID0gbmV3IEZsb2F0MzJBcnJheShvV2lkdGgpO1xuXG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IG51bUlDb21wczsgKytjKSB7XG4gICAgICAgIGNvbnN0IG9mdW4gPSB2cHJvcC5nZXRTY2FsYXJPcGFjaXR5KGMpO1xuICAgICAgICBjb25zdCBvcGFjaXR5RmFjdG9yID1cbiAgICAgICAgICBtb2RlbC5yZW5kZXJhYmxlLmdldFNhbXBsZURpc3RhbmNlKCkgL1xuICAgICAgICAgIHZwcm9wLmdldFNjYWxhck9wYWNpdHlVbml0RGlzdGFuY2UoYyk7XG5cbiAgICAgICAgY29uc3Qgb1JhbmdlID0gb2Z1bi5nZXRSYW5nZSgpO1xuICAgICAgICBvZnVuLmdldFRhYmxlKG9SYW5nZVswXSwgb1JhbmdlWzFdLCBvV2lkdGgsIHRtcFRhYmxlLCAxKTtcbiAgICAgICAgLy8gYWRqdXN0IGZvciBzYW1wbGUgZGlzdGFuY2UgZXRjXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb1dpZHRoOyArK2kpIHtcbiAgICAgICAgICBvZlRhYmxlW2MgKiBvV2lkdGggKiAyICsgaV0gPVxuICAgICAgICAgICAgMS4wIC0gKDEuMCAtIHRtcFRhYmxlW2ldKSAqKiBvcGFjaXR5RmFjdG9yO1xuICAgICAgICAgIG9mVGFibGVbYyAqIG9XaWR0aCAqIDIgKyBpICsgb1dpZHRoXSA9IG9mVGFibGVbYyAqIG9XaWR0aCAqIDIgKyBpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtb2RlbC5vcGFjaXR5VGV4dHVyZS5yZWxlYXNlR3JhcGhpY3NSZXNvdXJjZXMobW9kZWwub3BlbkdMUmVuZGVyV2luZG93KTtcbiAgICAgIG1vZGVsLm9wYWNpdHlUZXh0dXJlLnNldE1pbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTElORUFSKTtcbiAgICAgIG1vZGVsLm9wYWNpdHlUZXh0dXJlLnNldE1hZ25pZmljYXRpb25GaWx0ZXIoRmlsdGVyLkxJTkVBUik7XG5cbiAgICAgIC8vIHVzZSBmbG9hdCB0ZXh0dXJlIHdoZXJlIHBvc3NpYmxlIGJlY2F1c2Ugd2UgcmVhbGx5IG5lZWQgdGhlIHJlc29sdXRpb25cbiAgICAgIC8vIGZvciB0aGlzIHRhYmxlLiBFcnJvcnMgaW4gbG93IHZhbHVlcyBvZiBvcGFjaXR5IGFjY3VtdWxhdGUgdG9cbiAgICAgIC8vIHZpc2libGUgYXJ0aWZhY3RzLiBIaWdoIHZhbHVlcyBvZiBvcGFjaXR5IHF1aWNrbHkgdGVybWluYXRlIHdpdGhvdXRcbiAgICAgIC8vIGFydGlmYWN0cy5cbiAgICAgIGlmIChcbiAgICAgICAgbW9kZWwub3BlbkdMUmVuZGVyV2luZG93LmdldFdlYmdsMigpIHx8XG4gICAgICAgIChtb2RlbC5jb250ZXh0LmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSAmJlxuICAgICAgICAgIG1vZGVsLmNvbnRleHQuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSlcbiAgICAgICkge1xuICAgICAgICBtb2RlbC5vcGFjaXR5VGV4dHVyZS5jcmVhdGUyREZyb21SYXcoXG4gICAgICAgICAgb1dpZHRoLFxuICAgICAgICAgIDIgKiBudW1JQ29tcHMsXG4gICAgICAgICAgMSxcbiAgICAgICAgICBWdGtEYXRhVHlwZXMuRkxPQVQsXG4gICAgICAgICAgb2ZUYWJsZVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgb1RhYmxlID0gbmV3IFVpbnQ4QXJyYXkob1NpemUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9TaXplOyArK2kpIHtcbiAgICAgICAgICBvVGFibGVbaV0gPSAyNTUuMCAqIG9mVGFibGVbaV07XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwub3BhY2l0eVRleHR1cmUuY3JlYXRlMkRGcm9tUmF3KFxuICAgICAgICAgIG9XaWR0aCxcbiAgICAgICAgICAyICogbnVtSUNvbXBzLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgVnRrRGF0YVR5cGVzLlVOU0lHTkVEX0NIQVIsXG4gICAgICAgICAgb1RhYmxlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBtb2RlbC5vcGFjaXR5VGV4dHVyZVN0cmluZyA9IHRvU3RyaW5nO1xuICAgIH1cblxuICAgIC8vIHJlYnVpbGQgY29sb3IgdGZ1bj9cbiAgICB0b1N0cmluZyA9IGAke3Zwcm9wLmdldE1UaW1lKCl9YDtcbiAgICBpZiAobW9kZWwuY29sb3JUZXh0dXJlU3RyaW5nICE9PSB0b1N0cmluZykge1xuICAgICAgY29uc3QgY1dpZHRoID0gMTAyNDtcbiAgICAgIGNvbnN0IGNTaXplID0gY1dpZHRoICogMiAqIG51bUlDb21wcyAqIDM7XG4gICAgICBjb25zdCBjVGFibGUgPSBuZXcgVWludDhBcnJheShjU2l6ZSk7XG4gICAgICBjb25zdCB0bXBUYWJsZSA9IG5ldyBGbG9hdDMyQXJyYXkoY1dpZHRoICogMyk7XG5cbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgbnVtSUNvbXBzOyArK2MpIHtcbiAgICAgICAgY29uc3QgY2Z1biA9IHZwcm9wLmdldFJHQlRyYW5zZmVyRnVuY3Rpb24oYyk7XG4gICAgICAgIGNvbnN0IGNSYW5nZSA9IGNmdW4uZ2V0UmFuZ2UoKTtcbiAgICAgICAgY2Z1bi5nZXRUYWJsZShjUmFuZ2VbMF0sIGNSYW5nZVsxXSwgY1dpZHRoLCB0bXBUYWJsZSwgMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY1dpZHRoICogMzsgKytpKSB7XG4gICAgICAgICAgY1RhYmxlW2MgKiBjV2lkdGggKiA2ICsgaV0gPSAyNTUuMCAqIHRtcFRhYmxlW2ldO1xuICAgICAgICAgIGNUYWJsZVtjICogY1dpZHRoICogNiArIGkgKyBjV2lkdGggKiAzXSA9IDI1NS4wICogdG1wVGFibGVbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbW9kZWwuY29sb3JUZXh0dXJlLnJlbGVhc2VHcmFwaGljc1Jlc291cmNlcyhtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cpO1xuICAgICAgbW9kZWwuY29sb3JUZXh0dXJlLnNldE1pbmlmaWNhdGlvbkZpbHRlcihGaWx0ZXIuTElORUFSKTtcbiAgICAgIG1vZGVsLmNvbG9yVGV4dHVyZS5zZXRNYWduaWZpY2F0aW9uRmlsdGVyKEZpbHRlci5MSU5FQVIpO1xuXG4gICAgICBtb2RlbC5jb2xvclRleHR1cmUuY3JlYXRlMkRGcm9tUmF3KFxuICAgICAgICBjV2lkdGgsXG4gICAgICAgIDIgKiBudW1JQ29tcHMsXG4gICAgICAgIDMsXG4gICAgICAgIFZ0a0RhdGFUeXBlcy5VTlNJR05FRF9DSEFSLFxuICAgICAgICBjVGFibGVcbiAgICAgICk7XG4gICAgICBtb2RlbC5jb2xvclRleHR1cmVTdHJpbmcgPSB0b1N0cmluZztcbiAgICB9XG5cbiAgICAvLyByZWJ1aWxkIHRoZSBzY2FsYXJUZXh0dXJlIGlmIHRoZSBkYXRhIGhhcyBjaGFuZ2VkXG4gICAgdG9TdHJpbmcgPSBgJHtpbWFnZS5nZXRNVGltZSgpfWA7XG4gICAgaWYgKG1vZGVsLnNjYWxhclRleHR1cmVTdHJpbmcgIT09IHRvU3RyaW5nKSB7XG4gICAgICAvLyBCdWlsZCB0aGUgdGV4dHVyZXNcbiAgICAgIGNvbnN0IGRpbXMgPSBpbWFnZS5nZXREaW1lbnNpb25zKCk7XG4gICAgICBtb2RlbC5zY2FsYXJUZXh0dXJlLnJlbGVhc2VHcmFwaGljc1Jlc291cmNlcyhtb2RlbC5vcGVuR0xSZW5kZXJXaW5kb3cpO1xuICAgICAgbW9kZWwuc2NhbGFyVGV4dHVyZS5yZXNldEZvcm1hdEFuZFR5cGUoKTtcbiAgICAgIG1vZGVsLnNjYWxhclRleHR1cmUuY3JlYXRlM0RGaWx0ZXJhYmxlRnJvbVJhdyhcbiAgICAgICAgZGltc1swXSxcbiAgICAgICAgZGltc1sxXSxcbiAgICAgICAgZGltc1syXSxcbiAgICAgICAgbnVtQ29tcCxcbiAgICAgICAgaW1hZ2UuZ2V0UG9pbnREYXRhKCkuZ2V0U2NhbGFycygpLmdldERhdGFUeXBlKCksXG4gICAgICAgIGltYWdlLmdldFBvaW50RGF0YSgpLmdldFNjYWxhcnMoKS5nZXREYXRhKClcbiAgICAgICk7XG4gICAgICAvLyBjb25zb2xlLmxvZyhtb2RlbC5zY2FsYXJUZXh0dXJlLmdldCgpKTtcbiAgICAgIG1vZGVsLnNjYWxhclRleHR1cmVTdHJpbmcgPSB0b1N0cmluZztcbiAgICB9XG5cbiAgICBpZiAoIW1vZGVsLnRyaXMuZ2V0Q0FCTygpLmdldEVsZW1lbnRDb3VudCgpKSB7XG4gICAgICAvLyBidWlsZCB0aGUgQ0FCT1xuICAgICAgY29uc3QgcHRzQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDEyKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgIHB0c0FycmF5W2kgKiAzXSA9IChpICUgMikgKiAyIC0gMS4wO1xuICAgICAgICBwdHNBcnJheVtpICogMyArIDFdID0gaSA+IDEgPyAxLjAgOiAtMS4wO1xuICAgICAgICBwdHNBcnJheVtpICogMyArIDJdID0gLTEuMDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2VsbEFycmF5ID0gbmV3IFVpbnQxNkFycmF5KDgpO1xuICAgICAgY2VsbEFycmF5WzBdID0gMztcbiAgICAgIGNlbGxBcnJheVsxXSA9IDA7XG4gICAgICBjZWxsQXJyYXlbMl0gPSAxO1xuICAgICAgY2VsbEFycmF5WzNdID0gMztcbiAgICAgIGNlbGxBcnJheVs0XSA9IDM7XG4gICAgICBjZWxsQXJyYXlbNV0gPSAwO1xuICAgICAgY2VsbEFycmF5WzZdID0gMztcbiAgICAgIGNlbGxBcnJheVs3XSA9IDI7XG5cbiAgICAgIC8vIGNvbnN0IGRpbSA9IDEyLjA7XG4gICAgICAvLyBjb25zdCBwdHNBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMyAqIGRpbSAqIGRpbSk7XG4gICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IGRpbTsgaSsrKSB7XG4gICAgICAvLyAgIGZvciAobGV0IGogPSAwOyBqIDwgZGltOyBqKyspIHtcbiAgICAgIC8vICAgICBjb25zdCBvZmZzZXQgPSAoKGkgKiBkaW0pICsgaikgKiAzO1xuICAgICAgLy8gICAgIHB0c0FycmF5W29mZnNldF0gPSAoMi4wICogKGkgLyAoZGltIC0gMS4wKSkpIC0gMS4wO1xuICAgICAgLy8gICAgIHB0c0FycmF5W29mZnNldCArIDFdID0gKDIuMCAqIChqIC8gKGRpbSAtIDEuMCkpKSAtIDEuMDtcbiAgICAgIC8vICAgICBwdHNBcnJheVtvZmZzZXQgKyAyXSA9IC0xLjA7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cblxuICAgICAgLy8gY29uc3QgY2VsbEFycmF5ID0gbmV3IFVpbnQxNkFycmF5KDggKiAoZGltIC0gMSkgKiAoZGltIC0gMSkpO1xuICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBkaW0gLSAxOyBpKyspIHtcbiAgICAgIC8vICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaW0gLSAxOyBqKyspIHtcbiAgICAgIC8vICAgICBjb25zdCBvZmZzZXQgPSA4ICogKChpICogKGRpbSAtIDEpKSArIGopO1xuICAgICAgLy8gICAgIGNlbGxBcnJheVtvZmZzZXRdID0gMztcbiAgICAgIC8vICAgICBjZWxsQXJyYXlbb2Zmc2V0ICsgMV0gPSAoaSAqIGRpbSkgKyBqO1xuICAgICAgLy8gICAgIGNlbGxBcnJheVtvZmZzZXQgKyAyXSA9IChpICogZGltKSArIDEgKyBqO1xuICAgICAgLy8gICAgIGNlbGxBcnJheVtvZmZzZXQgKyAzXSA9ICgoaSArIDEpICogZGltKSArIDEgKyBqO1xuICAgICAgLy8gICAgIGNlbGxBcnJheVtvZmZzZXQgKyA0XSA9IDM7XG4gICAgICAvLyAgICAgY2VsbEFycmF5W29mZnNldCArIDVdID0gKGkgKiBkaW0pICsgajtcbiAgICAgIC8vICAgICBjZWxsQXJyYXlbb2Zmc2V0ICsgNl0gPSAoKGkgKyAxKSAqIGRpbSkgKyAxICsgajtcbiAgICAgIC8vICAgICBjZWxsQXJyYXlbb2Zmc2V0ICsgN10gPSAoKGkgKyAxKSAqIGRpbSkgKyBqO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG5cbiAgICAgIGNvbnN0IHBvaW50cyA9IHZ0a0RhdGFBcnJheS5uZXdJbnN0YW5jZSh7XG4gICAgICAgIG51bWJlck9mQ29tcG9uZW50czogMyxcbiAgICAgICAgdmFsdWVzOiBwdHNBcnJheSxcbiAgICAgIH0pO1xuICAgICAgcG9pbnRzLnNldE5hbWUoJ3BvaW50cycpO1xuICAgICAgY29uc3QgY2VsbHMgPSB2dGtEYXRhQXJyYXkubmV3SW5zdGFuY2Uoe1xuICAgICAgICBudW1iZXJPZkNvbXBvbmVudHM6IDEsXG4gICAgICAgIHZhbHVlczogY2VsbEFycmF5LFxuICAgICAgfSk7XG4gICAgICBtb2RlbC50cmlzLmdldENBQk8oKS5jcmVhdGVWQk8oY2VsbHMsICdwb2x5cycsIFJlcHJlc2VudGF0aW9uLlNVUkZBQ0UsIHtcbiAgICAgICAgcG9pbnRzLFxuICAgICAgICBjZWxsT2Zmc2V0OiAwLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgbW9kZWwuVkJPQnVpbGRUaW1lLm1vZGlmaWVkKCk7XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBjb250ZXh0OiBudWxsLFxuICBWQk9CdWlsZFRpbWU6IG51bGwsXG4gIHNjYWxhclRleHR1cmU6IG51bGwsXG4gIHNjYWxhclRleHR1cmVTdHJpbmc6IG51bGwsXG4gIG9wYWNpdHlUZXh0dXJlOiBudWxsLFxuICBvcGFjaXR5VGV4dHVyZVN0cmluZzogbnVsbCxcbiAgY29sb3JUZXh0dXJlOiBudWxsLFxuICBjb2xvclRleHR1cmVTdHJpbmc6IG51bGwsXG4gIGppdHRlclRleHR1cmU6IG51bGwsXG4gIHRyaXM6IG51bGwsXG4gIGZyYW1lYnVmZmVyOiBudWxsLFxuICBjb3B5U2hhZGVyOiBudWxsLFxuICBjb3B5VkFPOiBudWxsLFxuICBsYXN0WFlGOiAxLjAsXG4gIHRhcmdldFhZRjogMS4wLFxuICB6QnVmZmVyVGV4dHVyZTogbnVsbCxcbiAgbGFzdFpCdWZmZXJUZXh0dXJlOiBudWxsLFxuICBsYXN0TGlnaHRDb21wbGV4aXR5OiAwLFxuICBmdWxsVmlld3BvcnRUaW1lOiAxLjAsXG4gIGlkeFRvVmlldzogbnVsbCxcbiAgaWR4Tm9ybWFsTWF0cml4OiBudWxsLFxuICBtb2RlbFRvVmlldzogbnVsbCxcbiAgcHJvamVjdGlvblRvVmlldzogbnVsbCxcbiAgYXZnV2luZG93QXJlYTogMC4wLFxuICBhdmdGcmFtZVRpbWU6IDAuMCxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEluaGVyaXRhbmNlXG4gIHZ0a1ZpZXdOb2RlLmV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzKTtcblxuICBtb2RlbC5WQk9CdWlsZFRpbWUgPSB7fTtcbiAgbWFjcm8ub2JqKG1vZGVsLlZCT0J1aWxkVGltZSwgeyBtdGltZTogMCB9KTtcblxuICBtb2RlbC50cmlzID0gdnRrSGVscGVyLm5ld0luc3RhbmNlKCk7XG4gIG1vZGVsLnNjYWxhclRleHR1cmUgPSB2dGtPcGVuR0xUZXh0dXJlLm5ld0luc3RhbmNlKCk7XG4gIG1vZGVsLm9wYWNpdHlUZXh0dXJlID0gdnRrT3BlbkdMVGV4dHVyZS5uZXdJbnN0YW5jZSgpO1xuICBtb2RlbC5jb2xvclRleHR1cmUgPSB2dGtPcGVuR0xUZXh0dXJlLm5ld0luc3RhbmNlKCk7XG4gIG1vZGVsLmppdHRlclRleHR1cmUgPSB2dGtPcGVuR0xUZXh0dXJlLm5ld0luc3RhbmNlKCk7XG4gIG1vZGVsLmppdHRlclRleHR1cmUuc2V0V3JhcFMoV3JhcC5SRVBFQVQpO1xuICBtb2RlbC5qaXR0ZXJUZXh0dXJlLnNldFdyYXBUKFdyYXAuUkVQRUFUKTtcbiAgbW9kZWwuZnJhbWVidWZmZXIgPSB2dGtPcGVuR0xGcmFtZWJ1ZmZlci5uZXdJbnN0YW5jZSgpO1xuXG4gIG1vZGVsLmlkeFRvVmlldyA9IG1hdDQuY3JlYXRlKCk7XG4gIG1vZGVsLmlkeE5vcm1hbE1hdHJpeCA9IG1hdDMuY3JlYXRlKCk7XG4gIG1vZGVsLm1vZGVsVG9WaWV3ID0gbWF0NC5jcmVhdGUoKTtcbiAgbW9kZWwucHJvamVjdGlvblRvVmlldyA9IG1hdDQuY3JlYXRlKCk7XG4gIG1vZGVsLnByb2plY3Rpb25Ub1dvcmxkID0gbWF0NC5jcmVhdGUoKTtcblxuICAvLyBCdWlsZCBWVEsgQVBJXG4gIG1hY3JvLnNldEdldChwdWJsaWNBUEksIG1vZGVsLCBbJ2NvbnRleHQnXSk7XG5cbiAgLy8gT2JqZWN0IG1ldGhvZHNcbiAgdnRrT3BlbkdMVm9sdW1lTWFwcGVyKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a09wZW5HTFZvbHVtZU1hcHBlcicpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vVlRLOjpTeXN0ZW06OkRlY1xcblxcbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcblxcbiAgUHJvZ3JhbTogICBWaXN1YWxpemF0aW9uIFRvb2xraXRcXG4gIE1vZHVsZTogICAgdnRrUG9seURhdGFGUy5nbHNsXFxuXFxuICBDb3B5cmlnaHQgKGMpIEtlbiBNYXJ0aW4sIFdpbGwgU2Nocm9lZGVyLCBCaWxsIExvcmVuc2VuXFxuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbiAgU2VlIENvcHlyaWdodC50eHQgb3IgaHR0cDovL3d3dy5raXR3YXJlLmNvbS9Db3B5cmlnaHQuaHRtIGZvciBkZXRhaWxzLlxcblxcbiAgICAgVGhpcyBzb2Z0d2FyZSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuXFxuICAgICB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXFxuICAgICBQVVJQT1NFLiAgU2VlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxcblxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xcbi8vIFRlbXBsYXRlIGZvciB0aGUgcG9seWRhdGEgbWFwcGVycyBmcmFnbWVudCBzaGFkZXJcXG5cXG51bmlmb3JtIGludCBQcmltaXRpdmVJRE9mZnNldDtcXG5cXG4vLyBWQyBwb3NpdGlvbiBvZiB0aGlzIGZyYWdtZW50XFxuLy9WVEs6OlBvc2l0aW9uVkM6OkRlY1xcblxcbi8vIG9wdGlvbmFsIGNvbG9yIHBhc3NlZCBpbiBmcm9tIHRoZSB2ZXJ0ZXggc2hhZGVyLCB2ZXJ0ZXhDb2xvclxcbi8vVlRLOjpDb2xvcjo6RGVjXFxuXFxuLy8gb3B0aW9uYWwgc3VyZmFjZSBub3JtYWwgZGVjbGFyYXRpb25cXG4vL1ZUSzo6Tm9ybWFsOjpEZWNcXG5cXG4vLyBleHRyYSBsaWdodGluZyBwYXJhbWV0ZXJzXFxuLy9WVEs6OkxpZ2h0OjpEZWNcXG5cXG4vLyBUZXh0dXJlIGNvb3JkaW5hdGVzXFxuLy9WVEs6OlRDb29yZDo6RGVjXFxuXFxuLy8gcGlja2luZyBzdXBwb3J0XFxuLy9WVEs6OlBpY2tpbmc6OkRlY1xcblxcbi8vIERlcHRoIFBlZWxpbmcgU3VwcG9ydFxcbi8vVlRLOjpEZXB0aFBlZWxpbmc6OkRlY1xcblxcbi8vIGNsaXBwaW5nIHBsYW5lIHZhcnNcXG4vL1ZUSzo6Q2xpcDo6RGVjXFxuXFxuLy8gdGhlIG91dHB1dCBvZiB0aGlzIHNoYWRlclxcbi8vVlRLOjpPdXRwdXQ6OkRlY1xcblxcbi8vIEFwcGxlIEJ1Z1xcbi8vVlRLOjpQcmltSUQ6OkRlY1xcblxcbi8vIGhhbmRsZSBjb2luY2lkZW50IG9mZnNldHNcXG4vL1ZUSzo6Q29pbmNpZGVudDo6RGVjXFxuXFxuLy9WVEs6OlpCdWZmZXI6OkRlY1xcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgLy8gVkMgcG9zaXRpb24gb2YgdGhpcyBmcmFnbWVudC4gVGhpcyBzaG91bGQgbm90IGJyYW5jaC9yZXR1cm4vZGlzY2FyZC5cXG4gIC8vVlRLOjpQb3NpdGlvblZDOjpJbXBsXFxuXFxuICAvLyBQbGFjZSBhbnkgY2FsbHMgdGhhdCByZXF1aXJlIHVuaWZvcm0gZmxvdyAoZS5nLiBkRmR4KSBoZXJlLlxcbiAgLy9WVEs6OlVuaWZvcm1GbG93OjpJbXBsXFxuXFxuICAvLyBTZXQgZ2xfRnJhZ0RlcHRoIGhlcmUgKGdsX0ZyYWdDb29yZC56IGJ5IGRlZmF1bHQpXFxuICAvL1ZUSzo6RGVwdGg6OkltcGxcXG5cXG4gIC8vIEVhcmx5IGRlcHRoIHBlZWxpbmcgYWJvcnQ6XFxuICAvL1ZUSzo6RGVwdGhQZWVsaW5nOjpQcmVDb2xvclxcblxcbiAgLy8gQXBwbGUgQnVnXFxuICAvL1ZUSzo6UHJpbUlEOjpJbXBsXFxuXFxuICAvL1ZUSzo6Q2xpcDo6SW1wbFxcblxcbiAgLy9WVEs6OkNvbG9yOjpJbXBsXFxuXFxuICAvLyBHZW5lcmF0ZSB0aGUgbm9ybWFsIGlmIHdlIGFyZSBub3QgcGFzc2VkIGluIG9uZVxcbiAgLy9WVEs6Ok5vcm1hbDo6SW1wbFxcblxcbiAgLy9WVEs6OkxpZ2h0OjpJbXBsXFxuXFxuICAvL1ZUSzo6VENvb3JkOjpJbXBsXFxuXFxuICBpZiAoZ2xfRnJhZ0RhdGFbMF0uYSA8PSAwLjApXFxuICAgIHtcXG4gICAgZGlzY2FyZDtcXG4gICAgfVxcblxcbiAgLy9WVEs6OkRlcHRoUGVlbGluZzo6SW1wbFxcblxcbiAgLy9WVEs6OlBpY2tpbmc6OkltcGxcXG5cXG4gIC8vIGhhbmRsZSBjb2luY2lkZW50IG9mZnNldHNcXG4gIC8vVlRLOjpDb2luY2lkZW50OjpJbXBsXFxuXFxuICAvL1ZUSzo6WkJ1ZmZlcjo6SW1wbFxcbn1cXG5cIiIsIm1vZHVsZS5leHBvcnRzID0gXCIvL1ZUSzo6U3lzdGVtOjpEZWNcXG5cXG4vKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG5cXG4gIFByb2dyYW06ICAgVmlzdWFsaXphdGlvbiBUb29sa2l0XFxuICBNb2R1bGU6ICAgIHZ0a1BvbHlEYXRhVlMuZ2xzbFxcblxcbiAgQ29weXJpZ2h0IChjKSBLZW4gTWFydGluLCBXaWxsIFNjaHJvZWRlciwgQmlsbCBMb3JlbnNlblxcbiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4gIFNlZSBDb3B5cmlnaHQudHh0IG9yIGh0dHA6Ly93d3cua2l0d2FyZS5jb20vQ29weXJpZ2h0Lmh0bSBmb3IgZGV0YWlscy5cXG5cXG4gICAgIFRoaXMgc29mdHdhcmUgaXMgZGlzdHJpYnV0ZWQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlblxcbiAgICAgdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxcbiAgICAgUFVSUE9TRS4gIFNlZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cXG5cXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cXG5cXG5hdHRyaWJ1dGUgdmVjNCB2ZXJ0ZXhNQztcXG5cXG4vLyBmcmFnIHBvc2l0aW9uIGluIFZDXFxuLy9WVEs6OlBvc2l0aW9uVkM6OkRlY1xcblxcbi8vIG9wdGlvbmFsIG5vcm1hbCBkZWNsYXJhdGlvblxcbi8vVlRLOjpOb3JtYWw6OkRlY1xcblxcbi8vIGV4dHJhIGxpZ2h0aW5nIHBhcmFtZXRlcnNcXG4vL1ZUSzo6TGlnaHQ6OkRlY1xcblxcbi8vIFRleHR1cmUgY29vcmRpbmF0ZXNcXG4vL1ZUSzo6VENvb3JkOjpEZWNcXG5cXG4vLyBtYXRlcmlhbCBwcm9wZXJ0eSB2YWx1ZXNcXG4vL1ZUSzo6Q29sb3I6OkRlY1xcblxcbi8vIGNsaXBwaW5nIHBsYW5lIHZhcnNcXG4vL1ZUSzo6Q2xpcDo6RGVjXFxuXFxuLy8gY2FtZXJhIGFuZCBhY3RvciBtYXRyaXggdmFsdWVzXFxuLy9WVEs6OkNhbWVyYTo6RGVjXFxuXFxuLy8gQXBwbGUgQnVnXFxuLy9WVEs6OlByaW1JRDo6RGVjXFxuXFxuLy8gcGlja2luZyBzdXBwb3J0XFxuLy9WVEs6OlBpY2tpbmc6OkRlY1xcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgLy9WVEs6OkNvbG9yOjpJbXBsXFxuXFxuICAvL1ZUSzo6Tm9ybWFsOjpJbXBsXFxuXFxuICAvL1ZUSzo6VENvb3JkOjpJbXBsXFxuXFxuICAvL1ZUSzo6Q2xpcDo6SW1wbFxcblxcbiAgLy9WVEs6OlByaW1JRDo6SW1wbFxcblxcbiAgLy9WVEs6OlBvc2l0aW9uVkM6OkltcGxcXG5cXG4gIC8vVlRLOjpMaWdodDo6SW1wbFxcblxcbiAgLy9WVEs6OlBpY2tpbmc6OkltcGxcXG59XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLy9WVEs6OlN5c3RlbTo6RGVjXFxuXFxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuXFxuICBQcm9ncmFtOiAgIFZpc3VhbGl6YXRpb24gVG9vbGtpdFxcbiAgTW9kdWxlOiAgICB2dGtTcGhlcmVNYXBwZXJWUy5nbHNsXFxuXFxuICBDb3B5cmlnaHQgKGMpIEtlbiBNYXJ0aW4sIFdpbGwgU2Nocm9lZGVyLCBCaWxsIExvcmVuc2VuXFxuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbiAgU2VlIENvcHlyaWdodC50eHQgb3IgaHR0cDovL3d3dy5raXR3YXJlLmNvbS9Db3B5cmlnaHQuaHRtIGZvciBkZXRhaWxzLlxcblxcbiAgICAgVGhpcyBzb2Z0d2FyZSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuXFxuICAgICB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXFxuICAgICBQVVJQT1NFLiAgU2VlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxcblxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xcbi8vIHRoaXMgc2hhZGVyIGltcGxlbWVudHMgaW1wb3N0ZXJzIGluIE9wZW5HTCBmb3IgU3BoZXJlc1xcblxcbmF0dHJpYnV0ZSB2ZWM0IHZlcnRleE1DO1xcbmF0dHJpYnV0ZSB2ZWMyIG9mZnNldE1DO1xcblxcbi8vIG9wdGlvbmFsIG5vcm1hbCBkZWNsYXJhdGlvblxcbi8vVlRLOjpOb3JtYWw6OkRlY1xcblxcbi8vIFRleHR1cmUgY29vcmRpbmF0ZXNcXG4vL1ZUSzo6VENvb3JkOjpEZWNcXG5cXG51bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4OyAvLyB0cmFuc2Zvcm0gbW9kZWwgY29vcmRpbmF0ZSBkaXJlY3Rpb25zIHRvIHZpZXcgY29vcmRpbmF0ZXNcXG5cXG4vLyBtYXRlcmlhbCBwcm9wZXJ0eSB2YWx1ZXNcXG4vL1ZUSzo6Q29sb3I6OkRlY1xcblxcbi8vIGNsaXBwaW5nIHBsYW5lIHZhcnNcXG4vL1ZUSzo6Q2xpcDo6RGVjXFxuXFxuLy8gY2FtZXJhIGFuZCBhY3RvciBtYXRyaXggdmFsdWVzXFxuLy9WVEs6OkNhbWVyYTo6RGVjXFxuXFxudmFyeWluZyB2ZWM0IHZlcnRleFZDVlNPdXRwdXQ7XFxudmFyeWluZyBmbG9hdCByYWRpdXNWQ1ZTT3V0cHV0O1xcbnZhcnlpbmcgdmVjMyBjZW50ZXJWQ1ZTT3V0cHV0O1xcblxcbnVuaWZvcm0gaW50IGNhbWVyYVBhcmFsbGVsO1xcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgLy9WVEs6OkNvbG9yOjpJbXBsXFxuXFxuICAvL1ZUSzo6Tm9ybWFsOjpJbXBsXFxuXFxuICAvL1ZUSzo6VENvb3JkOjpJbXBsXFxuXFxuICAvL1ZUSzo6Q2xpcDo6SW1wbFxcblxcbiAgLy8gY29tcHV0ZSB0aGUgcHJvamVjdGVkIHZlcnRleCBwb3NpdGlvblxcbiAgdmVydGV4VkNWU091dHB1dCA9IE1DVkNNYXRyaXggKiB2ZXJ0ZXhNQztcXG4gIGNlbnRlclZDVlNPdXRwdXQgPSB2ZXJ0ZXhWQ1ZTT3V0cHV0Lnh5ejtcXG4gIHJhZGl1c1ZDVlNPdXRwdXQgPSBsZW5ndGgob2Zmc2V0TUMpKjAuNTtcXG5cXG4gIC8vIG1ha2UgdGhlIHRyaWFuZ2xlIGZhY2UgdGhlIGNhbWVyYVxcbiAgaWYgKGNhbWVyYVBhcmFsbGVsID09IDApXFxuICAgIHtcXG4gICAgdmVjMyBkaXIgPSBub3JtYWxpemUoLXZlcnRleFZDVlNPdXRwdXQueHl6KTtcXG4gICAgdmVjMyBiYXNlMiA9IG5vcm1hbGl6ZShjcm9zcyhkaXIsdmVjMygxLjAsMC4wLDAuMCkpKTtcXG4gICAgdmVjMyBiYXNlMSA9IGNyb3NzKGJhc2UyLGRpcik7XFxuICAgIHZlcnRleFZDVlNPdXRwdXQueHl6ID0gdmVydGV4VkNWU091dHB1dC54eXogKyBvZmZzZXRNQy54KmJhc2UxICsgb2Zmc2V0TUMueSpiYXNlMjtcXG4gICAgfVxcbiAgZWxzZVxcbiAgICB7XFxuICAgIC8vIGFkZCBpbiB0aGUgb2Zmc2V0XFxuICAgIHZlcnRleFZDVlNPdXRwdXQueHkgPSB2ZXJ0ZXhWQ1ZTT3V0cHV0Lnh5ICsgb2Zmc2V0TUM7XFxuICAgIH1cXG5cXG4gIGdsX1Bvc2l0aW9uID0gVkNQQ01hdHJpeCAqIHZlcnRleFZDVlNPdXRwdXQ7XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vVlRLOjpTeXN0ZW06OkRlY1xcblxcbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcblxcbiAgUHJvZ3JhbTogICBWaXN1YWxpemF0aW9uIFRvb2xraXRcXG4gIE1vZHVsZTogICAgdnRrU3RpY2tNYXBwZXJWUy5nbHNsXFxuXFxuICBDb3B5cmlnaHQgKGMpIEtlbiBNYXJ0aW4sIFdpbGwgU2Nocm9lZGVyLCBCaWxsIExvcmVuc2VuXFxuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbiAgU2VlIENvcHlyaWdodC50eHQgb3IgaHR0cDovL3d3dy5raXR3YXJlLmNvbS9Db3B5cmlnaHQuaHRtIGZvciBkZXRhaWxzLlxcblxcbiAgICAgVGhpcyBzb2Z0d2FyZSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuXFxuICAgICB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXFxuICAgICBQVVJQT1NFLiAgU2VlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxcblxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xcbi8vIHRoaXMgc2hhZGVyIGltcGxlbWVudHMgaW1wb3N0ZXJzIGluIE9wZW5HTCBmb3IgU3RpY2tzXFxuXFxuYXR0cmlidXRlIHZlYzQgdmVydGV4TUM7XFxuYXR0cmlidXRlIHZlYzMgb3JpZW50TUM7XFxuYXR0cmlidXRlIHZlYzQgb2Zmc2V0TUM7XFxuYXR0cmlidXRlIGZsb2F0IHJhZGl1c01DO1xcblxcbi8vIG9wdGlvbmFsIG5vcm1hbCBkZWNsYXJhdGlvblxcbi8vVlRLOjpOb3JtYWw6OkRlY1xcblxcbi8vVlRLOjpQaWNraW5nOjpEZWNcXG5cXG4vLyBUZXh0dXJlIGNvb3JkaW5hdGVzXFxuLy9WVEs6OlRDb29yZDo6RGVjXFxuXFxudW5pZm9ybSBtYXQzIG5vcm1hbE1hdHJpeDsgLy8gdHJhbnNmb3JtIG1vZGVsIGNvb3JkaW5hdGUgZGlyZWN0aW9ucyB0byB2aWV3IGNvb3JkaW5hdGVzXFxuXFxuLy8gbWF0ZXJpYWwgcHJvcGVydHkgdmFsdWVzXFxuLy9WVEs6OkNvbG9yOjpEZWNcXG5cXG4vLyBjbGlwcGluZyBwbGFuZSB2YXJzXFxuLy9WVEs6OkNsaXA6OkRlY1xcblxcbi8vIGNhbWVyYSBhbmQgYWN0b3IgbWF0cml4IHZhbHVlc1xcbi8vVlRLOjpDYW1lcmE6OkRlY1xcblxcbnZhcnlpbmcgdmVjNCB2ZXJ0ZXhWQ1ZTT3V0cHV0O1xcbnZhcnlpbmcgZmxvYXQgcmFkaXVzVkNWU091dHB1dDtcXG52YXJ5aW5nIGZsb2F0IGxlbmd0aFZDVlNPdXRwdXQ7XFxudmFyeWluZyB2ZWMzIGNlbnRlclZDVlNPdXRwdXQ7XFxudmFyeWluZyB2ZWMzIG9yaWVudFZDVlNPdXRwdXQ7XFxuXFxudW5pZm9ybSBpbnQgY2FtZXJhUGFyYWxsZWw7XFxuXFxudm9pZCBtYWluKClcXG57XFxuICAvL1ZUSzo6UGlja2luZzo6SW1wbFxcblxcbiAgLy9WVEs6OkNvbG9yOjpJbXBsXFxuXFxuICAvL1ZUSzo6Tm9ybWFsOjpJbXBsXFxuXFxuICAvL1ZUSzo6VENvb3JkOjpJbXBsXFxuXFxuICAvL1ZUSzo6Q2xpcDo6SW1wbFxcblxcbiAgdmVydGV4VkNWU091dHB1dCA9IE1DVkNNYXRyaXggKiB2ZXJ0ZXhNQztcXG4gIGNlbnRlclZDVlNPdXRwdXQgPSB2ZXJ0ZXhWQ1ZTT3V0cHV0Lnh5ejtcXG4gIHJhZGl1c1ZDVlNPdXRwdXQgPSByYWRpdXNNQztcXG4gIGxlbmd0aFZDVlNPdXRwdXQgPSBsZW5ndGgob3JpZW50TUMpO1xcbiAgb3JpZW50VkNWU091dHB1dCA9IG5vcm1hbE1hdHJpeCAqIG5vcm1hbGl6ZShvcmllbnRNQyk7XFxuXFxuICAvLyBtYWtlIHN1cmUgaXQgaXMgcG9pbnRpbmcgb3V0IG9mIHRoZSBzY3JlZW5cXG4gIGlmIChvcmllbnRWQ1ZTT3V0cHV0LnogPCAwLjApXFxuICAgIHtcXG4gICAgb3JpZW50VkNWU091dHB1dCA9IC1vcmllbnRWQ1ZTT3V0cHV0O1xcbiAgICB9XFxuXFxuICAvLyBtYWtlIHRoZSBiYXNpc1xcbiAgdmVjMyB4YmFzZTtcXG4gIHZlYzMgeWJhc2U7XFxuICB2ZWMzIGRpciA9IHZlYzMoMC4wLDAuMCwxLjApO1xcbiAgaWYgKGNhbWVyYVBhcmFsbGVsID09IDApXFxuICAgIHtcXG4gICAgZGlyID0gbm9ybWFsaXplKC12ZXJ0ZXhWQ1ZTT3V0cHV0Lnh5eik7XFxuICAgIH1cXG4gIGlmIChhYnMoZG90KGRpcixvcmllbnRWQ1ZTT3V0cHV0KSkgPT0gMS4wKVxcbiAgICB7XFxuICAgIHhiYXNlID0gbm9ybWFsaXplKGNyb3NzKHZlYzMoMC4wLDEuMCwwLjApLG9yaWVudFZDVlNPdXRwdXQpKTtcXG4gICAgeWJhc2UgPSBjcm9zcyh4YmFzZSxvcmllbnRWQ1ZTT3V0cHV0KTtcXG4gICAgfVxcbiAgZWxzZVxcbiAgICB7XFxuICAgIHhiYXNlID0gbm9ybWFsaXplKGNyb3NzKG9yaWVudFZDVlNPdXRwdXQsZGlyKSk7XFxuICAgIHliYXNlID0gY3Jvc3Mob3JpZW50VkNWU091dHB1dCx4YmFzZSk7XFxuICAgIH1cXG5cXG4gIHZlYzMgb2Zmc2V0cyA9IG9mZnNldE1DLnh5eioyLjAtMS4wO1xcbiAgdmVydGV4VkNWU091dHB1dC54eXogPSB2ZXJ0ZXhWQ1ZTT3V0cHV0Lnh5eiArXFxuICAgIHJhZGl1c1ZDVlNPdXRwdXQqb2Zmc2V0cy54KnhiYXNlICtcXG4gICAgcmFkaXVzVkNWU091dHB1dCpvZmZzZXRzLnkqeWJhc2UgK1xcbiAgICAwLjUqbGVuZ3RoVkNWU091dHB1dCpvZmZzZXRzLnoqb3JpZW50VkNWU091dHB1dDtcXG5cXG4gIGdsX1Bvc2l0aW9uID0gVkNQQ01hdHJpeCAqIHZlcnRleFZDVlNPdXRwdXQ7XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vVlRLOjpTeXN0ZW06OkRlY1xcblxcbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcblxcbiAgUHJvZ3JhbTogICBWaXN1YWxpemF0aW9uIFRvb2xraXRcXG4gIE1vZHVsZTogICAgdnRrVm9sdW1lRlMuZ2xzbFxcblxcbiAgQ29weXJpZ2h0IChjKSBLZW4gTWFydGluLCBXaWxsIFNjaHJvZWRlciwgQmlsbCBMb3JlbnNlblxcbiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4gIFNlZSBDb3B5cmlnaHQudHh0IG9yIGh0dHA6Ly93d3cua2l0d2FyZS5jb20vQ29weXJpZ2h0Lmh0bSBmb3IgZGV0YWlscy5cXG5cXG4gICAgIFRoaXMgc29mdHdhcmUgaXMgZGlzdHJpYnV0ZWQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlblxcbiAgICAgdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUlxcbiAgICAgUFVSUE9TRS4gIFNlZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cXG5cXG49PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cXG4vLyBUZW1wbGF0ZSBmb3IgdGhlIHZvbHVtZSBtYXBwZXJzIGZyYWdtZW50IHNoYWRlclxcblxcbi8vIHRoZSBvdXRwdXQgb2YgdGhpcyBzaGFkZXJcXG4vL1ZUSzo6T3V0cHV0OjpEZWNcXG5cXG52YXJ5aW5nIHZlYzMgdmVydGV4VkNWU091dHB1dDtcXG5cXG4vLyBmaXJzdCBkZWNsYXJlIHRoZSBzZXR0aW5ncyBmcm9tIHRoZSBtYXBwZXJcXG4vLyB0aGF0IGltcGFjdCB0aGUgY29kZSBwYXRocyBpbiBoZXJlXFxuXFxuLy8gYWx3YXlzIHNldCB2dGtOdW1Db21wb25lbnRzIDEsMiwzLDRcXG4vL1ZUSzo6TnVtQ29tcG9uZW50c1xcblxcbi8vIHBvc3NpYmx5IGRlZmluZSB2dGtVc2VUcmlsaWVhclxcbi8vVlRLOjpUcmlsaW5lYXJPblxcblxcbi8vIHBvc3NpYmx5IGRlZmluZSB2dGtJbmRlcGVuZGVudENvbXBvbmVudHNcXG4vL1ZUSzo6SW5kZXBlbmRlbnRDb21wb25lbnRzT25cXG5cXG4vLyBwb3NzaWJseSBkZWZpbmUgYW55IFxcXCJwcm9wb3J0aW9uYWxcXFwiIGNvbXBvbmVudHNcXG4vL1ZUSzo6dnRrUHJvcG9ydGlvbmFsQ29tcG9uZW50c1xcblxcbi8vIERlZmluZSB0aGUgYmxlbmQgbW9kZSB0byB1c2VcXG4jZGVmaW5lIHZ0a0JsZW5kTW9kZSAvL1ZUSzo6QmxlbmRNb2RlXFxuXFxuLy8gUG9zc2libHkgZGVmaW5lIHZ0a0ltYWdlTGFiZWxPdXRsaW5lT25cXG4vL1ZUSzo6SW1hZ2VMYWJlbE91dGxpbmVPblxcblxcbiNpZmRlZiB2dGtJbWFnZUxhYmVsT3V0bGluZU9uXFxudW5pZm9ybSBpbnQgb3V0bGluZVRoaWNrbmVzcztcXG51bmlmb3JtIGZsb2F0IHZwV2lkdGg7XFxudW5pZm9ybSBmbG9hdCB2cEhlaWdodDtcXG51bmlmb3JtIG1hdDQgUENXQ01hdHJpeDtcXG51bmlmb3JtIG1hdDQgdldDdG9JRFg7XFxuI2VuZGlmXFxuXFxuLy8gZGVmaW5lIHZ0a0xpZ2h0Q29tcGxleGl0eVxcbi8vVlRLOjpMaWdodENvbXBsZXhpdHlcXG4jaWYgdnRrTGlnaHRDb21wbGV4aXR5ID4gMFxcbnVuaWZvcm0gZmxvYXQgdlNwZWN1bGFyUG93ZXI7XFxudW5pZm9ybSBmbG9hdCB2QW1iaWVudDtcXG51bmlmb3JtIGZsb2F0IHZEaWZmdXNlO1xcbnVuaWZvcm0gZmxvYXQgdlNwZWN1bGFyO1xcbi8vVlRLOjpMaWdodDo6RGVjXFxuI2VuZGlmXFxuXFxuLy8gcG9zc2libHkgZGVmaW5lIHZ0a0dyYWRpZW50T3BhY2l0eU9uXFxuLy9WVEs6OkdyYWRpZW50T3BhY2l0eU9uXFxuI2lmZGVmIHZ0a0dyYWRpZW50T3BhY2l0eU9uXFxudW5pZm9ybSBmbG9hdCBnb3NjYWxlMDtcXG51bmlmb3JtIGZsb2F0IGdvc2hpZnQwO1xcbnVuaWZvcm0gZmxvYXQgZ29taW4wO1xcbnVuaWZvcm0gZmxvYXQgZ29tYXgwO1xcbiNpZiBkZWZpbmVkKHZ0a0luZGVwZW5kZW50Q29tcG9uZW50c09uKSAmJiAodnRrTnVtQ29tcG9uZW50cyA+IDEpXFxudW5pZm9ybSBmbG9hdCBnb3NjYWxlMTtcXG51bmlmb3JtIGZsb2F0IGdvc2hpZnQxO1xcbnVuaWZvcm0gZmxvYXQgZ29taW4xO1xcbnVuaWZvcm0gZmxvYXQgZ29tYXgxO1xcbiNpZiB2dGtOdW1Db21wb25lbnRzID49IDNcXG51bmlmb3JtIGZsb2F0IGdvc2NhbGUyO1xcbnVuaWZvcm0gZmxvYXQgZ29zaGlmdDI7XFxudW5pZm9ybSBmbG9hdCBnb21pbjI7XFxudW5pZm9ybSBmbG9hdCBnb21heDI7XFxuI2VuZGlmXFxuI2lmIHZ0a051bUNvbXBvbmVudHMgPj0gNFxcbnVuaWZvcm0gZmxvYXQgZ29zY2FsZTM7XFxudW5pZm9ybSBmbG9hdCBnb3NoaWZ0MztcXG51bmlmb3JtIGZsb2F0IGdvbWluMztcXG51bmlmb3JtIGZsb2F0IGdvbWF4MztcXG4jZW5kaWZcXG4jZW5kaWZcXG4jZW5kaWZcXG5cXG4vLyBpZiB5b3Ugd2FudCB0byBzZWUgdGhlIHJhdyB0aWxlZFxcbi8vIGRhdGEgaW4gd2ViZ2wxIHVuY29tbWVudCB0aGUgZm9sbG93aW5nIGxpbmVcXG4vLyAjZGVmaW5lIGRlYnVndGlsZVxcblxcbi8vIGNhbWVyYSB2YWx1ZXNcXG51bmlmb3JtIGZsb2F0IGNhbVRoaWNrO1xcbnVuaWZvcm0gZmxvYXQgY2FtTmVhcjtcXG51bmlmb3JtIGZsb2F0IGNhbUZhcjtcXG51bmlmb3JtIGludCBjYW1lcmFQYXJhbGxlbDtcXG5cXG4vLyB2YWx1ZXMgZGVzY3JpYmluZyB0aGUgdm9sdW1lIGdlb21ldHJ5XFxudW5pZm9ybSB2ZWMzIHZPcmlnaW5WQztcXG51bmlmb3JtIHZlYzMgdlNwYWNpbmc7XFxudW5pZm9ybSBpdmVjMyB2b2x1bWVEaW1lbnNpb25zOyAvLyAzZCB0ZXh0dXJlIGRpbWVuc2lvbnNcXG51bmlmb3JtIHZlYzMgdlBsYW5lTm9ybWFsMDtcXG51bmlmb3JtIGZsb2F0IHZQbGFuZURpc3RhbmNlMDtcXG51bmlmb3JtIHZlYzMgdlBsYW5lTm9ybWFsMTtcXG51bmlmb3JtIGZsb2F0IHZQbGFuZURpc3RhbmNlMTtcXG51bmlmb3JtIHZlYzMgdlBsYW5lTm9ybWFsMjtcXG51bmlmb3JtIGZsb2F0IHZQbGFuZURpc3RhbmNlMjtcXG51bmlmb3JtIHZlYzMgdlBsYW5lTm9ybWFsMztcXG51bmlmb3JtIGZsb2F0IHZQbGFuZURpc3RhbmNlMztcXG51bmlmb3JtIHZlYzMgdlBsYW5lTm9ybWFsNDtcXG51bmlmb3JtIGZsb2F0IHZQbGFuZURpc3RhbmNlNDtcXG51bmlmb3JtIHZlYzMgdlBsYW5lTm9ybWFsNTtcXG51bmlmb3JtIGZsb2F0IHZQbGFuZURpc3RhbmNlNTtcXG5cXG4vLyBvcGFjaXR5IGFuZCBjb2xvciB0ZXh0dXJlc1xcbnVuaWZvcm0gc2FtcGxlcjJEIG90ZXh0dXJlO1xcbnVuaWZvcm0gZmxvYXQgb3NoaWZ0MDtcXG51bmlmb3JtIGZsb2F0IG9zY2FsZTA7XFxudW5pZm9ybSBzYW1wbGVyMkQgY3RleHR1cmU7XFxudW5pZm9ybSBmbG9hdCBjc2hpZnQwO1xcbnVuaWZvcm0gZmxvYXQgY3NjYWxlMDtcXG5cXG4vLyBqaXR0ZXIgdGV4dHVyZVxcbnVuaWZvcm0gc2FtcGxlcjJEIGp0ZXh0dXJlO1xcblxcbi8vIHNvbWUgM0QgdGV4dHVyZSB2YWx1ZXNcXG51bmlmb3JtIGZsb2F0IHNhbXBsZURpc3RhbmNlO1xcbnVuaWZvcm0gdmVjMyB2VkNUb0lKSztcXG5cXG4vLyB0aGUgaGVpZ2h0cyBkZWZpbmVkIGJlbG93IGFyZSB0aGUgbG9jYXRpb25zXFxuLy8gZm9yIHRoZSB1cCB0byBmb3VyIGNvbXBvbmVudHMgb2YgdGhlIHRmdW5zXFxuLy8gdGhlIHRmdW5zIGhhdmUgYSBoZWlnaHQgb2YgMlhudW1Db21wcyBwaXhlbHMgc28gdGhlXFxuLy8gdmFsdWVzIGFyZSBjb21wdXRlZCB0byBoaXQgdGhlIG1pZGRsZSBvZiB0aGUgdHdvIHJvd3NcXG4vLyBmb3IgdGhhdCBjb21wb25lbnRcXG4jaWZkZWYgdnRrSW5kZXBlbmRlbnRDb21wb25lbnRzT25cXG4jaWYgdnRrTnVtQ29tcG9uZW50cyA9PSAyXFxudW5pZm9ybSBmbG9hdCBtaXgwO1xcbnVuaWZvcm0gZmxvYXQgbWl4MTtcXG4jZGVmaW5lIGhlaWdodDAgMC4yNVxcbiNkZWZpbmUgaGVpZ2h0MSAwLjc1XFxuI2VuZGlmXFxuI2lmIHZ0a051bUNvbXBvbmVudHMgPT0gM1xcbnVuaWZvcm0gZmxvYXQgbWl4MDtcXG51bmlmb3JtIGZsb2F0IG1peDE7XFxudW5pZm9ybSBmbG9hdCBtaXgyO1xcbiNkZWZpbmUgaGVpZ2h0MCAwLjE3XFxuI2RlZmluZSBoZWlnaHQxIDAuNVxcbiNkZWZpbmUgaGVpZ2h0MiAwLjgzXFxuI2VuZGlmXFxuI2lmIHZ0a051bUNvbXBvbmVudHMgPT0gNFxcbnVuaWZvcm0gZmxvYXQgbWl4MDtcXG51bmlmb3JtIGZsb2F0IG1peDE7XFxudW5pZm9ybSBmbG9hdCBtaXgyO1xcbnVuaWZvcm0gZmxvYXQgbWl4MztcXG4jZGVmaW5lIGhlaWdodDAgMC4xMjVcXG4jZGVmaW5lIGhlaWdodDEgMC4zNzVcXG4jZGVmaW5lIGhlaWdodDIgMC42MjVcXG4jZGVmaW5lIGhlaWdodDMgMC44NzVcXG4jZW5kaWZcXG4jZW5kaWZcXG5cXG4jaWYgdnRrTnVtQ29tcG9uZW50cyA+PSAyXFxudW5pZm9ybSBmbG9hdCBvc2hpZnQxO1xcbnVuaWZvcm0gZmxvYXQgb3NjYWxlMTtcXG51bmlmb3JtIGZsb2F0IGNzaGlmdDE7XFxudW5pZm9ybSBmbG9hdCBjc2NhbGUxO1xcbiNlbmRpZlxcbiNpZiB2dGtOdW1Db21wb25lbnRzID49IDNcXG51bmlmb3JtIGZsb2F0IG9zaGlmdDI7XFxudW5pZm9ybSBmbG9hdCBvc2NhbGUyO1xcbnVuaWZvcm0gZmxvYXQgY3NoaWZ0MjtcXG51bmlmb3JtIGZsb2F0IGNzY2FsZTI7XFxuI2VuZGlmXFxuI2lmIHZ0a051bUNvbXBvbmVudHMgPj0gNFxcbnVuaWZvcm0gZmxvYXQgb3NoaWZ0MztcXG51bmlmb3JtIGZsb2F0IG9zY2FsZTM7XFxudW5pZm9ybSBmbG9hdCBjc2hpZnQzO1xcbnVuaWZvcm0gZmxvYXQgY3NjYWxlMztcXG4jZW5kaWZcXG5cXG4vLyBkZWNsYXJhdGlvbiBmb3IgaW50ZXJtaXhlZCBnZW9tZXRyeVxcbi8vVlRLOjpaQnVmZmVyOjpEZWNcXG5cXG4vLyBMaWdodGluZyB2YWx1ZXNcXG4vL1ZUSzo6TGlnaHQ6OkRlY1xcblxcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4vLyBXZWJnbDIgc3BlY2lmaWMgdmVyc2lvbiBvZiBmdW5jdGlvbnNcXG4jaWYgX19WRVJTSU9OX18gPT0gMzAwXFxuXFxudW5pZm9ybSBoaWdocCBzYW1wbGVyM0QgdGV4dHVyZTE7XFxuXFxudmVjNCBnZXRUZXh0dXJlVmFsdWUodmVjMyBwb3MpXFxue1xcbiAgdmVjNCB0bXAgPSB0ZXh0dXJlKHRleHR1cmUxLCBwb3MpO1xcbiNpZiB2dGtOdW1Db21wb25lbnRzID09IDFcXG4gIHRtcC5hID0gdG1wLnI7XFxuI2VuZGlmXFxuI2lmIHZ0a051bUNvbXBvbmVudHMgPT0gMlxcbiAgdG1wLmEgPSB0bXAuZztcXG4jZW5kaWZcXG4jaWYgdnRrTnVtQ29tcG9uZW50cyA9PSAzXFxuICB0bXAuYSA9IGxlbmd0aCh0bXAucmdiKTtcXG4jZW5kaWZcXG4gIHJldHVybiB0bXA7XFxufVxcblxcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXG4vLyBXZWJHTDEgc3BlY2lmaWMgdmVyc2lvbiBvZiBmdW5jdGlvbnNcXG4jZWxzZVxcblxcbnVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmUxO1xcblxcbnVuaWZvcm0gZmxvYXQgdGV4V2lkdGg7XFxudW5pZm9ybSBmbG9hdCB0ZXhIZWlnaHQ7XFxudW5pZm9ybSBpbnQgeHJlcHM7XFxudW5pZm9ybSBpbnQgeHN0cmlkZTtcXG51bmlmb3JtIGludCB5c3RyaWRlO1xcblxcbi8vIGlmIGNvbXB1dGluZyB0cmlsaWVhciB2YWx1ZXMgZnJvbSBtdWx0aXBsZSB6IHNsaWNlc1xcbiNpZmRlZiB2dGtUcmlsaWVhck9uXFxudmVjNCBnZXRUZXh0dXJlVmFsdWUodmVjMyBpamspXFxue1xcbiAgZmxvYXQgem9mZiA9IDEuMC9mbG9hdCh2b2x1bWVEaW1lbnNpb25zLnopO1xcbiAgdmVjNCB2YWwxID0gZ2V0T25lVGV4dHVyZVZhbHVlKGlqayk7XFxuICB2ZWM0IHZhbDIgPSBnZXRPbmVUZXh0dXJlVmFsdWUodmVjMyhpamsueHksIGlqay56ICsgem9mZikpO1xcblxcbiAgZmxvYXQgaW5kZXhaID0gZmxvYXQodm9sdW1lRGltZW5zaW9ucykqaWprLno7XFxuICBmbG9hdCB6bWl4ID0gIGluZGV4WiAtIGZsb29yKGluZGV4Wik7XFxuXFxuICByZXR1cm4gbWl4KHZhbDEsIHZhbDIsIHptaXgpO1xcbn1cXG5cXG52ZWM0IGdldE9uZVRleHR1cmVWYWx1ZSh2ZWMzIGlqaylcXG4jZWxzZSAvLyBuZWFyZXN0IG9yIGZhc3QgbGluZWFyXFxudmVjNCBnZXRUZXh0dXJlVmFsdWUodmVjMyBpamspXFxuI2VuZGlmXFxue1xcbiAgdmVjMyB0ZGltcyA9IHZlYzModm9sdW1lRGltZW5zaW9ucyk7XFxuXFxuI2lmZGVmIGRlYnVndGlsZVxcbiAgdmVjMiB0cG9zID0gdmVjMihpamsueCwgaWprLnkpO1xcbiAgdmVjNCB0bXAgPSB0ZXh0dXJlMkQodGV4dHVyZTEsIHRwb3MpO1xcbiAgdG1wLmEgPSAxLjA7XFxuXFxuI2Vsc2VcXG4gIGludCB6ID0gaW50KGlqay56ICogdGRpbXMueik7XFxuICBpbnQgeXogPSB6IC8geHJlcHM7XFxuICBpbnQgeHogPSB6IC0geXoqeHJlcHM7XFxuXFxuICBpbnQgdGlsZVdpZHRoID0gdm9sdW1lRGltZW5zaW9ucy54L3hzdHJpZGU7XFxuICBpbnQgdGlsZUhlaWdodCA9IHZvbHVtZURpbWVuc2lvbnMueS95c3RyaWRlO1xcblxcbiAgeHogKj0gdGlsZVdpZHRoO1xcbiAgeXogKj0gdGlsZUhlaWdodDtcXG5cXG4gIGZsb2F0IG5pID0gZmxvYXQoeHopICsgKGlqay54KmZsb2F0KHRpbGVXaWR0aCkpO1xcbiAgZmxvYXQgbmogPSBmbG9hdCh5eikgKyAoaWprLnkqZmxvYXQodGlsZUhlaWdodCkpO1xcblxcbiAgdmVjMiB0cG9zID0gdmVjMihuaS90ZXhXaWR0aCwgbmovdGV4SGVpZ2h0KTtcXG5cXG4gIHZlYzQgdG1wID0gdGV4dHVyZTJEKHRleHR1cmUxLCB0cG9zKTtcXG5cXG4jaWYgdnRrTnVtQ29tcG9uZW50cyA9PSAxXFxuICB0bXAuYSA9IHRtcC5yO1xcbiNlbmRpZlxcbiNpZiB2dGtOdW1Db21wb25lbnRzID09IDJcXG4gIHRtcC5nID0gdG1wLmE7XFxuI2VuZGlmXFxuI2lmIHZ0a051bUNvbXBvbmVudHMgPT0gM1xcbiAgdG1wLmEgPSBsZW5ndGgodG1wLnJnYik7XFxuI2VuZGlmXFxuI2VuZGlmXFxuXFxuICByZXR1cm4gdG1wO1xcbn1cXG5cXG4vLyBFbmQgb2YgV2ViZ2wxIHNwZWNpZmljIGNvZGVcXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuI2VuZGlmXFxuXFxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbi8vIGNvbXB1dGUgdGhlIG5vcm1hbCBhbmQgZ3JhZGllbnQgbWFnbml0dWRlIGZvciBhIHBvc2l0aW9uXFxudmVjNCBjb21wdXRlTm9ybWFsKHZlYzMgcG9zLCBmbG9hdCBzY2FsYXIsIHZlYzMgdHN0ZXApXFxue1xcbiAgdmVjNCByZXN1bHQ7XFxuXFxuICByZXN1bHQueCA9IGdldFRleHR1cmVWYWx1ZShwb3MgKyB2ZWMzKHRzdGVwLngsIDAuMCwgMC4wKSkuYSAtIHNjYWxhcjtcXG4gIHJlc3VsdC55ID0gZ2V0VGV4dHVyZVZhbHVlKHBvcyArIHZlYzMoMC4wLCB0c3RlcC55LCAwLjApKS5hIC0gc2NhbGFyO1xcbiAgcmVzdWx0LnogPSBnZXRUZXh0dXJlVmFsdWUocG9zICsgdmVjMygwLjAsIDAuMCwgdHN0ZXAueikpLmEgLSBzY2FsYXI7XFxuXFxuICAvLyBkaXZpZGUgYnkgc3BhY2luZ1xcbiAgcmVzdWx0Lnh5eiAvPSB2U3BhY2luZztcXG5cXG4gIHJlc3VsdC53ID0gbGVuZ3RoKHJlc3VsdC54eXopO1xcblxcbiAgLy8gcm90YXRlIHRvIFZpZXcgQ29vcmRzXFxuICByZXN1bHQueHl6ID1cXG4gICAgcmVzdWx0LnggKiB2UGxhbmVOb3JtYWwwICtcXG4gICAgcmVzdWx0LnkgKiB2UGxhbmVOb3JtYWwyICtcXG4gICAgcmVzdWx0LnogKiB2UGxhbmVOb3JtYWw0O1xcblxcbiAgaWYgKHJlc3VsdC53ID4gMC4wKVxcbiAge1xcbiAgICByZXN1bHQueHl6IC89IHJlc3VsdC53O1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XFxuXFxuI2lmZGVmIHZ0a0ltYWdlTGFiZWxPdXRsaW5lT25cXG52ZWMzIGZyYWdDb29yZFRvSW5kZXhTcGFjZSh2ZWM0IGZyYWdDb29yZCkge1xcbiAgdmVjNCBwY1BvcyA9IHZlYzQoXFxuICAgIChmcmFnQ29vcmQueCAvIHZwV2lkdGggLSAwLjUpICogMi4wLFxcbiAgICAoZnJhZ0Nvb3JkLnkgLyB2cEhlaWdodCAtIDAuNSkgKiAyLjAsXFxuICAgIChmcmFnQ29vcmQueiAtIDAuNSkgKiAyLjAsXFxuICAgIDEuMCk7XFxuXFxuICB2ZWM0IHdvcmxkQ29vcmQgPSBQQ1dDTWF0cml4ICogcGNQb3M7XFxuICB2ZWM0IHZlcnRleCA9ICh3b3JsZENvb3JkL3dvcmxkQ29vcmQudyk7XFxuXFxuICByZXR1cm4gKHZXQ3RvSURYICogdmVydGV4KS54eXogLyB2ZWMzKHZvbHVtZURpbWVuc2lvbnMpO1xcbn1cXG4jZW5kaWZcXG5cXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuLy8gY29tcHV0ZSB0aGUgbm9ybWFscyBhbmQgZ3JhZGllbnQgbWFnbml0dWRlcyBmb3IgYSBwb3NpdGlvblxcbi8vIGZvciBpbmRlcGVuZGVudCBjb21wb25lbnRzXFxubWF0NCBjb21wdXRlTWF0NE5vcm1hbCh2ZWMzIHBvcywgdmVjNCB0VmFsdWUsIHZlYzMgdHN0ZXApXFxue1xcbiAgbWF0NCByZXN1bHQ7XFxuICB2ZWM0IGRpc3RYID0gZ2V0VGV4dHVyZVZhbHVlKHBvcyArIHZlYzModHN0ZXAueCwgMC4wLCAwLjApKSAtIHRWYWx1ZTtcXG4gIHZlYzQgZGlzdFkgPSBnZXRUZXh0dXJlVmFsdWUocG9zICsgdmVjMygwLjAsIHRzdGVwLnksIDAuMCkpIC0gdFZhbHVlO1xcbiAgdmVjNCBkaXN0WiA9IGdldFRleHR1cmVWYWx1ZShwb3MgKyB2ZWMzKDAuMCwgMC4wLCB0c3RlcC56KSkgLSB0VmFsdWU7XFxuXFxuICAvLyBkaXZpZGUgYnkgc3BhY2luZ1xcbiAgZGlzdFggLz0gdlNwYWNpbmcueDtcXG4gIGRpc3RZIC89IHZTcGFjaW5nLnk7XFxuICBkaXN0WiAvPSB2U3BhY2luZy56O1xcblxcbiAgbWF0MyByb3Q7XFxuICByb3RbMF0gPSB2UGxhbmVOb3JtYWwwO1xcbiAgcm90WzFdID0gdlBsYW5lTm9ybWFsMjtcXG4gIHJvdFsyXSA9IHZQbGFuZU5vcm1hbDQ7XFxuXFxuI2lmICFkZWZpbmVkKHZ0a0NvbXBvbmVudDBQcm9wb3J0aW9uYWwpXFxuICByZXN1bHRbMF0ueHl6ID0gdmVjMyhkaXN0WC5yLCBkaXN0WS5yLCBkaXN0Wi5yKTtcXG4gIHJlc3VsdFswXS5hID0gbGVuZ3RoKHJlc3VsdFswXS54eXopO1xcbiAgcmVzdWx0WzBdLnh5eiAqPSByb3Q7XFxuICBpZiAocmVzdWx0WzBdLncgPiAwLjApXFxuICB7XFxuICAgIHJlc3VsdFswXS54eXogLz0gcmVzdWx0WzBdLnc7XFxuICB9XFxuI2VuZGlmXFxuXFxuLy8gb3B0aW9uYWxseSBjb21wdXRlIHRoZSAybmQgY29tcG9uZW50XFxuI2lmIHZ0a051bUNvbXBvbmVudHMgPj0gMiAmJiAhZGVmaW5lZCh2dGtDb21wb25lbnQxUHJvcG9ydGlvbmFsKVxcbiAgcmVzdWx0WzFdLnh5eiA9IHZlYzMoZGlzdFguZywgZGlzdFkuZywgZGlzdFouZyk7XFxuICByZXN1bHRbMV0uYSA9IGxlbmd0aChyZXN1bHRbMV0ueHl6KTtcXG4gIHJlc3VsdFsxXS54eXogKj0gcm90O1xcbiAgaWYgKHJlc3VsdFsxXS53ID4gMC4wKVxcbiAge1xcbiAgICByZXN1bHRbMV0ueHl6IC89IHJlc3VsdFsxXS53O1xcbiAgfVxcbiNlbmRpZlxcblxcbi8vIG9wdGlvbmFsbHkgY29tcHV0ZSB0aGUgM3JkIGNvbXBvbmVudFxcbiNpZiB2dGtOdW1Db21wb25lbnRzID49IDMgJiYgIWRlZmluZWQodnRrQ29tcG9uZW50MlByb3BvcnRpb25hbClcXG4gIHJlc3VsdFsyXS54eXogPSB2ZWMzKGRpc3RYLmIsIGRpc3RZLmIsIGRpc3RaLmIpO1xcbiAgcmVzdWx0WzJdLmEgPSBsZW5ndGgocmVzdWx0WzJdLnh5eik7XFxuICByZXN1bHRbMl0ueHl6ICo9IHJvdDtcXG4gIGlmIChyZXN1bHRbMl0udyA+IDAuMClcXG4gIHtcXG4gICAgcmVzdWx0WzJdLnh5eiAvPSByZXN1bHRbMl0udztcXG4gIH1cXG4jZW5kaWZcXG5cXG4vLyBvcHRpb25hbGx5IGNvbXB1dGUgdGhlIDR0aCBjb21wb25lbnRcXG4jaWYgdnRrTnVtQ29tcG9uZW50cyA+PSA0ICYmICFkZWZpbmVkKHZ0a0NvbXBvbmVudDNQcm9wb3J0aW9uYWwpXFxuICByZXN1bHRbM10ueHl6ID0gdmVjMyhkaXN0WC5hLCBkaXN0WS5hLCBkaXN0Wi5hKTtcXG4gIHJlc3VsdFszXS5hID0gbGVuZ3RoKHJlc3VsdFszXS54eXopO1xcbiAgcmVzdWx0WzNdLnh5eiAqPSByb3Q7XFxuICBpZiAocmVzdWx0WzNdLncgPiAwLjApXFxuICB7XFxuICAgIHJlc3VsdFszXS54eXogLz0gcmVzdWx0WzNdLnc7XFxuICB9XFxuI2VuZGlmXFxuXFxuICByZXR1cm4gcmVzdWx0O1xcbn1cXG5cXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuLy8gR2l2ZW4gYSBub3JtYWwgY29tcHV0ZSB0aGUgZ3JhZGllbnQgb3BhY2l0eSBmYWN0b3JzXFxuLy9cXG5mbG9hdCBjb21wdXRlR3JhZGllbnRPcGFjaXR5RmFjdG9yKFxcbiAgdmVjNCBub3JtYWwsIGZsb2F0IGdvc2NhbGUsIGZsb2F0IGdvc2hpZnQsIGZsb2F0IGdvbWluLCBmbG9hdCBnb21heClcXG57XFxuI2lmIGRlZmluZWQodnRrR3JhZGllbnRPcGFjaXR5T24pXFxuICByZXR1cm4gY2xhbXAobm9ybWFsLmEqZ29zY2FsZSArIGdvc2hpZnQsIGdvbWluLCBnb21heCk7XFxuI2Vsc2VcXG4gIHJldHVybiAxLjA7XFxuI2VuZGlmXFxufVxcblxcbiNpZiB2dGtMaWdodENvbXBsZXhpdHkgPiAwXFxudm9pZCBhcHBseUxpZ2h0aW5nKGlub3V0IHZlYzMgdENvbG9yLCB2ZWM0IG5vcm1hbClcXG57XFxuICB2ZWMzIGRpZmZ1c2UgPSB2ZWMzKDAuMCwgMC4wLCAwLjApO1xcbiAgdmVjMyBzcGVjdWxhciA9IHZlYzMoMC4wLCAwLjAsIDAuMCk7XFxuICAvL1ZUSzo6TGlnaHQ6OkltcGxcXG4gIHRDb2xvci5yZ2IgPSB0Q29sb3IucmdiKihkaWZmdXNlKnZEaWZmdXNlICsgdkFtYmllbnQpICsgc3BlY3VsYXIqdlNwZWN1bGFyO1xcbn1cXG4jZW5kaWZcXG5cXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuLy8gR2l2ZW4gYSB0ZXh0dXJlIHZhbHVlIGNvbXB1dGUgdGhlIGNvbG9yIGFuZCBvcGFjaXR5XFxuLy9cXG52ZWM0IGdldENvbG9yRm9yVmFsdWUodmVjNCB0VmFsdWUsIHZlYzMgcG9zSVMsIHZlYzMgdHN0ZXApXFxue1xcbiNpZmRlZiB2dGtJbWFnZUxhYmVsT3V0bGluZU9uXFxuICB2ZWMzIGNlbnRlclBvc0lTID0gZnJhZ0Nvb3JkVG9JbmRleFNwYWNlKGdsX0ZyYWdDb29yZCk7IC8vIHBvcyBpbiB0ZXh0dXJlIHNwYWNlXFxuICB2ZWM0IGNlbnRlclZhbHVlID0gZ2V0VGV4dHVyZVZhbHVlKGNlbnRlclBvc0lTKTtcXG4gIGJvb2wgcGl4ZWxPbkJvcmRlciA9IGZhbHNlO1xcbiAgdmVjNCB0Q29sb3IgPSB0ZXh0dXJlMkQoY3RleHR1cmUsIHZlYzIoY2VudGVyVmFsdWUuciAqIGNzY2FsZTAgKyBjc2hpZnQwLCAwLjUpKTtcXG5cXG4gIC8vIEdldCBhbHBoYSBvZiBzZWdtZW50IGZyb20gb3BhY2l0eSBmdW5jdGlvbi5cXG4gIHRDb2xvci5hID0gdGV4dHVyZTJEKG90ZXh0dXJlLCB2ZWMyKGNlbnRlclZhbHVlLnIgKiBvc2NhbGUwICsgb3NoaWZ0MCwgMC41KSkucjtcXG5cXG4gIC8vIE9ubHkgcGVyZm9ybSBvdXRsaW5lIGNoZWNrIG9uIGZyYWdtZW50cyByZW5kZXJpbmcgdm94ZWxzIHRoYXQgYXJlbid0IGludmlzaWJsZS5cXG4gIC8vIFNhdmVzIGEgYnVuY2ggb2YgbmVlZGxlc3MgY2hlY2tzIG9uIHRoZSBiYWNrZ3JvdW5kLlxcbiAgLy8gVE9ETyBkZWZpbmUgZXBzaWxvbiB3aGVuIGJ1aWxkaW5nIHNoYWRlcj9cXG4gIGlmIChmbG9hdCh0Q29sb3IuYSkgPiAwLjAxKSB7XFxuICAgIGZvciAoaW50IGkgPSAtb3V0bGluZVRoaWNrbmVzczsgaSA8PSBvdXRsaW5lVGhpY2tuZXNzOyBpKyspIHtcXG4gICAgICBmb3IgKGludCBqID0gLW91dGxpbmVUaGlja25lc3M7IGogPD0gb3V0bGluZVRoaWNrbmVzczsgaisrKSB7XFxuICAgICAgICBpZiAoaSA9PSAwIHx8IGogPT0gMCkge1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZlYzQgbmVpZ2hib3JQaXhlbENvb3JkID0gdmVjNChnbF9GcmFnQ29vcmQueCArIGZsb2F0KGkpLFxcbiAgICAgICAgICBnbF9GcmFnQ29vcmQueSArIGZsb2F0KGopLFxcbiAgICAgICAgICBnbF9GcmFnQ29vcmQueiwgZ2xfRnJhZ0Nvb3JkLncpO1xcblxcbiAgICAgICAgdmVjMyBuZWlnaGJvclBvc0lTID0gZnJhZ0Nvb3JkVG9JbmRleFNwYWNlKG5laWdoYm9yUGl4ZWxDb29yZCk7XFxuICAgICAgICB2ZWM0IHZhbHVlID0gZ2V0VGV4dHVyZVZhbHVlKG5laWdoYm9yUG9zSVMpO1xcblxcbiAgICAgICAgLy8gSWYgYW55IG9mIG15IG5laWdoYm91cnMgYXJlIG5vdCB0aGUgc2FtZSB2YWx1ZSBhcyBJXFxuICAgICAgICAvLyBhbSwgdGhpcyBtZWFucyBJIGFtIG9uIHRoZSBib3JkZXIgb2YgdGhlIHNlZ21lbnQuXFxuICAgICAgICAvLyBXZSBjYW4gYnJlYWsgdGhlIGxvb3BzXFxuICAgICAgICBpZiAoYW55KG5vdEVxdWFsKHZhbHVlLCBjZW50ZXJWYWx1ZSkpKSB7XFxuICAgICAgICAgIHBpeGVsT25Cb3JkZXIgPSB0cnVlO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHBpeGVsT25Cb3JkZXIgPT0gdHJ1ZSkge1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIElmIEkgYW0gb24gdGhlIGJvcmRlciwgSSBhbSBkaXNwbGF5ZWQgYXQgZnVsbCBvcGFjaXR5XFxuICAgIGlmIChwaXhlbE9uQm9yZGVyID09IHRydWUpIHtcXG4gICAgICB0Q29sb3IuYSA9IDEuMDtcXG4gICAgfVxcbiAgfVxcblxcbiNlbHNlXFxuICAvLyBjb21wdXRlIHRoZSBub3JtYWwgYW5kIGdyYWRpZW50IG1hZ25pdHVkZSBpZiBuZWVkZWRcXG4gIC8vIFdlIGNvbXB1dGUgaXQgYXMgYSB2ZWM0IGlmIHBvc3NpYmxlIG90aGVyd2lzZSBhIG1hdDRcXG4gIC8vXFxuICB2ZWM0IGdvRmFjdG9yID0gdmVjNCgxLjAsMS4wLDEuMCwxLjApO1xcblxcbiAgLy8gY29tcHV0ZSB0aGUgbm9ybWFsIHZlY3RvcnMgYXMgbmVlZGVkXFxuICAjaWYgKHZ0a0xpZ2h0Q29tcGxleGl0eSA+IDApIHx8IGRlZmluZWQodnRrR3JhZGllbnRPcGFjaXR5T24pXFxuICAgICNpZiBkZWZpbmVkKHZ0a0luZGVwZW5kZW50Q29tcG9uZW50c09uKSAmJiAodnRrTnVtQ29tcG9uZW50cyA+IDEpXFxuICAgICAgbWF0NCBub3JtYWxNYXQgPSBjb21wdXRlTWF0NE5vcm1hbChwb3NJUywgdFZhbHVlLCB0c3RlcCk7XFxuICAgICAgI2lmICFkZWZpbmVkKHZ0a0NvbXBvbmVudDBQcm9wb3J0aW9uYWwpXFxuICAgICAgICB2ZWM0IG5vcm1hbDAgPSBub3JtYWxNYXRbMF07XFxuICAgICAgI2VuZGlmXFxuICAgICAgI2lmICFkZWZpbmVkKHZ0a0NvbXBvbmVudDFQcm9wb3J0aW9uYWwpXFxuICAgICAgICB2ZWM0IG5vcm1hbDEgPSBub3JtYWxNYXRbMV07XFxuICAgICAgI2VuZGlmXFxuICAgICAgI2lmIHZ0a051bUNvbXBvbmVudHMgPiAyXFxuICAgICAgICAjaWYgIWRlZmluZWQodnRrQ29tcG9uZW50MlByb3BvcnRpb25hbClcXG4gICAgICAgICAgdmVjNCBub3JtYWwyID0gbm9ybWFsTWF0WzJdO1xcbiAgICAgICAgI2VuZGlmXFxuICAgICAgICAjaWYgdnRrTnVtQ29tcG9uZW50cyA+IDNcXG4gICAgICAgICAgI2lmICFkZWZpbmVkKHZ0a0NvbXBvbmVudDNQcm9wb3J0aW9uYWwpXFxuICAgICAgICAgICAgdmVjNCBub3JtYWwzID0gbm9ybWFsTWF0WzNdO1xcbiAgICAgICAgICAjZW5kaWZcXG4gICAgICAgICNlbmRpZlxcbiAgICAgICNlbmRpZlxcbiAgICAjZWxzZVxcbiAgICAgIHZlYzQgbm9ybWFsMCA9IGNvbXB1dGVOb3JtYWwocG9zSVMsIHRWYWx1ZS5hLCB0c3RlcCk7XFxuICAgICNlbmRpZlxcbiAgI2VuZGlmXFxuXFxuICAvLyBjb21wdXRlIGdyYWRpZW50IG9wYWNpdHkgZmFjdG9ycyBhcyBuZWVkZWRcXG4gICNpZiBkZWZpbmVkKHZ0a0dyYWRpZW50T3BhY2l0eU9uKVxcbiAgICAjaWYgIWRlZmluZWQodnRrQ29tcG9uZW50MFByb3BvcnRpb25hbClcXG4gICAgICBnb0ZhY3Rvci54ID1cXG4gICAgICAgIGNvbXB1dGVHcmFkaWVudE9wYWNpdHlGYWN0b3Iobm9ybWFsMCwgZ29zY2FsZTAsIGdvc2hpZnQwLCBnb21pbjAsIGdvbWF4MCk7XFxuICAgICNlbmRpZlxcbiAgICAjaWYgZGVmaW5lZCh2dGtJbmRlcGVuZGVudENvbXBvbmVudHNPbikgJiYgKHZ0a051bUNvbXBvbmVudHMgPiAxKVxcbiAgICAgICNpZiAhZGVmaW5lZCh2dGtDb21wb25lbnQxUHJvcG9ydGlvbmFsKVxcbiAgICAgICAgZ29GYWN0b3IueSA9XFxuICAgICAgICAgIGNvbXB1dGVHcmFkaWVudE9wYWNpdHlGYWN0b3Iobm9ybWFsMSwgZ29zY2FsZTEsIGdvc2hpZnQxLCBnb21pbjEsIGdvbWF4MSk7XFxuICAgICAgI2VuZGlmXFxuICAgICAgI2lmIHZ0a051bUNvbXBvbmVudHMgPiAyXFxuICAgICAgICAjaWYgIWRlZmluZWQodnRrQ29tcG9uZW50MlByb3BvcnRpb25hbClcXG4gICAgICAgICAgZ29GYWN0b3IueiA9XFxuICAgICAgICAgICAgY29tcHV0ZUdyYWRpZW50T3BhY2l0eUZhY3Rvcihub3JtYWwyLCBnb3NjYWxlMiwgZ29zaGlmdDIsIGdvbWluMiwgZ29tYXgyKTtcXG4gICAgICAgICNlbmRpZlxcbiAgICAgICAgI2lmIHZ0a051bUNvbXBvbmVudHMgPiAzXFxuICAgICAgICAgICNpZiAhZGVmaW5lZCh2dGtDb21wb25lbnQzUHJvcG9ydGlvbmFsKVxcbiAgICAgICAgICAgIGdvRmFjdG9yLncgPVxcbiAgICAgICAgICAgICAgY29tcHV0ZUdyYWRpZW50T3BhY2l0eUZhY3Rvcihub3JtYWwzLCBnb3NjYWxlMywgZ29zaGlmdDMsIGdvbWluMywgZ29tYXgzKTtcXG4gICAgICAgICAgI2VuZGlmXFxuICAgICAgICAjZW5kaWZcXG4gICAgICAjZW5kaWZcXG4gICAgI2VuZGlmXFxuICAjZW5kaWZcXG5cXG4gIC8vIHNpbmdsZSBjb21wb25lbnQgaXMgYWx3YXlzIGluZGVwZW5kZW50XFxuICAjaWYgdnRrTnVtQ29tcG9uZW50cyA9PSAxXFxuICAgIHZlYzQgdENvbG9yID0gdGV4dHVyZTJEKGN0ZXh0dXJlLCB2ZWMyKHRWYWx1ZS5yICogY3NjYWxlMCArIGNzaGlmdDAsIDAuNSkpO1xcbiAgICB0Q29sb3IuYSA9IGdvRmFjdG9yLngqdGV4dHVyZTJEKG90ZXh0dXJlLCB2ZWMyKHRWYWx1ZS5yICogb3NjYWxlMCArIG9zaGlmdDAsIDAuNSkpLnI7XFxuICAjZW5kaWZcXG5cXG4gICNpZiBkZWZpbmVkKHZ0a0luZGVwZW5kZW50Q29tcG9uZW50c09uKSAmJiB2dGtOdW1Db21wb25lbnRzID49IDJcXG4gICAgdmVjNCB0Q29sb3IgPSBtaXgwKnRleHR1cmUyRChjdGV4dHVyZSwgdmVjMih0VmFsdWUuciAqIGNzY2FsZTAgKyBjc2hpZnQwLCBoZWlnaHQwKSk7XFxuICAgICNpZiAhZGVmaW5lZCh2dGtDb21wb25lbnQwUHJvcG9ydGlvbmFsKVxcbiAgICAgIHRDb2xvci5hID0gZ29GYWN0b3IueCptaXgwKnRleHR1cmUyRChvdGV4dHVyZSwgdmVjMih0VmFsdWUuciAqIG9zY2FsZTAgKyBvc2hpZnQwLCBoZWlnaHQwKSkucjtcXG4gICAgI2Vsc2VcXG4gICAgICBmbG9hdCBwd2ZWYWx1ZSA9IHRleHR1cmUyRChvdGV4dHVyZSwgdmVjMih0VmFsdWUuciAqIG9zY2FsZTAgKyBvc2hpZnQwLCBoZWlnaHQwKSkucjtcXG4gICAgICB0Q29sb3IgKj0gcHdmVmFsdWU7XFxuICAgICAgdENvbG9yLmEgKj0gbWl4KHB3ZlZhbHVlLCAxLjAsICgxLjAgLSBtaXgwKSk7XFxuICAgICNlbmRpZlxcblxcbiAgICB2ZWMzIHRDb2xvcjEgPSBtaXgxKnRleHR1cmUyRChjdGV4dHVyZSwgdmVjMih0VmFsdWUuZyAqIGNzY2FsZTEgKyBjc2hpZnQxLCBoZWlnaHQxKSkucmdiO1xcbiAgICAjaWYgIWRlZmluZWQodnRrQ29tcG9uZW50MVByb3BvcnRpb25hbClcXG4gICAgICB0Q29sb3IuYSArPSBnb0ZhY3Rvci55Km1peDEqdGV4dHVyZTJEKG90ZXh0dXJlLCB2ZWMyKHRWYWx1ZS5nICogb3NjYWxlMSArIG9zaGlmdDEsIGhlaWdodDEpKS5yO1xcbiAgICAjZWxzZVxcbiAgICAgIGZsb2F0IHB3ZlZhbHVlID0gdGV4dHVyZTJEKG90ZXh0dXJlLCB2ZWMyKHRWYWx1ZS5nICogb3NjYWxlMSArIG9zaGlmdDEsIGhlaWdodDEpKS5yO1xcbiAgICAgIHRDb2xvcjEgKj0gcHdmVmFsdWU7XFxuICAgICAgdENvbG9yLmEgKj0gbWl4KHB3ZlZhbHVlLCAxLjAsICgxLjAgLSBtaXgxKSk7XFxuICAgICNlbmRpZlxcblxcbiAgICAjaWYgdnRrTnVtQ29tcG9uZW50cyA+PSAzXFxuICAgICAgdmVjMyB0Q29sb3IyID0gbWl4Mip0ZXh0dXJlMkQoY3RleHR1cmUsIHZlYzIodFZhbHVlLmIgKiBjc2NhbGUyICsgY3NoaWZ0MiwgaGVpZ2h0MikpLnJnYjtcXG4gICAgICAjaWYgIWRlZmluZWQodnRrQ29tcG9uZW50MlByb3BvcnRpb25hbClcXG4gICAgICAgIHRDb2xvci5hICs9IGdvRmFjdG9yLnoqbWl4Mip0ZXh0dXJlMkQob3RleHR1cmUsIHZlYzIodFZhbHVlLmIgKiBvc2NhbGUyICsgb3NoaWZ0MiwgaGVpZ2h0MikpLnI7XFxuICAgICAgI2Vsc2VcXG4gICAgICAgIGZsb2F0IHB3ZlZhbHVlID0gdGV4dHVyZTJEKG90ZXh0dXJlLCB2ZWMyKHRWYWx1ZS5iICogb3NjYWxlMiArIG9zaGlmdDIsIGhlaWdodDIpKS5yO1xcbiAgICAgICAgdENvbG9yMiAqPSBwd2ZWYWx1ZTtcXG4gICAgICAgIHRDb2xvci5hICo9IG1peChwd2ZWYWx1ZSwgMS4wLCAoMS4wIC0gbWl4MikpO1xcbiAgICAgICNlbmRpZlxcblxcbiAgICAgICNpZiB2dGtOdW1Db21wb25lbnRzID49IDRcXG4gICAgICAgIHZlYzMgdENvbG9yMyA9IG1peDMqdGV4dHVyZTJEKGN0ZXh0dXJlLCB2ZWMyKHRWYWx1ZS5hICogY3NjYWxlMyArIGNzaGlmdDMsIGhlaWdodDMpKS5yZ2I7XFxuICAgICAgICAjaWYgIWRlZmluZWQodnRrQ29tcG9uZW50M1Byb3BvcnRpb25hbClcXG4gICAgICAgICAgdENvbG9yLmEgKz0gZ29GYWN0b3IudyptaXgzKnRleHR1cmUyRChvdGV4dHVyZSwgdmVjMih0VmFsdWUuYSAqIG9zY2FsZTMgKyBvc2hpZnQzLCBoZWlnaHQzKSkucjtcXG4gICAgICAgICNlbHNlXFxuICAgICAgICAgIGZsb2F0IHB3ZlZhbHVlID0gdGV4dHVyZTJEKG90ZXh0dXJlLCB2ZWMyKHRWYWx1ZS5hICogb3NjYWxlMyArIG9zaGlmdDMsIGhlaWdodDMpKS5yO1xcbiAgICAgICAgICB0Q29sb3IzICo9IHB3ZlZhbHVlO1xcbiAgICAgICAgICB0Q29sb3IuYSAqPSBtaXgocHdmVmFsdWUsIDEuMCwgKDEuMCAtIG1peDMpKTtcXG4gICAgICAgICNlbmRpZlxcbiAgICAgICNlbmRpZlxcbiAgICAjZW5kaWZcXG4gICNlbHNlIC8vIHRoZW4gbm90IGluZGVwZW5kZW50XFxuXFxuICAjaWYgdnRrTnVtQ29tcG9uZW50cyA9PSAyXFxuICAgIGZsb2F0IGx1bSA9IHRWYWx1ZS5yICogY3NjYWxlMCArIGNzaGlmdDA7XFxuICAgIGZsb2F0IGFscGhhID0gZ29GYWN0b3IueCp0ZXh0dXJlMkQob3RleHR1cmUsIHZlYzIodFZhbHVlLmEgKiBvc2NhbGUxICsgb3NoaWZ0MSwgMC41KSkucjtcXG4gICAgdmVjNCB0Q29sb3IgPSB2ZWM0KGx1bSwgbHVtLCBsdW0sIGFscGhhKTtcXG4gICNlbmRpZlxcbiAgI2lmIHZ0a051bUNvbXBvbmVudHMgPT0gM1xcbiAgICB2ZWM0IHRDb2xvcjtcXG4gICAgdENvbG9yLnIgPSB0VmFsdWUuciAqIGNzY2FsZTAgKyBjc2hpZnQwO1xcbiAgICB0Q29sb3IuZyA9IHRWYWx1ZS5nICogY3NjYWxlMSArIGNzaGlmdDE7XFxuICAgIHRDb2xvci5iID0gdFZhbHVlLmIgKiBjc2NhbGUyICsgY3NoaWZ0MjtcXG4gICAgdENvbG9yLmEgPSBnb0ZhY3Rvci54KnRleHR1cmUyRChvdGV4dHVyZSwgdmVjMih0VmFsdWUuYSAqIG9zY2FsZTAgKyBvc2hpZnQwLCAwLjUpKS5yO1xcbiAgI2VuZGlmXFxuICAjaWYgdnRrTnVtQ29tcG9uZW50cyA9PSA0XFxuICAgIHZlYzQgdENvbG9yO1xcbiAgICB0Q29sb3IuciA9IHRWYWx1ZS5yICogY3NjYWxlMCArIGNzaGlmdDA7XFxuICAgIHRDb2xvci5nID0gdFZhbHVlLmcgKiBjc2NhbGUxICsgY3NoaWZ0MTtcXG4gICAgdENvbG9yLmIgPSB0VmFsdWUuYiAqIGNzY2FsZTIgKyBjc2hpZnQyO1xcbiAgICB0Q29sb3IuYSA9IGdvRmFjdG9yLngqdGV4dHVyZTJEKG90ZXh0dXJlLCB2ZWMyKHRWYWx1ZS5hICogb3NjYWxlMyArIG9zaGlmdDMsIDAuNSkpLnI7XFxuICAjZW5kaWZcXG4gICNlbmRpZiAvLyBkZXBlbmRlbnRcXG5cXG4gIC8vIGFwcGx5IGxpZ2h0aW5nIGlmIHJlcXVlc3RlZCBhcyBhcHByb3ByaWF0ZVxcbiAgI2lmIHZ0a0xpZ2h0Q29tcGxleGl0eSA+IDBcXG4gICAgI2lmICFkZWZpbmVkKHZ0a0NvbXBvbmVudDBQcm9wb3J0aW9uYWwpXFxuICAgICAgYXBwbHlMaWdodGluZyh0Q29sb3IucmdiLCBub3JtYWwwKTtcXG4gICAgI2VuZGlmXFxuICAjaWYgZGVmaW5lZCh2dGtJbmRlcGVuZGVudENvbXBvbmVudHNPbikgJiYgdnRrTnVtQ29tcG9uZW50cyA+PSAyXFxuICAgICNpZiAhZGVmaW5lZCh2dGtDb21wb25lbnQxUHJvcG9ydGlvbmFsKVxcbiAgICAgIGFwcGx5TGlnaHRpbmcodENvbG9yMSwgbm9ybWFsMSk7XFxuICAgICNlbmRpZlxcbiAgI2lmIHZ0a051bUNvbXBvbmVudHMgPj0gM1xcbiAgICAjaWYgIWRlZmluZWQodnRrQ29tcG9uZW50MlByb3BvcnRpb25hbClcXG4gICAgICBhcHBseUxpZ2h0aW5nKHRDb2xvcjIsIG5vcm1hbDIpO1xcbiAgICAjZW5kaWZcXG4gICNpZiB2dGtOdW1Db21wb25lbnRzID49IDRcXG4gICAgI2lmICFkZWZpbmVkKHZ0a0NvbXBvbmVudDNQcm9wb3J0aW9uYWwpXFxuICAgICAgYXBwbHlMaWdodGluZyh0Q29sb3IzLCBub3JtYWwzKTtcXG4gICAgI2VuZGlmXFxuICAjZW5kaWZcXG4gICNlbmRpZlxcbiAgI2VuZGlmXFxuI2VuZGlmXFxuXFxuLy8gcGVyZm9ybSBmaW5hbCBpbmRlcGVuZGVudCBibGVuZCBhcyBuZWVkZWRcXG4jaWYgZGVmaW5lZCh2dGtJbmRlcGVuZGVudENvbXBvbmVudHNPbikgJiYgdnRrTnVtQ29tcG9uZW50cyA+PSAyXFxuICB0Q29sb3IucmdiICs9IHRDb2xvcjE7XFxuI2lmIHZ0a051bUNvbXBvbmVudHMgPj0gM1xcbiAgdENvbG9yLnJnYiArPSB0Q29sb3IyO1xcbiNpZiB2dGtOdW1Db21wb25lbnRzID49IDRcXG4gIHRDb2xvci5yZ2IgKz0gdENvbG9yMztcXG4jZW5kaWZcXG4jZW5kaWZcXG4jZW5kaWZcXG5cXG4jZW5kaWZcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5yZXR1cm4gdENvbG9yO1xcbn1cXG5cXG5cXG5cXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuLy8gQXBwbHkgdGhlIHNwZWNpZmllZCBibGVuZCBtb2RlIG9wZXJhdGlvbiBhbG9uZyB0aGUgcmF5J3MgcGF0aC5cXG4vL1xcbnZvaWQgYXBwbHlCbGVuZCh2ZWMzIHBvc0lTLCB2ZWMzIGVuZElTLCBmbG9hdCBzYW1wbGVEaXN0YW5jZUlTLCB2ZWMzIHRkaW1zKVxcbntcXG4gIHZlYzMgdHN0ZXAgPSAxLjAvdGRpbXM7XFxuXFxuICAvLyBzdGFydCBzbGlnaHRseSBpbnNpZGUgYW5kIGFwcGx5IHNvbWUgaml0dGVyXFxuICB2ZWMzIGRlbHRhID0gZW5kSVMgLSBwb3NJUztcXG4gIHZlYzMgc3RlcElTID0gbm9ybWFsaXplKGRlbHRhKSpzYW1wbGVEaXN0YW5jZUlTO1xcbiAgZmxvYXQgcmF5U3RlcHMgPSBsZW5ndGgoZGVsdGEpL3NhbXBsZURpc3RhbmNlSVM7XFxuXFxuICAvLyBhdm9pZCAwLjAgaml0dGVyXFxuICBmbG9hdCBqaXR0ZXIgPSAwLjAxICsgMC45OSp0ZXh0dXJlMkQoanRleHR1cmUsIGdsX0ZyYWdDb29yZC54eS8zMi4wKS5yO1xcbiAgZmxvYXQgc3RlcHNUcmF2ZWxlZCA9IGppdHRlcjtcXG5cXG4gIC8vIGxvY2FsIHZhcnMgZm9yIHRoZSBsb29wXFxuICB2ZWM0IGNvbG9yID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcbiAgdmVjNCB0VmFsdWU7XFxuICB2ZWM0IHRDb2xvcjtcXG5cXG4gIC8vIGlmIHdlIGhhdmUgbGVzcyB0aGFuIG9uZSBzdGVwIHRoZW4gcGljayB0aGUgbWlkZGxlIHBvaW50XFxuICAvLyBhcyBvdXIgdmFsdWVcXG4gIC8vIGlmIChyYXlTdGVwcyA8PSAxLjApXFxuICAvLyB7XFxuICAvLyAgIHBvc0lTID0gKHBvc0lTICsgZW5kSVMpKjAuNTtcXG4gIC8vIH1cXG5cXG4gIC8vIFBlcmZvcm0gaW5pdGlhbCBzdGVwIGF0IHRoZSB2b2x1bWUgYm91bmRhcnlcXG4gIC8vIGNvbXB1dGUgdGhlIHNjYWxhclxcbiAgdFZhbHVlID0gZ2V0VGV4dHVyZVZhbHVlKHBvc0lTKTtcXG5cXG4gICNpZiB2dGtCbGVuZE1vZGUgPT0gMCAvLyBDT01QT1NJVEVfQkxFTkRcXG4gICAgLy8gbm93IG1hcCB0aHJvdWdoIG9wYWNpdHkgYW5kIGNvbG9yXFxuICAgIHRDb2xvciA9IGdldENvbG9yRm9yVmFsdWUodFZhbHVlLCBwb3NJUywgdHN0ZXApO1xcblxcbiAgICAvLyBoYW5kbGUgdmVyeSB0aGluIHZvbHVtZXNcXG4gICAgaWYgKHJheVN0ZXBzIDw9IDEuMClcXG4gICAge1xcbiAgICAgIHRDb2xvci5hID0gMS4wIC0gcG93KDEuMCAtIHRDb2xvci5hLCByYXlTdGVwcyk7XFxuICAgICAgZ2xfRnJhZ0RhdGFbMF0gPSB0Q29sb3I7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRDb2xvci5hID0gMS4wIC0gcG93KDEuMCAtIHRDb2xvci5hLCBqaXR0ZXIpO1xcbiAgICBjb2xvciA9IHZlYzQodENvbG9yLnJnYip0Q29sb3IuYSwgdENvbG9yLmEpO1xcbiAgICBwb3NJUyArPSAoaml0dGVyKnN0ZXBJUyk7XFxuXFxuICAgIGZvciAoaW50IGkgPSAwOyBpIDwgLy9WVEs6Ok1heGltdW1TYW1wbGVzVmFsdWUgOyArK2kpXFxuICAgIHtcXG4gICAgICBpZiAoc3RlcHNUcmF2ZWxlZCArIDEuMCA+PSByYXlTdGVwcykgeyBicmVhazsgfVxcblxcbiAgICAgIC8vIGNvbXB1dGUgdGhlIHNjYWxhclxcbiAgICAgIHRWYWx1ZSA9IGdldFRleHR1cmVWYWx1ZShwb3NJUyk7XFxuXFxuICAgICAgLy8gbm93IG1hcCB0aHJvdWdoIG9wYWNpdHkgYW5kIGNvbG9yXFxuICAgICAgdENvbG9yID0gZ2V0Q29sb3JGb3JWYWx1ZSh0VmFsdWUsIHBvc0lTLCB0c3RlcCk7XFxuXFxuICAgICAgZmxvYXQgbWl4ID0gKDEuMCAtIGNvbG9yLmEpO1xcblxcbiAgICAgIC8vIHRoaXMgbGluZSBzaG91bGQgbm90IGJlIG5lZWRlZCBidXQgbnZpZGlhIHNlZW1zIHRvIG5vdCBoYW5kbGVcXG4gICAgICAvLyB0aGUgYnJlYWsgY29ycmVjdGx5IG9uIHdpbmRvd3MvY2hyb21lIDU4IGFuZ2xlXFxuICAgICAgLy9taXggPSBtaXggKiBzaWduKG1heChyYXlTdGVwcyAtIHN0ZXBzVHJhdmVsZWQgLSAxLjAsIDAuMCkpO1xcblxcbiAgICAgIGNvbG9yID0gY29sb3IgKyB2ZWM0KHRDb2xvci5yZ2IqdENvbG9yLmEsIHRDb2xvci5hKSptaXg7XFxuICAgICAgc3RlcHNUcmF2ZWxlZCsrO1xcbiAgICAgIHBvc0lTICs9IHN0ZXBJUztcXG4gICAgICBpZiAoY29sb3IuYSA+IDAuOTkpIHsgY29sb3IuYSA9IDEuMDsgYnJlYWs7IH1cXG4gICAgfVxcblxcbiAgICBpZiAoY29sb3IuYSA8IDAuOTkgJiYgKHJheVN0ZXBzIC0gc3RlcHNUcmF2ZWxlZCkgPiAwLjApXFxuICAgIHtcXG4gICAgICBwb3NJUyA9IGVuZElTO1xcblxcbiAgICAgIC8vIGNvbXB1dGUgdGhlIHNjYWxhclxcbiAgICAgIHRWYWx1ZSA9IGdldFRleHR1cmVWYWx1ZShwb3NJUyk7XFxuXFxuICAgICAgLy8gbm93IG1hcCB0aHJvdWdoIG9wYWNpdHkgYW5kIGNvbG9yXFxuICAgICAgdENvbG9yID0gZ2V0Q29sb3JGb3JWYWx1ZSh0VmFsdWUsIHBvc0lTLCB0c3RlcCk7XFxuICAgICAgdENvbG9yLmEgPSAxLjAgLSBwb3coMS4wIC0gdENvbG9yLmEsIHJheVN0ZXBzIC0gc3RlcHNUcmF2ZWxlZCk7XFxuXFxuICAgICAgZmxvYXQgbWl4ID0gKDEuMCAtIGNvbG9yLmEpO1xcbiAgICAgIGNvbG9yID0gY29sb3IgKyB2ZWM0KHRDb2xvci5yZ2IqdENvbG9yLmEsIHRDb2xvci5hKSptaXg7XFxuICAgIH1cXG5cXG4gICAgZ2xfRnJhZ0RhdGFbMF0gPSB2ZWM0KGNvbG9yLnJnYi9jb2xvci5hLCBjb2xvci5hKTtcXG4gICNlbmRpZlxcbiAgI2lmIHZ0a0JsZW5kTW9kZSA9PSAxIHx8IHZ0a0JsZW5kTW9kZSA9PSAyXFxuICAgIC8vIE1BWElNVU1fSU5URU5TSVRZX0JMRU5EIHx8IE1JTklNVU1fSU5URU5TSVRZX0JMRU5EXFxuICAgIC8vIEZpbmQgbWF4aW11bS9taW5pbXVtIGludGVuc2l0eSBhbG9uZyB0aGUgcmF5LlxcblxcbiAgICAvLyBEZWZpbmUgdGhlIG9wZXJhdGlvbiB3ZSB3aWxsIHVzZSAobWluIG9yIG1heClcXG4gICAgI2lmIHZ0a0JsZW5kTW9kZSA9PSAxXFxuICAgICNkZWZpbmUgT1AgbWF4XFxuICAgICNlbHNlXFxuICAgICNkZWZpbmUgT1AgbWluXFxuICAgICNlbmRpZlxcblxcbiAgICAvLyBJZiB0aGUgY2xpcHBpbmcgcmFuZ2UgaXMgc2hvcnRlciB0aGFuIHRoZSBzYW1wbGUgZGlzdGFuY2VcXG4gICAgLy8gd2UgY2FuIHNraXAgdGhlIHNhbXBsaW5nIGxvb3AgYWxvbmcgdGhlIHJheS5cXG4gICAgaWYgKHJheVN0ZXBzIDw9IDEuMClcXG4gICAge1xcbiAgICAgIGdsX0ZyYWdEYXRhWzBdID0gZ2V0Q29sb3JGb3JWYWx1ZSh0VmFsdWUsIHBvc0lTLCB0c3RlcCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZlYzQgdmFsdWUgPSB0VmFsdWU7XFxuICAgIHBvc0lTICs9IChqaXR0ZXIqc3RlcElTKTtcXG5cXG4gICAgLy8gU2FtcGxlIGFsb25nIHRoZSByYXkgdW50aWwgTWF4aW11bVNhbXBsZXNWYWx1ZSxcXG4gICAgLy8gZW5kaW5nIHNsaWdodGx5IGluc2lkZSB0aGUgdG90YWwgZGlzdGFuY2VcXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCAvL1ZUSzo6TWF4aW11bVNhbXBsZXNWYWx1ZSA7ICsraSlcXG4gICAge1xcbiAgICAgIC8vIElmIHdlIGhhdmUgcmVhY2hlZCB0aGUgbGFzdCBzdGVwLCBicmVha1xcbiAgICAgIGlmIChzdGVwc1RyYXZlbGVkICsgMS4wID49IHJheVN0ZXBzKSB7IGJyZWFrOyB9XFxuXFxuICAgICAgLy8gY29tcHV0ZSB0aGUgc2NhbGFyXFxuICAgICAgdFZhbHVlID0gZ2V0VGV4dHVyZVZhbHVlKHBvc0lTKTtcXG5cXG4gICAgICAvLyBVcGRhdGUgdGhlIG1heGltdW0gdmFsdWUgaWYgbmVjZXNzYXJ5XFxuICAgICAgdmFsdWUgPSBPUCh0VmFsdWUsIHZhbHVlKTtcXG5cXG4gICAgICAvLyBPdGhlcndpc2UsIGNvbnRpbnVlIGFsb25nIHRoZSByYXlcXG4gICAgICBzdGVwc1RyYXZlbGVkKys7XFxuICAgICAgcG9zSVMgKz0gc3RlcElTO1xcbiAgICB9XFxuXFxuICAgIC8vIFBlcmZvcm0gdGhlIGxhc3Qgc3RlcCBhbG9uZyB0aGUgcmF5IHVzaW5nIHRoZVxcbiAgICAvLyByZXNpZHVhbCBkaXN0YW5jZVxcbiAgICBwb3NJUyA9IGVuZElTO1xcbiAgICB0VmFsdWUgPSBnZXRUZXh0dXJlVmFsdWUocG9zSVMpO1xcbiAgICB2YWx1ZSA9IE9QKHRWYWx1ZSwgdmFsdWUpO1xcblxcbiAgICAvLyBOb3cgbWFwIHRocm91Z2ggb3BhY2l0eSBhbmQgY29sb3JcXG4gICAgZ2xfRnJhZ0RhdGFbMF0gPSBnZXRDb2xvckZvclZhbHVlKHZhbHVlLCBwb3NJUywgdHN0ZXApO1xcbiAgI2VuZGlmXFxuICAjaWYgdnRrQmxlbmRNb2RlID09IDMgLy9BVkVSQUdFX0lOVEVOU0lUWV9CTEVORFxcbiAgICB2ZWM0IGF2ZXJhZ2VJUFNjYWxhclJhbmdlTWluID0gdmVjNCAoXFxuICAgICAgLy9WVEs6OkF2ZXJhZ2VJUFNjYWxhclJhbmdlTWluLFxcbiAgICAgIC8vVlRLOjpBdmVyYWdlSVBTY2FsYXJSYW5nZU1pbixcXG4gICAgICAvL1ZUSzo6QXZlcmFnZUlQU2NhbGFyUmFuZ2VNaW4sXFxuICAgICAgMS4wKTtcXG4gICAgdmVjNCBhdmVyYWdlSVBTY2FsYXJSYW5nZU1heCA9IHZlYzQoXFxuICAgICAgLy9WVEs6OkF2ZXJhZ2VJUFNjYWxhclJhbmdlTWF4LFxcbiAgICAgIC8vVlRLOjpBdmVyYWdlSVBTY2FsYXJSYW5nZU1heCxcXG4gICAgICAvL1ZUSzo6QXZlcmFnZUlQU2NhbGFyUmFuZ2VNYXgsXFxuICAgICAgMS4wKTtcXG5cXG4gICAgdmVjNCBzdW0gPSB2ZWM0KDAuKTtcXG5cXG4gICAgYXZlcmFnZUlQU2NhbGFyUmFuZ2VNaW4uYSA9IHRWYWx1ZS5hO1xcbiAgICBhdmVyYWdlSVBTY2FsYXJSYW5nZU1heC5hID0gdFZhbHVlLmE7XFxuXFxuICAgIGlmIChhbGwoZ3JlYXRlclRoYW5FcXVhbCh0VmFsdWUsIGF2ZXJhZ2VJUFNjYWxhclJhbmdlTWluKSkgJiZcXG4gICAgYWxsKGxlc3NUaGFuRXF1YWwodFZhbHVlLCBhdmVyYWdlSVBTY2FsYXJSYW5nZU1heCkpKSB7XFxuICAgICAgc3VtICs9IHRWYWx1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAocmF5U3RlcHMgPD0gMS4wKSB7XFxuICAgICAgZ2xfRnJhZ0RhdGFbMF0gPSBnZXRDb2xvckZvclZhbHVlKHN1bSwgcG9zSVMsIHRzdGVwKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgcG9zSVMgKz0gKGppdHRlcipzdGVwSVMpO1xcblxcbiAgICAvLyBTYW1wbGUgYWxvbmcgdGhlIHJheSB1bnRpbCBNYXhpbXVtU2FtcGxlc1ZhbHVlLFxcbiAgICAvLyBlbmRpbmcgc2xpZ2h0bHkgaW5zaWRlIHRoZSB0b3RhbCBkaXN0YW5jZVxcbiAgICBmb3IgKGludCBpID0gMDsgaSA8IC8vVlRLOjpNYXhpbXVtU2FtcGxlc1ZhbHVlIDsgKytpKVxcbiAgICB7XFxuICAgICAgLy8gSWYgd2UgaGF2ZSByZWFjaGVkIHRoZSBsYXN0IHN0ZXAsIGJyZWFrXFxuICAgICAgaWYgKHN0ZXBzVHJhdmVsZWQgKyAxLjAgPj0gcmF5U3RlcHMpIHsgYnJlYWs7IH1cXG5cXG4gICAgICAvLyBjb21wdXRlIHRoZSBzY2FsYXJcXG4gICAgICB0VmFsdWUgPSBnZXRUZXh0dXJlVmFsdWUocG9zSVMpO1xcblxcbiAgICAgIC8vIE9uZSBjYW4gY29udHJvbCB0aGUgc2NhbGFyIHJhbmdlIGJ5IHNldHRpbmcgdGhlIEF2ZXJhZ2VJUFNjYWxhclJhbmdlIHRvIGRpc3JlZ2FyZCBzY2FsYXIgdmFsdWVzLCBub3QgaW4gdGhlIHJhbmdlIG9mIGludGVyZXN0LCBmcm9tIHRoZSBhdmVyYWdlIGNvbXB1dGF0aW9uLlxcbiAgICAgIC8vIE5vdGVzOlxcbiAgICAgIC8vIC0gV2UgYXJlIGNvbXBhcmluZyBhbGwgdmFsdWVzIGluIHRoZSB0ZXh0dXJlIHRvIHNlZSBpZiBhbnkgb2YgdGhlbVxcbiAgICAgIC8vICAgYXJlIG91dHNpZGUgb2YgdGhlIHNjYWxhciByYW5nZS4gSW4gdGhlIGZ1dHVyZSB3ZSBtaWdodCB3YW50IHRvIGFsbG93XFxuICAgICAgLy8gICBzY2FsYXIgcmFuZ2VzIGZvciBlYWNoIGNvbXBvbmVudC5cXG4gICAgICAvLyAtIFdlIGFyZSBzZXR0aW5nIHRoZSBhbHBoYSBjaGFubmVsIGZvciBhdmVyYWdlSVBTY2FsYXJSYW5nZU1pbiBhbmRcXG4gICAgICAvLyAgIGF2ZXJhZ2VJUFNjYWxhclJhbmdlTWF4IHNvIHRoYXQgd2UgZG8gbm90IHRyaWdnZXIgdGhpcyAnY29udGludWUnXFxuICAgICAgLy8gICBiYXNlZCBvbiB0aGUgYWxwaGEgY2hhbm5lbCBjb21wYXJpc29uLlxcbiAgICAgIC8vIC0gVGhlcmUgbWlnaHQgYmUgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXMuIEknbSBub3Qgc3VyZSBpZiB0aGVyZSBpcyBhblxcbiAgICAgIC8vICAgZXF1aXZhbGVudCBvZiAnYW55JyB3aGljaCBvbmx5IG9wZXJhdGVzIG9uIFJHQiwgdGhvdWdoIEkgc3VwcG9zZVxcbiAgICAgIC8vICAgd2UgY291bGQgd3JpdGUgYW4gJ2FueVJHQicgZnVuY3Rpb24gYW5kIHNlZSBpZiB0aGF0IGlzIGZhc3Rlci5cXG4gICAgICBhdmVyYWdlSVBTY2FsYXJSYW5nZU1pbi5hID0gdFZhbHVlLmE7XFxuICAgICAgYXZlcmFnZUlQU2NhbGFyUmFuZ2VNYXguYSA9IHRWYWx1ZS5hO1xcbiAgICAgIGlmIChhbnkobGVzc1RoYW4odFZhbHVlLCBhdmVyYWdlSVBTY2FsYXJSYW5nZU1pbikpIHx8XFxuICAgICAgICAgIGFueShncmVhdGVyVGhhbih0VmFsdWUsIGF2ZXJhZ2VJUFNjYWxhclJhbmdlTWF4KSkpIHtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBTdW0gdGhlIHZhbHVlcyBhY3Jvc3MgZWFjaCBzdGVwIGluIHRoZSBwYXRoXFxuICAgICAgc3VtICs9IHRWYWx1ZTtcXG5cXG4gICAgICAvLyBPdGhlcndpc2UsIGNvbnRpbnVlIGFsb25nIHRoZSByYXlcXG4gICAgICBzdGVwc1RyYXZlbGVkKys7XFxuICAgICAgcG9zSVMgKz0gc3RlcElTO1xcbiAgICB9XFxuXFxuICAgIC8vIFBlcmZvcm0gdGhlIGxhc3Qgc3RlcCBhbG9uZyB0aGUgcmF5IHVzaW5nIHRoZVxcbiAgICAvLyByZXNpZHVhbCBkaXN0YW5jZVxcbiAgICBwb3NJUyA9IGVuZElTO1xcblxcbiAgICAvLyBjb21wdXRlIHRoZSBzY2FsYXJcXG4gICAgdFZhbHVlID0gZ2V0VGV4dHVyZVZhbHVlKHBvc0lTKTtcXG5cXG4gICAgLy8gT25lIGNhbiBjb250cm9sIHRoZSBzY2FsYXIgcmFuZ2UgYnkgc2V0dGluZyB0aGUgQXZlcmFnZUlQU2NhbGFyUmFuZ2UgdG8gZGlzcmVnYXJkIHNjYWxhciB2YWx1ZXMsIG5vdCBpbiB0aGUgcmFuZ2Ugb2YgaW50ZXJlc3QsIGZyb20gdGhlIGF2ZXJhZ2UgY29tcHV0YXRpb25cXG4gICAgaWYgKGFsbChncmVhdGVyVGhhbkVxdWFsKHRWYWx1ZSwgYXZlcmFnZUlQU2NhbGFyUmFuZ2VNaW4pKSAmJlxcbiAgICAgICAgYWxsKGxlc3NUaGFuRXF1YWwodFZhbHVlLCBhdmVyYWdlSVBTY2FsYXJSYW5nZU1heCkpKSB7XFxuICAgICAgc3VtICs9IHRWYWx1ZTtcXG5cXG4gICAgICBzdGVwc1RyYXZlbGVkKys7XFxuICAgIH1cXG5cXG4gICAgc3VtIC89IHZlYzQoc3RlcHNUcmF2ZWxlZCwgc3RlcHNUcmF2ZWxlZCwgc3RlcHNUcmF2ZWxlZCwgMS4wKTtcXG5cXG4gICAgZ2xfRnJhZ0RhdGFbMF0gPSBnZXRDb2xvckZvclZhbHVlKHN1bSwgcG9zSVMsIHRzdGVwKTtcXG4gICNlbmRpZlxcbn1cXG5cXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuLy8gQ29tcHV0ZSBhIG5ldyBzdGFydCBhbmQgZW5kIHBvaW50IGZvciBhIGdpdmVuIHJheSBiYXNlZFxcbi8vIG9uIHRoZSBwcm92aWRlZCBib3VuZGVkIGNsaXBwaW5nIHBsYW5lIChha2EgYSByZWN0YW5nbGUpXFxudm9pZCBnZXRSYXlQb2ludEludGVyc2VjdGlvbkJvdW5kcyhcXG4gIHZlYzMgcmF5UG9zLCB2ZWMzIHJheURpcixcXG4gIHZlYzMgcGxhbmVEaXIsIGZsb2F0IHBsYW5lRGlzdCxcXG4gIGlub3V0IHZlYzIgdGJvdW5kcywgdmVjMyB2UGxhbmVYLCB2ZWMzIHZQbGFuZVksXFxuICBmbG9hdCB2U2l6ZTEsIGZsb2F0IHZTaXplMilcXG57XFxuICBmbG9hdCByZXN1bHQgPSBkb3QocmF5RGlyLCBwbGFuZURpcik7XFxuICBpZiAocmVzdWx0ID09IDAuMClcXG4gIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgcmVzdWx0ID0gLTEuMCAqIChkb3QocmF5UG9zLCBwbGFuZURpcikgKyBwbGFuZURpc3QpIC8gcmVzdWx0O1xcbiAgdmVjMyB4cG9zVkMgPSByYXlQb3MgKyByYXlEaXIqcmVzdWx0O1xcbiAgdmVjMyB2eHBvcyA9IHhwb3NWQyAtIHZPcmlnaW5WQztcXG4gIHZlYzIgdnBvcyA9IHZlYzIoXFxuICAgIGRvdCh2eHBvcywgdlBsYW5lWCksXFxuICAgIGRvdCh2eHBvcywgdlBsYW5lWSkpO1xcblxcbiAgLy8gb24gc29tZSBhcHBsZSBudmlkaWEgc3lzdGVtcyB0aGlzIGRvZXMgbm90IHdvcmtcXG4gIC8vIGlmICh2cG9zLnggPCAwLjAgfHwgdnBvcy54ID4gdlNpemUxIHx8XFxuICAvLyAgICAgdnBvcy55IDwgMC4wIHx8IHZwb3MueSA+IHZTaXplMilcXG4gIC8vIGV2ZW4ganVzdFxcbiAgLy8gaWYgKHZwb3MueCA8IDAuMCB8fCB2cG9zLnkgPCAwLjApXFxuICAvLyBmYWlsc1xcbiAgLy8gc28gaW5zdGVhZCB3ZSBjb21wdXRlIGEgdmFsdWUgdGhhdCByZXByZXNlbnRzIGluIGFuZCBvdXRcXG4gIC8vYW5kIHRoZW4gY29tcHV0ZSB0aGUgcmV0dXJuIHVzaW5nIHRoaXMgdmFsdWVcXG4gIGZsb2F0IHhjaGVjayA9IG1heCgwLjAsIHZwb3MueCAqICh2cG9zLnggLSB2U2l6ZTEpKTsgLy8gIDAgbWVhbnMgaW4gYm91bmRzXFxuICBmbG9hdCBjaGVjayA9IHNpZ24obWF4KHhjaGVjaywgdnBvcy55ICogKHZwb3MueSAtIHZTaXplMikpKTsgLy8gIDAgbWVhbnMgaW4gYm91bmRzLCAxID0gb3V0XFxuXFxuICB0Ym91bmRzID0gbWl4KFxcbiAgIHZlYzIobWluKHRib3VuZHMueCwgcmVzdWx0KSwgbWF4KHRib3VuZHMueSwgcmVzdWx0KSksIC8vIGluIHZhbHVlXFxuICAgdGJvdW5kcywgLy8gb3V0IHZhbHVlXFxuICAgY2hlY2spOyAgLy8gMCBpbiAxIG91dFxcbn1cXG5cXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxuLy8gZ2l2ZW4gYVxcbi8vIC0gcmF5IGRpcmVjdGlvbiAocmF5RGlyKVxcbi8vIC0gc3RhcnRpbmcgcG9pbnQgKHZlcnRleFZDVlNPdXRwdXQpXFxuLy8gLSBib3VuZGluZyBwbGFuZXMgb2YgdGhlIHZvbHVtZVxcbi8vIC0gb3B0aW9uYWxseSBkZXB0aCBidWZmZXIgdmFsdWVzXFxuLy8gLSBmYXIgY2xpcHBpbmcgcGxhbmVcXG4vLyBjb21wdXRlIHRoZSBzdGFydC9lbmQgZGlzdGFuY2VzIG9mIHRoZSByYXkgd2UgbmVlZCB0byBjYXN0XFxudmVjMiBjb21wdXRlUmF5RGlzdGFuY2VzKHZlYzMgcmF5RGlyLCB2ZWMzIHRkaW1zKVxcbntcXG4gIHZlYzIgZGlzdHMgPSB2ZWMyKDEwMC4wKmNhbUZhciwgLTEuMCk7XFxuXFxuICB2ZWMzIHZTaXplID0gdlNwYWNpbmcqKHRkaW1zIC0gMS4wKTtcXG5cXG4gIC8vIGFsbCB0aGlzIGlzIGluIFZpZXcgQ29vcmRpbmF0ZXNcXG4gIGdldFJheVBvaW50SW50ZXJzZWN0aW9uQm91bmRzKHZlcnRleFZDVlNPdXRwdXQsIHJheURpcixcXG4gICAgdlBsYW5lTm9ybWFsMCwgdlBsYW5lRGlzdGFuY2UwLCBkaXN0cywgdlBsYW5lTm9ybWFsMiwgdlBsYW5lTm9ybWFsNCxcXG4gICAgdlNpemUueSwgdlNpemUueik7XFxuICBnZXRSYXlQb2ludEludGVyc2VjdGlvbkJvdW5kcyh2ZXJ0ZXhWQ1ZTT3V0cHV0LCByYXlEaXIsXFxuICAgIHZQbGFuZU5vcm1hbDEsIHZQbGFuZURpc3RhbmNlMSwgZGlzdHMsIHZQbGFuZU5vcm1hbDIsIHZQbGFuZU5vcm1hbDQsXFxuICAgIHZTaXplLnksIHZTaXplLnopO1xcbiAgZ2V0UmF5UG9pbnRJbnRlcnNlY3Rpb25Cb3VuZHModmVydGV4VkNWU091dHB1dCwgcmF5RGlyLFxcbiAgICB2UGxhbmVOb3JtYWwyLCB2UGxhbmVEaXN0YW5jZTIsIGRpc3RzLCB2UGxhbmVOb3JtYWwwLCB2UGxhbmVOb3JtYWw0LFxcbiAgICB2U2l6ZS54LCB2U2l6ZS56KTtcXG4gIGdldFJheVBvaW50SW50ZXJzZWN0aW9uQm91bmRzKHZlcnRleFZDVlNPdXRwdXQsIHJheURpcixcXG4gICAgdlBsYW5lTm9ybWFsMywgdlBsYW5lRGlzdGFuY2UzLCBkaXN0cywgdlBsYW5lTm9ybWFsMCwgdlBsYW5lTm9ybWFsNCxcXG4gICAgdlNpemUueCwgdlNpemUueik7XFxuICBnZXRSYXlQb2ludEludGVyc2VjdGlvbkJvdW5kcyh2ZXJ0ZXhWQ1ZTT3V0cHV0LCByYXlEaXIsXFxuICAgIHZQbGFuZU5vcm1hbDQsIHZQbGFuZURpc3RhbmNlNCwgZGlzdHMsIHZQbGFuZU5vcm1hbDAsIHZQbGFuZU5vcm1hbDIsXFxuICAgIHZTaXplLngsIHZTaXplLnkpO1xcbiAgZ2V0UmF5UG9pbnRJbnRlcnNlY3Rpb25Cb3VuZHModmVydGV4VkNWU091dHB1dCwgcmF5RGlyLFxcbiAgICB2UGxhbmVOb3JtYWw1LCB2UGxhbmVEaXN0YW5jZTUsIGRpc3RzLCB2UGxhbmVOb3JtYWwwLCB2UGxhbmVOb3JtYWwyLFxcbiAgICB2U2l6ZS54LCB2U2l6ZS55KTtcXG5cXG4gIC8vIGRvIG5vdCBnbyBiZWhpbmQgZnJvbnQgY2xpcHBpbmcgcGxhbmVcXG4gIGRpc3RzLnggPSBtYXgoMC4wLGRpc3RzLngpO1xcblxcbiAgLy8gZG8gbm90IGdvIFBBU1QgZmFyIGNsaXBwaW5nIHBsYW5lXFxuICBmbG9hdCBmYXJEaXN0ID0gLWNhbVRoaWNrL3JheURpci56O1xcbiAgZGlzdHMueSA9IG1pbihmYXJEaXN0LGRpc3RzLnkpO1xcblxcbiAgLy8gRG8gbm90IGdvIHBhc3QgdGhlIHpidWZmZXIgdmFsdWUgaWYgc2V0XFxuICAvLyBUaGlzIGlzIHVzZWQgZm9yIGludGVybWl4aW5nIG9wYXF1ZSBnZW9tZXRyeVxcbiAgLy9WVEs6OlpCdWZmZXI6OkltcGxcXG5cXG4gIHJldHVybiBkaXN0cztcXG59XFxuXFxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcbi8vIENvbXB1dGUgdGhlIGluZGV4IHNwYWNlIHN0YXJ0aW5nIHBvc2l0aW9uIChwb3MpIGFuZCBlbmRcXG4vLyBwb3NpdGlvblxcbi8vXFxudm9pZCBjb21wdXRlSW5kZXhTcGFjZVZhbHVlcyhvdXQgdmVjMyBwb3MsIG91dCB2ZWMzIGVuZFBvcywgb3V0IGZsb2F0IHNhbXBsZURpc3RhbmNlSVMsIHZlYzMgcmF5RGlyLCB2ZWMyIGRpc3RzKVxcbntcXG4gIC8vIGNvbXB1dGUgc3RhcnRpbmcgYW5kIGVuZGluZyB2YWx1ZXMgaW4gdm9sdW1lIHNwYWNlXFxuICBwb3MgPSB2ZXJ0ZXhWQ1ZTT3V0cHV0ICsgZGlzdHMueCpyYXlEaXI7XFxuICBwb3MgPSBwb3MgLSB2T3JpZ2luVkM7XFxuICAvLyBjb252ZXJ0IHRvIHZvbHVtZSBiYXNpcyBhbmQgb3JpZ2luXFxuICBwb3MgPSB2ZWMzKFxcbiAgICBkb3QocG9zLCB2UGxhbmVOb3JtYWwwKSxcXG4gICAgZG90KHBvcywgdlBsYW5lTm9ybWFsMiksXFxuICAgIGRvdChwb3MsIHZQbGFuZU5vcm1hbDQpKTtcXG5cXG4gIGVuZFBvcyA9IHZlcnRleFZDVlNPdXRwdXQgKyBkaXN0cy55KnJheURpcjtcXG4gIGVuZFBvcyA9IGVuZFBvcyAtIHZPcmlnaW5WQztcXG4gIGVuZFBvcyA9IHZlYzMoXFxuICAgIGRvdChlbmRQb3MsIHZQbGFuZU5vcm1hbDApLFxcbiAgICBkb3QoZW5kUG9zLCB2UGxhbmVOb3JtYWwyKSxcXG4gICAgZG90KGVuZFBvcywgdlBsYW5lTm9ybWFsNCkpO1xcblxcbiAgZmxvYXQgZGVsdGEgPSBsZW5ndGgoZW5kUG9zIC0gcG9zKTtcXG5cXG4gIHBvcyAqPSB2VkNUb0lKSztcXG4gIGVuZFBvcyAqPSB2VkNUb0lKSztcXG5cXG4gIGZsb2F0IGRlbHRhMiA9IGxlbmd0aChlbmRQb3MgLSBwb3MpO1xcbiAgc2FtcGxlRGlzdGFuY2VJUyA9IHNhbXBsZURpc3RhbmNlKmRlbHRhMi9kZWx0YTtcXG59XFxuXFxudm9pZCBtYWluKClcXG57XFxuXFxuICB2ZWMzIHJheURpclZDO1xcblxcbiAgaWYgKGNhbWVyYVBhcmFsbGVsID09IDEpXFxuICB7XFxuICAgIC8vIENhbWVyYSBpcyBwYXJhbGxlbCwgc28gdGhlIHJheURpciBpcyBqdXN0IHRoZSBkaXJlY3Rpb24gb2YgdGhlIGNhbWVyYS5cXG4gICAgcmF5RGlyVkMgPSB2ZWMzKDAuMCwgMC4wLCAtMS4wKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIGNhbWVyYSBpcyBhdCAwLDAsMCBzbyByYXlEaXIgZm9yIHBlcnNwZWN0aXZlIGlzIGp1c3QgdGhlIHZjIGNvb3JkXFxuICAgIHJheURpclZDID0gbm9ybWFsaXplKHZlcnRleFZDVlNPdXRwdXQpO1xcbiAgfVxcblxcbiAgdmVjMyB0ZGltcyA9IHZlYzModm9sdW1lRGltZW5zaW9ucyk7XFxuXFxuICAvLyBjb21wdXRlIHRoZSBzdGFydCBhbmQgZW5kIHBvaW50cyBmb3IgdGhlIHJheVxcbiAgdmVjMiByYXlTdGFydEVuZERpc3RhbmNlc1ZDID0gY29tcHV0ZVJheURpc3RhbmNlcyhyYXlEaXJWQywgdGRpbXMpO1xcblxcbiAgLy8gZG8gd2UgbmVlZCB0byBjb21wb3NpdGU/IGFrYSBkb2VzIHRoZSByYXkgaGF2ZSBhbnkgbGVuZ3RoXFxuICAvLyBJZiBub3QsIGJhaWwgb3V0IGVhcmx5XFxuICBpZiAocmF5U3RhcnRFbmREaXN0YW5jZXNWQy55IDw9IHJheVN0YXJ0RW5kRGlzdGFuY2VzVkMueClcXG4gIHtcXG4gICAgZGlzY2FyZDtcXG4gIH1cXG5cXG4gIC8vIElTID0gSW5kZXggU3BhY2VcXG4gIHZlYzMgcG9zSVM7XFxuICB2ZWMzIGVuZElTO1xcbiAgZmxvYXQgc2FtcGxlRGlzdGFuY2VJUztcXG4gIGNvbXB1dGVJbmRleFNwYWNlVmFsdWVzKHBvc0lTLCBlbmRJUywgc2FtcGxlRGlzdGFuY2VJUywgcmF5RGlyVkMsIHJheVN0YXJ0RW5kRGlzdGFuY2VzVkMpO1xcblxcbiAgLy8gUGVyZm9ybSB0aGUgYmxlbmRpbmcgb3BlcmF0aW9uIGFsb25nIHRoZSByYXlcXG4gIGFwcGx5QmxlbmQocG9zSVMsIGVuZElTLCBzYW1wbGVEaXN0YW5jZUlTLCB0ZGltcyk7XFxufVxcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8vVlRLOjpTeXN0ZW06OkRlY1xcblxcbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxcblxcbiAgUHJvZ3JhbTogICBWaXN1YWxpemF0aW9uIFRvb2xraXRcXG4gIE1vZHVsZTogICAgdnRrUG9seURhdGFWUy5nbHNsXFxuXFxuICBDb3B5cmlnaHQgKGMpIEtlbiBNYXJ0aW4sIFdpbGwgU2Nocm9lZGVyLCBCaWxsIExvcmVuc2VuXFxuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbiAgU2VlIENvcHlyaWdodC50eHQgb3IgaHR0cDovL3d3dy5raXR3YXJlLmNvbS9Db3B5cmlnaHQuaHRtIGZvciBkZXRhaWxzLlxcblxcbiAgICAgVGhpcyBzb2Z0d2FyZSBpcyBkaXN0cmlidXRlZCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuXFxuICAgICB0aGUgaW1wbGllZCB3YXJyYW50eSBvZiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXFxuICAgICBQVVJQT1NFLiAgU2VlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGZvciBtb3JlIGluZm9ybWF0aW9uLlxcblxcbj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xcblxcbmF0dHJpYnV0ZSB2ZWM0IHZlcnRleERDO1xcblxcbnZhcnlpbmcgdmVjMyB2ZXJ0ZXhWQ1ZTT3V0cHV0O1xcbnVuaWZvcm0gbWF0NCBQQ1ZDTWF0cml4O1xcblxcbnVuaWZvcm0gZmxvYXQgZGN4bWluO1xcbnVuaWZvcm0gZmxvYXQgZGN4bWF4O1xcbnVuaWZvcm0gZmxvYXQgZGN5bWluO1xcbnVuaWZvcm0gZmxvYXQgZGN5bWF4O1xcblxcbnZvaWQgbWFpbigpXFxue1xcbiAgLy8gZGNzbWFsbCBpcyB0aGUgZGV2aWNlIGNvb3JkcyByZWR1Y2VkIHRvIHRoZVxcbiAgLy8geCB5IGFyZWEgY292ZXJlZCBieSB0aGUgdm9sdW1lXFxuICB2ZWM0IGRjc21hbGwgPSB2ZWM0KFxcbiAgICBkY3htaW4gKyAwLjUgKiAodmVydGV4REMueCArIDEuMCkgKiAoZGN4bWF4IC0gZGN4bWluKSxcXG4gICAgZGN5bWluICsgMC41ICogKHZlcnRleERDLnkgKyAxLjApICogKGRjeW1heCAtIGRjeW1pbiksXFxuICAgIHZlcnRleERDLnosXFxuICAgIHZlcnRleERDLncpO1xcbiAgdmVjNCB2Y3BvcyA9IFBDVkNNYXRyaXggKiBkY3NtYWxsO1xcbiAgdmVydGV4VkNWU091dHB1dCA9IHZjcG9zLnh5ei92Y3Bvcy53O1xcbiAgZ2xfUG9zaXRpb24gPSBkY3NtYWxsO1xcbn1cXG5cIiIsImltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5pbXBvcnQgdnRrVmlld05vZGUgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL1NjZW5lR3JhcGgvVmlld05vZGUnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtPcGVuR0xBY3RvciBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a0dlbmVyaWNXaWRnZXRSZXByZXNlbnRhdGlvbihwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIFNldCBvdXIgY2xhc3NOYW1lXG4gIG1vZGVsLmNsYXNzSGllcmFyY2h5LnB1c2goJ3Z0a0dlbmVyaWNXaWRnZXRSZXByZXNlbnRhdGlvbicpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHt9O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyA9IHt9KSB7XG4gIE9iamVjdC5hc3NpZ24obW9kZWwsIERFRkFVTFRfVkFMVUVTLCBpbml0aWFsVmFsdWVzKTtcblxuICAvLyBJbmhlcml0YW5jZVxuICB2dGtWaWV3Tm9kZS5leHRlbmQocHVibGljQVBJLCBtb2RlbCwgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gT2JqZWN0IG1ldGhvZHNcbiAgdnRrR2VuZXJpY1dpZGdldFJlcHJlc2VudGF0aW9uKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGRlZmF1bHQgeyBuZXdJbnN0YW5jZSwgZXh0ZW5kIH07XG4iLCJpbXBvcnQgbWFjcm8gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a1JlbmRlclBhc3MocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtSZW5kZXJQYXNzJyk7XG5cbiAgcHVibGljQVBJLmdldE9wZXJhdGlvbiA9ICgpID0+IG1vZGVsLmN1cnJlbnRPcGVyYXRpb247XG5cbiAgcHVibGljQVBJLnNldEN1cnJlbnRPcGVyYXRpb24gPSAodmFsKSA9PiB7XG4gICAgbW9kZWwuY3VycmVudE9wZXJhdGlvbiA9IHZhbDtcbiAgICBtb2RlbC5jdXJyZW50VHJhdmVyc2VPcGVyYXRpb24gPSBgdHJhdmVyc2Uke21hY3JvLmNhcGl0YWxpemUoXG4gICAgICBtb2RlbC5jdXJyZW50T3BlcmF0aW9uXG4gICAgKX1gO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRUcmF2ZXJzZU9wZXJhdGlvbiA9ICgpID0+IG1vZGVsLmN1cnJlbnRUcmF2ZXJzZU9wZXJhdGlvbjtcblxuICAvLyBieSBkZWZhdWx0IHRoaXMgY2xhc3Mgd2lsbCB0cmF2ZXJzZSBhbGwgb2YgaXRzXG4gIC8vIHByZURlbGVnYXRlT3BlcmF0aW9ucywgdGhlbiBjYWxsIGl0cyBkZWxlZ2F0ZSByZW5kZXIgcGFzc2VzXG4gIC8vIHRoZSB0cmF2ZXJzZSBhbGwgb2YgaXRzIHBvc3REZWxlZ2F0ZU9wZXJhdGlvbnNcbiAgLy8gYW55IG9mIHRob3NlIHRocmVlIGFycmF5cyBjYW4gYmUgZW1wdHlcbiAgcHVibGljQVBJLnRyYXZlcnNlID0gKHZpZXdOb2RlLCBwYXJlbnQgPSBudWxsKSA9PiB7XG4gICAgaWYgKG1vZGVsLmRlbGV0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB3ZSBqdXN0IHJlbmRlciBvdXIgZGVsZWdhdGVzIGluIG9yZGVyXG4gICAgbW9kZWwuY3VycmVudFBhcmVudCA9IHBhcmVudDtcblxuICAgIG1vZGVsLnByZURlbGVnYXRlT3BlcmF0aW9ucy5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgIHB1YmxpY0FQSS5zZXRDdXJyZW50T3BlcmF0aW9uKHZhbCk7XG4gICAgICB2aWV3Tm9kZS50cmF2ZXJzZShwdWJsaWNBUEkpO1xuICAgIH0pO1xuICAgIG1vZGVsLmRlbGVnYXRlcy5mb3JFYWNoKCh2YWwpID0+IHtcbiAgICAgIHZhbC50cmF2ZXJzZSh2aWV3Tm9kZSwgcHVibGljQVBJKTtcbiAgICB9KTtcbiAgICBtb2RlbC5wb3N0RGVsZWdhdGVPcGVyYXRpb25zLmZvckVhY2goKHZhbCkgPT4ge1xuICAgICAgcHVibGljQVBJLnNldEN1cnJlbnRPcGVyYXRpb24odmFsKTtcbiAgICAgIHZpZXdOb2RlLnRyYXZlcnNlKHB1YmxpY0FQSSk7XG4gICAgfSk7XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICBkZWxlZ2F0ZXM6IFtdLFxuICBjdXJyZW50T3BlcmF0aW9uOiBudWxsLFxuICBwcmVEZWxlZ2F0ZU9wZXJhdGlvbnM6IFtdLFxuICBwb3N0RGVsZWdhdGVPcGVyYXRpb25zOiBbXSxcbiAgY3VycmVudFBhcmVudDogbnVsbCxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEJ1aWxkIFZUSyBBUElcbiAgbWFjcm8ub2JqKHB1YmxpY0FQSSwgbW9kZWwpO1xuICBtYWNyby5nZXQocHVibGljQVBJLCBtb2RlbCwgWydjdXJyZW50T3BlcmF0aW9uJ10pO1xuICBtYWNyby5zZXRHZXQocHVibGljQVBJLCBtb2RlbCwgW1xuICAgICdkZWxlZ2F0ZXMnLFxuICAgICdjdXJyZW50UGFyZW50JyxcbiAgICAncHJlRGVsZWdhdGVPcGVyYXRpb25zJyxcbiAgICAncG9zdERlbGVnYXRlT3BlcmF0aW9ucycsXG4gIF0pO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIHZ0a1JlbmRlclBhc3MocHVibGljQVBJLCBtb2RlbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrUmVuZGVyUGFzcycpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCB9O1xuIiwiaW1wb3J0IG1hY3JvIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL21hY3JvJztcblxuY29uc3QgeyB2dGtFcnJvck1hY3JvIH0gPSBtYWNybztcblxuY29uc3QgUEFTU19UWVBFUyA9IFsnQnVpbGQnLCAnUmVuZGVyJ107XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a1ZpZXdOb2RlIG1ldGhvZHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gdnRrVmlld05vZGUocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBTZXQgb3VyIGNsYXNzTmFtZVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeS5wdXNoKCd2dGtWaWV3Tm9kZScpO1xuXG4gIC8vIEJ1aWxkcyBteXNlbGYuXG4gIHB1YmxpY0FQSS5idWlsZCA9IChwcmVwYXNzKSA9PiB7fTtcblxuICAvLyBSZW5kZXJzIG15c2VsZlxuICBwdWJsaWNBUEkucmVuZGVyID0gKHByZXBhc3MpID0+IHt9O1xuXG4gIHB1YmxpY0FQSS50cmF2ZXJzZSA9IChyZW5kZXJQYXNzKSA9PiB7XG4gICAgLy8gd2UgY2FuIGNob29zZSB0byBkbyBzcGVjaWFsXG4gICAgLy8gdHJhdmVyc2FsIGhlcmUgYmFzZWQgb24gcGFzc1xuICAgIGNvbnN0IHBhc3NUcmF2ZXJzYWwgPSByZW5kZXJQYXNzLmdldFRyYXZlcnNlT3BlcmF0aW9uKCk7XG4gICAgY29uc3QgZm4gPSBwdWJsaWNBUElbcGFzc1RyYXZlcnNhbF07XG4gICAgaWYgKGZuKSB7XG4gICAgICBmbihyZW5kZXJQYXNzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBkZWZhdWx0IHRyYXZlcnNhbFxuICAgIHB1YmxpY0FQSS5hcHBseShyZW5kZXJQYXNzLCB0cnVlKTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBtb2RlbC5jaGlsZHJlbi5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIG1vZGVsLmNoaWxkcmVuW2luZGV4XS50cmF2ZXJzZShyZW5kZXJQYXNzKTtcbiAgICB9XG5cbiAgICBwdWJsaWNBUEkuYXBwbHkocmVuZGVyUGFzcywgZmFsc2UpO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5hcHBseSA9IChyZW5kZXJQYXNzLCBwcmVwYXNzKSA9PiB7XG4gICAgY29uc3QgY3VzdG9tUmVuZGVyUGFzcyA9IHB1YmxpY0FQSVtyZW5kZXJQYXNzLmdldE9wZXJhdGlvbigpXTtcbiAgICBpZiAoY3VzdG9tUmVuZGVyUGFzcykge1xuICAgICAgY3VzdG9tUmVuZGVyUGFzcyhwcmVwYXNzLCByZW5kZXJQYXNzKTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmdldFZpZXdOb2RlRm9yID0gKGRhdGFPYmplY3QpID0+IHtcbiAgICBpZiAobW9kZWwucmVuZGVyYWJsZSA9PT0gZGF0YU9iamVjdCkge1xuICAgICAgcmV0dXJuIHB1YmxpY0FQSTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbW9kZWwuY2hpbGRyZW4ubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICBjb25zdCBjaGlsZCA9IG1vZGVsLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgIGNvbnN0IHZuID0gY2hpbGQuZ2V0Vmlld05vZGVGb3IoZGF0YU9iamVjdCk7XG4gICAgICBpZiAodm4pIHtcbiAgICAgICAgcmV0dXJuIHZuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRGaXJzdEFuY2VzdG9yT2ZUeXBlID0gKHR5cGUpID0+IHtcbiAgICBpZiAoIW1vZGVsLnBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChtb2RlbC5wYXJlbnQuaXNBKHR5cGUpKSB7XG4gICAgICByZXR1cm4gbW9kZWwucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWwucGFyZW50LmdldEZpcnN0QW5jZXN0b3JPZlR5cGUodHlwZSk7XG4gIH07XG5cbiAgcHVibGljQVBJLmFkZE1pc3NpbmdOb2RlID0gKGRvYmopID0+IHtcbiAgICBpZiAoIWRvYmopIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbW9kZWwucmVuZGVyYWJsZUNoaWxkTWFwLmdldChkb2JqKTtcbiAgICAvLyBpZiBmb3VuZCBqdXN0IG1hcmsgYXMgdmlzaXRlZFxuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVzdWx0LnNldFZpc2l0ZWQodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBjcmVhdGUgYSBub2RlXG4gICAgICBjb25zdCBuZXdOb2RlID0gcHVibGljQVBJLmNyZWF0ZVZpZXdOb2RlKGRvYmopO1xuICAgICAgaWYgKG5ld05vZGUpIHtcbiAgICAgICAgbmV3Tm9kZS5zZXRQYXJlbnQocHVibGljQVBJKTtcbiAgICAgICAgbmV3Tm9kZS5zZXRWaXNpdGVkKHRydWUpO1xuICAgICAgICBtb2RlbC5yZW5kZXJhYmxlQ2hpbGRNYXAuc2V0KGRvYmosIG5ld05vZGUpO1xuICAgICAgICBtb2RlbC5jaGlsZHJlbi5wdXNoKG5ld05vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuYWRkTWlzc2luZ05vZGVzID0gKGRhdGFPYmpzKSA9PiB7XG4gICAgaWYgKCFkYXRhT2JqcyB8fCAhZGF0YU9ianMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGRhdGFPYmpzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgY29uc3QgZG9iaiA9IGRhdGFPYmpzW2luZGV4XTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG1vZGVsLnJlbmRlcmFibGVDaGlsZE1hcC5nZXQoZG9iaik7XG4gICAgICAvLyBpZiBmb3VuZCBqdXN0IG1hcmsgYXMgdmlzaXRlZFxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlc3VsdC5zZXRWaXNpdGVkKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGNyZWF0ZSBhIG5vZGVcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHB1YmxpY0FQSS5jcmVhdGVWaWV3Tm9kZShkb2JqKTtcbiAgICAgICAgaWYgKG5ld05vZGUpIHtcbiAgICAgICAgICBuZXdOb2RlLnNldFBhcmVudChwdWJsaWNBUEkpO1xuICAgICAgICAgIG5ld05vZGUuc2V0VmlzaXRlZCh0cnVlKTtcbiAgICAgICAgICBtb2RlbC5yZW5kZXJhYmxlQ2hpbGRNYXAuc2V0KGRvYmosIG5ld05vZGUpO1xuICAgICAgICAgIG1vZGVsLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLnByZXBhcmVOb2RlcyA9ICgpID0+IHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbW9kZWwuY2hpbGRyZW4ubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICBtb2RlbC5jaGlsZHJlbltpbmRleF0uc2V0VmlzaXRlZChmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIHB1YmxpY0FQSS5zZXRWaXNpdGVkID0gKHZhbCkgPT4ge1xuICAgIG1vZGVsLnZpc2l0ZWQgPSB2YWw7XG4gIH07XG5cbiAgcHVibGljQVBJLnJlbW92ZVVudXNlZE5vZGVzID0gKCkgPT4ge1xuICAgIGxldCBkZWxldGVkID0gbnVsbDtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbW9kZWwuY2hpbGRyZW4ubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICBjb25zdCBjaGlsZCA9IG1vZGVsLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgIGNvbnN0IHZpc2l0ZWQgPSBjaGlsZC5nZXRWaXNpdGVkKCk7XG4gICAgICBpZiAoIXZpc2l0ZWQpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyYWJsZSA9IGNoaWxkLmdldFJlbmRlcmFibGUoKTtcbiAgICAgICAgaWYgKHJlbmRlcmFibGUpIHtcbiAgICAgICAgICBtb2RlbC5yZW5kZXJhYmxlQ2hpbGRNYXAuZGVsZXRlKHJlbmRlcmFibGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGVsZXRlZCkge1xuICAgICAgICAgIGRlbGV0ZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGVkLnB1c2goY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQuc2V0VmlzaXRlZChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgIC8vIHNsb3cgZG9lcyBhbGxvYyBidXQgbm90IGFzIGNvbW1vblxuICAgICAgbW9kZWwuY2hpbGRyZW4gPSBtb2RlbC5jaGlsZHJlbi5maWx0ZXIoKGVsKSA9PiAhZGVsZXRlZC5pbmNsdWRlcyhlbCkpO1xuICAgIH1cbiAgfTtcblxuICBwdWJsaWNBUEkuY3JlYXRlVmlld05vZGUgPSAoZGF0YU9iaikgPT4ge1xuICAgIGlmICghbW9kZWwubXlGYWN0b3J5KSB7XG4gICAgICB2dGtFcnJvck1hY3JvKCdDYW5ub3QgY3JlYXRlIHZpZXcgbm9kZXMgd2l0aG91dCBteSBvd24gZmFjdG9yeScpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IG1vZGVsLm15RmFjdG9yeS5jcmVhdGVOb2RlKGRhdGFPYmopO1xuICAgIGlmIChyZXQpIHtcbiAgICAgIHJldC5zZXRSZW5kZXJhYmxlKGRhdGFPYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPYmplY3QgZmFjdG9yeVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5jb25zdCBERUZBVUxUX1ZBTFVFUyA9IHtcbiAgcGFyZW50OiBudWxsLFxuICByZW5kZXJhYmxlOiBudWxsLFxuICBteUZhY3Rvcnk6IG51bGwsXG4gIGNoaWxkcmVuOiBbXSxcbiAgdmlzaXRlZDogZmFsc2UsXG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIGV4dGVuZChwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsVmFsdWVzID0ge30pIHtcbiAgT2JqZWN0LmFzc2lnbihtb2RlbCwgREVGQVVMVF9WQUxVRVMsIGluaXRpYWxWYWx1ZXMpO1xuXG4gIC8vIEJ1aWxkIFZUSyBBUElcbiAgbWFjcm8ub2JqKHB1YmxpY0FQSSwgbW9kZWwpO1xuICBtYWNyby5ldmVudChwdWJsaWNBUEksIG1vZGVsLCAnZXZlbnQnKTtcblxuICBtb2RlbC5yZW5kZXJhYmxlQ2hpbGRNYXAgPSBuZXcgTWFwKCk7XG5cbiAgbWFjcm8uZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsndmlzaXRlZCddKTtcbiAgbWFjcm8uc2V0R2V0KHB1YmxpY0FQSSwgbW9kZWwsIFsncGFyZW50JywgJ3JlbmRlcmFibGUnLCAnbXlGYWN0b3J5J10pO1xuICBtYWNyby5nZXRBcnJheShwdWJsaWNBUEksIG1vZGVsLCBbJ2NoaWxkcmVuJ10pO1xuXG4gIC8vIE9iamVjdCBtZXRob2RzXG4gIHZ0a1ZpZXdOb2RlKHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG5ld0luc3RhbmNlID0gbWFjcm8ubmV3SW5zdGFuY2UoZXh0ZW5kLCAndnRrVmlld05vZGUnKTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7IG5ld0luc3RhbmNlLCBleHRlbmQsIFBBU1NfVFlQRVMgfTtcbiIsImltcG9ydCBtYWNybyBmcm9tICd2dGsuanMvU291cmNlcy9tYWNybyc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a1ZpZXdOb2RlRmFjdG9yeSBtZXRob2RzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHZ0a1ZpZXdOb2RlRmFjdG9yeShwdWJsaWNBUEksIG1vZGVsKSB7XG4gIC8vIE1ha2Ugc3VyZSBvdXIgb3ZlcnJpZGVzIGlzIGp1c3QgZm9yIG91ciBpbnN0YW5jZSBub3Qgc2hhcmVkIHdpdGggZXZlcnlvbmUuLi5cbiAgbW9kZWwub3ZlcnJpZGVzID0ge307XG5cbiAgLy8gU2V0IG91ciBjbGFzc05hbWVcbiAgbW9kZWwuY2xhc3NIaWVyYXJjaHkucHVzaCgndnRrVmlld05vZGVGYWN0b3J5Jyk7XG5cbiAgcHVibGljQVBJLmNyZWF0ZU5vZGUgPSAoZGF0YU9iamVjdCkgPT4ge1xuICAgIGlmIChkYXRhT2JqZWN0LmlzRGVsZXRlZCgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgY3B0ID0gMDtcbiAgICBsZXQgY2xhc3NOYW1lID0gZGF0YU9iamVjdC5nZXRDbGFzc05hbWUoY3B0KyspO1xuICAgIGxldCBpc09iamVjdCA9IGZhbHNlO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhtb2RlbC5vdmVycmlkZXMpO1xuICAgIHdoaWxlIChjbGFzc05hbWUgJiYgIWlzT2JqZWN0KSB7XG4gICAgICBpZiAoa2V5cy5pbmRleE9mKGNsYXNzTmFtZSkgIT09IC0xKSB7XG4gICAgICAgIGlzT2JqZWN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IGRhdGFPYmplY3QuZ2V0Q2xhc3NOYW1lKGNwdCsrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWlzT2JqZWN0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgdm4gPSBtb2RlbC5vdmVycmlkZXNbY2xhc3NOYW1lXSgpO1xuICAgIHZuLnNldE15RmFjdG9yeShwdWJsaWNBUEkpO1xuICAgIHJldHVybiB2bjtcbiAgfTtcblxuICBwdWJsaWNBUEkucmVnaXN0ZXJPdmVycmlkZSA9IChjbGFzc05hbWUsIGZ1bmMpID0+IHtcbiAgICBtb2RlbC5vdmVycmlkZXNbY2xhc3NOYW1lXSA9IGZ1bmM7XG4gIH07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE9iamVjdCBmYWN0b3J5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IERFRkFVTFRfVkFMVUVTID0ge1xuICAvLyBvdmVycmlkZXM6IHt9LFxufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMgPSB7fSkge1xuICBPYmplY3QuYXNzaWduKG1vZGVsLCBERUZBVUxUX1ZBTFVFUywgaW5pdGlhbFZhbHVlcyk7XG5cbiAgLy8gQnVpbGQgVlRLIEFQSVxuICBtYWNyby5vYmoocHVibGljQVBJLCBtb2RlbCk7XG5cbiAgLy8gT2JqZWN0IG1ldGhvZHNcbiAgdnRrVmlld05vZGVGYWN0b3J5KHB1YmxpY0FQSSwgbW9kZWwpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBuZXdJbnN0YW5jZSA9IG1hY3JvLm5ld0luc3RhbmNlKGV4dGVuZCwgJ3Z0a1ZpZXdOb2RlRmFjdG9yeScpO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBkZWZhdWx0IHsgbmV3SW5zdGFuY2UsIGV4dGVuZCB9O1xuIiwiaW1wb3J0IHZ0ayBmcm9tICcuL3Z0ayc7XG5cbmxldCBnbG9iYWxNVGltZSA9IDA7XG5cbmV4cG9ydCBjb25zdCBWT0lEID0gU3ltYm9sKCd2b2lkJyk7XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRHbG9iYWxNVGltZSgpIHtcbiAgcmV0dXJuIGdsb2JhbE1UaW1lO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMb2dnaW5nIGZ1bmN0aW9uIGNhbGxzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbmNvbnN0IGZha2VDb25zb2xlID0ge307XG5cbmZ1bmN0aW9uIG5vT3AoKSB7fVxuXG5jb25zdCBjb25zb2xlTWV0aG9kcyA9IFtcbiAgJ2xvZycsXG4gICdkZWJ1ZycsXG4gICdpbmZvJyxcbiAgJ3dhcm4nLFxuICAnZXJyb3InLFxuICAndGltZScsXG4gICd0aW1lRW5kJyxcbiAgJ2dyb3VwJyxcbiAgJ2dyb3VwRW5kJyxcbl07XG5jb25zb2xlTWV0aG9kcy5mb3JFYWNoKChtZXRob2ROYW1lKSA9PiB7XG4gIGZha2VDb25zb2xlW21ldGhvZE5hbWVdID0gbm9PcDtcbn0pO1xuXG5nbG9iYWwuY29uc29sZSA9IGNvbnNvbGUuaGFzT3duUHJvcGVydHkoJ2xvZycpID8gY29uc29sZSA6IGZha2VDb25zb2xlO1xuXG5jb25zdCBsb2dnZXJGdW5jdGlvbnMgPSB7XG4gIGRlYnVnOiBub09wLCAvLyBEb24ndCBwcmludCBkZWJ1ZyBieSBkZWZhdWx0XG4gIGVycm9yOiBnbG9iYWwuY29uc29sZS5lcnJvciB8fCBub09wLFxuICBpbmZvOiBnbG9iYWwuY29uc29sZS5pbmZvIHx8IG5vT3AsXG4gIGxvZzogZ2xvYmFsLmNvbnNvbGUubG9nIHx8IG5vT3AsXG4gIHdhcm46IGdsb2JhbC5jb25zb2xlLndhcm4gfHwgbm9PcCxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRMb2dnZXJGdW5jdGlvbihuYW1lLCBmbikge1xuICBpZiAobG9nZ2VyRnVuY3Rpb25zW25hbWVdKSB7XG4gICAgbG9nZ2VyRnVuY3Rpb25zW25hbWVdID0gZm4gfHwgbm9PcDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdnRrTG9nTWFjcm8oLi4uYXJncykge1xuICBsb2dnZXJGdW5jdGlvbnMubG9nKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdnRrSW5mb01hY3JvKC4uLmFyZ3MpIHtcbiAgbG9nZ2VyRnVuY3Rpb25zLmluZm8oLi4uYXJncyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2dGtEZWJ1Z01hY3JvKC4uLmFyZ3MpIHtcbiAgbG9nZ2VyRnVuY3Rpb25zLmRlYnVnKC4uLmFyZ3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdnRrRXJyb3JNYWNybyguLi5hcmdzKSB7XG4gIGxvZ2dlckZ1bmN0aW9ucy5lcnJvciguLi5hcmdzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZ0a1dhcm5pbmdNYWNybyguLi5hcmdzKSB7XG4gIGxvZ2dlckZ1bmN0aW9ucy53YXJuKC4uLmFyZ3MpO1xufVxuXG5jb25zdCBFUlJPUl9PTkNFX01BUCA9IHt9O1xuZXhwb3J0IGZ1bmN0aW9uIHZ0a09uY2VFcnJvck1hY3JvKHN0cikge1xuICBpZiAoIUVSUk9SX09OQ0VfTUFQW3N0cl0pIHtcbiAgICBsb2dnZXJGdW5jdGlvbnMuZXJyb3Ioc3RyKTtcbiAgICBFUlJPUl9PTkNFX01BUFtzdHJdID0gdHJ1ZTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUeXBlZEFycmF5XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBUWVBFRF9BUlJBWVMgPSB7XG4gIEZsb2F0MzJBcnJheSxcbiAgRmxvYXQ2NEFycmF5LFxuICBVaW50OEFycmF5LFxuICBJbnQ4QXJyYXksXG4gIFVpbnQxNkFycmF5LFxuICBJbnQxNkFycmF5LFxuICBVaW50MzJBcnJheSxcbiAgSW50MzJBcnJheSxcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGNhcGl0aWx6ZSBwcm92aWRlZCBzdHJpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmNhcGl0YWxpemUoc3RyKSB7XG4gIHJldHVybiBzdHIuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENvbnZlcnQgYnl0ZSBzaXplIGludG8gYSB3ZWxsIGZvcm1hdHRlZCBzdHJpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEJ5dGVzVG9Qcm9wZXJVbml0KHNpemUsIHByZWNpc2lvbiA9IDIsIGNodW5rU2l6ZSA9IDEwMDApIHtcbiAgY29uc3QgdW5pdHMgPSBbJ1RCJywgJ0dCJywgJ01CJywgJ0tCJ107XG4gIGxldCB2YWx1ZSA9IE51bWJlcihzaXplKTtcbiAgbGV0IGN1cnJlbnRVbml0ID0gJ0InO1xuICB3aGlsZSAodmFsdWUgPiBjaHVua1NpemUpIHtcbiAgICB2YWx1ZSAvPSBjaHVua1NpemU7XG4gICAgY3VycmVudFVuaXQgPSB1bml0cy5wb3AoKTtcbiAgfVxuICByZXR1cm4gYCR7dmFsdWUudG9GaXhlZChwcmVjaXNpb24pfSAke2N1cnJlbnRVbml0fWA7XG59XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDb252ZXJ0IHRob3VzYW5kIG51bWJlciB3aXRoIHByb3BlciBzZXBhcmF0b3Jcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdE51bWJlcnNXaXRoVGhvdXNhbmRTZXBhcmF0b3Iobiwgc2VwYXJhdG9yID0gJyAnKSB7XG4gIGNvbnN0IHNlY3Rpb25zID0gW107XG4gIGxldCBzaXplID0gbjtcbiAgd2hpbGUgKHNpemUgPiAxMDAwKSB7XG4gICAgc2VjdGlvbnMucHVzaChgMDAwJHtzaXplICUgMTAwMH1gLnNsaWNlKC0zKSk7XG4gICAgc2l6ZSA9IE1hdGguZmxvb3Ioc2l6ZSAvIDEwMDApO1xuICB9XG4gIGlmIChzaXplID4gMCkge1xuICAgIHNlY3Rpb25zLnB1c2goc2l6ZSk7XG4gIH1cbiAgc2VjdGlvbnMucmV2ZXJzZSgpO1xuICByZXR1cm4gc2VjdGlvbnMuam9pbihzZXBhcmF0b3IpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBcnJheSBoZWxwZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gc2FmZUFycmF5cyhtb2RlbCkge1xuICBPYmplY3Qua2V5cyhtb2RlbCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWxba2V5XSkpIHtcbiAgICAgIG1vZGVsW2tleV0gPSBbXS5jb25jYXQobW9kZWxba2V5XSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gc2hhbGxvdyBlcXVhbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gc2hhbGxvd0VxdWFscyhhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gZW51bVRvU3RyaW5nKGUsIHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhlKS5maW5kKChrZXkpID0+IGVba2V5XSA9PT0gdmFsdWUpO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUFycmF5TWFwRnVuYyhpdGVtKSB7XG4gIGlmIChpdGVtLmlzQSkge1xuICAgIHJldHVybiBpdGVtLmdldFN0YXRlKCk7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHNldEltbWVkaWF0ZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0SW1tZWRpYXRlVlRLKGZuKSB7XG4gIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyB2dGtPYmplY3Q6IG1vZGlmaWVkKCksIG9uTW9kaWZpZWQoY2FsbGJhY2spLCBkZWxldGUoKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gb2JqKHB1YmxpY0FQSSA9IHt9LCBtb2RlbCA9IHt9KSB7XG4gIC8vIEVuc3VyZSBlYWNoIGluc3RhbmNlIGFzIGEgdW5pcXVlIHJlZiBvZiBhcnJheVxuICBzYWZlQXJyYXlzKG1vZGVsKTtcblxuICBjb25zdCBjYWxsYmFja3MgPSBbXTtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1vZGVsLm10aW1lKSkge1xuICAgIG1vZGVsLm10aW1lID0gKytnbG9iYWxNVGltZTtcbiAgfVxuICBtb2RlbC5jbGFzc0hpZXJhcmNoeSA9IFsndnRrT2JqZWN0J107XG5cbiAgZnVuY3Rpb24gb2ZmKGluZGV4KSB7XG4gICAgY2FsbGJhY2tzW2luZGV4XSA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBvbihpbmRleCkge1xuICAgIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgb2ZmKGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgdW5zdWJzY3JpYmUsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWNBUEkuaXNEZWxldGVkID0gKCkgPT4gISFtb2RlbC5kZWxldGVkO1xuXG4gIHB1YmxpY0FQSS5tb2RpZmllZCA9IChvdGhlck1UaW1lKSA9PiB7XG4gICAgaWYgKG1vZGVsLmRlbGV0ZWQpIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oJ2luc3RhbmNlIGRlbGV0ZWQgLSBjYW5ub3QgY2FsbCBhbnkgbWV0aG9kJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG90aGVyTVRpbWUgJiYgb3RoZXJNVGltZSA8IHB1YmxpY0FQSS5nZXRNVGltZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbW9kZWwubXRpbWUgPSArK2dsb2JhbE1UaW1lO1xuICAgIGNhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2sgJiYgY2FsbGJhY2socHVibGljQVBJKSk7XG4gIH07XG5cbiAgcHVibGljQVBJLm9uTW9kaWZpZWQgPSAoY2FsbGJhY2spID0+IHtcbiAgICBpZiAobW9kZWwuZGVsZXRlZCkge1xuICAgICAgdnRrRXJyb3JNYWNybygnaW5zdGFuY2UgZGVsZXRlZCAtIGNhbm5vdCBjYWxsIGFueSBtZXRob2QnKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmxlbmd0aDtcbiAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuIG9uKGluZGV4KTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0TVRpbWUgPSAoKSA9PiBtb2RlbC5tdGltZTtcblxuICBwdWJsaWNBUEkuaXNBID0gKGNsYXNzTmFtZSkgPT4ge1xuICAgIGxldCBjb3VudCA9IG1vZGVsLmNsYXNzSGllcmFyY2h5Lmxlbmd0aDtcbiAgICAvLyB3ZSBnbyBiYWNrd2FyZHMgYXMgdGhhdCBpcyBtb3JlIGxpa2VseSBmb3JcbiAgICAvLyBlYXJseSB0ZXJtaW5hdGlvblxuICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICBpZiAobW9kZWwuY2xhc3NIaWVyYXJjaHlbY291bnRdID09PSBjbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZ2V0Q2xhc3NOYW1lID0gKGRlcHRoID0gMCkgPT5cbiAgICBtb2RlbC5jbGFzc0hpZXJhcmNoeVttb2RlbC5jbGFzc0hpZXJhcmNoeS5sZW5ndGggLSAxIC0gZGVwdGhdO1xuXG4gIHB1YmxpY0FQSS5zZXQgPSAobWFwID0ge30sIG5vV2FybmluZyA9IGZhbHNlLCBub0Z1bmN0aW9uID0gZmFsc2UpID0+IHtcbiAgICBsZXQgcmV0ID0gZmFsc2U7XG4gICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBjb25zdCBmbiA9IG5vRnVuY3Rpb24gPyBudWxsIDogcHVibGljQVBJW2BzZXQke2NhcGl0YWxpemUobmFtZSl9YF07XG4gICAgICBpZiAoZm4gJiYgQXJyYXkuaXNBcnJheShtYXBbbmFtZV0pICYmIGZuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0ID0gZm4oLi4ubWFwW25hbWVdKSB8fCByZXQ7XG4gICAgICB9IGVsc2UgaWYgKGZuKSB7XG4gICAgICAgIHJldCA9IGZuKG1hcFtuYW1lXSkgfHwgcmV0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0IGRhdGEgb24gbW9kZWwgZGlyZWN0bHlcbiAgICAgICAgaWYgKFsnbXRpbWUnXS5pbmRleE9mKG5hbWUpID09PSAtMSAmJiAhbm9XYXJuaW5nKSB7XG4gICAgICAgICAgdnRrV2FybmluZ01hY3JvKFxuICAgICAgICAgICAgYFdhcm5pbmc6IFNldCB2YWx1ZSB0byBtb2RlbCBkaXJlY3RseSAke25hbWV9LCAke21hcFtuYW1lXX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RlbFtuYW1lXSA9IG1hcFtuYW1lXTtcbiAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXQgPSAoLi4ubGlzdCkgPT4ge1xuICAgIGlmICghbGlzdC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9XG4gICAgY29uc3Qgc3Vic2V0ID0ge307XG4gICAgbGlzdC5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBzdWJzZXRbbmFtZV0gPSBtb2RlbFtuYW1lXTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3Vic2V0O1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nZXRSZWZlcmVuY2VCeU5hbWUgPSAodmFsKSA9PiBtb2RlbFt2YWxdO1xuXG4gIHB1YmxpY0FQSS5kZWxldGUgPSAoKSA9PiB7XG4gICAgT2JqZWN0LmtleXMobW9kZWwpLmZvckVhY2goKGZpZWxkKSA9PiBkZWxldGUgbW9kZWxbZmllbGRdKTtcbiAgICBjYWxsYmFja3MuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiBvZmYoaW5kZXgpKTtcblxuICAgIC8vIEZsYWcgdGhlIGluc3RhbmNlIGJlaW5nIGRlbGV0ZWRcbiAgICBtb2RlbC5kZWxldGVkID0gdHJ1ZTtcbiAgfTtcblxuICAvLyBBZGQgc2VyaWFsaXphdGlvbiBzdXBwb3J0XG4gIHB1YmxpY0FQSS5nZXRTdGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCBqc29uQXJjaGl2ZSA9IHsgLi4ubW9kZWwsIHZ0a0NsYXNzOiBwdWJsaWNBUEkuZ2V0Q2xhc3NOYW1lKCkgfTtcblxuICAgIC8vIENvbnZlcnQgZXZlcnkgdnRrT2JqZWN0IHRvIGl0cyBzZXJpYWxpemFibGUgZm9ybVxuICAgIE9iamVjdC5rZXlzKGpzb25BcmNoaXZlKS5mb3JFYWNoKChrZXlOYW1lKSA9PiB7XG4gICAgICBpZiAoanNvbkFyY2hpdmVba2V5TmFtZV0gPT09IG51bGwgfHwganNvbkFyY2hpdmVba2V5TmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUganNvbkFyY2hpdmVba2V5TmFtZV07XG4gICAgICB9IGVsc2UgaWYgKGpzb25BcmNoaXZlW2tleU5hbWVdLmlzQSkge1xuICAgICAgICBqc29uQXJjaGl2ZVtrZXlOYW1lXSA9IGpzb25BcmNoaXZlW2tleU5hbWVdLmdldFN0YXRlKCk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoanNvbkFyY2hpdmVba2V5TmFtZV0pKSB7XG4gICAgICAgIGpzb25BcmNoaXZlW2tleU5hbWVdID0ganNvbkFyY2hpdmVba2V5TmFtZV0ubWFwKGdldFN0YXRlQXJyYXlNYXBGdW5jKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNvcnQgcmVzdWx0aW5nIG9iamVjdCBieSBrZXkgbmFtZVxuICAgIGNvbnN0IHNvcnRlZE9iaiA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGpzb25BcmNoaXZlKVxuICAgICAgLnNvcnQoKVxuICAgICAgLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgc29ydGVkT2JqW25hbWVdID0ganNvbkFyY2hpdmVbbmFtZV07XG4gICAgICB9KTtcblxuICAgIC8vIFJlbW92ZSBtdGltZVxuICAgIGlmIChzb3J0ZWRPYmoubXRpbWUpIHtcbiAgICAgIGRlbGV0ZSBzb3J0ZWRPYmoubXRpbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNvcnRlZE9iajtcbiAgfTtcblxuICAvLyBBZGQgc2hhbGxvd0NvcHkob3RoZXJJbnN0YW5jZSkgc3VwcG9ydFxuICBwdWJsaWNBUEkuc2hhbGxvd0NvcHkgPSAob3RoZXIsIGRlYnVnID0gZmFsc2UpID0+IHtcbiAgICBpZiAob3RoZXIuZ2V0Q2xhc3NOYW1lKCkgIT09IHB1YmxpY0FQSS5nZXRDbGFzc05hbWUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ2Fubm90IFNoYWxsb3dDb3B5ICR7b3RoZXIuZ2V0Q2xhc3NOYW1lKCl9IGludG8gJHtwdWJsaWNBUEkuZ2V0Q2xhc3NOYW1lKCl9YFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgb3RoZXJNb2RlbCA9IG90aGVyLmdldCgpO1xuXG4gICAgY29uc3Qga2V5TGlzdCA9IE9iamVjdC5rZXlzKG1vZGVsKS5zb3J0KCk7XG4gICAgY29uc3Qgb3RoZXJLZXlMaXN0ID0gT2JqZWN0LmtleXMob3RoZXJNb2RlbCkuc29ydCgpO1xuXG4gICAgb3RoZXJLZXlMaXN0LmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3Qga2V5SWR4ID0ga2V5TGlzdC5pbmRleE9mKGtleSk7XG4gICAgICBpZiAoa2V5SWR4ID09PSAtMSkge1xuICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICB2dGtEZWJ1Z01hY3JvKGBhZGQgJHtrZXl9IGluIHNoYWxsb3dDb3B5YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleUxpc3Quc3BsaWNlKGtleUlkeCwgMSk7XG4gICAgICB9XG4gICAgICBtb2RlbFtrZXldID0gb3RoZXJNb2RlbFtrZXldO1xuICAgIH0pO1xuICAgIGlmIChrZXlMaXN0Lmxlbmd0aCAmJiBkZWJ1Zykge1xuICAgICAgdnRrRGVidWdNYWNybyhgVW50b3VjaGVkIGtleXM6ICR7a2V5TGlzdC5qb2luKCcsICcpfWApO1xuICAgIH1cblxuICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICB9O1xuXG4gIC8vIEFsbG93IHVzYWdlIGFzIGRlY29yYXRvclxuICByZXR1cm4gcHVibGljQVBJO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBnZXRYWFg6IGFkZCBnZXR0ZXJzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXQocHVibGljQVBJLCBtb2RlbCwgZmllbGROYW1lcykge1xuICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHB1YmxpY0FQSVtgZ2V0JHtjYXBpdGFsaXplKGZpZWxkLm5hbWUpfWBdID0gKCkgPT4gbW9kZWxbZmllbGQubmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1YmxpY0FQSVtgZ2V0JHtjYXBpdGFsaXplKGZpZWxkKX1gXSA9ICgpID0+IG1vZGVsW2ZpZWxkXTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzZXRYWFg6IGFkZCBzZXR0ZXJzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmNvbnN0IG9iamVjdFNldHRlck1hcCA9IHtcbiAgZW51bShwdWJsaWNBUEksIG1vZGVsLCBmaWVsZCkge1xuICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChmaWVsZC5lbnVtW3ZhbHVlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKG1vZGVsW2ZpZWxkLm5hbWVdICE9PSBmaWVsZC5lbnVtW3ZhbHVlXSkge1xuICAgICAgICAgICAgbW9kZWxbZmllbGQubmFtZV0gPSBmaWVsZC5lbnVtW3ZhbHVlXTtcbiAgICAgICAgICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2dGtFcnJvck1hY3JvKGBTZXQgRW51bSB3aXRoIGludmFsaWQgYXJndW1lbnQgJHtmaWVsZH0sICR7dmFsdWV9YCk7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdTZXQgRW51bSB3aXRoIGludmFsaWQgc3RyaW5nIGFyZ3VtZW50Jyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAobW9kZWxbZmllbGQubmFtZV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgT2JqZWN0LmtleXMoZmllbGQuZW51bSlcbiAgICAgICAgICAgICAgLm1hcCgoa2V5KSA9PiBmaWVsZC5lbnVtW2tleV0pXG4gICAgICAgICAgICAgIC5pbmRleE9mKHZhbHVlKSAhPT0gLTFcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIG1vZGVsW2ZpZWxkLm5hbWVdID0gdmFsdWU7XG4gICAgICAgICAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2dGtFcnJvck1hY3JvKGBTZXQgRW51bSBvdXRzaWRlIG51bWVyaWMgcmFuZ2UgJHtmaWVsZH0sICR7dmFsdWV9YCk7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1NldCBFbnVtIG91dHNpZGUgbnVtZXJpYyByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZ0a0Vycm9yTWFjcm8oXG4gICAgICAgIGBTZXQgRW51bSB3aXRoIGludmFsaWQgYXJndW1lbnQgKFN0cmluZy9OdW1iZXIpICR7ZmllbGR9LCAke3ZhbHVlfWBcbiAgICAgICk7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZXQgRW51bSB3aXRoIGludmFsaWQgYXJndW1lbnQgKFN0cmluZy9OdW1iZXIpJyk7XG4gICAgfTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIGZpbmRTZXR0ZXIoZmllbGQpIHtcbiAgaWYgKHR5cGVvZiBmaWVsZCA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCBmbiA9IG9iamVjdFNldHRlck1hcFtmaWVsZC50eXBlXTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJldHVybiAocHVibGljQVBJLCBtb2RlbCkgPT4gZm4ocHVibGljQVBJLCBtb2RlbCwgZmllbGQpO1xuICAgIH1cblxuICAgIHZ0a0Vycm9yTWFjcm8oYE5vIHNldHRlciBmb3IgZmllbGQgJHtmaWVsZH1gKTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdObyBzZXR0ZXIgZm9yIGZpZWxkJyk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGdldFNldHRlcihwdWJsaWNBUEksIG1vZGVsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHNldHRlcih2YWx1ZSkge1xuICAgICAgaWYgKG1vZGVsLmRlbGV0ZWQpIHtcbiAgICAgICAgdnRrRXJyb3JNYWNybygnaW5zdGFuY2UgZGVsZXRlZCAtIGNhbm5vdCBjYWxsIGFueSBtZXRob2QnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZWxbZmllbGRdICE9PSB2YWx1ZSkge1xuICAgICAgICBtb2RlbFtmaWVsZF0gPSB2YWx1ZTtcbiAgICAgICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQocHVibGljQVBJLCBtb2RlbCwgZmllbGRzKSB7XG4gIGZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZmllbGQgPT09ICdvYmplY3QnKSB7XG4gICAgICBwdWJsaWNBUElbYHNldCR7Y2FwaXRhbGl6ZShmaWVsZC5uYW1lKX1gXSA9IGZpbmRTZXR0ZXIoZmllbGQpKFxuICAgICAgICBwdWJsaWNBUEksXG4gICAgICAgIG1vZGVsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdWJsaWNBUElbYHNldCR7Y2FwaXRhbGl6ZShmaWVsZCl9YF0gPSBmaW5kU2V0dGVyKGZpZWxkKShcbiAgICAgICAgcHVibGljQVBJLFxuICAgICAgICBtb2RlbFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzZXQvZ2V0IFhYWDogYWRkIGJvdGggc2V0dGVycyBhbmQgZ2V0dGVyc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0R2V0KHB1YmxpY0FQSSwgbW9kZWwsIGZpZWxkTmFtZXMpIHtcbiAgZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIGZpZWxkTmFtZXMpO1xuICBzZXQocHVibGljQVBJLCBtb2RlbCwgZmllbGROYW1lcyk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGdldFhYWDogYWRkIGdldHRlcnMgZm9yIG9iamVjdCBvZiB0eXBlIGFycmF5IHdpdGggY29weSB0byBiZSBzYWZlXG4vLyBnZXRYWFhCeVJlZmVyZW5jZTogYWRkIGdldHRlcnMgZm9yIG9iamVjdCBvZiB0eXBlIGFycmF5IHdpdGhvdXQgY29weVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJyYXkocHVibGljQVBJLCBtb2RlbCwgZmllbGROYW1lcykge1xuICBmaWVsZE5hbWVzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgcHVibGljQVBJW2BnZXQke2NhcGl0YWxpemUoZmllbGQpfWBdID0gKCkgPT4gW10uY29uY2F0KG1vZGVsW2ZpZWxkXSk7XG4gICAgcHVibGljQVBJW2BnZXQke2NhcGl0YWxpemUoZmllbGQpfUJ5UmVmZXJlbmNlYF0gPSAoKSA9PiBtb2RlbFtmaWVsZF07XG4gIH0pO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzZXRYWFg6IGFkZCBzZXR0ZXIgZm9yIG9iamVjdCBvZiB0eXBlIGFycmF5XG4vLyBpZiAnZGVmYXVsdFZhbCcgaXMgc3VwcGxpZWQsIHNob3J0ZXIgYXJyYXlzIHdpbGwgYmUgcGFkZGVkIHRvICdzaXplJyB3aXRoICdkZWZhdWx0VmFsJ1xuLy8gc2V0Li4uRnJvbTogZmFzdCBwYXRoIHRvIGNvcHkgdGhlIGNvbnRlbnQgb2YgYW4gYXJyYXkgdG8gdGhlIGN1cnJlbnQgb25lIHdpdGhvdXQgY2FsbCB0byBtb2RpZmllZC5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEFycmF5KFxuICBwdWJsaWNBUEksXG4gIG1vZGVsLFxuICBmaWVsZE5hbWVzLFxuICBzaXplLFxuICBkZWZhdWx0VmFsID0gdW5kZWZpbmVkXG4pIHtcbiAgZmllbGROYW1lcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgIHB1YmxpY0FQSVtgc2V0JHtjYXBpdGFsaXplKGZpZWxkKX1gXSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICBpZiAobW9kZWwuZGVsZXRlZCkge1xuICAgICAgICB2dGtFcnJvck1hY3JvKCdpbnN0YW5jZSBkZWxldGVkIC0gY2Fubm90IGNhbGwgYW55IG1ldGhvZCcpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGxldCBhcnJheSA9IGFyZ3M7XG4gICAgICAvLyBhbGxvdyBhbiBhcnJheSBwYXNzZWQgYXMgYSBzaW5nbGUgYXJnLlxuICAgICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFycmF5WzBdKSkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItZGVzdHJ1Y3R1cmluZyAqL1xuICAgICAgICBhcnJheSA9IGFycmF5WzBdO1xuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHByZWZlci1kZXN0cnVjdHVyaW5nICovXG4gICAgICB9XG5cbiAgICAgIGlmIChhcnJheS5sZW5ndGggIT09IHNpemUpIHtcbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA8IHNpemUgJiYgZGVmYXVsdFZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYXJyYXkgPSBbXS5jb25jYXQoYXJyYXkpO1xuICAgICAgICAgIHdoaWxlIChhcnJheS5sZW5ndGggPCBzaXplKSBhcnJheS5wdXNoKGRlZmF1bHRWYWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgbnVtYmVyIG9mIHZhbHVlcyBmb3IgYXJyYXkgc2V0dGVyICgke2ZpZWxkfSlgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGNoYW5nZURldGVjdGVkID0gZmFsc2U7XG4gICAgICBtb2RlbFtmaWVsZF0uZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGl0ZW0gIT09IGFycmF5W2luZGV4XSkge1xuICAgICAgICAgIGlmIChjaGFuZ2VEZXRlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGFuZ2VEZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoY2hhbmdlRGV0ZWN0ZWQgfHwgbW9kZWxbZmllbGRdLmxlbmd0aCAhPT0gYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIG1vZGVsW2ZpZWxkXSA9IFtdLmNvbmNhdChhcnJheSk7XG4gICAgICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgcHVibGljQVBJW2BzZXQke2NhcGl0YWxpemUoZmllbGQpfUZyb21gXSA9IChvdGhlckFycmF5KSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBtb2RlbFtmaWVsZF07XG4gICAgICBvdGhlckFycmF5LmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgdGFyZ2V0W2ldID0gdjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0pO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBzZXQvZ2V0IFhYWDogYWRkIHNldHRlciBhbmQgZ2V0dGVyIGZvciBvYmplY3Qgb2YgdHlwZSBhcnJheVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0R2V0QXJyYXkoXG4gIHB1YmxpY0FQSSxcbiAgbW9kZWwsXG4gIGZpZWxkTmFtZXMsXG4gIHNpemUsXG4gIGRlZmF1bHRWYWwgPSB1bmRlZmluZWRcbikge1xuICBnZXRBcnJheShwdWJsaWNBUEksIG1vZGVsLCBmaWVsZE5hbWVzKTtcbiAgc2V0QXJyYXkocHVibGljQVBJLCBtb2RlbCwgZmllbGROYW1lcywgc2l6ZSwgZGVmYXVsdFZhbCk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHZ0a0FsZ29yaXRobTogc2V0SW5wdXREYXRhKCksIHNldElucHV0Q29ubmVjdGlvbigpLCBnZXRPdXRwdXREYXRhKCksIGdldE91dHB1dFBvcnQoKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gYWxnbyhwdWJsaWNBUEksIG1vZGVsLCBudW1iZXJPZklucHV0cywgbnVtYmVyT2ZPdXRwdXRzKSB7XG4gIGlmIChtb2RlbC5pbnB1dERhdGEpIHtcbiAgICBtb2RlbC5pbnB1dERhdGEgPSBtb2RlbC5pbnB1dERhdGEubWFwKHZ0ayk7XG4gIH0gZWxzZSB7XG4gICAgbW9kZWwuaW5wdXREYXRhID0gW107XG4gIH1cblxuICBpZiAobW9kZWwuaW5wdXRDb25uZWN0aW9uKSB7XG4gICAgbW9kZWwuaW5wdXRDb25uZWN0aW9uID0gbW9kZWwuaW5wdXRDb25uZWN0aW9uLm1hcCh2dGspO1xuICB9IGVsc2Uge1xuICAgIG1vZGVsLmlucHV0Q29ubmVjdGlvbiA9IFtdO1xuICB9XG5cbiAgaWYgKG1vZGVsLm91dHB1dCkge1xuICAgIG1vZGVsLm91dHB1dCA9IG1vZGVsLm91dHB1dC5tYXAodnRrKTtcbiAgfSBlbHNlIHtcbiAgICBtb2RlbC5vdXRwdXQgPSBbXTtcbiAgfVxuXG4gIGlmIChtb2RlbC5pbnB1dEFycmF5VG9Qcm9jZXNzKSB7XG4gICAgbW9kZWwuaW5wdXRBcnJheVRvUHJvY2VzcyA9IG1vZGVsLmlucHV0QXJyYXlUb1Byb2Nlc3MubWFwKHZ0ayk7XG4gIH0gZWxzZSB7XG4gICAgbW9kZWwuaW5wdXRBcnJheVRvUHJvY2VzcyA9IFtdO1xuICB9XG5cbiAgLy8gQ2FjaGUgdGhlIGFyZ3VtZW50IGZvciBsYXRlciBtYW5pcHVsYXRpb25cbiAgbW9kZWwubnVtYmVyT2ZJbnB1dHMgPSBudW1iZXJPZklucHV0cztcblxuICAvLyBNZXRob2RzXG4gIGZ1bmN0aW9uIHNldElucHV0RGF0YShkYXRhc2V0LCBwb3J0ID0gMCkge1xuICAgIGlmIChtb2RlbC5kZWxldGVkKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKCdpbnN0YW5jZSBkZWxldGVkIC0gY2Fubm90IGNhbGwgYW55IG1ldGhvZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocG9ydCA+PSBtb2RlbC5udW1iZXJPZklucHV0cykge1xuICAgICAgdnRrRXJyb3JNYWNybyhcbiAgICAgICAgYGFsZ29yaXRobSAke3B1YmxpY0FQSS5nZXRDbGFzc05hbWUoKX0gb25seSBoYXMgJHtcbiAgICAgICAgICBtb2RlbC5udW1iZXJPZklucHV0c1xuICAgICAgICB9IGlucHV0IHBvcnRzLiBUbyBhZGQgbW9yZSBpbnB1dCBwb3J0cywgdXNlIGFkZElucHV0RGF0YSgpYFxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG1vZGVsLmlucHV0RGF0YVtwb3J0XSAhPT0gZGF0YXNldCB8fCBtb2RlbC5pbnB1dENvbm5lY3Rpb25bcG9ydF0pIHtcbiAgICAgIG1vZGVsLmlucHV0RGF0YVtwb3J0XSA9IGRhdGFzZXQ7XG4gICAgICBtb2RlbC5pbnB1dENvbm5lY3Rpb25bcG9ydF0gPSBudWxsO1xuICAgICAgaWYgKHB1YmxpY0FQSS5tb2RpZmllZCkge1xuICAgICAgICBwdWJsaWNBUEkubW9kaWZpZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJbnB1dERhdGEocG9ydCA9IDApIHtcbiAgICBpZiAobW9kZWwuaW5wdXRDb25uZWN0aW9uW3BvcnRdKSB7XG4gICAgICBtb2RlbC5pbnB1dERhdGFbcG9ydF0gPSBtb2RlbC5pbnB1dENvbm5lY3Rpb25bcG9ydF0oKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsLmlucHV0RGF0YVtwb3J0XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldElucHV0Q29ubmVjdGlvbihvdXRwdXRQb3J0LCBwb3J0ID0gMCkge1xuICAgIGlmIChtb2RlbC5kZWxldGVkKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKCdpbnN0YW5jZSBkZWxldGVkIC0gY2Fubm90IGNhbGwgYW55IG1ldGhvZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocG9ydCA+PSBtb2RlbC5udW1iZXJPZklucHV0cykge1xuICAgICAgbGV0IG1zZyA9IGBhbGdvcml0aG0gJHtwdWJsaWNBUEkuZ2V0Q2xhc3NOYW1lKCl9IG9ubHkgaGFzIGA7XG4gICAgICBtc2cgKz0gYCR7bW9kZWwubnVtYmVyT2ZJbnB1dHN9YDtcbiAgICAgIG1zZyArPSAnIGlucHV0IHBvcnRzLiBUbyBhZGQgbW9yZSBpbnB1dCBwb3J0cywgdXNlIGFkZElucHV0Q29ubmVjdGlvbigpJztcbiAgICAgIHZ0a0Vycm9yTWFjcm8obXNnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbW9kZWwuaW5wdXREYXRhW3BvcnRdID0gbnVsbDtcbiAgICBtb2RlbC5pbnB1dENvbm5lY3Rpb25bcG9ydF0gPSBvdXRwdXRQb3J0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW5wdXRDb25uZWN0aW9uKHBvcnQgPSAwKSB7XG4gICAgcmV0dXJuIG1vZGVsLmlucHV0Q29ubmVjdGlvbltwb3J0XTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZElucHV0Q29ubmVjdGlvbihvdXRwdXRQb3J0KSB7XG4gICAgaWYgKG1vZGVsLmRlbGV0ZWQpIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oJ2luc3RhbmNlIGRlbGV0ZWQgLSBjYW5ub3QgY2FsbCBhbnkgbWV0aG9kJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1vZGVsLm51bWJlck9mSW5wdXRzKys7XG4gICAgc2V0SW5wdXRDb25uZWN0aW9uKG91dHB1dFBvcnQsIG1vZGVsLm51bWJlck9mSW5wdXRzIC0gMSk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRJbnB1dERhdGEoZGF0YXNldCkge1xuICAgIGlmIChtb2RlbC5kZWxldGVkKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKCdpbnN0YW5jZSBkZWxldGVkIC0gY2Fubm90IGNhbGwgYW55IG1ldGhvZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtb2RlbC5udW1iZXJPZklucHV0cysrO1xuICAgIHNldElucHV0RGF0YShkYXRhc2V0LCBtb2RlbC5udW1iZXJPZklucHV0cyAtIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3V0cHV0RGF0YShwb3J0ID0gMCkge1xuICAgIGlmIChtb2RlbC5kZWxldGVkKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKCdpbnN0YW5jZSBkZWxldGVkIC0gY2Fubm90IGNhbGwgYW55IG1ldGhvZCcpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChwdWJsaWNBUEkuc2hvdWxkVXBkYXRlKCkpIHtcbiAgICAgIHB1YmxpY0FQSS51cGRhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsLm91dHB1dFtwb3J0XTtcbiAgfVxuXG4gIHB1YmxpY0FQSS5zaG91bGRVcGRhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgbG9jYWxNVGltZSA9IHB1YmxpY0FQSS5nZXRNVGltZSgpO1xuICAgIGxldCBjb3VudCA9IG51bWJlck9mT3V0cHV0cztcbiAgICBsZXQgbWluT3V0cHV0TVRpbWUgPSBJbmZpbml0eTtcbiAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgaWYgKCFtb2RlbC5vdXRwdXRbY291bnRdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbXQgPSBtb2RlbC5vdXRwdXRbY291bnRdLmdldE1UaW1lKCk7XG4gICAgICBpZiAobXQgPCBsb2NhbE1UaW1lKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG10IDwgbWluT3V0cHV0TVRpbWUpIHtcbiAgICAgICAgbWluT3V0cHV0TVRpbWUgPSBtdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb3VudCA9IG1vZGVsLm51bWJlck9mSW5wdXRzO1xuICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICBpZiAoXG4gICAgICAgIG1vZGVsLmlucHV0Q29ubmVjdGlvbltjb3VudF0gJiZcbiAgICAgICAgbW9kZWwuaW5wdXRDb25uZWN0aW9uW2NvdW50XS5maWx0ZXIuc2hvdWxkVXBkYXRlKClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb3VudCA9IG1vZGVsLm51bWJlck9mSW5wdXRzO1xuICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHB1YmxpY0FQSS5nZXRJbnB1dERhdGEoY291bnQpICYmXG4gICAgICAgIHB1YmxpY0FQSS5nZXRJbnB1dERhdGEoY291bnQpLmdldE1UaW1lKCkgPiBtaW5PdXRwdXRNVGltZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0T3V0cHV0UG9ydChwb3J0ID0gMCkge1xuICAgIGNvbnN0IG91dHB1dFBvcnRBY2Nlc3MgPSAoKSA9PiBnZXRPdXRwdXREYXRhKHBvcnQpO1xuICAgIC8vIEFkZCByZWZlcmVuY2UgdG8gZmlsdGVyXG4gICAgb3V0cHV0UG9ydEFjY2Vzcy5maWx0ZXIgPSBwdWJsaWNBUEk7XG4gICAgcmV0dXJuIG91dHB1dFBvcnRBY2Nlc3M7XG4gIH1cblxuICAvLyBIYW5kbGUgaW5wdXQgaWYgbmVlZGVkXG4gIGlmIChtb2RlbC5udW1iZXJPZklucHV0cykge1xuICAgIC8vIFJlc2VydmUgaW5wdXRzXG4gICAgbGV0IGNvdW50ID0gbW9kZWwubnVtYmVyT2ZJbnB1dHM7XG4gICAgd2hpbGUgKGNvdW50LS0pIHtcbiAgICAgIG1vZGVsLmlucHV0RGF0YS5wdXNoKG51bGwpO1xuICAgICAgbW9kZWwuaW5wdXRDb25uZWN0aW9uLnB1c2gobnVsbCk7XG4gICAgfVxuXG4gICAgLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzXG4gICAgcHVibGljQVBJLnNldElucHV0RGF0YSA9IHNldElucHV0RGF0YTtcbiAgICBwdWJsaWNBUEkuc2V0SW5wdXRDb25uZWN0aW9uID0gc2V0SW5wdXRDb25uZWN0aW9uO1xuICAgIHB1YmxpY0FQSS5hZGRJbnB1dERhdGEgPSBhZGRJbnB1dERhdGE7XG4gICAgcHVibGljQVBJLmFkZElucHV0Q29ubmVjdGlvbiA9IGFkZElucHV0Q29ubmVjdGlvbjtcbiAgICBwdWJsaWNBUEkuZ2V0SW5wdXREYXRhID0gZ2V0SW5wdXREYXRhO1xuICAgIHB1YmxpY0FQSS5nZXRJbnB1dENvbm5lY3Rpb24gPSBnZXRJbnB1dENvbm5lY3Rpb247XG4gIH1cblxuICBpZiAobnVtYmVyT2ZPdXRwdXRzKSB7XG4gICAgcHVibGljQVBJLmdldE91dHB1dERhdGEgPSBnZXRPdXRwdXREYXRhO1xuICAgIHB1YmxpY0FQSS5nZXRPdXRwdXRQb3J0ID0gZ2V0T3V0cHV0UG9ydDtcbiAgfVxuXG4gIHB1YmxpY0FQSS51cGRhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgaW5zID0gW107XG4gICAgaWYgKG1vZGVsLm51bWJlck9mSW5wdXRzKSB7XG4gICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgd2hpbGUgKGNvdW50IDwgbW9kZWwubnVtYmVyT2ZJbnB1dHMpIHtcbiAgICAgICAgaW5zW2NvdW50XSA9IHB1YmxpY0FQSS5nZXRJbnB1dERhdGEoY291bnQpO1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHVibGljQVBJLnNob3VsZFVwZGF0ZSgpICYmIHB1YmxpY0FQSS5yZXF1ZXN0RGF0YSkge1xuICAgICAgcHVibGljQVBJLnJlcXVlc3REYXRhKGlucywgbW9kZWwub3V0cHV0KTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmdldE51bWJlck9mSW5wdXRQb3J0cyA9ICgpID0+IG1vZGVsLm51bWJlck9mSW5wdXRzO1xuICBwdWJsaWNBUEkuZ2V0TnVtYmVyT2ZPdXRwdXRQb3J0cyA9ICgpID0+XG4gICAgbnVtYmVyT2ZPdXRwdXRzIHx8IG1vZGVsLm91dHB1dC5sZW5ndGg7XG5cbiAgcHVibGljQVBJLmdldElucHV0QXJyYXlUb1Byb2Nlc3MgPSAoaW5wdXRQb3J0KSA9PiB7XG4gICAgY29uc3QgYXJyYXlEZXNjID0gbW9kZWwuaW5wdXRBcnJheVRvUHJvY2Vzc1tpbnB1dFBvcnRdO1xuICAgIGNvbnN0IGRzID0gbW9kZWwuaW5wdXREYXRhW2lucHV0UG9ydF07XG4gICAgaWYgKGFycmF5RGVzYyAmJiBkcykge1xuICAgICAgcmV0dXJuIGRzW2BnZXQke2FycmF5RGVzYy5maWVsZEFzc29jaWF0aW9ufWBdKCkuZ2V0QXJyYXkoXG4gICAgICAgIGFycmF5RGVzYy5hcnJheU5hbWVcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBwdWJsaWNBUEkuc2V0SW5wdXRBcnJheVRvUHJvY2VzcyA9IChcbiAgICBpbnB1dFBvcnQsXG4gICAgYXJyYXlOYW1lLFxuICAgIGZpZWxkQXNzb2NpYXRpb24sXG4gICAgYXR0cmlidXRlVHlwZSA9ICdTY2FsYXJzJ1xuICApID0+IHtcbiAgICB3aGlsZSAobW9kZWwuaW5wdXRBcnJheVRvUHJvY2Vzcy5sZW5ndGggPCBpbnB1dFBvcnQpIHtcbiAgICAgIG1vZGVsLmlucHV0QXJyYXlUb1Byb2Nlc3MucHVzaChudWxsKTtcbiAgICB9XG4gICAgbW9kZWwuaW5wdXRBcnJheVRvUHJvY2Vzc1tpbnB1dFBvcnRdID0ge1xuICAgICAgYXJyYXlOYW1lLFxuICAgICAgZmllbGRBc3NvY2lhdGlvbixcbiAgICAgIGF0dHJpYnV0ZVR5cGUsXG4gICAgfTtcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRXZlbnQgaGFuZGxpbmc6IG9uWFhYKGNhbGxiYWNrKSwgaW52b2tlWFhYKGFyZ3MuLi4pXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBjb25zdCBFVkVOVF9BQk9SVCA9IFN5bWJvbCgnRXZlbnQgYWJvcnQnKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGV2ZW50KHB1YmxpY0FQSSwgbW9kZWwsIGV2ZW50TmFtZSkge1xuICBjb25zdCBjYWxsYmFja3MgPSBbXTtcbiAgY29uc3QgcHJldmlvdXNEZWxldGUgPSBwdWJsaWNBUEkuZGVsZXRlO1xuICBsZXQgY3VyQ2FsbGJhY2tJRCA9IDE7XG5cbiAgZnVuY3Rpb24gb2ZmKGNhbGxiYWNrSUQpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgW2NiSURdID0gY2FsbGJhY2tzW2ldO1xuICAgICAgaWYgKGNiSUQgPT09IGNhbGxiYWNrSUQpIHtcbiAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKGNhbGxiYWNrSUQpIHtcbiAgICBmdW5jdGlvbiB1bnN1YnNjcmliZSgpIHtcbiAgICAgIG9mZihjYWxsYmFja0lEKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgdW5zdWJzY3JpYmUsXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2UoKSB7XG4gICAgaWYgKG1vZGVsLmRlbGV0ZWQpIHtcbiAgICAgIHZ0a0Vycm9yTWFjcm8oJ2luc3RhbmNlIGRlbGV0ZWQgLSBjYW5ub3QgY2FsbCBhbnkgbWV0aG9kJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1yZXN0LXBhcmFtcyAqL1xuICAgIC8vIEdvIHRocm91Z2ggYSBjb3B5IG9mIHRoZSBjYWxsYmFja3MgYXJyYXkgaW4gY2FzZSBuZXcgY2FsbGJhY2tzXG4gICAgLy8gZ2V0IHByZXBlbmRlZCB3aXRoaW4gcHJldmlvdXMgY2FsbGJhY2tzXG4gICAgY29uc3QgY3VycmVudENhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBjdXJyZW50Q2FsbGJhY2tzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgY29uc3QgWywgY2IsIHByaW9yaXR5XSA9IGN1cnJlbnRDYWxsYmFja3NbaW5kZXhdO1xuXG4gICAgICBpZiAoIWNiKSB7XG4gICAgICAgIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICB9XG5cbiAgICAgIGlmIChwcmlvcml0eSA8IDApIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBjYi5hcHBseShwdWJsaWNBUEksIGFyZ3VtZW50cyksIDEgLSBwcmlvcml0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBYm9ydCBvbmx5IGlmIHRoZSBjYWxsYmFjayBleHBsaWNpdGx5IHJldHVybnMgZmFsc2VcbiAgICAgICAgY29uc3QgY29udGludWVOZXh0ID0gY2IuYXBwbHkocHVibGljQVBJLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoY29udGludWVOZXh0ID09PSBFVkVOVF9BQk9SVCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgcHJlZmVyLXJlc3QtcGFyYW1zICovXG4gIH1cblxuICBwdWJsaWNBUElbYGludm9rZSR7Y2FwaXRhbGl6ZShldmVudE5hbWUpfWBdID0gaW52b2tlO1xuXG4gIHB1YmxpY0FQSVtgb24ke2NhcGl0YWxpemUoZXZlbnROYW1lKX1gXSA9IChjYWxsYmFjaywgcHJpb3JpdHkgPSAwLjApID0+IHtcbiAgICBpZiAoIWNhbGxiYWNrLmFwcGx5KSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBJbnZhbGlkIGNhbGxiYWNrIGZvciBldmVudCAke2V2ZW50TmFtZX1gKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChtb2RlbC5kZWxldGVkKSB7XG4gICAgICB2dGtFcnJvck1hY3JvKCdpbnN0YW5jZSBkZWxldGVkIC0gY2Fubm90IGNhbGwgYW55IG1ldGhvZCcpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgY2FsbGJhY2tJRCA9IGN1ckNhbGxiYWNrSUQrKztcbiAgICBjYWxsYmFja3MucHVzaChbY2FsbGJhY2tJRCwgY2FsbGJhY2ssIHByaW9yaXR5XSk7XG4gICAgY2FsbGJhY2tzLnNvcnQoKGNiMSwgY2IyKSA9PiBjYjJbMl0gLSBjYjFbMl0pO1xuICAgIHJldHVybiBvbihjYWxsYmFja0lEKTtcbiAgfTtcblxuICBwdWJsaWNBUEkuZGVsZXRlID0gKCkgPT4ge1xuICAgIHByZXZpb3VzRGVsZXRlKCk7XG4gICAgY2FsbGJhY2tzLmZvckVhY2goKFtjYklEXSkgPT4gb2ZmKGNiSUQpKTtcbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gbmV3SW5zdGFuY2Vcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIG5ld0luc3RhbmNlKGV4dGVuZCwgY2xhc3NOYW1lKSB7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gKGluaXRpYWxWYWx1ZXMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG1vZGVsID0ge307XG4gICAgY29uc3QgcHVibGljQVBJID0ge307XG4gICAgZXh0ZW5kKHB1YmxpY0FQSSwgbW9kZWwsIGluaXRpYWxWYWx1ZXMpO1xuXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUocHVibGljQVBJKTtcbiAgfTtcblxuICAvLyBSZWdpc3RlciBjb25zdHJ1Y3RvciB0byBmYWN0b3J5XG4gIGlmIChjbGFzc05hbWUpIHtcbiAgICB2dGsucmVnaXN0ZXIoY2xhc3NOYW1lLCBjb25zdHJ1Y3Rvcik7XG4gIH1cblxuICByZXR1cm4gY29uc3RydWN0b3I7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENoYWluIGZ1bmN0aW9uIGNhbGxzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBjaGFpbiguLi5mbikge1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IGZuLmZpbHRlcigoaSkgPT4gISFpKS5tYXAoKGkpID0+IGkoLi4uYXJncykpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTb21lIHV0aWxpdHkgbWV0aG9kcyBmb3IgdnRrIG9iamVjdHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVnRrT2JqZWN0KGluc3RhbmNlKSB7XG4gIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZS5pc0EgJiYgaW5zdGFuY2UuaXNBKCd2dGtPYmplY3QnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYXZlcnNlSW5zdGFuY2VUcmVlKFxuICBpbnN0YW5jZSxcbiAgZXh0cmFjdEZ1bmN0aW9uLFxuICBhY2N1bXVsYXRvciA9IFtdLFxuICB2aXNpdGVkSW5zdGFuY2VzID0gW11cbikge1xuICBpZiAoaXNWdGtPYmplY3QoaW5zdGFuY2UpKSB7XG4gICAgaWYgKHZpc2l0ZWRJbnN0YW5jZXMuaW5kZXhPZihpbnN0YW5jZSkgPj0gMCkge1xuICAgICAgLy8gYXZvaWQgY3ljbGVzXG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgdmlzaXRlZEluc3RhbmNlcy5wdXNoKGluc3RhbmNlKTtcbiAgICBjb25zdCByZXN1bHQgPSBleHRyYWN0RnVuY3Rpb24oaW5zdGFuY2UpO1xuICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYWNjdW11bGF0b3IucHVzaChyZXN1bHQpO1xuICAgIH1cblxuICAgIC8vIE5vdyBnbyB0aHJvdWdoIHRoaXMgaW5zdGFuY2UncyBtb2RlbFxuICAgIGNvbnN0IG1vZGVsID0gaW5zdGFuY2UuZ2V0KCk7XG4gICAgT2JqZWN0LmtleXMobW9kZWwpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgbW9kZWxPYmogPSBtb2RlbFtrZXldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobW9kZWxPYmopKSB7XG4gICAgICAgIG1vZGVsT2JqLmZvckVhY2goKHN1Yk9iaikgPT4ge1xuICAgICAgICAgIHRyYXZlcnNlSW5zdGFuY2VUcmVlKFxuICAgICAgICAgICAgc3ViT2JqLFxuICAgICAgICAgICAgZXh0cmFjdEZ1bmN0aW9uLFxuICAgICAgICAgICAgYWNjdW11bGF0b3IsXG4gICAgICAgICAgICB2aXNpdGVkSW5zdGFuY2VzXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmF2ZXJzZUluc3RhbmNlVHJlZShcbiAgICAgICAgICBtb2RlbE9iaixcbiAgICAgICAgICBleHRyYWN0RnVuY3Rpb24sXG4gICAgICAgICAgYWNjdW11bGF0b3IsXG4gICAgICAgICAgdmlzaXRlZEluc3RhbmNlc1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XG4vLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4vLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbi8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzO1xuICAgIGNvbnN0IGxhdGVyID0gKCkgPT4ge1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgIGlmIChjYWxsTm93KSB7XG4gICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuLy8gZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy5cblxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCBkZWxheSkge1xuICBsZXQgaXNUaHJvdHRsZWQgPSBmYWxzZTtcbiAgbGV0IGFyZ3NUb1VzZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICBpc1Rocm90dGxlZCA9IGZhbHNlO1xuICAgIGlmIChhcmdzVG9Vc2UgIT09IG51bGwpIHtcbiAgICAgIHdyYXBwZXIoLi4uYXJnc1RvVXNlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgYXJnc1RvVXNlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwcGVyKC4uLmFyZ3MpIHtcbiAgICBpZiAoaXNUaHJvdHRsZWQpIHtcbiAgICAgIGFyZ3NUb1VzZSA9IGFyZ3M7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzVGhyb3R0bGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjayguLi5hcmdzKTtcbiAgICBzZXRUaW1lb3V0KG5leHQsIGRlbGF5KTtcbiAgfVxuXG4gIHJldHVybiB3cmFwcGVyO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBrZXlzdG9yZShwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsS2V5c3RvcmUpXG4vL1xuLy8gICAgLSBpbml0aWFsS2V5c3RvcmU6IEluaXRpYWwga2V5c3RvcmUuIFRoaXMgY2FuIGJlIGVpdGhlciBhIE1hcCBvciBhblxuLy8gICAgICBvYmplY3QuXG4vL1xuLy8gR2VuZXJhdGVkIEFQSVxuLy8gIHNldEtleShrZXksIHZhbHVlKSA6IG1peGVkIChyZXR1cm5zIHZhbHVlKVxuLy8gIGdldEtleShrZXkpIDogbWl4ZWRcbi8vICBnZXRBbGxLZXlzKCkgOiBbbWl4ZWRdXG4vLyAgZGVsZXRlS2V5KGtleSkgOiBCb29sZWFuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydCBmdW5jdGlvbiBrZXlzdG9yZShwdWJsaWNBUEksIG1vZGVsLCBpbml0aWFsS2V5c3RvcmUgPSB7fSkge1xuICBtb2RlbC5rZXlzdG9yZSA9IE9iamVjdC5hc3NpZ24obW9kZWwua2V5c3RvcmUgfHwge30sIGluaXRpYWxLZXlzdG9yZSk7XG5cbiAgcHVibGljQVBJLnNldEtleSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgbW9kZWwua2V5c3RvcmVba2V5XSA9IHZhbHVlO1xuICB9O1xuICBwdWJsaWNBUEkuZ2V0S2V5ID0gKGtleSkgPT4gbW9kZWwua2V5c3RvcmVba2V5XTtcbiAgcHVibGljQVBJLmdldEFsbEtleXMgPSAoKSA9PiBPYmplY3Qua2V5cyhtb2RlbC5rZXlzdG9yZSk7XG4gIHB1YmxpY0FQSS5kZWxldGVLZXkgPSAoa2V5KSA9PiBkZWxldGUgbW9kZWwua2V5c3RvcmVba2V5XTtcbiAgcHVibGljQVBJLmNsZWFyS2V5c3RvcmUgPSAoKSA9PlxuICAgIHB1YmxpY0FQSS5nZXRBbGxLZXlzKCkuZm9yRWFjaCgoa2V5KSA9PiBkZWxldGUgbW9kZWwua2V5c3RvcmVba2V5XSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIHByb3h5KHB1YmxpY0FQSSwgbW9kZWwsIHNlY3Rpb25OYW1lLCBwcm9wZXJ0eVVJKVxuLy9cbi8vICAgIC0gc2VjdGlvbk5hbWU6IE5hbWUgb2YgdGhlIHNlY3Rpb24gZm9yIFVJXG4vLyAgICAtIHByb3BlcnR5VUk6IExpc3Qgb2YgcHJvcHMgd2l0aCB0aGVpciBVSSBkZXNjcmlwdGlvblxuLy9cbi8vIEdlbmVyYXRlZCBBUElcbi8vICBnZXRQcm94eUlkKCkgOiBTdHJpbmdcbi8vICBsaXN0UHJveHlQcm9wZXJ0aWVzKCkgOiBbc3RyaW5nXVxuLy8gIHVwZGF0ZVByb3h5UHJvcGVydHkobmFtZSwgcHJvcClcbi8vICBnZXRQcm94eVNlY3Rpb24oKSA9PiBMaXN0IG9mIHByb3BlcnRpZXMgZm9yIFVJIGdlbmVyYXRpb25cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmxldCBuZXh0UHJveHlJZCA9IDE7XG5jb25zdCBST09UX0dST1VQX05BTUUgPSAnX19yb290X18nO1xuXG5leHBvcnQgZnVuY3Rpb24gcHJveHkocHVibGljQVBJLCBtb2RlbCkge1xuICAvLyBQcm94aWVzIGFyZSBrZXlzdG9yZXNcbiAga2V5c3RvcmUocHVibGljQVBJLCBtb2RlbCk7XG5cbiAgY29uc3QgcGFyZW50RGVsZXRlID0gcHVibGljQVBJLmRlbGV0ZTtcblxuICAvLyBnZXRQcm94eUlkXG4gIG1vZGVsLnByb3h5SWQgPSBgJHtuZXh0UHJveHlJZCsrfWA7XG5cbiAgLy8gdWkgaGFuZGxpbmdcbiAgbW9kZWwudWkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1vZGVsLnVpIHx8IFtdKSk7IC8vIGRlZXAgY29weVxuICBnZXQocHVibGljQVBJLCBtb2RlbCwgWydwcm94eUlkJywgJ3Byb3h5R3JvdXAnLCAncHJveHlOYW1lJ10pO1xuICBzZXRHZXQocHVibGljQVBJLCBtb2RlbCwgWydwcm94eU1hbmFnZXInXSk7XG5cbiAgLy8gZ3JvdXAgcHJvcGVydGllc1xuICBjb25zdCBwcm9wZXJ0eU1hcCA9IHt9O1xuICBjb25zdCBncm91cENoaWxkcmVuTmFtZXMgPSB7fTtcblxuICBmdW5jdGlvbiByZWdpc3RlclByb3BlcnRpZXMoZGVzY3JpcHRpb25MaXN0LCBjdXJyZW50R3JvdXBOYW1lKSB7XG4gICAgaWYgKCFncm91cENoaWxkcmVuTmFtZXNbY3VycmVudEdyb3VwTmFtZV0pIHtcbiAgICAgIGdyb3VwQ2hpbGRyZW5OYW1lc1tjdXJyZW50R3JvdXBOYW1lXSA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZHJlbk5hbWVzID0gZ3JvdXBDaGlsZHJlbk5hbWVzW2N1cnJlbnRHcm91cE5hbWVdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZXNjcmlwdGlvbkxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkcmVuTmFtZXMucHVzaChkZXNjcmlwdGlvbkxpc3RbaV0ubmFtZSk7XG4gICAgICBwcm9wZXJ0eU1hcFtkZXNjcmlwdGlvbkxpc3RbaV0ubmFtZV0gPSBkZXNjcmlwdGlvbkxpc3RbaV07XG4gICAgICBpZiAoZGVzY3JpcHRpb25MaXN0W2ldLmNoaWxkcmVuICYmIGRlc2NyaXB0aW9uTGlzdFtpXS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmVnaXN0ZXJQcm9wZXJ0aWVzKFxuICAgICAgICAgIGRlc2NyaXB0aW9uTGlzdFtpXS5jaGlsZHJlbixcbiAgICAgICAgICBkZXNjcmlwdGlvbkxpc3RbaV0ubmFtZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZWdpc3RlclByb3BlcnRpZXMobW9kZWwudWksIFJPT1RfR1JPVVBfTkFNRSk7XG5cbiAgcHVibGljQVBJLnVwZGF0ZVVJID0gKHVpKSA9PiB7XG4gICAgbW9kZWwudWkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHVpIHx8IFtdKSk7IC8vIGRlZXAgY29weVxuICAgIE9iamVjdC5rZXlzKHByb3BlcnR5TWFwKS5mb3JFYWNoKChrKSA9PiBkZWxldGUgcHJvcGVydHlNYXBba10pO1xuICAgIE9iamVjdC5rZXlzKGdyb3VwQ2hpbGRyZW5OYW1lcykuZm9yRWFjaChcbiAgICAgIChrKSA9PiBkZWxldGUgZ3JvdXBDaGlsZHJlbk5hbWVzW2tdXG4gICAgKTtcbiAgICByZWdpc3RlclByb3BlcnRpZXMobW9kZWwudWksIFJPT1RfR1JPVVBfTkFNRSk7XG4gICAgcHVibGljQVBJLm1vZGlmaWVkKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbGlzdFByb3h5UHJvcGVydGllcyhnTmFtZSA9IFJPT1RfR1JPVVBfTkFNRSkge1xuICAgIHJldHVybiBncm91cENoaWxkcmVuTmFtZXNbZ05hbWVdO1xuICB9XG5cbiAgcHVibGljQVBJLnVwZGF0ZVByb3h5UHJvcGVydHkgPSAocHJvcGVydHlOYW1lLCBwcm9wVUkpID0+IHtcbiAgICBjb25zdCBwcm9wID0gcHJvcGVydHlNYXBbcHJvcGVydHlOYW1lXTtcbiAgICBpZiAocHJvcCkge1xuICAgICAgT2JqZWN0LmFzc2lnbihwcm9wLCBwcm9wVUkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wZXJ0eU1hcFtwcm9wZXJ0eU5hbWVdID0geyAuLi5wcm9wVUkgfTtcbiAgICB9XG4gIH07XG5cbiAgcHVibGljQVBJLmFjdGl2YXRlID0gKCkgPT4ge1xuICAgIGlmIChtb2RlbC5wcm94eU1hbmFnZXIpIHtcbiAgICAgIGNvbnN0IHNldEFjdGl2ZU1ldGhvZCA9IGBzZXRBY3RpdmUke2NhcGl0YWxpemUoXG4gICAgICAgIHB1YmxpY0FQSS5nZXRQcm94eUdyb3VwKCkuc2xpY2UoMCwgLTEpXG4gICAgICApfWA7XG4gICAgICBpZiAobW9kZWwucHJveHlNYW5hZ2VyW3NldEFjdGl2ZU1ldGhvZF0pIHtcbiAgICAgICAgbW9kZWwucHJveHlNYW5hZ2VyW3NldEFjdGl2ZU1ldGhvZF0ocHVibGljQVBJKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gcHJvcGVydHkgbGlua1xuICBtb2RlbC5wcm9wZXJ0eUxpbmtTdWJzY3JpYmVycyA9IHt9O1xuICBwdWJsaWNBUEkucmVnaXN0ZXJQcm9wZXJ0eUxpbmtGb3JHQyA9IChvdGhlckxpbmssIHR5cGUpID0+IHtcbiAgICBpZiAoISh0eXBlIGluIG1vZGVsLnByb3BlcnR5TGlua1N1YnNjcmliZXJzKSkge1xuICAgICAgbW9kZWwucHJvcGVydHlMaW5rU3Vic2NyaWJlcnNbdHlwZV0gPSBbXTtcbiAgICB9XG4gICAgbW9kZWwucHJvcGVydHlMaW5rU3Vic2NyaWJlcnNbdHlwZV0ucHVzaChvdGhlckxpbmspO1xuICB9O1xuXG4gIHB1YmxpY0FQSS5nY1Byb3BlcnR5TGlua3MgPSAodHlwZSkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmliZXJzID0gbW9kZWwucHJvcGVydHlMaW5rU3Vic2NyaWJlcnNbdHlwZV0gfHwgW107XG4gICAgd2hpbGUgKHN1YnNjcmliZXJzLmxlbmd0aCkge1xuICAgICAgc3Vic2NyaWJlcnMucG9wKCkudW5iaW5kKHB1YmxpY0FQSSk7XG4gICAgfVxuICB9O1xuXG4gIG1vZGVsLnByb3BlcnR5TGlua01hcCA9IHt9O1xuICBwdWJsaWNBUEkuZ2V0UHJvcGVydHlMaW5rID0gKGlkLCBwZXJzaXN0ZW50ID0gZmFsc2UpID0+IHtcbiAgICBpZiAobW9kZWwucHJvcGVydHlMaW5rTWFwW2lkXSkge1xuICAgICAgcmV0dXJuIG1vZGVsLnByb3BlcnR5TGlua01hcFtpZF07XG4gICAgfVxuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgY29uc3QgbGlua3MgPSBbXTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGxldCB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGUoc291cmNlLCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmVlZFVwZGF0ZSA9IFtdO1xuICAgICAgbGV0IHNvdXJjZUxpbmsgPSBudWxsO1xuICAgICAgY291bnQgPSBsaW5rcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgICBjb25zdCBsaW5rID0gbGlua3NbY291bnRdO1xuICAgICAgICBpZiAobGluay5pbnN0YW5jZSA9PT0gc291cmNlKSB7XG4gICAgICAgICAgc291cmNlTGluayA9IGxpbms7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmVlZFVwZGF0ZS5wdXNoKGxpbmspO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc291cmNlTGluaykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3VmFsdWUgPSBzb3VyY2VMaW5rLmluc3RhbmNlW1xuICAgICAgICBgZ2V0JHtjYXBpdGFsaXplKHNvdXJjZUxpbmsucHJvcGVydHlOYW1lKX1gXG4gICAgICBdKCk7XG4gICAgICBpZiAoIXNoYWxsb3dFcXVhbHMobmV3VmFsdWUsIHZhbHVlKSB8fCBmb3JjZSkge1xuICAgICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKG5lZWRVcGRhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc3QgbGlua1RvVXBkYXRlID0gbmVlZFVwZGF0ZS5wb3AoKTtcbiAgICAgICAgICBsaW5rVG9VcGRhdGUuaW5zdGFuY2Uuc2V0KHtcbiAgICAgICAgICAgIFtsaW5rVG9VcGRhdGUucHJvcGVydHlOYW1lXTogdmFsdWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZWwucHJvcGVydHlMaW5rTWFwW2lkXS5wZXJzaXN0ZW50KSB7XG4gICAgICAgIG1vZGVsLnByb3BlcnR5TGlua01hcFtpZF0udmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuYmluZChpbnN0YW5jZSwgcHJvcGVydHlOYW1lKSB7XG4gICAgICBjb25zdCBpbmRleFRvRGVsZXRlID0gW107XG4gICAgICBjb3VudCA9IGxpbmtzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICAgIGNvbnN0IGxpbmsgPSBsaW5rc1tjb3VudF07XG4gICAgICAgIGlmIChcbiAgICAgICAgICBsaW5rLmluc3RhbmNlID09PSBpbnN0YW5jZSAmJlxuICAgICAgICAgIChsaW5rLnByb3BlcnR5TmFtZSA9PT0gcHJvcGVydHlOYW1lIHx8IHByb3BlcnR5TmFtZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICApIHtcbiAgICAgICAgICBsaW5rLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICAgIGluZGV4VG9EZWxldGUucHVzaChjb3VudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChpbmRleFRvRGVsZXRlLmxlbmd0aCkge1xuICAgICAgICBsaW5rcy5zcGxpY2UoaW5kZXhUb0RlbGV0ZS5wb3AoKSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmluZChpbnN0YW5jZSwgcHJvcGVydHlOYW1lLCB1cGRhdGVNZSA9IGZhbHNlKSB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBpbnN0YW5jZS5vbk1vZGlmaWVkKHVwZGF0ZSk7XG4gICAgICBjb25zdCBvdGhlciA9IGxpbmtzWzBdO1xuICAgICAgbGlua3MucHVzaCh7XG4gICAgICAgIGluc3RhbmNlLFxuICAgICAgICBwcm9wZXJ0eU5hbWUsXG4gICAgICAgIHN1YnNjcmlwdGlvbixcbiAgICAgIH0pO1xuICAgICAgaWYgKHVwZGF0ZU1lKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBtb2RlbC5wcm9wZXJ0eUxpbmtNYXBbaWRdLnBlcnNpc3RlbnQgJiZcbiAgICAgICAgICBtb2RlbC5wcm9wZXJ0eUxpbmtNYXBbaWRdLnZhbHVlICE9PSB1bmRlZmluZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgaW5zdGFuY2Uuc2V0KHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eU5hbWVdOiBtb2RlbC5wcm9wZXJ0eUxpbmtNYXBbaWRdLnZhbHVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKG90aGVyKSB7XG4gICAgICAgICAgdXBkYXRlKG90aGVyLmluc3RhbmNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHVuYmluZChpbnN0YW5jZSwgcHJvcGVydHlOYW1lKSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG4gICAgICB3aGlsZSAobGlua3MubGVuZ3RoKSB7XG4gICAgICAgIGxpbmtzLnBvcCgpLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGxpbmtIYW5kbGVyID0ge1xuICAgICAgYmluZCxcbiAgICAgIHVuYmluZCxcbiAgICAgIHVuc3Vic2NyaWJlLFxuICAgICAgcGVyc2lzdGVudCxcbiAgICB9O1xuICAgIG1vZGVsLnByb3BlcnR5TGlua01hcFtpZF0gPSBsaW5rSGFuZGxlcjtcbiAgICByZXR1cm4gbGlua0hhbmRsZXI7XG4gIH07XG5cbiAgLy8gZXh0cmFjdCB2YWx1ZXNcbiAgZnVuY3Rpb24gZ2V0UHJvcGVydGllcyhncm91cE5hbWUgPSBST09UX0dST1VQX05BTUUpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICBjb25zdCBpZCA9IG1vZGVsLnByb3h5SWQ7XG4gICAgY29uc3QgcHJvcGVydHlOYW1lcyA9IGxpc3RQcm94eVByb3BlcnRpZXMoZ3JvdXBOYW1lKSB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb3BlcnR5TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBwcm9wZXJ0eU5hbWVzW2ldO1xuICAgICAgY29uc3QgbWV0aG9kID0gcHVibGljQVBJW2BnZXQke2NhcGl0YWxpemUobmFtZSl9YF07XG4gICAgICBjb25zdCB2YWx1ZSA9IG1ldGhvZCA/IG1ldGhvZCgpIDogdW5kZWZpbmVkO1xuICAgICAgY29uc3QgcHJvcCA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgfTtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0UHJvcGVydGllcyhuYW1lKTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcHJvcC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgfVxuICAgICAgdmFsdWVzLnB1c2gocHJvcCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICBwdWJsaWNBUEkubGlzdFByb3BlcnR5TmFtZXMgPSAoKSA9PiBnZXRQcm9wZXJ0aWVzKCkubWFwKChwKSA9PiBwLm5hbWUpO1xuXG4gIHB1YmxpY0FQSS5nZXRQcm9wZXJ0eUJ5TmFtZSA9IChuYW1lKSA9PlxuICAgIGdldFByb3BlcnRpZXMoKS5maW5kKChwKSA9PiBwLm5hbWUgPT09IG5hbWUpO1xuXG4gIHB1YmxpY0FQSS5nZXRQcm9wZXJ0eURvbWFpbkJ5TmFtZSA9IChuYW1lKSA9PlxuICAgIChwcm9wZXJ0eU1hcFtuYW1lXSB8fCB7fSkuZG9tYWluO1xuXG4gIC8vIHVpIHNlY3Rpb25cbiAgcHVibGljQVBJLmdldFByb3h5U2VjdGlvbiA9ICgpID0+ICh7XG4gICAgaWQ6IG1vZGVsLnByb3h5SWQsXG4gICAgbmFtZTogbW9kZWwucHJveHlHcm91cCxcbiAgICB1aTogbW9kZWwudWksXG4gICAgcHJvcGVydGllczogZ2V0UHJvcGVydGllcygpLFxuICB9KTtcblxuICAvLyBmcmVlIHJlc291cmNlc1xuICBwdWJsaWNBUEkuZGVsZXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IGxpc3QgPSBPYmplY3Qua2V5cyhtb2RlbC5wcm9wZXJ0eUxpbmtNYXApO1xuICAgIGxldCBjb3VudCA9IGxpc3QubGVuZ3RoO1xuICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICBtb2RlbC5wcm9wZXJ0eUxpbmtNYXBbbGlzdFtjb3VudF1dLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKG1vZGVsLnByb3BlcnR5TGlua1N1YnNjcmliZXJzKS5mb3JFYWNoKFxuICAgICAgcHVibGljQVBJLmdjUHJvcGVydHlMaW5rc1xuICAgICk7XG4gICAgcGFyZW50RGVsZXRlKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJMaW5rcygpIHtcbiAgICAvLyBBbGxvdyBkeW5hbWljIHJlZ2lzdHJhdGlvbiBvZiBsaW5rcyBhdCB0aGUgYXBwbGljYXRpb24gbGV2ZWxcbiAgICBpZiAobW9kZWwubGlua3MpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW9kZWwubGlua3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBsaW5rLCBwcm9wZXJ0eSwgcGVyc2lzdGVudCwgdXBkYXRlT25CaW5kLCB0eXBlIH0gPSBtb2RlbC5saW5rc1tcbiAgICAgICAgICBpXG4gICAgICAgIF07XG4gICAgICAgIGlmICh0eXBlID09PSAnYXBwbGljYXRpb24nKSB7XG4gICAgICAgICAgY29uc3Qgc0xpbmsgPSBtb2RlbC5wcm94eU1hbmFnZXIuZ2V0UHJvcGVydHlMaW5rKGxpbmssIHBlcnNpc3RlbnQpO1xuICAgICAgICAgIHB1YmxpY0FQSS5yZWdpc3RlclByb3BlcnR5TGlua0ZvckdDKHNMaW5rLCAnYXBwbGljYXRpb24nKTtcbiAgICAgICAgICBzTGluay5iaW5kKHB1YmxpY0FQSSwgcHJvcGVydHksIHVwZGF0ZU9uQmluZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2V0SW1tZWRpYXRlVlRLKHJlZ2lzdGVyTGlua3MpO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBwcm94eVByb3BlcnR5TWFwcGluZyhwdWJsaWNBUEksIG1vZGVsLCBtYXApXG4vL1xuLy8gICBtYXAgPSB7XG4vLyAgICAgIG9wYWNpdHk6IHsgbW9kZWxLZXk6ICdwcm9wZXJ0eScsIHByb3BlcnR5OiAnb3BhY2l0eScgfSxcbi8vICAgfVxuLy9cbi8vIEdlbmVyYXRlZCBBUEk6XG4vLyAgRWxldmF0ZSBzZXQvZ2V0IG1ldGhvZHMgZnJvbSBpbnRlcm5hbCBvYmplY3Qgc3RvcmVkIGluIHRoZSBtb2RlbCB0byBjdXJyZW50IG9uZVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gcHJveHlQcm9wZXJ0eU1hcHBpbmcocHVibGljQVBJLCBtb2RlbCwgbWFwKSB7XG4gIGNvbnN0IHBhcmVudERlbGV0ZSA9IHB1YmxpY0FQSS5kZWxldGU7XG4gIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBbXTtcblxuICBjb25zdCBwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmtleXMobWFwKTtcbiAgbGV0IGNvdW50ID0gcHJvcGVydHlOYW1lcy5sZW5ndGg7XG4gIHdoaWxlIChjb3VudC0tKSB7XG4gICAgY29uc3QgcHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lc1tjb3VudF07XG4gICAgY29uc3QgeyBtb2RlbEtleSwgcHJvcGVydHksIG1vZGlmaWVkID0gdHJ1ZSB9ID0gbWFwW3Byb3BlcnR5TmFtZV07XG4gICAgY29uc3QgbWV0aG9kU3JjID0gY2FwaXRhbGl6ZShwcm9wZXJ0eSk7XG4gICAgY29uc3QgbWV0aG9kRHN0ID0gY2FwaXRhbGl6ZShwcm9wZXJ0eU5hbWUpO1xuICAgIHB1YmxpY0FQSVtgZ2V0JHttZXRob2REc3R9YF0gPSBtb2RlbFttb2RlbEtleV1bYGdldCR7bWV0aG9kU3JjfWBdO1xuICAgIHB1YmxpY0FQSVtgc2V0JHttZXRob2REc3R9YF0gPSBtb2RlbFttb2RlbEtleV1bYHNldCR7bWV0aG9kU3JjfWBdO1xuICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgc3Vic2NyaXB0aW9ucy5wdXNoKG1vZGVsW21vZGVsS2V5XS5vbk1vZGlmaWVkKHB1YmxpY0FQSS5tb2RpZmllZCkpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpY0FQSS5kZWxldGUgPSAoKSA9PiB7XG4gICAgd2hpbGUgKHN1YnNjcmlwdGlvbnMubGVuZ3RoKSB7XG4gICAgICBzdWJzY3JpcHRpb25zLnBvcCgpLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIHBhcmVudERlbGV0ZSgpO1xuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBwcm94eVByb3BlcnR5U3RhdGUocHVibGljQVBJLCBtb2RlbCwgc3RhdGUsIGRlZmF1bHRzKVxuLy9cbi8vICAgc3RhdGUgPSB7XG4vLyAgICAgcmVwcmVzZW50YXRpb246IHtcbi8vICAgICAgICdTdXJmYWNlIHdpdGggZWRnZXMnOiB7IHByb3BlcnR5OiB7IGVkZ2VWaXNpYmlsaXR5OiB0cnVlLCByZXByZXNlbnRhdGlvbjogMiB9IH0sXG4vLyAgICAgICBTdXJmYWNlOiB7IHByb3BlcnR5OiB7IGVkZ2VWaXNpYmlsaXR5OiBmYWxzZSwgcmVwcmVzZW50YXRpb246IDIgfSB9LFxuLy8gICAgICAgV2lyZWZyYW1lOiB7IHByb3BlcnR5OiB7IGVkZ2VWaXNpYmlsaXR5OiBmYWxzZSwgcmVwcmVzZW50YXRpb246IDEgfSB9LFxuLy8gICAgICAgUG9pbnRzOiB7IHByb3BlcnR5OiB7IGVkZ2VWaXNpYmlsaXR5OiBmYWxzZSwgcmVwcmVzZW50YXRpb246IDAgfSB9LFxuLy8gICAgIH0sXG4vLyAgIH1cbi8vXG4vLyAgIGRlZmF1bHRzID0ge1xuLy8gICAgICByZXByZXNlbnRhdGlvbjogJ1N1cmZhY2UnLFxuLy8gICB9XG4vL1xuLy8gR2VuZXJhdGVkIEFQSVxuLy8gICBnZXQgLyBzZXQgUmVwcmVzZW50YXRpb24gKCBzdHJpbmcgKSA9PiBwdXNoIHN0YXRlIHRvIHZhcmlvdXMgaW50ZXJuYWwgb2JqZWN0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZnVuY3Rpb24gcHJveHlQcm9wZXJ0eVN0YXRlKFxuICBwdWJsaWNBUEksXG4gIG1vZGVsLFxuICBzdGF0ZSA9IHt9LFxuICBkZWZhdWx0cyA9IHt9XG4pIHtcbiAgbW9kZWwudGhpcyA9IHB1YmxpY0FQSTtcblxuICBmdW5jdGlvbiBhcHBseVN0YXRlKG1hcCkge1xuICAgIGNvbnN0IG1vZGVsS2V5cyA9IE9iamVjdC5rZXlzKG1hcCk7XG4gICAgbGV0IGNvdW50ID0gbW9kZWxLZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgY29uc3QgbW9kZWxLZXkgPSBtb2RlbEtleXNbY291bnRdO1xuICAgICAgbW9kZWxbbW9kZWxLZXldLnNldChtYXBbbW9kZWxLZXldKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBtb2RlbEtleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cyk7XG4gIGxldCBjb3VudCA9IG1vZGVsS2V5cy5sZW5ndGg7XG4gIHdoaWxlIChjb3VudC0tKSB7XG4gICAgLy8gQWRkIGRlZmF1bHRcbiAgICBjb25zdCBrZXkgPSBtb2RlbEtleXNbY291bnRdO1xuICAgIG1vZGVsW2tleV0gPSBkZWZhdWx0c1trZXldO1xuXG4gICAgLy8gQWRkIHNldCBtZXRob2RcbiAgICBjb25zdCBtYXBwaW5nID0gc3RhdGVba2V5XTtcbiAgICBwdWJsaWNBUElbYHNldCR7Y2FwaXRhbGl6ZShrZXkpfWBdID0gKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IG1vZGVsW2tleV0pIHtcbiAgICAgICAgbW9kZWxba2V5XSA9IHZhbHVlO1xuICAgICAgICBjb25zdCBwcm9wVmFsdWVzID0gbWFwcGluZ1t2YWx1ZV07XG4gICAgICAgIGFwcGx5U3RhdGUocHJvcFZhbHVlcyk7XG4gICAgICAgIHB1YmxpY0FQSS5tb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBBZGQgZ2V0dGVyXG4gIGlmIChtb2RlbEtleXMubGVuZ3RoKSB7XG4gICAgZ2V0KHB1YmxpY0FQSSwgbW9kZWwsIG1vZGVsS2V5cyk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRnJvbSA6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9va2FyY2hpdmUvZml4ZWQtZGF0YS10YWJsZS9ibG9iL21hc3Rlci9zcmMvdmVuZG9yX3Vwc3RyZWFtL2RvbS9ub3JtYWxpemVXaGVlbC5qc1xuLy9cbi8vXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTUsIEZhY2Vib29rLCBJbmMuXG4vLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuLy9cbi8vIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuLy8gTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4vLyBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbi8vXG4vL1xuLy8gTW91c2Ugd2hlZWwgKGFuZCAyLWZpbmdlciB0cmFja3BhZCkgc3VwcG9ydCBvbiB0aGUgd2ViIHN1Y2tzLiAgSXQgaXNcbi8vIGNvbXBsaWNhdGVkLCB0aHVzIHRoaXMgZG9jIGlzIGxvbmcgYW5kIChob3BlZnVsbHkpIGRldGFpbGVkIGVub3VnaCB0byBhbnN3ZXJcbi8vIHlvdXIgcXVlc3Rpb25zLlxuLy9cbi8vIElmIHlvdSBuZWVkIHRvIHJlYWN0IHRvIHRoZSBtb3VzZSB3aGVlbCBpbiBhIHByZWRpY3RhYmxlIHdheSwgdGhpcyBjb2RlIGlzXG4vLyBsaWtlIHlvdXIgYmVzdGVzdCBmcmllbmQuLy8gaHVncy8vXG4vL1xuLy8gQXMgb2YgdG9kYXksIHRoZXJlIGFyZSA0IERPTSBldmVudCB0eXBlcyB5b3UgY2FuIGxpc3RlbiB0bzpcbi8vXG4vLyAgICd3aGVlbCcgICAgICAgICAgICAgICAgLS0gQ2hyb21lKDMxKyksIEZGKDE3KyksIElFKDkrKVxuLy8gICAnbW91c2V3aGVlbCcgICAgICAgICAgIC0tIENocm9tZSwgSUUoNispLCBPcGVyYSwgU2FmYXJpXG4vLyAgICdNb3pNb3VzZVBpeGVsU2Nyb2xsJyAgLS0gRkYoMy41IG9ubHkhKSAoMjAxMC0yMDEzKSAtLSBkb24ndCBib3RoZXIhXG4vLyAgICdET01Nb3VzZVNjcm9sbCcgICAgICAgLS0gRkYoMC45LjcrKSBzaW5jZSAyMDAzXG4vL1xuLy8gU28gd2hhdCB0byBkbz8gIFRoZSBpcyB0aGUgYmVzdDpcbi8vXG4vLyAgIG5vcm1hbGl6ZVdoZWVsLmdldEV2ZW50VHlwZSgpO1xuLy9cbi8vIEluIHlvdXIgZXZlbnQgY2FsbGJhY2ssIHVzZSB0aGlzIGNvZGUgdG8gZ2V0IHNhbmUgaW50ZXJwcmV0YXRpb24gb2YgdGhlXG4vLyBkZWx0YXMuICBUaGlzIGNvZGUgd2lsbCByZXR1cm4gYW4gb2JqZWN0IHdpdGggcHJvcGVydGllczpcbi8vXG4vLyAgIHNwaW5YICAgLS0gbm9ybWFsaXplZCBzcGluIHNwZWVkICh1c2UgZm9yIHpvb20pIC0geCBwbGFuZVxuLy8gICBzcGluWSAgIC0tIFwiIC0geSBwbGFuZVxuLy8gICBwaXhlbFggIC0tIG5vcm1hbGl6ZWQgZGlzdGFuY2UgKHRvIHBpeGVscykgLSB4IHBsYW5lXG4vLyAgIHBpeGVsWSAgLS0gXCIgLSB5IHBsYW5lXG4vL1xuLy8gV2hlZWwgdmFsdWVzIGFyZSBwcm92aWRlZCBieSB0aGUgYnJvd3NlciBhc3N1bWluZyB5b3UgYXJlIHVzaW5nIHRoZSB3aGVlbCB0b1xuLy8gc2Nyb2xsIGEgd2ViIHBhZ2UgYnkgYSBudW1iZXIgb2YgbGluZXMgb3IgcGl4ZWxzIChvciBwYWdlcykuICBWYWx1ZXMgY2FuIHZhcnlcbi8vIHNpZ25pZmljYW50bHkgb24gZGlmZmVyZW50IHBsYXRmb3JtcyBhbmQgYnJvd3NlcnMsIGZvcmdldHRpbmcgdGhhdCB5b3UgY2FuXG4vLyBzY3JvbGwgYXQgZGlmZmVyZW50IHNwZWVkcy4gIFNvbWUgZGV2aWNlcyAobGlrZSB0cmFja3BhZHMpIGVtaXQgbW9yZSBldmVudHNcbi8vIGF0IHNtYWxsZXIgaW5jcmVtZW50cyB3aXRoIGZpbmUgZ3JhbnVsYXJpdHksIGFuZCBzb21lIGVtaXQgbWFzc2l2ZSBqdW1wcyB3aXRoXG4vLyBsaW5lYXIgc3BlZWQgb3IgYWNjZWxlcmF0aW9uLlxuLy9cbi8vIFRoaXMgY29kZSBkb2VzIGl0cyBiZXN0IHRvIG5vcm1hbGl6ZSB0aGUgZGVsdGFzIGZvciB5b3U6XG4vL1xuLy8gICAtIHNwaW4gaXMgdHJ5aW5nIHRvIG5vcm1hbGl6ZSBob3cgZmFyIHRoZSB3aGVlbCB3YXMgc3B1biAob3IgdHJhY2twYWRcbi8vICAgICBkcmFnZ2VkKS4gIFRoaXMgaXMgc3VwZXIgdXNlZnVsIGZvciB6b29tIHN1cHBvcnQgd2hlcmUgeW91IHdhbnQgdG9cbi8vICAgICB0aHJvdyBhd2F5IHRoZSBjaHVua3kgc2Nyb2xsIHN0ZXBzIG9uIHRoZSBQQyBhbmQgbWFrZSB0aG9zZSBlcXVhbCB0b1xuLy8gICAgIHRoZSBzbG93IGFuZCBzbW9vdGggdGlueSBzdGVwcyBvbiB0aGUgTWFjLiBLZXkgZGF0YTogVGhpcyBjb2RlIHRyaWVzIHRvXG4vLyAgICAgcmVzb2x2ZSBhIHNpbmdsZSBzbG93IHN0ZXAgb24gYSB3aGVlbCB0byAxLlxuLy9cbi8vICAgLSBwaXhlbCBpcyBub3JtYWxpemluZyB0aGUgZGVzaXJlZCBzY3JvbGwgZGVsdGEgaW4gcGl4ZWwgdW5pdHMuICBZb3UnbGxcbi8vICAgICBnZXQgdGhlIGNyYXp5IGRpZmZlcmVuY2VzIGJldHdlZW4gYnJvd3NlcnMsIGJ1dCBhdCBsZWFzdCBpdCdsbCBiZSBpblxuLy8gICAgIHBpeGVscyFcbi8vXG4vLyAgIC0gcG9zaXRpdmUgdmFsdWUgaW5kaWNhdGVzIHNjcm9sbGluZyBET1dOL1JJR0hULCBuZWdhdGl2ZSBVUC9MRUZULiAgVGhpc1xuLy8gICAgIHNob3VsZCB0cmFuc2xhdGUgdG8gcG9zaXRpdmUgdmFsdWUgem9vbWluZyBJTiwgbmVnYXRpdmUgem9vbWluZyBPVVQuXG4vLyAgICAgVGhpcyBtYXRjaGVzIHRoZSBuZXdlciAnd2hlZWwnIGV2ZW50LlxuLy9cbi8vIFdoeSBhcmUgdGhlcmUgc3BpblgsIHNwaW5ZIChvciBwaXhlbHMpP1xuLy9cbi8vICAgLSBzcGluWCBpcyBhIDItZmluZ2VyIHNpZGUgZHJhZyBvbiB0aGUgdHJhY2twYWQsIGFuZCBhIHNoaWZ0ICsgd2hlZWwgdHVyblxuLy8gICAgIHdpdGggYSBtb3VzZS4gIEl0IHJlc3VsdHMgaW4gc2lkZS1zY3JvbGxpbmcgaW4gdGhlIGJyb3dzZXIgYnkgZGVmYXVsdC5cbi8vXG4vLyAgIC0gc3BpblkgaXMgd2hhdCB5b3UgZXhwZWN0IC0tIGl0J3MgdGhlIGNsYXNzaWMgYXhpcyBvZiBhIG1vdXNlIHdoZWVsLlxuLy9cbi8vICAgLSBJIGRyb3BwZWQgc3BpblovcGl4ZWxaLiAgSXQgaXMgc3VwcG9ydGVkIGJ5IHRoZSBET00gMyAnd2hlZWwnIGV2ZW50IGFuZFxuLy8gICAgIHByb2JhYmx5IGlzIGJ5IGJyb3dzZXJzIGluIGNvbmp1bmN0aW9uIHdpdGggZmFuY3kgM0QgY29udHJvbGxlcnMgLi4gYnV0XG4vLyAgICAgeW91IGtub3cuXG4vL1xuLy8gSW1wbGVtZW50YXRpb24gaW5mbzpcbi8vXG4vLyBFeGFtcGxlcyBvZiAnd2hlZWwnIGV2ZW50IGlmIHlvdSBzY3JvbGwgc2xvd2x5IChkb3duKSBieSBvbmUgc3RlcCB3aXRoIGFuXG4vLyBhdmVyYWdlIG1vdXNlOlxuLy9cbi8vICAgT1MgWCArIENocm9tZSAgKG1vdXNlKSAgICAgLSAgICA0ICAgcGl4ZWwgZGVsdGEgICh3aGVlbERlbHRhIC0xMjApXG4vLyAgIE9TIFggKyBTYWZhcmkgIChtb3VzZSkgICAgIC0gIE4vQSAgIHBpeGVsIGRlbHRhICAod2hlZWxEZWx0YSAgLTEyKVxuLy8gICBPUyBYICsgRmlyZWZveCAobW91c2UpICAgICAtICAgIDAuMSBsaW5lICBkZWx0YSAgKHdoZWVsRGVsdGEgIE4vQSlcbi8vICAgV2luOCArIENocm9tZSAgKG1vdXNlKSAgICAgLSAgMTAwICAgcGl4ZWwgZGVsdGEgICh3aGVlbERlbHRhIC0xMjApXG4vLyAgIFdpbjggKyBGaXJlZm94IChtb3VzZSkgICAgIC0gICAgMyAgIGxpbmUgIGRlbHRhICAod2hlZWxEZWx0YSAtMTIwKVxuLy9cbi8vIE9uIHRoZSB0cmFja3BhZDpcbi8vXG4vLyAgIE9TIFggKyBDaHJvbWUgICh0cmFja3BhZCkgIC0gICAgMiAgIHBpeGVsIGRlbHRhICAod2hlZWxEZWx0YSAgIC02KVxuLy8gICBPUyBYICsgRmlyZWZveCAodHJhY2twYWQpICAtICAgIDEgICBwaXhlbCBkZWx0YSAgKHdoZWVsRGVsdGEgIE4vQSlcbi8vXG4vLyBPbiBvdGhlci9vbGRlciBicm93c2Vycy4uIGl0J3MgbW9yZSBjb21wbGljYXRlZCBhcyB0aGVyZSBjYW4gYmUgbXVsdGlwbGUgYW5kXG4vLyBhbHNvIG1pc3NpbmcgZGVsdGEgdmFsdWVzLlxuLy9cbi8vIFRoZSAnd2hlZWwnIGV2ZW50IGlzIG1vcmUgc3RhbmRhcmQ6XG4vL1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtd2hlZWxldmVudHNcbi8vXG4vLyBUaGUgYmFzaWNzIGlzIHRoYXQgaXQgaW5jbHVkZXMgYSB1bml0LCBkZWx0YU1vZGUgKHBpeGVscywgbGluZXMsIHBhZ2VzKSwgYW5kXG4vLyBkZWx0YVgsIGRlbHRhWSBhbmQgZGVsdGFaLiAgU29tZSBicm93c2VycyBwcm92aWRlIG90aGVyIHZhbHVlcyB0byBtYWludGFpblxuLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIGV2ZW50cy4gIFRob3NlIG90aGVyIHZhbHVlcyBoZWxwIHVzXG4vLyBiZXR0ZXIgbm9ybWFsaXplIHNwaW4gc3BlZWQuICBFeGFtcGxlIG9mIHdoYXQgdGhlIGJyb3dzZXJzIHByb3ZpZGU6XG4vL1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgIHwgZXZlbnQud2hlZWxEZWx0YSB8IGV2ZW50LmRldGFpbFxuLy8gICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS1cbi8vICAgICAgICAgIFNhZmFyaSB2NS9PUyBYICB8ICAgICAgIC0xMjAgICAgICAgfCAgICAgICAwXG4vLyAgICAgICAgICBTYWZhcmkgdjUvV2luNyAgfCAgICAgICAtMTIwICAgICAgIHwgICAgICAgMFxuLy8gICAgICAgICBDaHJvbWUgdjE3L09TIFggIHwgICAgICAgLTEyMCAgICAgICB8ICAgICAgIDBcbi8vICAgICAgICAgQ2hyb21lIHYxNy9XaW43ICB8ICAgICAgIC0xMjAgICAgICAgfCAgICAgICAwXG4vLyAgICAgICAgICAgICAgICBJRTkvV2luNyAgfCAgICAgICAtMTIwICAgICAgIHwgICB1bmRlZmluZWRcbi8vICAgICAgICAgRmlyZWZveCB2NC9PUyBYICB8ICAgICB1bmRlZmluZWQgICAgfCAgICAgICAxXG4vLyAgICAgICAgIEZpcmVmb3ggdjQvV2luNyAgfCAgICAgdW5kZWZpbmVkICAgIHwgICAgICAgM1xuLy9cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLy8gUmVhc29uYWJsZSBkZWZhdWx0c1xuY29uc3QgUElYRUxfU1RFUCA9IDEwO1xuY29uc3QgTElORV9IRUlHSFQgPSA0MDtcbmNvbnN0IFBBR0VfSEVJR0hUID0gODAwO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplV2hlZWwod2hlZWxFdmVudCkge1xuICBsZXQgc1ggPSAwOyAvLyBzcGluWFxuICBsZXQgc1kgPSAwOyAvLyBzcGluWVxuICBsZXQgcFggPSAwOyAvLyBwaXhlbFhcbiAgbGV0IHBZID0gMDsgLy8gcGl4ZWxZXG5cbiAgLy8gTGVnYWN5XG4gIGlmICgnZGV0YWlsJyBpbiB3aGVlbEV2ZW50KSB7XG4gICAgc1kgPSB3aGVlbEV2ZW50LmRldGFpbDtcbiAgfVxuICBpZiAoJ3doZWVsRGVsdGEnIGluIHdoZWVsRXZlbnQpIHtcbiAgICBzWSA9IC13aGVlbEV2ZW50LndoZWVsRGVsdGEgLyAxMjA7XG4gIH1cbiAgaWYgKCd3aGVlbERlbHRhWScgaW4gd2hlZWxFdmVudCkge1xuICAgIHNZID0gLXdoZWVsRXZlbnQud2hlZWxEZWx0YVkgLyAxMjA7XG4gIH1cbiAgaWYgKCd3aGVlbERlbHRhWCcgaW4gd2hlZWxFdmVudCkge1xuICAgIHNYID0gLXdoZWVsRXZlbnQud2hlZWxEZWx0YVggLyAxMjA7XG4gIH1cblxuICAvLyBzaWRlIHNjcm9sbGluZyBvbiBGRiB3aXRoIERPTU1vdXNlU2Nyb2xsXG4gIGlmICgnYXhpcycgaW4gd2hlZWxFdmVudCAmJiB3aGVlbEV2ZW50LmF4aXMgPT09IHdoZWVsRXZlbnQuSE9SSVpPTlRBTF9BWElTKSB7XG4gICAgc1ggPSBzWTtcbiAgICBzWSA9IDA7XG4gIH1cblxuICBwWCA9IHNYICogUElYRUxfU1RFUDtcbiAgcFkgPSBzWSAqIFBJWEVMX1NURVA7XG5cbiAgaWYgKCdkZWx0YVknIGluIHdoZWVsRXZlbnQpIHtcbiAgICBwWSA9IHdoZWVsRXZlbnQuZGVsdGFZO1xuICB9XG4gIGlmICgnZGVsdGFYJyBpbiB3aGVlbEV2ZW50KSB7XG4gICAgcFggPSB3aGVlbEV2ZW50LmRlbHRhWDtcbiAgfVxuXG4gIGlmICgocFggfHwgcFkpICYmIHdoZWVsRXZlbnQuZGVsdGFNb2RlKSB7XG4gICAgaWYgKHdoZWVsRXZlbnQuZGVsdGFNb2RlID09PSAxKSB7XG4gICAgICAvLyBkZWx0YSBpbiBMSU5FIHVuaXRzXG4gICAgICBwWCAqPSBMSU5FX0hFSUdIVDtcbiAgICAgIHBZICo9IExJTkVfSEVJR0hUO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkZWx0YSBpbiBQQUdFIHVuaXRzXG4gICAgICBwWCAqPSBQQUdFX0hFSUdIVDtcbiAgICAgIHBZICo9IFBBR0VfSEVJR0hUO1xuICAgIH1cbiAgfVxuXG4gIC8vIEZhbGwtYmFjayBpZiBzcGluIGNhbm5vdCBiZSBkZXRlcm1pbmVkXG4gIGlmIChwWCAmJiAhc1gpIHtcbiAgICBzWCA9IHBYIDwgMSA/IC0xIDogMTtcbiAgfVxuICBpZiAocFkgJiYgIXNZKSB7XG4gICAgc1kgPSBwWSA8IDEgPyAtMSA6IDE7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNwaW5YOiBzWCxcbiAgICBzcGluWTogc1ksXG4gICAgcGl4ZWxYOiBwWCxcbiAgICBwaXhlbFk6IHBZLFxuICB9O1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEZWZhdWx0IGV4cG9ydFxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGFsZ28sXG4gIGNhcGl0YWxpemUsXG4gIGNoYWluLFxuICBkZWJvdW5jZSxcbiAgZW51bVRvU3RyaW5nLFxuICBldmVudCxcbiAgRVZFTlRfQUJPUlQsXG4gIGZvcm1hdEJ5dGVzVG9Qcm9wZXJVbml0LFxuICBmb3JtYXROdW1iZXJzV2l0aFRob3VzYW5kU2VwYXJhdG9yLFxuICBnZXQsXG4gIGdldEFycmF5LFxuICBnZXRDdXJyZW50R2xvYmFsTVRpbWUsXG4gIGdldFN0YXRlQXJyYXlNYXBGdW5jLFxuICBpc1Z0a09iamVjdCxcbiAga2V5c3RvcmUsXG4gIG5ld0luc3RhbmNlLFxuICBub3JtYWxpemVXaGVlbCxcbiAgb2JqLFxuICBwcm94eSxcbiAgcHJveHlQcm9wZXJ0eU1hcHBpbmcsXG4gIHByb3h5UHJvcGVydHlTdGF0ZSxcbiAgc2FmZUFycmF5cyxcbiAgc2V0LFxuICBzZXRBcnJheSxcbiAgc2V0R2V0LFxuICBzZXRHZXRBcnJheSxcbiAgc2V0SW1tZWRpYXRlOiBzZXRJbW1lZGlhdGVWVEssXG4gIHNldExvZ2dlckZ1bmN0aW9uLFxuICB0aHJvdHRsZSxcbiAgdHJhdmVyc2VJbnN0YW5jZVRyZWUsXG4gIFRZUEVEX0FSUkFZUyxcbiAgdW5jYXBpdGFsaXplLFxuICBWT0lELFxuICB2dGtEZWJ1Z01hY3JvLFxuICB2dGtFcnJvck1hY3JvLFxuICB2dGtJbmZvTWFjcm8sXG4gIHZ0a0xvZ01hY3JvLFxuICB2dGtPbmNlRXJyb3JNYWNybyxcbiAgdnRrV2FybmluZ01hY3JvLFxufTtcbiIsImNvbnN0IGZhY3RvcnlNYXBwaW5nID0ge1xuICB2dGtPYmplY3Q6ICgpID0+IG51bGwsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2dGsob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgb2JqID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG4gIGlmIChvYmouaXNBKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICBpZiAoIW9iai52dGtDbGFzcykge1xuICAgIGlmIChnbG9iYWwuY29uc29sZSAmJiBnbG9iYWwuY29uc29sZS5lcnJvcikge1xuICAgICAgZ2xvYmFsLmNvbnNvbGUuZXJyb3IoJ0ludmFsaWQgVlRLIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBjb25zdHJ1Y3RvciA9IGZhY3RvcnlNYXBwaW5nW29iai52dGtDbGFzc107XG4gIGlmICghY29uc3RydWN0b3IpIHtcbiAgICBpZiAoZ2xvYmFsLmNvbnNvbGUgJiYgZ2xvYmFsLmNvbnNvbGUuZXJyb3IpIHtcbiAgICAgIGdsb2JhbC5jb25zb2xlLmVycm9yKFxuICAgICAgICBgTm8gdnRrIGNsYXNzIGZvdW5kIGZvciBPYmplY3Qgb2YgdHlwZSAke29iai52dGtDbGFzc31gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFNoYWxsb3cgY29weSBvYmplY3RcbiAgY29uc3QgbW9kZWwgPSB7IC4uLm9iaiB9O1xuXG4gIC8vIENvbnZlcnQgaW50byB2dGtPYmplY3QgYW55IG5lc3RlZCBrZXlcbiAgT2JqZWN0LmtleXMobW9kZWwpLmZvckVhY2goKGtleU5hbWUpID0+IHtcbiAgICBpZiAoXG4gICAgICBtb2RlbFtrZXlOYW1lXSAmJlxuICAgICAgdHlwZW9mIG1vZGVsW2tleU5hbWVdID09PSAnb2JqZWN0JyAmJlxuICAgICAgbW9kZWxba2V5TmFtZV0udnRrQ2xhc3NcbiAgICApIHtcbiAgICAgIG1vZGVsW2tleU5hbWVdID0gdnRrKG1vZGVsW2tleU5hbWVdKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFJldHVybiB0aGUgcm9vdFxuICBjb25zdCBuZXdJbnN0ID0gY29uc3RydWN0b3IobW9kZWwpO1xuICBpZiAobmV3SW5zdCAmJiBuZXdJbnN0Lm1vZGlmaWVkKSB7XG4gICAgbmV3SW5zdC5tb2RpZmllZCgpO1xuICB9XG4gIHJldHVybiBuZXdJbnN0O1xufVxuXG5mdW5jdGlvbiByZWdpc3Rlcih2dGtDbGFzc05hbWUsIGNvbnN0cnVjdG9yKSB7XG4gIGZhY3RvcnlNYXBwaW5nW3Z0a0NsYXNzTmFtZV0gPSBjb25zdHJ1Y3Rvcjtcbn1cblxuLy8gTmVzdCByZWdpc3RlciBtZXRob2QgdW5kZXIgdGhlIHZ0ayBmdW5jdGlvblxudnRrLnJlZ2lzdGVyID0gcmVnaXN0ZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoXCJkZWZpbmUgY2Fubm90IGJlIHVzZWQgaW5kaXJlY3RcIik7XG59O1xuIiwiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xubW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXztcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIHdlYnZyLXBvbHlmaWxsXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNyBHb29nbGVcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIGNhcmRib2FyZC12ci1kaXNwbGF5XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNyBHb29nbGVcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIHdlYnZyLXBvbHlmaWxsLWRwZGIgXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgR29vZ2xlXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiB3Z2x1LXByZXNlcnZlLXN0YXRlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYsIEJyYW5kb24gSm9uZXMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBub3NsZWVwLmpzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcsIFJpY2ggVGliYmV0dFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLldlYlZSUG9seWZpbGwgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG5cblxuXG5mdW5jdGlvbiB1bndyYXBFeHBvcnRzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxuXG52YXIgaXNNb2JpbGUgPSBmdW5jdGlvbiBpc01vYmlsZSgpIHtcbiAgcmV0dXJuICgvQW5kcm9pZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG4gICk7XG59O1xudmFyIGNvcHlBcnJheSA9IGZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGRlc3QpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgZGVzdFtpXSA9IHNvdXJjZVtpXTtcbiAgfVxufTtcbnZhciBleHRlbmQgPSBmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjKSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGRlc3Rba2V5XSA9IHNyY1trZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdDtcbn07XG5cbnZhciBjYXJkYm9hcmRWckRpc3BsYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBjYXJkYm9hcmQtdnItZGlzcGxheVxuICogQ29weXJpZ2h0IChjKSAyMDE1LTIwMTcgR29vZ2xlXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBAbGljZW5zZVxuICogZ2wtcHJlc2VydmUtc3RhdGVcbiAqIENvcHlyaWdodCAoYykgMjAxNiwgQnJhbmRvbiBKb25lcy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiB3ZWJ2ci1wb2x5ZmlsbC1kcGRiXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtMjAxNyBHb29nbGVcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBub3NsZWVwLmpzXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcsIFJpY2ggVGliYmV0dFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xufShjb21tb25qc0dsb2JhbCwgKGZ1bmN0aW9uICgpIHsgdmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xudmFyIHNsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkge1xuICAgICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuICAgICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9IHRydWU7XG4gICAgICBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfYXJyO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgcmV0dXJuIGFycjtcbiAgICB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkge1xuICAgICAgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7XG4gICAgfVxuICB9O1xufSgpO1xudmFyIE1JTl9USU1FU1RFUCA9IDAuMDAxO1xudmFyIE1BWF9USU1FU1RFUCA9IDE7XG52YXIgZGF0YVVyaSA9IGZ1bmN0aW9uIGRhdGFVcmkobWltZVR5cGUsIHN2Zykge1xuICByZXR1cm4gJ2RhdGE6JyArIG1pbWVUeXBlICsgJywnICsgZW5jb2RlVVJJQ29tcG9uZW50KHN2Zyk7XG59O1xudmFyIGxlcnAgPSBmdW5jdGlvbiBsZXJwKGEsIGIsIHQpIHtcbiAgcmV0dXJuIGEgKyAoYiAtIGEpICogdDtcbn07XG52YXIgaXNJT1MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpc0lPUyA9IC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzSU9TO1xuICB9O1xufSgpO1xudmFyIGlzV2ViVmlld0FuZHJvaWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBpc1dlYlZpZXdBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdWZXJzaW9uJykgIT09IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQW5kcm9pZCcpICE9PSAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpICE9PSAtMTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNXZWJWaWV3QW5kcm9pZDtcbiAgfTtcbn0oKTtcbnZhciBpc1NhZmFyaSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlzU2FmYXJpID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNTYWZhcmk7XG4gIH07XG59KCk7XG52YXIgaXNGaXJlZm94QW5kcm9pZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlzRmlyZWZveEFuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0ZpcmVmb3gnKSAhPT0gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdBbmRyb2lkJykgIT09IC0xO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpc0ZpcmVmb3hBbmRyb2lkO1xuICB9O1xufSgpO1xudmFyIGdldENocm9tZVZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBtYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goLy4qQ2hyb21lXFwvKFswLTldKykvKTtcbiAgdmFyIHZhbHVlID0gbWF0Y2ggPyBwYXJzZUludChtYXRjaFsxXSwgMTApIDogbnVsbDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59KCk7XG52YXIgaXNTYWZhcmlXaXRob3V0RGV2aWNlTW90aW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmFsdWUgPSBmYWxzZTtcbiAgdmFsdWUgPSBpc0lPUygpICYmIGlzU2FmYXJpKCkgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCcxM180JykgIT09IC0xO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn0oKTtcbnZhciBpc0Nocm9tZVdpdGhvdXREZXZpY2VNb3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2YWx1ZSA9IGZhbHNlO1xuICBpZiAoZ2V0Q2hyb21lVmVyc2lvbigpID09PSA2NSkge1xuICAgIHZhciBtYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goLy4qQ2hyb21lXFwvKFswLTlcXC5dKikvKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHZhciBfbWF0Y2gkMSRzcGxpdCA9IG1hdGNoWzFdLnNwbGl0KCcuJyksXG4gICAgICAgICAgX21hdGNoJDEkc3BsaXQyID0gc2xpY2VkVG9BcnJheShfbWF0Y2gkMSRzcGxpdCwgNCksXG4gICAgICAgICAgbWFqb3IgPSBfbWF0Y2gkMSRzcGxpdDJbMF0sXG4gICAgICAgICAgbWlub3IgPSBfbWF0Y2gkMSRzcGxpdDJbMV0sXG4gICAgICAgICAgYnJhbmNoID0gX21hdGNoJDEkc3BsaXQyWzJdLFxuICAgICAgICAgIGJ1aWxkID0gX21hdGNoJDEkc3BsaXQyWzNdO1xuICAgICAgdmFsdWUgPSBwYXJzZUludChicmFuY2gsIDEwKSA9PT0gMzMyNSAmJiBwYXJzZUludChidWlsZCwgMTApIDwgMTQ4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn0oKTtcbnZhciBpc1I3ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgaXNSNyA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignUjcgQnVpbGQnKSAhPT0gLTE7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzUjc7XG4gIH07XG59KCk7XG52YXIgaXNMYW5kc2NhcGVNb2RlID0gZnVuY3Rpb24gaXNMYW5kc2NhcGVNb2RlKCkge1xuICB2YXIgcnRuID0gd2luZG93Lm9yaWVudGF0aW9uID09IDkwIHx8IHdpbmRvdy5vcmllbnRhdGlvbiA9PSAtOTA7XG4gIHJldHVybiBpc1I3KCkgPyAhcnRuIDogcnRuO1xufTtcbnZhciBpc1RpbWVzdGFtcERlbHRhVmFsaWQgPSBmdW5jdGlvbiBpc1RpbWVzdGFtcERlbHRhVmFsaWQodGltZXN0YW1wRGVsdGFTKSB7XG4gIGlmIChpc05hTih0aW1lc3RhbXBEZWx0YVMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aW1lc3RhbXBEZWx0YVMgPD0gTUlOX1RJTUVTVEVQKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aW1lc3RhbXBEZWx0YVMgPiBNQVhfVElNRVNURVApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGdldFNjcmVlbldpZHRoID0gZnVuY3Rpb24gZ2V0U2NyZWVuV2lkdGgoKSB7XG4gIHJldHVybiBNYXRoLm1heCh3aW5kb3cuc2NyZWVuLndpZHRoLCB3aW5kb3cuc2NyZWVuLmhlaWdodCkgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbn07XG52YXIgZ2V0U2NyZWVuSGVpZ2h0ID0gZnVuY3Rpb24gZ2V0U2NyZWVuSGVpZ2h0KCkge1xuICByZXR1cm4gTWF0aC5taW4od2luZG93LnNjcmVlbi53aWR0aCwgd2luZG93LnNjcmVlbi5oZWlnaHQpICogd2luZG93LmRldmljZVBpeGVsUmF0aW87XG59O1xudmFyIHJlcXVlc3RGdWxsc2NyZWVuID0gZnVuY3Rpb24gcmVxdWVzdEZ1bGxzY3JlZW4oZWxlbWVudCkge1xuICBpZiAoaXNXZWJWaWV3QW5kcm9pZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgZWxlbWVudC5yZXF1ZXN0RnVsbHNjcmVlbigpO1xuICB9IGVsc2UgaWYgKGVsZW1lbnQud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICBlbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gIH0gZWxzZSBpZiAoZWxlbWVudC5tb3pSZXF1ZXN0RnVsbFNjcmVlbikge1xuICAgIGVsZW1lbnQubW96UmVxdWVzdEZ1bGxTY3JlZW4oKTtcbiAgfSBlbHNlIGlmIChlbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICBlbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4oKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGV4aXRGdWxsc2NyZWVuID0gZnVuY3Rpb24gZXhpdEZ1bGxzY3JlZW4oKSB7XG4gIGlmIChkb2N1bWVudC5leGl0RnVsbHNjcmVlbikge1xuICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4pIHtcbiAgICBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbigpO1xuICB9IGVsc2UgaWYgKGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4pIHtcbiAgICBkb2N1bWVudC5tb3pDYW5jZWxGdWxsU2NyZWVuKCk7XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQubXNFeGl0RnVsbHNjcmVlbikge1xuICAgIGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW4oKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xudmFyIGdldEZ1bGxzY3JlZW5FbGVtZW50ID0gZnVuY3Rpb24gZ2V0RnVsbHNjcmVlbkVsZW1lbnQoKSB7XG4gIHJldHVybiBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50O1xufTtcbnZhciBsaW5rUHJvZ3JhbSA9IGZ1bmN0aW9uIGxpbmtQcm9ncmFtKGdsLCB2ZXJ0ZXhTb3VyY2UsIGZyYWdtZW50U291cmNlLCBhdHRyaWJMb2NhdGlvbk1hcCkge1xuICB2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xuICBnbC5zaGFkZXJTb3VyY2UodmVydGV4U2hhZGVyLCB2ZXJ0ZXhTb3VyY2UpO1xuICBnbC5jb21waWxlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gIHZhciBmcmFnbWVudFNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U291cmNlKTtcbiAgZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgZm9yICh2YXIgYXR0cmliTmFtZSBpbiBhdHRyaWJMb2NhdGlvbk1hcCkge1xuICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJMb2NhdGlvbk1hcFthdHRyaWJOYW1lXSwgYXR0cmliTmFtZSk7XG4gIH1nbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gIHJldHVybiBwcm9ncmFtO1xufTtcbnZhciBnZXRQcm9ncmFtVW5pZm9ybXMgPSBmdW5jdGlvbiBnZXRQcm9ncmFtVW5pZm9ybXMoZ2wsIHByb2dyYW0pIHtcbiAgdmFyIHVuaWZvcm1zID0ge307XG4gIHZhciB1bmlmb3JtQ291bnQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyk7XG4gIHZhciB1bmlmb3JtTmFtZSA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHVuaWZvcm1Db3VudDsgaSsrKSB7XG4gICAgdmFyIHVuaWZvcm1JbmZvID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKTtcbiAgICB1bmlmb3JtTmFtZSA9IHVuaWZvcm1JbmZvLm5hbWUucmVwbGFjZSgnWzBdJywgJycpO1xuICAgIHVuaWZvcm1zW3VuaWZvcm1OYW1lXSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gIH1cbiAgcmV0dXJuIHVuaWZvcm1zO1xufTtcbnZhciBvcnRob01hdHJpeCA9IGZ1bmN0aW9uIG9ydGhvTWF0cml4KG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpLFxuICAgICAgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCksXG4gICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IC0yICogbHI7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IC0yICogYnQ7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAyICogbmY7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59O1xudmFyIGlzTW9iaWxlID0gZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gIHZhciBjaGVjayA9IGZhbHNlO1xuICAoZnVuY3Rpb24gKGEpIHtcbiAgICBpZiAoLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLnRlc3QoYSkgfHwgLzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdChhLnN1YnN0cigwLCA0KSkpIGNoZWNrID0gdHJ1ZTtcbiAgfSkobmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBuYXZpZ2F0b3IudmVuZG9yIHx8IHdpbmRvdy5vcGVyYSk7XG4gIHJldHVybiBjaGVjaztcbn07XG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBkZXN0W2tleV0gPSBzcmNba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlc3Q7XG59O1xudmFyIHNhZmFyaUNzc1NpemVXb3JrYXJvdW5kID0gZnVuY3Rpb24gc2FmYXJpQ3NzU2l6ZVdvcmthcm91bmQoY2FudmFzKSB7XG4gIGlmIChpc0lPUygpKSB7XG4gICAgdmFyIHdpZHRoID0gY2FudmFzLnN0eWxlLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBjYW52YXMuc3R5bGUuaGVpZ2h0O1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHBhcnNlSW50KHdpZHRoKSArIDEgKyAncHgnO1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBwYXJzZUludChoZWlnaHQpICsgJ3B4JztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICB9LCAxMDApO1xuICB9XG4gIHdpbmRvdy5jYW52YXMgPSBjYW52YXM7XG59O1xudmFyIGZyYW1lRGF0YUZyb21Qb3NlID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcGlPdmVyMTgwID0gTWF0aC5QSSAvIDE4MC4wO1xuICB2YXIgcmFkNDUgPSBNYXRoLlBJICogMC4yNTtcbiAgZnVuY3Rpb24gbWF0NF9wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyhvdXQsIGZvdiwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHVwVGFuID0gTWF0aC50YW4oZm92ID8gZm92LnVwRGVncmVlcyAqIHBpT3ZlcjE4MCA6IHJhZDQ1KSxcbiAgICAgICAgZG93blRhbiA9IE1hdGgudGFuKGZvdiA/IGZvdi5kb3duRGVncmVlcyAqIHBpT3ZlcjE4MCA6IHJhZDQ1KSxcbiAgICAgICAgbGVmdFRhbiA9IE1hdGgudGFuKGZvdiA/IGZvdi5sZWZ0RGVncmVlcyAqIHBpT3ZlcjE4MCA6IHJhZDQ1KSxcbiAgICAgICAgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YgPyBmb3YucmlnaHREZWdyZWVzICogcGlPdmVyMTgwIDogcmFkNDUpLFxuICAgICAgICB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKSxcbiAgICAgICAgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG4gICAgb3V0WzBdID0geFNjYWxlO1xuICAgIG91dFsxXSA9IDAuMDtcbiAgICBvdXRbMl0gPSAwLjA7XG4gICAgb3V0WzNdID0gMC4wO1xuICAgIG91dFs0XSA9IDAuMDtcbiAgICBvdXRbNV0gPSB5U2NhbGU7XG4gICAgb3V0WzZdID0gMC4wO1xuICAgIG91dFs3XSA9IDAuMDtcbiAgICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgICBvdXRbOV0gPSAodXBUYW4gLSBkb3duVGFuKSAqIHlTY2FsZSAqIDAuNTtcbiAgICBvdXRbMTBdID0gZmFyIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMV0gPSAtMS4wO1xuICAgIG91dFsxMl0gPSAwLjA7XG4gICAgb3V0WzEzXSA9IDAuMDtcbiAgICBvdXRbMTRdID0gZmFyICogbmVhciAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTVdID0gMC4wO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgZnVuY3Rpb24gbWF0NF9mcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIHEsIHYpIHtcbiAgICB2YXIgeCA9IHFbMF0sXG4gICAgICAgIHkgPSBxWzFdLFxuICAgICAgICB6ID0gcVsyXSxcbiAgICAgICAgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG4gICAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcbiAgICBvdXRbMV0gPSB4eSArIHd6O1xuICAgIG91dFsyXSA9IHh6IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4eSAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gICAgb3V0WzZdID0geXogKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHh6ICsgd3k7XG4gICAgb3V0WzldID0geXogLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGZ1bmN0aW9uIG1hdDRfdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSxcbiAgICAgICAgeSA9IHZbMV0sXG4gICAgICAgIHogPSB2WzJdLFxuICAgICAgICBhMDAsXG4gICAgICAgIGEwMSxcbiAgICAgICAgYTAyLFxuICAgICAgICBhMDMsXG4gICAgICAgIGExMCxcbiAgICAgICAgYTExLFxuICAgICAgICBhMTIsXG4gICAgICAgIGExMyxcbiAgICAgICAgYTIwLFxuICAgICAgICBhMjEsXG4gICAgICAgIGEyMixcbiAgICAgICAgYTIzO1xuICAgIGlmIChhID09PSBvdXQpIHtcbiAgICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XG4gICAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBhMDAgPSBhWzBdO2EwMSA9IGFbMV07YTAyID0gYVsyXTthMDMgPSBhWzNdO1xuICAgICAgYTEwID0gYVs0XTthMTEgPSBhWzVdO2ExMiA9IGFbNl07YTEzID0gYVs3XTtcbiAgICAgIGEyMCA9IGFbOF07YTIxID0gYVs5XTthMjIgPSBhWzEwXTthMjMgPSBhWzExXTtcbiAgICAgIG91dFswXSA9IGEwMDtvdXRbMV0gPSBhMDE7b3V0WzJdID0gYTAyO291dFszXSA9IGEwMztcbiAgICAgIG91dFs0XSA9IGExMDtvdXRbNV0gPSBhMTE7b3V0WzZdID0gYTEyO291dFs3XSA9IGExMztcbiAgICAgIG91dFs4XSA9IGEyMDtvdXRbOV0gPSBhMjE7b3V0WzEwXSA9IGEyMjtvdXRbMTFdID0gYTIzO1xuICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIGZ1bmN0aW9uIG1hdDRfaW52ZXJ0KG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLFxuICAgICAgICBhMzEgPSBhWzEzXSxcbiAgICAgICAgYTMyID0gYVsxNF0sXG4gICAgICAgIGEzMyA9IGFbMTVdLFxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbiAgICBpZiAoIWRldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICAgIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xuICB9XG4gIHZhciBkZWZhdWx0T3JpZW50YXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxXSk7XG4gIHZhciBkZWZhdWx0UG9zaXRpb24gPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwXSk7XG4gIGZ1bmN0aW9uIHVwZGF0ZUV5ZU1hdHJpY2VzKHByb2plY3Rpb24sIHZpZXcsIHBvc2UsIGZvdiwgb2Zmc2V0LCB2ckRpc3BsYXkpIHtcbiAgICBtYXQ0X3BlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KHByb2plY3Rpb24sIGZvdiB8fCBudWxsLCB2ckRpc3BsYXkuZGVwdGhOZWFyLCB2ckRpc3BsYXkuZGVwdGhGYXIpO1xuICAgIHZhciBvcmllbnRhdGlvbiA9IHBvc2Uub3JpZW50YXRpb24gfHwgZGVmYXVsdE9yaWVudGF0aW9uO1xuICAgIHZhciBwb3NpdGlvbiA9IHBvc2UucG9zaXRpb24gfHwgZGVmYXVsdFBvc2l0aW9uO1xuICAgIG1hdDRfZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24odmlldywgb3JpZW50YXRpb24sIHBvc2l0aW9uKTtcbiAgICBpZiAob2Zmc2V0KSBtYXQ0X3RyYW5zbGF0ZSh2aWV3LCB2aWV3LCBvZmZzZXQpO1xuICAgIG1hdDRfaW52ZXJ0KHZpZXcsIHZpZXcpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoZnJhbWVEYXRhLCBwb3NlLCB2ckRpc3BsYXkpIHtcbiAgICBpZiAoIWZyYW1lRGF0YSB8fCAhcG9zZSkgcmV0dXJuIGZhbHNlO1xuICAgIGZyYW1lRGF0YS5wb3NlID0gcG9zZTtcbiAgICBmcmFtZURhdGEudGltZXN0YW1wID0gcG9zZS50aW1lc3RhbXA7XG4gICAgdXBkYXRlRXllTWF0cmljZXMoZnJhbWVEYXRhLmxlZnRQcm9qZWN0aW9uTWF0cml4LCBmcmFtZURhdGEubGVmdFZpZXdNYXRyaXgsIHBvc2UsIHZyRGlzcGxheS5fZ2V0RmllbGRPZlZpZXcoXCJsZWZ0XCIpLCB2ckRpc3BsYXkuX2dldEV5ZU9mZnNldChcImxlZnRcIiksIHZyRGlzcGxheSk7XG4gICAgdXBkYXRlRXllTWF0cmljZXMoZnJhbWVEYXRhLnJpZ2h0UHJvamVjdGlvbk1hdHJpeCwgZnJhbWVEYXRhLnJpZ2h0Vmlld01hdHJpeCwgcG9zZSwgdnJEaXNwbGF5Ll9nZXRGaWVsZE9mVmlldyhcInJpZ2h0XCIpLCB2ckRpc3BsYXkuX2dldEV5ZU9mZnNldChcInJpZ2h0XCIpLCB2ckRpc3BsYXkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xufSgpO1xudmFyIGlzSW5zaWRlQ3Jvc3NPcmlnaW5JRnJhbWUgPSBmdW5jdGlvbiBpc0luc2lkZUNyb3NzT3JpZ2luSUZyYW1lKCkge1xuICB2YXIgaXNGcmFtZWQgPSB3aW5kb3cuc2VsZiAhPT0gd2luZG93LnRvcDtcbiAgdmFyIHJlZk9yaWdpbiA9IGdldE9yaWdpbkZyb21VcmwoZG9jdW1lbnQucmVmZXJyZXIpO1xuICB2YXIgdGhpc09yaWdpbiA9IGdldE9yaWdpbkZyb21Vcmwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuICByZXR1cm4gaXNGcmFtZWQgJiYgcmVmT3JpZ2luICE9PSB0aGlzT3JpZ2luO1xufTtcbnZhciBnZXRPcmlnaW5Gcm9tVXJsID0gZnVuY3Rpb24gZ2V0T3JpZ2luRnJvbVVybCh1cmwpIHtcbiAgdmFyIGRvbWFpbklkeDtcbiAgdmFyIHByb3RvU2VwSWR4ID0gdXJsLmluZGV4T2YoXCI6Ly9cIik7XG4gIGlmIChwcm90b1NlcElkeCAhPT0gLTEpIHtcbiAgICBkb21haW5JZHggPSBwcm90b1NlcElkeCArIDM7XG4gIH0gZWxzZSB7XG4gICAgZG9tYWluSWR4ID0gMDtcbiAgfVxuICB2YXIgZG9tYWluRW5kSWR4ID0gdXJsLmluZGV4T2YoJy8nLCBkb21haW5JZHgpO1xuICBpZiAoZG9tYWluRW5kSWR4ID09PSAtMSkge1xuICAgIGRvbWFpbkVuZElkeCA9IHVybC5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgZG9tYWluRW5kSWR4KTtcbn07XG52YXIgZ2V0UXVhdGVybmlvbkFuZ2xlID0gZnVuY3Rpb24gZ2V0UXVhdGVybmlvbkFuZ2xlKHF1YXQpIHtcbiAgaWYgKHF1YXQudyA+IDEpIHtcbiAgICBjb25zb2xlLndhcm4oJ2dldFF1YXRlcm5pb25BbmdsZTogdyA+IDEnKTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICB2YXIgYW5nbGUgPSAyICogTWF0aC5hY29zKHF1YXQudyk7XG4gIHJldHVybiBhbmdsZTtcbn07XG52YXIgd2Fybk9uY2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvYnNlcnZlZFdhcm5pbmdzID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoa2V5LCBtZXNzYWdlKSB7XG4gICAgaWYgKG9ic2VydmVkV2FybmluZ3Nba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ3dlYnZyLXBvbHlmaWxsOiAnICsgbWVzc2FnZSk7XG4gICAgICBvYnNlcnZlZFdhcm5pbmdzW2tleV0gPSB0cnVlO1xuICAgIH1cbiAgfTtcbn0oKTtcbnZhciBkZXByZWNhdGVXYXJuaW5nID0gZnVuY3Rpb24gZGVwcmVjYXRlV2FybmluZyhkZXByZWNhdGVkLCBzdWdnZXN0ZWQpIHtcbiAgdmFyIGFsdGVybmF0aXZlID0gc3VnZ2VzdGVkID8gJ1BsZWFzZSB1c2UgJyArIHN1Z2dlc3RlZCArICcgaW5zdGVhZC4nIDogJyc7XG4gIHdhcm5PbmNlKGRlcHJlY2F0ZWQsIGRlcHJlY2F0ZWQgKyAnIGhhcyBiZWVuIGRlcHJlY2F0ZWQuICcgKyAnVGhpcyBtYXkgbm90IHdvcmsgb24gbmF0aXZlIFdlYlZSIGRpc3BsYXlzLiAnICsgYWx0ZXJuYXRpdmUpO1xufTtcbmZ1bmN0aW9uIFdHTFVQcmVzZXJ2ZUdMU3RhdGUoZ2wsIGJpbmRpbmdzLCBjYWxsYmFjaykge1xuICBpZiAoIWJpbmRpbmdzKSB7XG4gICAgY2FsbGJhY2soZ2wpO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYm91bmRWYWx1ZXMgPSBbXTtcbiAgdmFyIGFjdGl2ZVRleHR1cmUgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICBzd2l0Y2ggKGJpbmRpbmcpIHtcbiAgICAgIGNhc2UgZ2wuVEVYVFVSRV9CSU5ESU5HXzJEOlxuICAgICAgY2FzZSBnbC5URVhUVVJFX0JJTkRJTkdfQ1VCRV9NQVA6XG4gICAgICAgIHZhciB0ZXh0dXJlVW5pdCA9IGJpbmRpbmdzWysraV07XG4gICAgICAgIGlmICh0ZXh0dXJlVW5pdCA8IGdsLlRFWFRVUkUwIHx8IHRleHR1cmVVbml0ID4gZ2wuVEVYVFVSRTMxKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlRFWFRVUkVfQklORElOR18yRCBvciBURVhUVVJFX0JJTkRJTkdfQ1VCRV9NQVAgbXVzdCBiZSBmb2xsb3dlZCBieSBhIHZhbGlkIHRleHR1cmUgdW5pdFwiKTtcbiAgICAgICAgICBib3VuZFZhbHVlcy5wdXNoKG51bGwsIG51bGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWN0aXZlVGV4dHVyZSkge1xuICAgICAgICAgIGFjdGl2ZVRleHR1cmUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuQUNUSVZFX1RFWFRVUkUpO1xuICAgICAgICB9XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUodGV4dHVyZVVuaXQpO1xuICAgICAgICBib3VuZFZhbHVlcy5wdXNoKGdsLmdldFBhcmFtZXRlcihiaW5kaW5nKSwgbnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnbC5BQ1RJVkVfVEVYVFVSRTpcbiAgICAgICAgYWN0aXZlVGV4dHVyZSA9IGdsLmdldFBhcmFtZXRlcihnbC5BQ1RJVkVfVEVYVFVSRSk7XG4gICAgICAgIGJvdW5kVmFsdWVzLnB1c2gobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYm91bmRWYWx1ZXMucHVzaChnbC5nZXRQYXJhbWV0ZXIoYmluZGluZykpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY2FsbGJhY2soZ2wpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICB2YXIgYm91bmRWYWx1ZSA9IGJvdW5kVmFsdWVzW2ldO1xuICAgIHN3aXRjaCAoYmluZGluZykge1xuICAgICAgY2FzZSBnbC5BQ1RJVkVfVEVYVFVSRTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGdsLkFSUkFZX0JVRkZFUl9CSU5ESU5HOlxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYm91bmRWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnbC5DT0xPUl9DTEVBUl9WQUxVRTpcbiAgICAgICAgZ2wuY2xlYXJDb2xvcihib3VuZFZhbHVlWzBdLCBib3VuZFZhbHVlWzFdLCBib3VuZFZhbHVlWzJdLCBib3VuZFZhbHVlWzNdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGdsLkNPTE9SX1dSSVRFTUFTSzpcbiAgICAgICAgZ2wuY29sb3JNYXNrKGJvdW5kVmFsdWVbMF0sIGJvdW5kVmFsdWVbMV0sIGJvdW5kVmFsdWVbMl0sIGJvdW5kVmFsdWVbM10pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ2wuQ1VSUkVOVF9QUk9HUkFNOlxuICAgICAgICBnbC51c2VQcm9ncmFtKGJvdW5kVmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVJfQklORElORzpcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYm91bmRWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9CSU5ESU5HOlxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGJvdW5kVmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZ2wuUkVOREVSQlVGRkVSX0JJTkRJTkc6XG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBib3VuZFZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGdsLlRFWFRVUkVfQklORElOR18yRDpcbiAgICAgICAgdmFyIHRleHR1cmVVbml0ID0gYmluZGluZ3NbKytpXTtcbiAgICAgICAgaWYgKHRleHR1cmVVbml0IDwgZ2wuVEVYVFVSRTAgfHwgdGV4dHVyZVVuaXQgPiBnbC5URVhUVVJFMzEpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUodGV4dHVyZVVuaXQpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBib3VuZFZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGdsLlRFWFRVUkVfQklORElOR19DVUJFX01BUDpcbiAgICAgICAgdmFyIHRleHR1cmVVbml0ID0gYmluZGluZ3NbKytpXTtcbiAgICAgICAgaWYgKHRleHR1cmVVbml0IDwgZ2wuVEVYVFVSRTAgfHwgdGV4dHVyZVVuaXQgPiBnbC5URVhUVVJFMzEpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUodGV4dHVyZVVuaXQpO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCBib3VuZFZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGdsLlZJRVdQT1JUOlxuICAgICAgICBnbC52aWV3cG9ydChib3VuZFZhbHVlWzBdLCBib3VuZFZhbHVlWzFdLCBib3VuZFZhbHVlWzJdLCBib3VuZFZhbHVlWzNdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGdsLkJMRU5EOlxuICAgICAgY2FzZSBnbC5DVUxMX0ZBQ0U6XG4gICAgICBjYXNlIGdsLkRFUFRIX1RFU1Q6XG4gICAgICBjYXNlIGdsLlNDSVNTT1JfVEVTVDpcbiAgICAgIGNhc2UgZ2wuU1RFTkNJTF9URVNUOlxuICAgICAgICBpZiAoYm91bmRWYWx1ZSkge1xuICAgICAgICAgIGdsLmVuYWJsZShiaW5kaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbC5kaXNhYmxlKGJpbmRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29uc29sZS5sb2coXCJObyBHTCByZXN0b3JlIGJlaGF2aW9yIGZvciAweFwiICsgYmluZGluZy50b1N0cmluZygxNikpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGFjdGl2ZVRleHR1cmUpIHtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoYWN0aXZlVGV4dHVyZSk7XG4gICAgfVxuICB9XG59XG52YXIgZ2xQcmVzZXJ2ZVN0YXRlID0gV0dMVVByZXNlcnZlR0xTdGF0ZTtcbnZhciBkaXN0b3J0aW9uVlMgPSBbJ2F0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uOycsICdhdHRyaWJ1dGUgdmVjMyB0ZXhDb29yZDsnLCAndmFyeWluZyB2ZWMyIHZUZXhDb29yZDsnLCAndW5pZm9ybSB2ZWM0IHZpZXdwb3J0T2Zmc2V0U2NhbGVbMl07JywgJ3ZvaWQgbWFpbigpIHsnLCAnICB2ZWM0IHZpZXdwb3J0ID0gdmlld3BvcnRPZmZzZXRTY2FsZVtpbnQodGV4Q29vcmQueildOycsICcgIHZUZXhDb29yZCA9ICh0ZXhDb29yZC54eSAqIHZpZXdwb3J0Lnp3KSArIHZpZXdwb3J0Lnh5OycsICcgIGdsX1Bvc2l0aW9uID0gdmVjNCggcG9zaXRpb24sIDEuMCwgMS4wICk7JywgJ30nXS5qb2luKCdcXG4nKTtcbnZhciBkaXN0b3J0aW9uRlMgPSBbJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsICd1bmlmb3JtIHNhbXBsZXIyRCBkaWZmdXNlOycsICd2YXJ5aW5nIHZlYzIgdlRleENvb3JkOycsICd2b2lkIG1haW4oKSB7JywgJyAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKGRpZmZ1c2UsIHZUZXhDb29yZCk7JywgJ30nXS5qb2luKCdcXG4nKTtcbmZ1bmN0aW9uIENhcmRib2FyZERpc3RvcnRlcihnbCwgY2FyZGJvYXJkVUksIGJ1ZmZlclNjYWxlLCBkaXJ0eVN1Ym1pdEZyYW1lQmluZGluZ3MpIHtcbiAgdGhpcy5nbCA9IGdsO1xuICB0aGlzLmNhcmRib2FyZFVJID0gY2FyZGJvYXJkVUk7XG4gIHRoaXMuYnVmZmVyU2NhbGUgPSBidWZmZXJTY2FsZTtcbiAgdGhpcy5kaXJ0eVN1Ym1pdEZyYW1lQmluZGluZ3MgPSBkaXJ0eVN1Ym1pdEZyYW1lQmluZGluZ3M7XG4gIHRoaXMuY3R4QXR0cmlicyA9IGdsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XG4gIHRoaXMuaW5zdGFuY2VFeHQgPSBnbC5nZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcbiAgdGhpcy5tZXNoV2lkdGggPSAyMDtcbiAgdGhpcy5tZXNoSGVpZ2h0ID0gMjA7XG4gIHRoaXMuYnVmZmVyV2lkdGggPSBnbC5kcmF3aW5nQnVmZmVyV2lkdGg7XG4gIHRoaXMuYnVmZmVySGVpZ2h0ID0gZ2wuZHJhd2luZ0J1ZmZlckhlaWdodDtcbiAgdGhpcy5yZWFsQmluZEZyYW1lYnVmZmVyID0gZ2wuYmluZEZyYW1lYnVmZmVyO1xuICB0aGlzLnJlYWxFbmFibGUgPSBnbC5lbmFibGU7XG4gIHRoaXMucmVhbERpc2FibGUgPSBnbC5kaXNhYmxlO1xuICB0aGlzLnJlYWxDb2xvck1hc2sgPSBnbC5jb2xvck1hc2s7XG4gIHRoaXMucmVhbENsZWFyQ29sb3IgPSBnbC5jbGVhckNvbG9yO1xuICB0aGlzLnJlYWxWaWV3cG9ydCA9IGdsLnZpZXdwb3J0O1xuICBpZiAoIWlzSU9TKCkpIHtcbiAgICB0aGlzLnJlYWxDYW52YXNXaWR0aCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZ2wuY2FudmFzLl9fcHJvdG9fXywgJ3dpZHRoJyk7XG4gICAgdGhpcy5yZWFsQ2FudmFzSGVpZ2h0ID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbC5jYW52YXMuX19wcm90b19fLCAnaGVpZ2h0Jyk7XG4gIH1cbiAgdGhpcy5pc1BhdGNoZWQgPSBmYWxzZTtcbiAgdGhpcy5sYXN0Qm91bmRGcmFtZWJ1ZmZlciA9IG51bGw7XG4gIHRoaXMuY3VsbEZhY2UgPSBmYWxzZTtcbiAgdGhpcy5kZXB0aFRlc3QgPSBmYWxzZTtcbiAgdGhpcy5ibGVuZCA9IGZhbHNlO1xuICB0aGlzLnNjaXNzb3JUZXN0ID0gZmFsc2U7XG4gIHRoaXMuc3RlbmNpbFRlc3QgPSBmYWxzZTtcbiAgdGhpcy52aWV3cG9ydCA9IFswLCAwLCAwLCAwXTtcbiAgdGhpcy5jb2xvck1hc2sgPSBbdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZV07XG4gIHRoaXMuY2xlYXJDb2xvciA9IFswLCAwLCAwLCAwXTtcbiAgdGhpcy5hdHRyaWJzID0ge1xuICAgIHBvc2l0aW9uOiAwLFxuICAgIHRleENvb3JkOiAxXG4gIH07XG4gIHRoaXMucHJvZ3JhbSA9IGxpbmtQcm9ncmFtKGdsLCBkaXN0b3J0aW9uVlMsIGRpc3RvcnRpb25GUywgdGhpcy5hdHRyaWJzKTtcbiAgdGhpcy51bmlmb3JtcyA9IGdldFByb2dyYW1Vbmlmb3JtcyhnbCwgdGhpcy5wcm9ncmFtKTtcbiAgdGhpcy52aWV3cG9ydE9mZnNldFNjYWxlID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcbiAgdGhpcy5zZXRUZXh0dXJlQm91bmRzKCk7XG4gIHRoaXMudmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gIHRoaXMuaW5kZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgdGhpcy5pbmRleENvdW50ID0gMDtcbiAgdGhpcy5yZW5kZXJUYXJnZXQgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gIHRoaXMuZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICB0aGlzLmRlcHRoU3RlbmNpbEJ1ZmZlciA9IG51bGw7XG4gIHRoaXMuZGVwdGhCdWZmZXIgPSBudWxsO1xuICB0aGlzLnN0ZW5jaWxCdWZmZXIgPSBudWxsO1xuICBpZiAodGhpcy5jdHhBdHRyaWJzLmRlcHRoICYmIHRoaXMuY3R4QXR0cmlicy5zdGVuY2lsKSB7XG4gICAgdGhpcy5kZXB0aFN0ZW5jaWxCdWZmZXIgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmN0eEF0dHJpYnMuZGVwdGgpIHtcbiAgICB0aGlzLmRlcHRoQnVmZmVyID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5jdHhBdHRyaWJzLnN0ZW5jaWwpIHtcbiAgICB0aGlzLnN0ZW5jaWxCdWZmZXIgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgfVxuICB0aGlzLnBhdGNoKCk7XG4gIHRoaXMub25SZXNpemUoKTtcbn1cbkNhcmRib2FyZERpc3RvcnRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdsID0gdGhpcy5nbDtcbiAgdGhpcy51bnBhdGNoKCk7XG4gIGdsLmRlbGV0ZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4QnVmZmVyKTtcbiAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuaW5kZXhCdWZmZXIpO1xuICBnbC5kZWxldGVUZXh0dXJlKHRoaXMucmVuZGVyVGFyZ2V0KTtcbiAgZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlcik7XG4gIGlmICh0aGlzLmRlcHRoU3RlbmNpbEJ1ZmZlcikge1xuICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcih0aGlzLmRlcHRoU3RlbmNpbEJ1ZmZlcik7XG4gIH1cbiAgaWYgKHRoaXMuZGVwdGhCdWZmZXIpIHtcbiAgICBnbC5kZWxldGVSZW5kZXJidWZmZXIodGhpcy5kZXB0aEJ1ZmZlcik7XG4gIH1cbiAgaWYgKHRoaXMuc3RlbmNpbEJ1ZmZlcikge1xuICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcih0aGlzLnN0ZW5jaWxCdWZmZXIpO1xuICB9XG4gIGlmICh0aGlzLmNhcmRib2FyZFVJKSB7XG4gICAgdGhpcy5jYXJkYm9hcmRVSS5kZXN0cm95KCk7XG4gIH1cbn07XG5DYXJkYm9hcmREaXN0b3J0ZXIucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ2wgPSB0aGlzLmdsO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBnbFN0YXRlID0gW2dsLlJFTkRFUkJVRkZFUl9CSU5ESU5HLCBnbC5URVhUVVJFX0JJTkRJTkdfMkQsIGdsLlRFWFRVUkUwXTtcbiAgZ2xQcmVzZXJ2ZVN0YXRlKGdsLCBnbFN0YXRlLCBmdW5jdGlvbiAoZ2wpIHtcbiAgICBzZWxmLnJlYWxCaW5kRnJhbWVidWZmZXIuY2FsbChnbCwgZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIGlmIChzZWxmLnNjaXNzb3JUZXN0KSB7XG4gICAgICBzZWxmLnJlYWxEaXNhYmxlLmNhbGwoZ2wsIGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgfVxuICAgIHNlbGYucmVhbENvbG9yTWFzay5jYWxsKGdsLCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICBzZWxmLnJlYWxWaWV3cG9ydC5jYWxsKGdsLCAwLCAwLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgIHNlbGYucmVhbENsZWFyQ29sb3IuY2FsbChnbCwgMCwgMCwgMCwgMSk7XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgc2VsZi5yZWFsQmluZEZyYW1lYnVmZmVyLmNhbGwoZ2wsIGdsLkZSQU1FQlVGRkVSLCBzZWxmLmZyYW1lYnVmZmVyKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBzZWxmLnJlbmRlclRhcmdldCk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBzZWxmLmN0eEF0dHJpYnMuYWxwaGEgPyBnbC5SR0JBIDogZ2wuUkdCLCBzZWxmLmJ1ZmZlcldpZHRoLCBzZWxmLmJ1ZmZlckhlaWdodCwgMCwgc2VsZi5jdHhBdHRyaWJzLmFscGhhID8gZ2wuUkdCQSA6IGdsLlJHQiwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBzZWxmLnJlbmRlclRhcmdldCwgMCk7XG4gICAgaWYgKHNlbGYuY3R4QXR0cmlicy5kZXB0aCAmJiBzZWxmLmN0eEF0dHJpYnMuc3RlbmNpbCkge1xuICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHNlbGYuZGVwdGhTdGVuY2lsQnVmZmVyKTtcbiAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMLCBzZWxmLmJ1ZmZlcldpZHRoLCBzZWxmLmJ1ZmZlckhlaWdodCk7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHNlbGYuZGVwdGhTdGVuY2lsQnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHNlbGYuY3R4QXR0cmlicy5kZXB0aCkge1xuICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIHNlbGYuZGVwdGhCdWZmZXIpO1xuICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCBzZWxmLmJ1ZmZlcldpZHRoLCBzZWxmLmJ1ZmZlckhlaWdodCk7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBzZWxmLmRlcHRoQnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHNlbGYuY3R4QXR0cmlicy5zdGVuY2lsKSB7XG4gICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgc2VsZi5zdGVuY2lsQnVmZmVyKTtcbiAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5TVEVOQ0lMX0lOREVYOCwgc2VsZi5idWZmZXJXaWR0aCwgc2VsZi5idWZmZXJIZWlnaHQpO1xuICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLlNURU5DSUxfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBzZWxmLnN0ZW5jaWxCdWZmZXIpO1xuICAgIH1cbiAgICBpZiAoIWdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpID09PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSkge1xuICAgICAgY29uc29sZS5lcnJvcignRnJhbWVidWZmZXIgaW5jb21wbGV0ZSEnKTtcbiAgICB9XG4gICAgc2VsZi5yZWFsQmluZEZyYW1lYnVmZmVyLmNhbGwoZ2wsIGdsLkZSQU1FQlVGRkVSLCBzZWxmLmxhc3RCb3VuZEZyYW1lYnVmZmVyKTtcbiAgICBpZiAoc2VsZi5zY2lzc29yVGVzdCkge1xuICAgICAgc2VsZi5yZWFsRW5hYmxlLmNhbGwoZ2wsIGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgfVxuICAgIHNlbGYucmVhbENvbG9yTWFzay5hcHBseShnbCwgc2VsZi5jb2xvck1hc2spO1xuICAgIHNlbGYucmVhbFZpZXdwb3J0LmFwcGx5KGdsLCBzZWxmLnZpZXdwb3J0KTtcbiAgICBzZWxmLnJlYWxDbGVhckNvbG9yLmFwcGx5KGdsLCBzZWxmLmNsZWFyQ29sb3IpO1xuICB9KTtcbiAgaWYgKHRoaXMuY2FyZGJvYXJkVUkpIHtcbiAgICB0aGlzLmNhcmRib2FyZFVJLm9uUmVzaXplKCk7XG4gIH1cbn07XG5DYXJkYm9hcmREaXN0b3J0ZXIucHJvdG90eXBlLnBhdGNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5pc1BhdGNoZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgY2FudmFzID0gdGhpcy5nbC5jYW52YXM7XG4gIHZhciBnbCA9IHRoaXMuZ2w7XG4gIGlmICghaXNJT1MoKSkge1xuICAgIGNhbnZhcy53aWR0aCA9IGdldFNjcmVlbldpZHRoKCkgKiB0aGlzLmJ1ZmZlclNjYWxlO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBnZXRTY3JlZW5IZWlnaHQoKSAqIHRoaXMuYnVmZmVyU2NhbGU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhbnZhcywgJ3dpZHRoJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gc2VsZi5idWZmZXJXaWR0aDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICBzZWxmLmJ1ZmZlcldpZHRoID0gdmFsdWU7XG4gICAgICAgIHNlbGYucmVhbENhbnZhc1dpZHRoLnNldC5jYWxsKGNhbnZhcywgdmFsdWUpO1xuICAgICAgICBzZWxmLm9uUmVzaXplKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhbnZhcywgJ2hlaWdodCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuYnVmZmVySGVpZ2h0O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICAgIHNlbGYuYnVmZmVySGVpZ2h0ID0gdmFsdWU7XG4gICAgICAgIHNlbGYucmVhbENhbnZhc0hlaWdodC5zZXQuY2FsbChjYW52YXMsIHZhbHVlKTtcbiAgICAgICAgc2VsZi5vblJlc2l6ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRoaXMubGFzdEJvdW5kRnJhbWVidWZmZXIgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuRlJBTUVCVUZGRVJfQklORElORyk7XG4gIGlmICh0aGlzLmxhc3RCb3VuZEZyYW1lYnVmZmVyID09IG51bGwpIHtcbiAgICB0aGlzLmxhc3RCb3VuZEZyYW1lYnVmZmVyID0gdGhpcy5mcmFtZWJ1ZmZlcjtcbiAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gIH1cbiAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIgPSBmdW5jdGlvbiAodGFyZ2V0LCBmcmFtZWJ1ZmZlcikge1xuICAgIHNlbGYubGFzdEJvdW5kRnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlciA/IGZyYW1lYnVmZmVyIDogc2VsZi5mcmFtZWJ1ZmZlcjtcbiAgICBzZWxmLnJlYWxCaW5kRnJhbWVidWZmZXIuY2FsbChnbCwgdGFyZ2V0LCBzZWxmLmxhc3RCb3VuZEZyYW1lYnVmZmVyKTtcbiAgfTtcbiAgdGhpcy5jdWxsRmFjZSA9IGdsLmdldFBhcmFtZXRlcihnbC5DVUxMX0ZBQ0UpO1xuICB0aGlzLmRlcHRoVGVzdCA9IGdsLmdldFBhcmFtZXRlcihnbC5ERVBUSF9URVNUKTtcbiAgdGhpcy5ibGVuZCA9IGdsLmdldFBhcmFtZXRlcihnbC5CTEVORCk7XG4gIHRoaXMuc2Npc3NvclRlc3QgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuU0NJU1NPUl9URVNUKTtcbiAgdGhpcy5zdGVuY2lsVGVzdCA9IGdsLmdldFBhcmFtZXRlcihnbC5TVEVOQ0lMX1RFU1QpO1xuICBnbC5lbmFibGUgPSBmdW5jdGlvbiAocG5hbWUpIHtcbiAgICBzd2l0Y2ggKHBuYW1lKSB7XG4gICAgICBjYXNlIGdsLkNVTExfRkFDRTpcbiAgICAgICAgc2VsZi5jdWxsRmFjZSA9IHRydWU7YnJlYWs7XG4gICAgICBjYXNlIGdsLkRFUFRIX1RFU1Q6XG4gICAgICAgIHNlbGYuZGVwdGhUZXN0ID0gdHJ1ZTticmVhaztcbiAgICAgIGNhc2UgZ2wuQkxFTkQ6XG4gICAgICAgIHNlbGYuYmxlbmQgPSB0cnVlO2JyZWFrO1xuICAgICAgY2FzZSBnbC5TQ0lTU09SX1RFU1Q6XG4gICAgICAgIHNlbGYuc2Npc3NvclRlc3QgPSB0cnVlO2JyZWFrO1xuICAgICAgY2FzZSBnbC5TVEVOQ0lMX1RFU1Q6XG4gICAgICAgIHNlbGYuc3RlbmNpbFRlc3QgPSB0cnVlO2JyZWFrO1xuICAgIH1cbiAgICBzZWxmLnJlYWxFbmFibGUuY2FsbChnbCwgcG5hbWUpO1xuICB9O1xuICBnbC5kaXNhYmxlID0gZnVuY3Rpb24gKHBuYW1lKSB7XG4gICAgc3dpdGNoIChwbmFtZSkge1xuICAgICAgY2FzZSBnbC5DVUxMX0ZBQ0U6XG4gICAgICAgIHNlbGYuY3VsbEZhY2UgPSBmYWxzZTticmVhaztcbiAgICAgIGNhc2UgZ2wuREVQVEhfVEVTVDpcbiAgICAgICAgc2VsZi5kZXB0aFRlc3QgPSBmYWxzZTticmVhaztcbiAgICAgIGNhc2UgZ2wuQkxFTkQ6XG4gICAgICAgIHNlbGYuYmxlbmQgPSBmYWxzZTticmVhaztcbiAgICAgIGNhc2UgZ2wuU0NJU1NPUl9URVNUOlxuICAgICAgICBzZWxmLnNjaXNzb3JUZXN0ID0gZmFsc2U7YnJlYWs7XG4gICAgICBjYXNlIGdsLlNURU5DSUxfVEVTVDpcbiAgICAgICAgc2VsZi5zdGVuY2lsVGVzdCA9IGZhbHNlO2JyZWFrO1xuICAgIH1cbiAgICBzZWxmLnJlYWxEaXNhYmxlLmNhbGwoZ2wsIHBuYW1lKTtcbiAgfTtcbiAgdGhpcy5jb2xvck1hc2sgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuQ09MT1JfV1JJVEVNQVNLKTtcbiAgZ2wuY29sb3JNYXNrID0gZnVuY3Rpb24gKHIsIGcsIGIsIGEpIHtcbiAgICBzZWxmLmNvbG9yTWFza1swXSA9IHI7XG4gICAgc2VsZi5jb2xvck1hc2tbMV0gPSBnO1xuICAgIHNlbGYuY29sb3JNYXNrWzJdID0gYjtcbiAgICBzZWxmLmNvbG9yTWFza1szXSA9IGE7XG4gICAgc2VsZi5yZWFsQ29sb3JNYXNrLmNhbGwoZ2wsIHIsIGcsIGIsIGEpO1xuICB9O1xuICB0aGlzLmNsZWFyQ29sb3IgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuQ09MT1JfQ0xFQVJfVkFMVUUpO1xuICBnbC5jbGVhckNvbG9yID0gZnVuY3Rpb24gKHIsIGcsIGIsIGEpIHtcbiAgICBzZWxmLmNsZWFyQ29sb3JbMF0gPSByO1xuICAgIHNlbGYuY2xlYXJDb2xvclsxXSA9IGc7XG4gICAgc2VsZi5jbGVhckNvbG9yWzJdID0gYjtcbiAgICBzZWxmLmNsZWFyQ29sb3JbM10gPSBhO1xuICAgIHNlbGYucmVhbENsZWFyQ29sb3IuY2FsbChnbCwgciwgZywgYiwgYSk7XG4gIH07XG4gIHRoaXMudmlld3BvcnQgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuVklFV1BPUlQpO1xuICBnbC52aWV3cG9ydCA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgc2VsZi52aWV3cG9ydFswXSA9IHg7XG4gICAgc2VsZi52aWV3cG9ydFsxXSA9IHk7XG4gICAgc2VsZi52aWV3cG9ydFsyXSA9IHc7XG4gICAgc2VsZi52aWV3cG9ydFszXSA9IGg7XG4gICAgc2VsZi5yZWFsVmlld3BvcnQuY2FsbChnbCwgeCwgeSwgdywgaCk7XG4gIH07XG4gIHRoaXMuaXNQYXRjaGVkID0gdHJ1ZTtcbiAgc2FmYXJpQ3NzU2l6ZVdvcmthcm91bmQoY2FudmFzKTtcbn07XG5DYXJkYm9hcmREaXN0b3J0ZXIucHJvdG90eXBlLnVucGF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5pc1BhdGNoZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGdsID0gdGhpcy5nbDtcbiAgdmFyIGNhbnZhcyA9IHRoaXMuZ2wuY2FudmFzO1xuICBpZiAoIWlzSU9TKCkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FudmFzLCAnd2lkdGgnLCB0aGlzLnJlYWxDYW52YXNXaWR0aCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhbnZhcywgJ2hlaWdodCcsIHRoaXMucmVhbENhbnZhc0hlaWdodCk7XG4gIH1cbiAgY2FudmFzLndpZHRoID0gdGhpcy5idWZmZXJXaWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IHRoaXMuYnVmZmVySGVpZ2h0O1xuICBnbC5iaW5kRnJhbWVidWZmZXIgPSB0aGlzLnJlYWxCaW5kRnJhbWVidWZmZXI7XG4gIGdsLmVuYWJsZSA9IHRoaXMucmVhbEVuYWJsZTtcbiAgZ2wuZGlzYWJsZSA9IHRoaXMucmVhbERpc2FibGU7XG4gIGdsLmNvbG9yTWFzayA9IHRoaXMucmVhbENvbG9yTWFzaztcbiAgZ2wuY2xlYXJDb2xvciA9IHRoaXMucmVhbENsZWFyQ29sb3I7XG4gIGdsLnZpZXdwb3J0ID0gdGhpcy5yZWFsVmlld3BvcnQ7XG4gIGlmICh0aGlzLmxhc3RCb3VuZEZyYW1lYnVmZmVyID09IHRoaXMuZnJhbWVidWZmZXIpIHtcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICB9XG4gIHRoaXMuaXNQYXRjaGVkID0gZmFsc2U7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNhZmFyaUNzc1NpemVXb3JrYXJvdW5kKGNhbnZhcyk7XG4gIH0sIDEpO1xufTtcbkNhcmRib2FyZERpc3RvcnRlci5wcm90b3R5cGUuc2V0VGV4dHVyZUJvdW5kcyA9IGZ1bmN0aW9uIChsZWZ0Qm91bmRzLCByaWdodEJvdW5kcykge1xuICBpZiAoIWxlZnRCb3VuZHMpIHtcbiAgICBsZWZ0Qm91bmRzID0gWzAsIDAsIDAuNSwgMV07XG4gIH1cbiAgaWYgKCFyaWdodEJvdW5kcykge1xuICAgIHJpZ2h0Qm91bmRzID0gWzAuNSwgMCwgMC41LCAxXTtcbiAgfVxuICB0aGlzLnZpZXdwb3J0T2Zmc2V0U2NhbGVbMF0gPSBsZWZ0Qm91bmRzWzBdO1xuICB0aGlzLnZpZXdwb3J0T2Zmc2V0U2NhbGVbMV0gPSBsZWZ0Qm91bmRzWzFdO1xuICB0aGlzLnZpZXdwb3J0T2Zmc2V0U2NhbGVbMl0gPSBsZWZ0Qm91bmRzWzJdO1xuICB0aGlzLnZpZXdwb3J0T2Zmc2V0U2NhbGVbM10gPSBsZWZ0Qm91bmRzWzNdO1xuICB0aGlzLnZpZXdwb3J0T2Zmc2V0U2NhbGVbNF0gPSByaWdodEJvdW5kc1swXTtcbiAgdGhpcy52aWV3cG9ydE9mZnNldFNjYWxlWzVdID0gcmlnaHRCb3VuZHNbMV07XG4gIHRoaXMudmlld3BvcnRPZmZzZXRTY2FsZVs2XSA9IHJpZ2h0Qm91bmRzWzJdO1xuICB0aGlzLnZpZXdwb3J0T2Zmc2V0U2NhbGVbN10gPSByaWdodEJvdW5kc1szXTtcbn07XG5DYXJkYm9hcmREaXN0b3J0ZXIucHJvdG90eXBlLnN1Ym1pdEZyYW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ2wgPSB0aGlzLmdsO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBnbFN0YXRlID0gW107XG4gIGlmICghdGhpcy5kaXJ0eVN1Ym1pdEZyYW1lQmluZGluZ3MpIHtcbiAgICBnbFN0YXRlLnB1c2goZ2wuQ1VSUkVOVF9QUk9HUkFNLCBnbC5BUlJBWV9CVUZGRVJfQklORElORywgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVJfQklORElORywgZ2wuVEVYVFVSRV9CSU5ESU5HXzJELCBnbC5URVhUVVJFMCk7XG4gIH1cbiAgZ2xQcmVzZXJ2ZVN0YXRlKGdsLCBnbFN0YXRlLCBmdW5jdGlvbiAoZ2wpIHtcbiAgICBzZWxmLnJlYWxCaW5kRnJhbWVidWZmZXIuY2FsbChnbCwgZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIHZhciBwb3NpdGlvbkRpdmlzb3IgPSAwO1xuICAgIHZhciB0ZXhDb29yZERpdmlzb3IgPSAwO1xuICAgIGlmIChzZWxmLmluc3RhbmNlRXh0KSB7XG4gICAgICBwb3NpdGlvbkRpdmlzb3IgPSBnbC5nZXRWZXJ0ZXhBdHRyaWIoc2VsZi5hdHRyaWJzLnBvc2l0aW9uLCBzZWxmLmluc3RhbmNlRXh0LlZFUlRFWF9BVFRSSUJfQVJSQVlfRElWSVNPUl9BTkdMRSk7XG4gICAgICB0ZXhDb29yZERpdmlzb3IgPSBnbC5nZXRWZXJ0ZXhBdHRyaWIoc2VsZi5hdHRyaWJzLnRleENvb3JkLCBzZWxmLmluc3RhbmNlRXh0LlZFUlRFWF9BVFRSSUJfQVJSQVlfRElWSVNPUl9BTkdMRSk7XG4gICAgfVxuICAgIGlmIChzZWxmLmN1bGxGYWNlKSB7XG4gICAgICBzZWxmLnJlYWxEaXNhYmxlLmNhbGwoZ2wsIGdsLkNVTExfRkFDRSk7XG4gICAgfVxuICAgIGlmIChzZWxmLmRlcHRoVGVzdCkge1xuICAgICAgc2VsZi5yZWFsRGlzYWJsZS5jYWxsKGdsLCBnbC5ERVBUSF9URVNUKTtcbiAgICB9XG4gICAgaWYgKHNlbGYuYmxlbmQpIHtcbiAgICAgIHNlbGYucmVhbERpc2FibGUuY2FsbChnbCwgZ2wuQkxFTkQpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5zY2lzc29yVGVzdCkge1xuICAgICAgc2VsZi5yZWFsRGlzYWJsZS5jYWxsKGdsLCBnbC5TQ0lTU09SX1RFU1QpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5zdGVuY2lsVGVzdCkge1xuICAgICAgc2VsZi5yZWFsRGlzYWJsZS5jYWxsKGdsLCBnbC5TVEVOQ0lMX1RFU1QpO1xuICAgIH1cbiAgICBzZWxmLnJlYWxDb2xvck1hc2suY2FsbChnbCwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgc2VsZi5yZWFsVmlld3BvcnQuY2FsbChnbCwgMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgICBpZiAoc2VsZi5jdHhBdHRyaWJzLmFscGhhIHx8IGlzSU9TKCkpIHtcbiAgICAgIHNlbGYucmVhbENsZWFyQ29sb3IuY2FsbChnbCwgMCwgMCwgMCwgMSk7XG4gICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICB9XG4gICAgZ2wudXNlUHJvZ3JhbShzZWxmLnByb2dyYW0pO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHNlbGYuaW5kZXhCdWZmZXIpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBzZWxmLnZlcnRleEJ1ZmZlcik7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoc2VsZi5hdHRyaWJzLnBvc2l0aW9uKTtcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShzZWxmLmF0dHJpYnMudGV4Q29vcmQpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2VsZi5hdHRyaWJzLnBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIwLCAwKTtcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNlbGYuYXR0cmlicy50ZXhDb29yZCwgMywgZ2wuRkxPQVQsIGZhbHNlLCAyMCwgOCk7XG4gICAgaWYgKHNlbGYuaW5zdGFuY2VFeHQpIHtcbiAgICAgIGlmIChwb3NpdGlvbkRpdmlzb3IgIT0gMCkge1xuICAgICAgICBzZWxmLmluc3RhbmNlRXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShzZWxmLmF0dHJpYnMucG9zaXRpb24sIDApO1xuICAgICAgfVxuICAgICAgaWYgKHRleENvb3JkRGl2aXNvciAhPSAwKSB7XG4gICAgICAgIHNlbGYuaW5zdGFuY2VFeHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKHNlbGYuYXR0cmlicy50ZXhDb29yZCwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgIGdsLnVuaWZvcm0xaShzZWxmLnVuaWZvcm1zLmRpZmZ1c2UsIDApO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHNlbGYucmVuZGVyVGFyZ2V0KTtcbiAgICBnbC51bmlmb3JtNGZ2KHNlbGYudW5pZm9ybXMudmlld3BvcnRPZmZzZXRTY2FsZSwgc2VsZi52aWV3cG9ydE9mZnNldFNjYWxlKTtcbiAgICBnbC5kcmF3RWxlbWVudHMoZ2wuVFJJQU5HTEVTLCBzZWxmLmluZGV4Q291bnQsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICBpZiAoc2VsZi5jYXJkYm9hcmRVSSkge1xuICAgICAgc2VsZi5jYXJkYm9hcmRVSS5yZW5kZXJOb1N0YXRlKCk7XG4gICAgfVxuICAgIHNlbGYucmVhbEJpbmRGcmFtZWJ1ZmZlci5jYWxsKHNlbGYuZ2wsIGdsLkZSQU1FQlVGRkVSLCBzZWxmLmZyYW1lYnVmZmVyKTtcbiAgICBpZiAoIXNlbGYuY3R4QXR0cmlicy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIpIHtcbiAgICAgIHNlbGYucmVhbENsZWFyQ29sb3IuY2FsbChnbCwgMCwgMCwgMCwgMCk7XG4gICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICB9XG4gICAgaWYgKCFzZWxmLmRpcnR5U3VibWl0RnJhbWVCaW5kaW5ncykge1xuICAgICAgc2VsZi5yZWFsQmluZEZyYW1lYnVmZmVyLmNhbGwoZ2wsIGdsLkZSQU1FQlVGRkVSLCBzZWxmLmxhc3RCb3VuZEZyYW1lYnVmZmVyKTtcbiAgICB9XG4gICAgaWYgKHNlbGYuY3VsbEZhY2UpIHtcbiAgICAgIHNlbGYucmVhbEVuYWJsZS5jYWxsKGdsLCBnbC5DVUxMX0ZBQ0UpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5kZXB0aFRlc3QpIHtcbiAgICAgIHNlbGYucmVhbEVuYWJsZS5jYWxsKGdsLCBnbC5ERVBUSF9URVNUKTtcbiAgICB9XG4gICAgaWYgKHNlbGYuYmxlbmQpIHtcbiAgICAgIHNlbGYucmVhbEVuYWJsZS5jYWxsKGdsLCBnbC5CTEVORCk7XG4gICAgfVxuICAgIGlmIChzZWxmLnNjaXNzb3JUZXN0KSB7XG4gICAgICBzZWxmLnJlYWxFbmFibGUuY2FsbChnbCwgZ2wuU0NJU1NPUl9URVNUKTtcbiAgICB9XG4gICAgaWYgKHNlbGYuc3RlbmNpbFRlc3QpIHtcbiAgICAgIHNlbGYucmVhbEVuYWJsZS5jYWxsKGdsLCBnbC5TVEVOQ0lMX1RFU1QpO1xuICAgIH1cbiAgICBzZWxmLnJlYWxDb2xvck1hc2suYXBwbHkoZ2wsIHNlbGYuY29sb3JNYXNrKTtcbiAgICBzZWxmLnJlYWxWaWV3cG9ydC5hcHBseShnbCwgc2VsZi52aWV3cG9ydCk7XG4gICAgaWYgKHNlbGYuY3R4QXR0cmlicy5hbHBoYSB8fCAhc2VsZi5jdHhBdHRyaWJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlcikge1xuICAgICAgc2VsZi5yZWFsQ2xlYXJDb2xvci5hcHBseShnbCwgc2VsZi5jbGVhckNvbG9yKTtcbiAgICB9XG4gICAgaWYgKHNlbGYuaW5zdGFuY2VFeHQpIHtcbiAgICAgIGlmIChwb3NpdGlvbkRpdmlzb3IgIT0gMCkge1xuICAgICAgICBzZWxmLmluc3RhbmNlRXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShzZWxmLmF0dHJpYnMucG9zaXRpb24sIHBvc2l0aW9uRGl2aXNvcik7XG4gICAgICB9XG4gICAgICBpZiAodGV4Q29vcmREaXZpc29yICE9IDApIHtcbiAgICAgICAgc2VsZi5pbnN0YW5jZUV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoc2VsZi5hdHRyaWJzLnRleENvb3JkLCB0ZXhDb29yZERpdmlzb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChpc0lPUygpKSB7XG4gICAgdmFyIGNhbnZhcyA9IGdsLmNhbnZhcztcbiAgICBpZiAoY2FudmFzLndpZHRoICE9IHNlbGYuYnVmZmVyV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPSBzZWxmLmJ1ZmZlckhlaWdodCkge1xuICAgICAgc2VsZi5idWZmZXJXaWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgIHNlbGYuYnVmZmVySGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgIHNlbGYub25SZXNpemUoKTtcbiAgICB9XG4gIH1cbn07XG5DYXJkYm9hcmREaXN0b3J0ZXIucHJvdG90eXBlLnVwZGF0ZURldmljZUluZm8gPSBmdW5jdGlvbiAoZGV2aWNlSW5mbykge1xuICB2YXIgZ2wgPSB0aGlzLmdsO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBnbFN0YXRlID0gW2dsLkFSUkFZX0JVRkZFUl9CSU5ESU5HLCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUl9CSU5ESU5HXTtcbiAgZ2xQcmVzZXJ2ZVN0YXRlKGdsLCBnbFN0YXRlLCBmdW5jdGlvbiAoZ2wpIHtcbiAgICB2YXIgdmVydGljZXMgPSBzZWxmLmNvbXB1dGVNZXNoVmVydGljZXNfKHNlbGYubWVzaFdpZHRoLCBzZWxmLm1lc2hIZWlnaHQsIGRldmljZUluZm8pO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBzZWxmLnZlcnRleEJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgaWYgKCFzZWxmLmluZGV4Q291bnQpIHtcbiAgICAgIHZhciBpbmRpY2VzID0gc2VsZi5jb21wdXRlTWVzaEluZGljZXNfKHNlbGYubWVzaFdpZHRoLCBzZWxmLm1lc2hIZWlnaHQpO1xuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgc2VsZi5pbmRleEJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICBzZWxmLmluZGV4Q291bnQgPSBpbmRpY2VzLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xufTtcbkNhcmRib2FyZERpc3RvcnRlci5wcm90b3R5cGUuY29tcHV0ZU1lc2hWZXJ0aWNlc18gPSBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCwgZGV2aWNlSW5mbykge1xuICB2YXIgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KDIgKiB3aWR0aCAqIGhlaWdodCAqIDUpO1xuICB2YXIgbGVuc0ZydXN0dW0gPSBkZXZpY2VJbmZvLmdldExlZnRFeWVWaXNpYmxlVGFuQW5nbGVzKCk7XG4gIHZhciBub0xlbnNGcnVzdHVtID0gZGV2aWNlSW5mby5nZXRMZWZ0RXllTm9MZW5zVGFuQW5nbGVzKCk7XG4gIHZhciB2aWV3cG9ydCA9IGRldmljZUluZm8uZ2V0TGVmdEV5ZVZpc2libGVTY3JlZW5SZWN0KG5vTGVuc0ZydXN0dW0pO1xuICB2YXIgdmlkeCA9IDA7XG4gIGZvciAodmFyIGUgPSAwOyBlIDwgMjsgZSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBoZWlnaHQ7IGorKykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aWR0aDsgaSsrLCB2aWR4KyspIHtcbiAgICAgICAgdmFyIHUgPSBpIC8gKHdpZHRoIC0gMSk7XG4gICAgICAgIHZhciB2ID0gaiAvIChoZWlnaHQgLSAxKTtcbiAgICAgICAgdmFyIHMgPSB1O1xuICAgICAgICB2YXIgdCA9IHY7XG4gICAgICAgIHZhciB4ID0gbGVycChsZW5zRnJ1c3R1bVswXSwgbGVuc0ZydXN0dW1bMl0sIHUpO1xuICAgICAgICB2YXIgeSA9IGxlcnAobGVuc0ZydXN0dW1bM10sIGxlbnNGcnVzdHVtWzFdLCB2KTtcbiAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG4gICAgICAgIHZhciByID0gZGV2aWNlSW5mby5kaXN0b3J0aW9uLmRpc3RvcnRJbnZlcnNlKGQpO1xuICAgICAgICB2YXIgcCA9IHggKiByIC8gZDtcbiAgICAgICAgdmFyIHEgPSB5ICogciAvIGQ7XG4gICAgICAgIHUgPSAocCAtIG5vTGVuc0ZydXN0dW1bMF0pIC8gKG5vTGVuc0ZydXN0dW1bMl0gLSBub0xlbnNGcnVzdHVtWzBdKTtcbiAgICAgICAgdiA9IChxIC0gbm9MZW5zRnJ1c3R1bVszXSkgLyAobm9MZW5zRnJ1c3R1bVsxXSAtIG5vTGVuc0ZydXN0dW1bM10pO1xuICAgICAgICB1ID0gKHZpZXdwb3J0LnggKyB1ICogdmlld3BvcnQud2lkdGggLSAwLjUpICogMi4wO1xuICAgICAgICB2ID0gKHZpZXdwb3J0LnkgKyB2ICogdmlld3BvcnQuaGVpZ2h0IC0gMC41KSAqIDIuMDtcbiAgICAgICAgdmVydGljZXNbdmlkeCAqIDUgKyAwXSA9IHU7XG4gICAgICAgIHZlcnRpY2VzW3ZpZHggKiA1ICsgMV0gPSB2O1xuICAgICAgICB2ZXJ0aWNlc1t2aWR4ICogNSArIDJdID0gcztcbiAgICAgICAgdmVydGljZXNbdmlkeCAqIDUgKyAzXSA9IHQ7XG4gICAgICAgIHZlcnRpY2VzW3ZpZHggKiA1ICsgNF0gPSBlO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdyA9IGxlbnNGcnVzdHVtWzJdIC0gbGVuc0ZydXN0dW1bMF07XG4gICAgbGVuc0ZydXN0dW1bMF0gPSAtKHcgKyBsZW5zRnJ1c3R1bVswXSk7XG4gICAgbGVuc0ZydXN0dW1bMl0gPSB3IC0gbGVuc0ZydXN0dW1bMl07XG4gICAgdyA9IG5vTGVuc0ZydXN0dW1bMl0gLSBub0xlbnNGcnVzdHVtWzBdO1xuICAgIG5vTGVuc0ZydXN0dW1bMF0gPSAtKHcgKyBub0xlbnNGcnVzdHVtWzBdKTtcbiAgICBub0xlbnNGcnVzdHVtWzJdID0gdyAtIG5vTGVuc0ZydXN0dW1bMl07XG4gICAgdmlld3BvcnQueCA9IDEgLSAodmlld3BvcnQueCArIHZpZXdwb3J0LndpZHRoKTtcbiAgfVxuICByZXR1cm4gdmVydGljZXM7XG59O1xuQ2FyZGJvYXJkRGlzdG9ydGVyLnByb3RvdHlwZS5jb21wdXRlTWVzaEluZGljZXNfID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoMiAqICh3aWR0aCAtIDEpICogKGhlaWdodCAtIDEpICogNik7XG4gIHZhciBoYWxmd2lkdGggPSB3aWR0aCAvIDI7XG4gIHZhciBoYWxmaGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgdmFyIHZpZHggPSAwO1xuICB2YXIgaWlkeCA9IDA7XG4gIGZvciAodmFyIGUgPSAwOyBlIDwgMjsgZSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBoZWlnaHQ7IGorKykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aWR0aDsgaSsrLCB2aWR4KyspIHtcbiAgICAgICAgaWYgKGkgPT0gMCB8fCBqID09IDApIGNvbnRpbnVlO1xuICAgICAgICBpZiAoaSA8PSBoYWxmd2lkdGggPT0gaiA8PSBoYWxmaGVpZ2h0KSB7XG4gICAgICAgICAgaW5kaWNlc1tpaWR4KytdID0gdmlkeDtcbiAgICAgICAgICBpbmRpY2VzW2lpZHgrK10gPSB2aWR4IC0gd2lkdGggLSAxO1xuICAgICAgICAgIGluZGljZXNbaWlkeCsrXSA9IHZpZHggLSB3aWR0aDtcbiAgICAgICAgICBpbmRpY2VzW2lpZHgrK10gPSB2aWR4IC0gd2lkdGggLSAxO1xuICAgICAgICAgIGluZGljZXNbaWlkeCsrXSA9IHZpZHg7XG4gICAgICAgICAgaW5kaWNlc1tpaWR4KytdID0gdmlkeCAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kaWNlc1tpaWR4KytdID0gdmlkeCAtIDE7XG4gICAgICAgICAgaW5kaWNlc1tpaWR4KytdID0gdmlkeCAtIHdpZHRoO1xuICAgICAgICAgIGluZGljZXNbaWlkeCsrXSA9IHZpZHg7XG4gICAgICAgICAgaW5kaWNlc1tpaWR4KytdID0gdmlkeCAtIHdpZHRoO1xuICAgICAgICAgIGluZGljZXNbaWlkeCsrXSA9IHZpZHggLSAxO1xuICAgICAgICAgIGluZGljZXNbaWlkeCsrXSA9IHZpZHggLSB3aWR0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZGljZXM7XG59O1xuQ2FyZGJvYXJkRGlzdG9ydGVyLnByb3RvdHlwZS5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JfID0gZnVuY3Rpb24gKHByb3RvLCBhdHRyTmFtZSkge1xuICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIGF0dHJOYW1lKTtcbiAgaWYgKGRlc2NyaXB0b3IuZ2V0ID09PSB1bmRlZmluZWQgfHwgZGVzY3JpcHRvci5zZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSB0cnVlO1xuICAgIGRlc2NyaXB0b3IuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHJOYW1lKTtcbiAgICB9O1xuICAgIGRlc2NyaXB0b3Iuc2V0ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIHZhbCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG52YXIgdWlWUyA9IFsnYXR0cmlidXRlIHZlYzIgcG9zaXRpb247JywgJ3VuaWZvcm0gbWF0NCBwcm9qZWN0aW9uTWF0OycsICd2b2lkIG1haW4oKSB7JywgJyAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0ICogdmVjNCggcG9zaXRpb24sIC0xLjAsIDEuMCApOycsICd9J10uam9pbignXFxuJyk7XG52YXIgdWlGUyA9IFsncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JywgJ3VuaWZvcm0gdmVjNCBjb2xvcjsnLCAndm9pZCBtYWluKCkgeycsICcgIGdsX0ZyYWdDb2xvciA9IGNvbG9yOycsICd9J10uam9pbignXFxuJyk7XG52YXIgREVHMlJBRCA9IE1hdGguUEkgLyAxODAuMDtcbnZhciBrQW5nbGVQZXJHZWFyU2VjdGlvbiA9IDYwO1xudmFyIGtPdXRlclJpbUVuZEFuZ2xlID0gMTI7XG52YXIga0lubmVyUmltQmVnaW5BbmdsZSA9IDIwO1xudmFyIGtPdXRlclJhZGl1cyA9IDE7XG52YXIga01pZGRsZVJhZGl1cyA9IDAuNzU7XG52YXIga0lubmVyUmFkaXVzID0gMC4zMTI1O1xudmFyIGtDZW50ZXJMaW5lVGhpY2tuZXNzRHAgPSA0O1xudmFyIGtCdXR0b25XaWR0aERwID0gMjg7XG52YXIga1RvdWNoU2xvcEZhY3RvciA9IDEuNTtcbmZ1bmN0aW9uIENhcmRib2FyZFVJKGdsKSB7XG4gIHRoaXMuZ2wgPSBnbDtcbiAgdGhpcy5hdHRyaWJzID0ge1xuICAgIHBvc2l0aW9uOiAwXG4gIH07XG4gIHRoaXMucHJvZ3JhbSA9IGxpbmtQcm9ncmFtKGdsLCB1aVZTLCB1aUZTLCB0aGlzLmF0dHJpYnMpO1xuICB0aGlzLnVuaWZvcm1zID0gZ2V0UHJvZ3JhbVVuaWZvcm1zKGdsLCB0aGlzLnByb2dyYW0pO1xuICB0aGlzLnZlcnRleEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICB0aGlzLmdlYXJPZmZzZXQgPSAwO1xuICB0aGlzLmdlYXJWZXJ0ZXhDb3VudCA9IDA7XG4gIHRoaXMuYXJyb3dPZmZzZXQgPSAwO1xuICB0aGlzLmFycm93VmVydGV4Q291bnQgPSAwO1xuICB0aGlzLnByb2pNYXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgdGhpcy5saXN0ZW5lciA9IG51bGw7XG4gIHRoaXMub25SZXNpemUoKTtcbn1cbkNhcmRib2FyZFVJLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ2wgPSB0aGlzLmdsO1xuICBpZiAodGhpcy5saXN0ZW5lcikge1xuICAgIGdsLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMubGlzdGVuZXIsIGZhbHNlKTtcbiAgfVxuICBnbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLnZlcnRleEJ1ZmZlcik7XG59O1xuQ2FyZGJvYXJkVUkucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChvcHRpb25zQ2FsbGJhY2ssIGJhY2tDYWxsYmFjaykge1xuICB2YXIgY2FudmFzID0gdGhpcy5nbC5jYW52YXM7XG4gIHRoaXMubGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgbWlkbGluZSA9IGNhbnZhcy5jbGllbnRXaWR0aCAvIDI7XG4gICAgdmFyIGJ1dHRvblNpemUgPSBrQnV0dG9uV2lkdGhEcCAqIGtUb3VjaFNsb3BGYWN0b3I7XG4gICAgaWYgKGV2ZW50LmNsaWVudFggPiBtaWRsaW5lIC0gYnV0dG9uU2l6ZSAmJiBldmVudC5jbGllbnRYIDwgbWlkbGluZSArIGJ1dHRvblNpemUgJiYgZXZlbnQuY2xpZW50WSA+IGNhbnZhcy5jbGllbnRIZWlnaHQgLSBidXR0b25TaXplKSB7XG4gICAgICBvcHRpb25zQ2FsbGJhY2soZXZlbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudC5jbGllbnRYIDwgYnV0dG9uU2l6ZSAmJiBldmVudC5jbGllbnRZIDwgYnV0dG9uU2l6ZSkge1xuICAgICAgICBiYWNrQ2FsbGJhY2soZXZlbnQpO1xuICAgICAgfVxuICB9O1xuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmxpc3RlbmVyLCBmYWxzZSk7XG59O1xuQ2FyZGJvYXJkVUkucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ2wgPSB0aGlzLmdsO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBnbFN0YXRlID0gW2dsLkFSUkFZX0JVRkZFUl9CSU5ESU5HXTtcbiAgZ2xQcmVzZXJ2ZVN0YXRlKGdsLCBnbFN0YXRlLCBmdW5jdGlvbiAoZ2wpIHtcbiAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICB2YXIgbWlkbGluZSA9IGdsLmRyYXdpbmdCdWZmZXJXaWR0aCAvIDI7XG4gICAgdmFyIHBoeXNpY2FsUGl4ZWxzID0gTWF0aC5tYXgoc2NyZWVuLndpZHRoLCBzY3JlZW4uaGVpZ2h0KSAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIHZhciBzY2FsaW5nUmF0aW8gPSBnbC5kcmF3aW5nQnVmZmVyV2lkdGggLyBwaHlzaWNhbFBpeGVscztcbiAgICB2YXIgZHBzID0gc2NhbGluZ1JhdGlvICogd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgdmFyIGxpbmVXaWR0aCA9IGtDZW50ZXJMaW5lVGhpY2tuZXNzRHAgKiBkcHMgLyAyO1xuICAgIHZhciBidXR0b25TaXplID0ga0J1dHRvbldpZHRoRHAgKiBrVG91Y2hTbG9wRmFjdG9yICogZHBzO1xuICAgIHZhciBidXR0b25TY2FsZSA9IGtCdXR0b25XaWR0aERwICogZHBzIC8gMjtcbiAgICB2YXIgYnV0dG9uQm9yZGVyID0gKGtCdXR0b25XaWR0aERwICoga1RvdWNoU2xvcEZhY3RvciAtIGtCdXR0b25XaWR0aERwKSAqIGRwcztcbiAgICB2ZXJ0aWNlcy5wdXNoKG1pZGxpbmUgLSBsaW5lV2lkdGgsIGJ1dHRvblNpemUpO1xuICAgIHZlcnRpY2VzLnB1c2gobWlkbGluZSAtIGxpbmVXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG4gICAgdmVydGljZXMucHVzaChtaWRsaW5lICsgbGluZVdpZHRoLCBidXR0b25TaXplKTtcbiAgICB2ZXJ0aWNlcy5wdXNoKG1pZGxpbmUgKyBsaW5lV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgIHNlbGYuZ2Vhck9mZnNldCA9IHZlcnRpY2VzLmxlbmd0aCAvIDI7XG4gICAgZnVuY3Rpb24gYWRkR2VhclNlZ21lbnQodGhldGEsIHIpIHtcbiAgICAgIHZhciBhbmdsZSA9ICg5MCAtIHRoZXRhKSAqIERFRzJSQUQ7XG4gICAgICB2YXIgeCA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHZhciB5ID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgdmVydGljZXMucHVzaChrSW5uZXJSYWRpdXMgKiB4ICogYnV0dG9uU2NhbGUgKyBtaWRsaW5lLCBrSW5uZXJSYWRpdXMgKiB5ICogYnV0dG9uU2NhbGUgKyBidXR0b25TY2FsZSk7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKHIgKiB4ICogYnV0dG9uU2NhbGUgKyBtaWRsaW5lLCByICogeSAqIGJ1dHRvblNjYWxlICsgYnV0dG9uU2NhbGUpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSA2OyBpKyspIHtcbiAgICAgIHZhciBzZWdtZW50VGhldGEgPSBpICoga0FuZ2xlUGVyR2VhclNlY3Rpb247XG4gICAgICBhZGRHZWFyU2VnbWVudChzZWdtZW50VGhldGEsIGtPdXRlclJhZGl1cyk7XG4gICAgICBhZGRHZWFyU2VnbWVudChzZWdtZW50VGhldGEgKyBrT3V0ZXJSaW1FbmRBbmdsZSwga091dGVyUmFkaXVzKTtcbiAgICAgIGFkZEdlYXJTZWdtZW50KHNlZ21lbnRUaGV0YSArIGtJbm5lclJpbUJlZ2luQW5nbGUsIGtNaWRkbGVSYWRpdXMpO1xuICAgICAgYWRkR2VhclNlZ21lbnQoc2VnbWVudFRoZXRhICsgKGtBbmdsZVBlckdlYXJTZWN0aW9uIC0ga0lubmVyUmltQmVnaW5BbmdsZSksIGtNaWRkbGVSYWRpdXMpO1xuICAgICAgYWRkR2VhclNlZ21lbnQoc2VnbWVudFRoZXRhICsgKGtBbmdsZVBlckdlYXJTZWN0aW9uIC0ga091dGVyUmltRW5kQW5nbGUpLCBrT3V0ZXJSYWRpdXMpO1xuICAgIH1cbiAgICBzZWxmLmdlYXJWZXJ0ZXhDb3VudCA9IHZlcnRpY2VzLmxlbmd0aCAvIDIgLSBzZWxmLmdlYXJPZmZzZXQ7XG4gICAgc2VsZi5hcnJvd09mZnNldCA9IHZlcnRpY2VzLmxlbmd0aCAvIDI7XG4gICAgZnVuY3Rpb24gYWRkQXJyb3dWZXJ0ZXgoeCwgeSkge1xuICAgICAgdmVydGljZXMucHVzaChidXR0b25Cb3JkZXIgKyB4LCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0IC0gYnV0dG9uQm9yZGVyIC0geSk7XG4gICAgfVxuICAgIHZhciBhbmdsZWRMaW5lV2lkdGggPSBsaW5lV2lkdGggLyBNYXRoLnNpbig0NSAqIERFRzJSQUQpO1xuICAgIGFkZEFycm93VmVydGV4KDAsIGJ1dHRvblNjYWxlKTtcbiAgICBhZGRBcnJvd1ZlcnRleChidXR0b25TY2FsZSwgMCk7XG4gICAgYWRkQXJyb3dWZXJ0ZXgoYnV0dG9uU2NhbGUgKyBhbmdsZWRMaW5lV2lkdGgsIGFuZ2xlZExpbmVXaWR0aCk7XG4gICAgYWRkQXJyb3dWZXJ0ZXgoYW5nbGVkTGluZVdpZHRoLCBidXR0b25TY2FsZSArIGFuZ2xlZExpbmVXaWR0aCk7XG4gICAgYWRkQXJyb3dWZXJ0ZXgoYW5nbGVkTGluZVdpZHRoLCBidXR0b25TY2FsZSAtIGFuZ2xlZExpbmVXaWR0aCk7XG4gICAgYWRkQXJyb3dWZXJ0ZXgoMCwgYnV0dG9uU2NhbGUpO1xuICAgIGFkZEFycm93VmVydGV4KGJ1dHRvblNjYWxlLCBidXR0b25TY2FsZSAqIDIpO1xuICAgIGFkZEFycm93VmVydGV4KGJ1dHRvblNjYWxlICsgYW5nbGVkTGluZVdpZHRoLCBidXR0b25TY2FsZSAqIDIgLSBhbmdsZWRMaW5lV2lkdGgpO1xuICAgIGFkZEFycm93VmVydGV4KGFuZ2xlZExpbmVXaWR0aCwgYnV0dG9uU2NhbGUgLSBhbmdsZWRMaW5lV2lkdGgpO1xuICAgIGFkZEFycm93VmVydGV4KDAsIGJ1dHRvblNjYWxlKTtcbiAgICBhZGRBcnJvd1ZlcnRleChhbmdsZWRMaW5lV2lkdGgsIGJ1dHRvblNjYWxlIC0gbGluZVdpZHRoKTtcbiAgICBhZGRBcnJvd1ZlcnRleChrQnV0dG9uV2lkdGhEcCAqIGRwcywgYnV0dG9uU2NhbGUgLSBsaW5lV2lkdGgpO1xuICAgIGFkZEFycm93VmVydGV4KGFuZ2xlZExpbmVXaWR0aCwgYnV0dG9uU2NhbGUgKyBsaW5lV2lkdGgpO1xuICAgIGFkZEFycm93VmVydGV4KGtCdXR0b25XaWR0aERwICogZHBzLCBidXR0b25TY2FsZSArIGxpbmVXaWR0aCk7XG4gICAgc2VsZi5hcnJvd1ZlcnRleENvdW50ID0gdmVydGljZXMubGVuZ3RoIC8gMiAtIHNlbGYuYXJyb3dPZmZzZXQ7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHNlbGYudmVydGV4QnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcyksIGdsLlNUQVRJQ19EUkFXKTtcbiAgfSk7XG59O1xuQ2FyZGJvYXJkVUkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGdsID0gdGhpcy5nbDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgZ2xTdGF0ZSA9IFtnbC5DVUxMX0ZBQ0UsIGdsLkRFUFRIX1RFU1QsIGdsLkJMRU5ELCBnbC5TQ0lTU09SX1RFU1QsIGdsLlNURU5DSUxfVEVTVCwgZ2wuQ09MT1JfV1JJVEVNQVNLLCBnbC5WSUVXUE9SVCwgZ2wuQ1VSUkVOVF9QUk9HUkFNLCBnbC5BUlJBWV9CVUZGRVJfQklORElOR107XG4gIGdsUHJlc2VydmVTdGF0ZShnbCwgZ2xTdGF0ZSwgZnVuY3Rpb24gKGdsKSB7XG4gICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gICAgZ2wuZGlzYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xuICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgICBzZWxmLnJlbmRlck5vU3RhdGUoKTtcbiAgfSk7XG59O1xuQ2FyZGJvYXJkVUkucHJvdG90eXBlLnJlbmRlck5vU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBnbCA9IHRoaXMuZ2w7XG4gIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5hdHRyaWJzLnBvc2l0aW9uKTtcbiAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmF0dHJpYnMucG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgOCwgMCk7XG4gIGdsLnVuaWZvcm00Zih0aGlzLnVuaWZvcm1zLmNvbG9yLCAxLjAsIDEuMCwgMS4wLCAxLjApO1xuICBvcnRob01hdHJpeCh0aGlzLnByb2pNYXQsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgMCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCwgMC4xLCAxMDI0LjApO1xuICBnbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMudW5pZm9ybXMucHJvamVjdGlvbk1hdCwgZmFsc2UsIHRoaXMucHJvak1hdCk7XG4gIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCB0aGlzLmdlYXJPZmZzZXQsIHRoaXMuZ2VhclZlcnRleENvdW50KTtcbiAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgdGhpcy5hcnJvd09mZnNldCwgdGhpcy5hcnJvd1ZlcnRleENvdW50KTtcbn07XG5mdW5jdGlvbiBEaXN0b3J0aW9uKGNvZWZmaWNpZW50cykge1xuICB0aGlzLmNvZWZmaWNpZW50cyA9IGNvZWZmaWNpZW50cztcbn1cbkRpc3RvcnRpb24ucHJvdG90eXBlLmRpc3RvcnRJbnZlcnNlID0gZnVuY3Rpb24gKHJhZGl1cykge1xuICB2YXIgcjAgPSAwO1xuICB2YXIgcjEgPSAxO1xuICB2YXIgZHIwID0gcmFkaXVzIC0gdGhpcy5kaXN0b3J0KHIwKTtcbiAgd2hpbGUgKE1hdGguYWJzKHIxIC0gcjApID4gMC4wMDAxICAgICAgICAgICAgICkge1xuICAgIHZhciBkcjEgPSByYWRpdXMgLSB0aGlzLmRpc3RvcnQocjEpO1xuICAgIHZhciByMiA9IHIxIC0gZHIxICogKChyMSAtIHIwKSAvIChkcjEgLSBkcjApKTtcbiAgICByMCA9IHIxO1xuICAgIHIxID0gcjI7XG4gICAgZHIwID0gZHIxO1xuICB9XG4gIHJldHVybiByMTtcbn07XG5EaXN0b3J0aW9uLnByb3RvdHlwZS5kaXN0b3J0ID0gZnVuY3Rpb24gKHJhZGl1cykge1xuICB2YXIgcjIgPSByYWRpdXMgKiByYWRpdXM7XG4gIHZhciByZXQgPSAwO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29lZmZpY2llbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmV0ID0gcjIgKiAocmV0ICsgdGhpcy5jb2VmZmljaWVudHNbaV0pO1xuICB9XG4gIHJldHVybiAocmV0ICsgMSkgKiByYWRpdXM7XG59O1xudmFyIGRlZ1RvUmFkID0gTWF0aC5QSSAvIDE4MDtcbnZhciByYWRUb0RlZyA9IDE4MCAvIE1hdGguUEk7XG52YXIgVmVjdG9yMyA9IGZ1bmN0aW9uIFZlY3RvcjMoeCwgeSwgeikge1xuICB0aGlzLnggPSB4IHx8IDA7XG4gIHRoaXMueSA9IHkgfHwgMDtcbiAgdGhpcy56ID0geiB8fCAwO1xufTtcblZlY3RvcjMucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogVmVjdG9yMyxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoeCwgeSwgeikge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnogPSB6O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb3B5OiBmdW5jdGlvbiBjb3B5KHYpIHtcbiAgICB0aGlzLnggPSB2Lng7XG4gICAgdGhpcy55ID0gdi55O1xuICAgIHRoaXMueiA9IHYuejtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbGVuZ3RoOiBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnopO1xuICB9LFxuICBub3JtYWxpemU6IGZ1bmN0aW9uIG5vcm1hbGl6ZSgpIHtcbiAgICB2YXIgc2NhbGFyID0gdGhpcy5sZW5ndGgoKTtcbiAgICBpZiAoc2NhbGFyICE9PSAwKSB7XG4gICAgICB2YXIgaW52U2NhbGFyID0gMSAvIHNjYWxhcjtcbiAgICAgIHRoaXMubXVsdGlwbHlTY2FsYXIoaW52U2NhbGFyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54ID0gMDtcbiAgICAgIHRoaXMueSA9IDA7XG4gICAgICB0aGlzLnogPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyKHNjYWxhcikge1xuICAgIHRoaXMueCAqPSBzY2FsYXI7XG4gICAgdGhpcy55ICo9IHNjYWxhcjtcbiAgICB0aGlzLnogKj0gc2NhbGFyO1xuICB9LFxuICBhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uIGFwcGx5UXVhdGVybmlvbihxKSB7XG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHogPSB0aGlzLno7XG4gICAgdmFyIHF4ID0gcS54O1xuICAgIHZhciBxeSA9IHEueTtcbiAgICB2YXIgcXogPSBxLno7XG4gICAgdmFyIHF3ID0gcS53O1xuICAgIHZhciBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeTtcbiAgICB2YXIgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHo7XG4gICAgdmFyIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICAgIHZhciBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG4gICAgdGhpcy54ID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgICB0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGRvdDogZnVuY3Rpb24gZG90KHYpIHtcbiAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xuICB9LFxuICBjcm9zc1ZlY3RvcnM6IGZ1bmN0aW9uIGNyb3NzVmVjdG9ycyhhLCBiKSB7XG4gICAgdmFyIGF4ID0gYS54LFxuICAgICAgICBheSA9IGEueSxcbiAgICAgICAgYXogPSBhLno7XG4gICAgdmFyIGJ4ID0gYi54LFxuICAgICAgICBieSA9IGIueSxcbiAgICAgICAgYnogPSBiLno7XG4gICAgdGhpcy54ID0gYXkgKiBieiAtIGF6ICogYnk7XG4gICAgdGhpcy55ID0gYXogKiBieCAtIGF4ICogYno7XG4gICAgdGhpcy56ID0gYXggKiBieSAtIGF5ICogYng7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG52YXIgUXVhdGVybmlvbiA9IGZ1bmN0aW9uIFF1YXRlcm5pb24oeCwgeSwgeiwgdykge1xuICB0aGlzLnggPSB4IHx8IDA7XG4gIHRoaXMueSA9IHkgfHwgMDtcbiAgdGhpcy56ID0geiB8fCAwO1xuICB0aGlzLncgPSB3ICE9PSB1bmRlZmluZWQgPyB3IDogMTtcbn07XG5RdWF0ZXJuaW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFF1YXRlcm5pb24sXG4gIHNldDogZnVuY3Rpb24gc2V0KHgsIHksIHosIHcpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy56ID0gejtcbiAgICB0aGlzLncgPSB3O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBjb3B5OiBmdW5jdGlvbiBjb3B5KHF1YXRlcm5pb24pIHtcbiAgICB0aGlzLnggPSBxdWF0ZXJuaW9uLng7XG4gICAgdGhpcy55ID0gcXVhdGVybmlvbi55O1xuICAgIHRoaXMueiA9IHF1YXRlcm5pb24uejtcbiAgICB0aGlzLncgPSBxdWF0ZXJuaW9uLnc7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldEZyb21FdWxlclhZWjogZnVuY3Rpb24gc2V0RnJvbUV1bGVyWFlaKHgsIHksIHopIHtcbiAgICB2YXIgYzEgPSBNYXRoLmNvcyh4IC8gMik7XG4gICAgdmFyIGMyID0gTWF0aC5jb3MoeSAvIDIpO1xuICAgIHZhciBjMyA9IE1hdGguY29zKHogLyAyKTtcbiAgICB2YXIgczEgPSBNYXRoLnNpbih4IC8gMik7XG4gICAgdmFyIHMyID0gTWF0aC5zaW4oeSAvIDIpO1xuICAgIHZhciBzMyA9IE1hdGguc2luKHogLyAyKTtcbiAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG4gICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldEZyb21FdWxlcllYWjogZnVuY3Rpb24gc2V0RnJvbUV1bGVyWVhaKHgsIHksIHopIHtcbiAgICB2YXIgYzEgPSBNYXRoLmNvcyh4IC8gMik7XG4gICAgdmFyIGMyID0gTWF0aC5jb3MoeSAvIDIpO1xuICAgIHZhciBjMyA9IE1hdGguY29zKHogLyAyKTtcbiAgICB2YXIgczEgPSBNYXRoLnNpbih4IC8gMik7XG4gICAgdmFyIHMyID0gTWF0aC5zaW4oeSAvIDIpO1xuICAgIHZhciBzMyA9IE1hdGguc2luKHogLyAyKTtcbiAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XG4gICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldEZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uIHNldEZyb21BeGlzQW5nbGUoYXhpcywgYW5nbGUpIHtcbiAgICB2YXIgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLFxuICAgICAgICBzID0gTWF0aC5zaW4oaGFsZkFuZ2xlKTtcbiAgICB0aGlzLnggPSBheGlzLnggKiBzO1xuICAgIHRoaXMueSA9IGF4aXMueSAqIHM7XG4gICAgdGhpcy56ID0gYXhpcy56ICogcztcbiAgICB0aGlzLncgPSBNYXRoLmNvcyhoYWxmQW5nbGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBtdWx0aXBseTogZnVuY3Rpb24gbXVsdGlwbHkocSkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnModGhpcywgcSk7XG4gIH0sXG4gIG11bHRpcGx5UXVhdGVybmlvbnM6IGZ1bmN0aW9uIG11bHRpcGx5UXVhdGVybmlvbnMoYSwgYikge1xuICAgIHZhciBxYXggPSBhLngsXG4gICAgICAgIHFheSA9IGEueSxcbiAgICAgICAgcWF6ID0gYS56LFxuICAgICAgICBxYXcgPSBhLnc7XG4gICAgdmFyIHFieCA9IGIueCxcbiAgICAgICAgcWJ5ID0gYi55LFxuICAgICAgICBxYnogPSBiLnosXG4gICAgICAgIHFidyA9IGIudztcbiAgICB0aGlzLnggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XG4gICAgdGhpcy55ID0gcWF5ICogcWJ3ICsgcWF3ICogcWJ5ICsgcWF6ICogcWJ4IC0gcWF4ICogcWJ6O1xuICAgIHRoaXMueiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcbiAgICB0aGlzLncgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGludmVyc2U6IGZ1bmN0aW9uIGludmVyc2UoKSB7XG4gICAgdGhpcy54ICo9IC0xO1xuICAgIHRoaXMueSAqPSAtMTtcbiAgICB0aGlzLnogKj0gLTE7XG4gICAgdGhpcy5ub3JtYWxpemUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUoKSB7XG4gICAgdmFyIGwgPSBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53KTtcbiAgICBpZiAobCA9PT0gMCkge1xuICAgICAgdGhpcy54ID0gMDtcbiAgICAgIHRoaXMueSA9IDA7XG4gICAgICB0aGlzLnogPSAwO1xuICAgICAgdGhpcy53ID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IDEgLyBsO1xuICAgICAgdGhpcy54ID0gdGhpcy54ICogbDtcbiAgICAgIHRoaXMueSA9IHRoaXMueSAqIGw7XG4gICAgICB0aGlzLnogPSB0aGlzLnogKiBsO1xuICAgICAgdGhpcy53ID0gdGhpcy53ICogbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNsZXJwOiBmdW5jdGlvbiBzbGVycChxYiwgdCkge1xuICAgIGlmICh0ID09PSAwKSByZXR1cm4gdGhpcztcbiAgICBpZiAodCA9PT0gMSkgcmV0dXJuIHRoaXMuY29weShxYik7XG4gICAgdmFyIHggPSB0aGlzLngsXG4gICAgICAgIHkgPSB0aGlzLnksXG4gICAgICAgIHogPSB0aGlzLnosXG4gICAgICAgIHcgPSB0aGlzLnc7XG4gICAgdmFyIGNvc0hhbGZUaGV0YSA9IHcgKiBxYi53ICsgeCAqIHFiLnggKyB5ICogcWIueSArIHogKiBxYi56O1xuICAgIGlmIChjb3NIYWxmVGhldGEgPCAwKSB7XG4gICAgICB0aGlzLncgPSAtcWIudztcbiAgICAgIHRoaXMueCA9IC1xYi54O1xuICAgICAgdGhpcy55ID0gLXFiLnk7XG4gICAgICB0aGlzLnogPSAtcWIuejtcbiAgICAgIGNvc0hhbGZUaGV0YSA9IC1jb3NIYWxmVGhldGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29weShxYik7XG4gICAgfVxuICAgIGlmIChjb3NIYWxmVGhldGEgPj0gMS4wKSB7XG4gICAgICB0aGlzLncgPSB3O1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLnogPSB6O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciBoYWxmVGhldGEgPSBNYXRoLmFjb3MoY29zSGFsZlRoZXRhKTtcbiAgICB2YXIgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KDEuMCAtIGNvc0hhbGZUaGV0YSAqIGNvc0hhbGZUaGV0YSk7XG4gICAgaWYgKE1hdGguYWJzKHNpbkhhbGZUaGV0YSkgPCAwLjAwMSkge1xuICAgICAgdGhpcy53ID0gMC41ICogKHcgKyB0aGlzLncpO1xuICAgICAgdGhpcy54ID0gMC41ICogKHggKyB0aGlzLngpO1xuICAgICAgdGhpcy55ID0gMC41ICogKHkgKyB0aGlzLnkpO1xuICAgICAgdGhpcy56ID0gMC41ICogKHogKyB0aGlzLnopO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHZhciByYXRpb0EgPSBNYXRoLnNpbigoMSAtIHQpICogaGFsZlRoZXRhKSAvIHNpbkhhbGZUaGV0YSxcbiAgICAgICAgcmF0aW9CID0gTWF0aC5zaW4odCAqIGhhbGZUaGV0YSkgLyBzaW5IYWxmVGhldGE7XG4gICAgdGhpcy53ID0gdyAqIHJhdGlvQSArIHRoaXMudyAqIHJhdGlvQjtcbiAgICB0aGlzLnggPSB4ICogcmF0aW9BICsgdGhpcy54ICogcmF0aW9CO1xuICAgIHRoaXMueSA9IHkgKiByYXRpb0EgKyB0aGlzLnkgKiByYXRpb0I7XG4gICAgdGhpcy56ID0geiAqIHJhdGlvQSArIHRoaXMueiAqIHJhdGlvQjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2V0RnJvbVVuaXRWZWN0b3JzOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHYxLCByO1xuICAgIHZhciBFUFMgPSAwLjAwMDAwMTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZGcm9tLCB2VG8pIHtcbiAgICAgIGlmICh2MSA9PT0gdW5kZWZpbmVkKSB2MSA9IG5ldyBWZWN0b3IzKCk7XG4gICAgICByID0gdkZyb20uZG90KHZUbykgKyAxO1xuICAgICAgaWYgKHIgPCBFUFMpIHtcbiAgICAgICAgciA9IDA7XG4gICAgICAgIGlmIChNYXRoLmFicyh2RnJvbS54KSA+IE1hdGguYWJzKHZGcm9tLnopKSB7XG4gICAgICAgICAgdjEuc2V0KC12RnJvbS55LCB2RnJvbS54LCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2MS5zZXQoMCwgLXZGcm9tLnosIHZGcm9tLnkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2MS5jcm9zc1ZlY3RvcnModkZyb20sIHZUbyk7XG4gICAgICB9XG4gICAgICB0aGlzLnggPSB2MS54O1xuICAgICAgdGhpcy55ID0gdjEueTtcbiAgICAgIHRoaXMueiA9IHYxLno7XG4gICAgICB0aGlzLncgPSByO1xuICAgICAgdGhpcy5ub3JtYWxpemUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0oKVxufTtcbmZ1bmN0aW9uIERldmljZShwYXJhbXMpIHtcbiAgdGhpcy53aWR0aCA9IHBhcmFtcy53aWR0aCB8fCBnZXRTY3JlZW5XaWR0aCgpO1xuICB0aGlzLmhlaWdodCA9IHBhcmFtcy5oZWlnaHQgfHwgZ2V0U2NyZWVuSGVpZ2h0KCk7XG4gIHRoaXMud2lkdGhNZXRlcnMgPSBwYXJhbXMud2lkdGhNZXRlcnM7XG4gIHRoaXMuaGVpZ2h0TWV0ZXJzID0gcGFyYW1zLmhlaWdodE1ldGVycztcbiAgdGhpcy5iZXZlbE1ldGVycyA9IHBhcmFtcy5iZXZlbE1ldGVycztcbn1cbnZhciBERUZBVUxUX0FORFJPSUQgPSBuZXcgRGV2aWNlKHtcbiAgd2lkdGhNZXRlcnM6IDAuMTEwLFxuICBoZWlnaHRNZXRlcnM6IDAuMDYyLFxuICBiZXZlbE1ldGVyczogMC4wMDRcbn0pO1xudmFyIERFRkFVTFRfSU9TID0gbmV3IERldmljZSh7XG4gIHdpZHRoTWV0ZXJzOiAwLjEwMzgsXG4gIGhlaWdodE1ldGVyczogMC4wNTg0LFxuICBiZXZlbE1ldGVyczogMC4wMDRcbn0pO1xudmFyIFZpZXdlcnMgPSB7XG4gIENhcmRib2FyZFYxOiBuZXcgQ2FyZGJvYXJkVmlld2VyKHtcbiAgICBpZDogJ0NhcmRib2FyZFYxJyxcbiAgICBsYWJlbDogJ0NhcmRib2FyZCBJL08gMjAxNCcsXG4gICAgZm92OiA0MCxcbiAgICBpbnRlckxlbnNEaXN0YW5jZTogMC4wNjAsXG4gICAgYmFzZWxpbmVMZW5zRGlzdGFuY2U6IDAuMDM1LFxuICAgIHNjcmVlbkxlbnNEaXN0YW5jZTogMC4wNDIsXG4gICAgZGlzdG9ydGlvbkNvZWZmaWNpZW50czogWzAuNDQxLCAwLjE1Nl0sXG4gICAgaW52ZXJzZUNvZWZmaWNpZW50czogWy0wLjQ0MTAwMzUsIDAuNDI3NTYxNTUsIC0wLjQ4MDQ0MzksIDAuNTQ2MDEzOSwgLTAuNTg4MjExODMsIDAuNTczMzkzOCwgLTAuNDgzMDMyMDIsIDAuMzMyOTkwODMsIC0wLjE3NTczODQxLCAwLjA2NTE3NzIsIC0wLjAxNDg4OTYzLCAwLjAwMTU1OTgzNF1cbiAgfSksXG4gIENhcmRib2FyZFYyOiBuZXcgQ2FyZGJvYXJkVmlld2VyKHtcbiAgICBpZDogJ0NhcmRib2FyZFYyJyxcbiAgICBsYWJlbDogJ0NhcmRib2FyZCBJL08gMjAxNScsXG4gICAgZm92OiA2MCxcbiAgICBpbnRlckxlbnNEaXN0YW5jZTogMC4wNjQsXG4gICAgYmFzZWxpbmVMZW5zRGlzdGFuY2U6IDAuMDM1LFxuICAgIHNjcmVlbkxlbnNEaXN0YW5jZTogMC4wMzksXG4gICAgZGlzdG9ydGlvbkNvZWZmaWNpZW50czogWzAuMzQsIDAuNTVdLFxuICAgIGludmVyc2VDb2VmZmljaWVudHM6IFstMC4zMzgzNjcwNCwgLTAuMTgxNjIxODUsIDAuODYyNjU1LCAtMS4yNDYyMDUxLCAxLjA1NjA2MDIsIC0wLjU4MjA4MzE3LCAwLjIxNjA5MDc4LCAtMC4wNTQ0NDgyMywgMC4wMDkxNzc5NTYsIC05LjkwNDE2OUUtNCwgNi4xODM1MzVFLTUsIC0xLjY5ODE4MDNFLTZdXG4gIH0pXG59O1xuZnVuY3Rpb24gRGV2aWNlSW5mbyhkZXZpY2VQYXJhbXMsIGFkZGl0aW9uYWxWaWV3ZXJzKSB7XG4gIHRoaXMudmlld2VyID0gVmlld2Vycy5DYXJkYm9hcmRWMjtcbiAgdGhpcy51cGRhdGVEZXZpY2VQYXJhbXMoZGV2aWNlUGFyYW1zKTtcbiAgdGhpcy5kaXN0b3J0aW9uID0gbmV3IERpc3RvcnRpb24odGhpcy52aWV3ZXIuZGlzdG9ydGlvbkNvZWZmaWNpZW50cyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkaXRpb25hbFZpZXdlcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdmlld2VyID0gYWRkaXRpb25hbFZpZXdlcnNbaV07XG4gICAgVmlld2Vyc1t2aWV3ZXIuaWRdID0gbmV3IENhcmRib2FyZFZpZXdlcih2aWV3ZXIpO1xuICB9XG59XG5EZXZpY2VJbmZvLnByb3RvdHlwZS51cGRhdGVEZXZpY2VQYXJhbXMgPSBmdW5jdGlvbiAoZGV2aWNlUGFyYW1zKSB7XG4gIHRoaXMuZGV2aWNlID0gdGhpcy5kZXRlcm1pbmVEZXZpY2VfKGRldmljZVBhcmFtcykgfHwgdGhpcy5kZXZpY2U7XG59O1xuRGV2aWNlSW5mby5wcm90b3R5cGUuZ2V0RGV2aWNlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5kZXZpY2U7XG59O1xuRGV2aWNlSW5mby5wcm90b3R5cGUuc2V0Vmlld2VyID0gZnVuY3Rpb24gKHZpZXdlcikge1xuICB0aGlzLnZpZXdlciA9IHZpZXdlcjtcbiAgdGhpcy5kaXN0b3J0aW9uID0gbmV3IERpc3RvcnRpb24odGhpcy52aWV3ZXIuZGlzdG9ydGlvbkNvZWZmaWNpZW50cyk7XG59O1xuRGV2aWNlSW5mby5wcm90b3R5cGUuZGV0ZXJtaW5lRGV2aWNlXyA9IGZ1bmN0aW9uIChkZXZpY2VQYXJhbXMpIHtcbiAgaWYgKCFkZXZpY2VQYXJhbXMpIHtcbiAgICBpZiAoaXNJT1MoKSkge1xuICAgICAgY29uc29sZS53YXJuKCdVc2luZyBmYWxsYmFjayBpT1MgZGV2aWNlIG1lYXN1cmVtZW50cy4nKTtcbiAgICAgIHJldHVybiBERUZBVUxUX0lPUztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdVc2luZyBmYWxsYmFjayBBbmRyb2lkIGRldmljZSBtZWFzdXJlbWVudHMuJyk7XG4gICAgICByZXR1cm4gREVGQVVMVF9BTkRST0lEO1xuICAgIH1cbiAgfVxuICB2YXIgTUVURVJTX1BFUl9JTkNIID0gMC4wMjU0O1xuICB2YXIgbWV0ZXJzUGVyUGl4ZWxYID0gTUVURVJTX1BFUl9JTkNIIC8gZGV2aWNlUGFyYW1zLnhkcGk7XG4gIHZhciBtZXRlcnNQZXJQaXhlbFkgPSBNRVRFUlNfUEVSX0lOQ0ggLyBkZXZpY2VQYXJhbXMueWRwaTtcbiAgdmFyIHdpZHRoID0gZ2V0U2NyZWVuV2lkdGgoKTtcbiAgdmFyIGhlaWdodCA9IGdldFNjcmVlbkhlaWdodCgpO1xuICByZXR1cm4gbmV3IERldmljZSh7XG4gICAgd2lkdGhNZXRlcnM6IG1ldGVyc1BlclBpeGVsWCAqIHdpZHRoLFxuICAgIGhlaWdodE1ldGVyczogbWV0ZXJzUGVyUGl4ZWxZICogaGVpZ2h0LFxuICAgIGJldmVsTWV0ZXJzOiBkZXZpY2VQYXJhbXMuYmV2ZWxNbSAqIDAuMDAxXG4gIH0pO1xufTtcbkRldmljZUluZm8ucHJvdG90eXBlLmdldERpc3RvcnRlZEZpZWxkT2ZWaWV3TGVmdEV5ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZpZXdlciA9IHRoaXMudmlld2VyO1xuICB2YXIgZGV2aWNlID0gdGhpcy5kZXZpY2U7XG4gIHZhciBkaXN0b3J0aW9uID0gdGhpcy5kaXN0b3J0aW9uO1xuICB2YXIgZXllVG9TY3JlZW5EaXN0YW5jZSA9IHZpZXdlci5zY3JlZW5MZW5zRGlzdGFuY2U7XG4gIHZhciBvdXRlckRpc3QgPSAoZGV2aWNlLndpZHRoTWV0ZXJzIC0gdmlld2VyLmludGVyTGVuc0Rpc3RhbmNlKSAvIDI7XG4gIHZhciBpbm5lckRpc3QgPSB2aWV3ZXIuaW50ZXJMZW5zRGlzdGFuY2UgLyAyO1xuICB2YXIgYm90dG9tRGlzdCA9IHZpZXdlci5iYXNlbGluZUxlbnNEaXN0YW5jZSAtIGRldmljZS5iZXZlbE1ldGVycztcbiAgdmFyIHRvcERpc3QgPSBkZXZpY2UuaGVpZ2h0TWV0ZXJzIC0gYm90dG9tRGlzdDtcbiAgdmFyIG91dGVyQW5nbGUgPSByYWRUb0RlZyAqIE1hdGguYXRhbihkaXN0b3J0aW9uLmRpc3RvcnQob3V0ZXJEaXN0IC8gZXllVG9TY3JlZW5EaXN0YW5jZSkpO1xuICB2YXIgaW5uZXJBbmdsZSA9IHJhZFRvRGVnICogTWF0aC5hdGFuKGRpc3RvcnRpb24uZGlzdG9ydChpbm5lckRpc3QgLyBleWVUb1NjcmVlbkRpc3RhbmNlKSk7XG4gIHZhciBib3R0b21BbmdsZSA9IHJhZFRvRGVnICogTWF0aC5hdGFuKGRpc3RvcnRpb24uZGlzdG9ydChib3R0b21EaXN0IC8gZXllVG9TY3JlZW5EaXN0YW5jZSkpO1xuICB2YXIgdG9wQW5nbGUgPSByYWRUb0RlZyAqIE1hdGguYXRhbihkaXN0b3J0aW9uLmRpc3RvcnQodG9wRGlzdCAvIGV5ZVRvU2NyZWVuRGlzdGFuY2UpKTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0RGVncmVlczogTWF0aC5taW4ob3V0ZXJBbmdsZSwgdmlld2VyLmZvdiksXG4gICAgcmlnaHREZWdyZWVzOiBNYXRoLm1pbihpbm5lckFuZ2xlLCB2aWV3ZXIuZm92KSxcbiAgICBkb3duRGVncmVlczogTWF0aC5taW4oYm90dG9tQW5nbGUsIHZpZXdlci5mb3YpLFxuICAgIHVwRGVncmVlczogTWF0aC5taW4odG9wQW5nbGUsIHZpZXdlci5mb3YpXG4gIH07XG59O1xuRGV2aWNlSW5mby5wcm90b3R5cGUuZ2V0TGVmdEV5ZVZpc2libGVUYW5BbmdsZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2aWV3ZXIgPSB0aGlzLnZpZXdlcjtcbiAgdmFyIGRldmljZSA9IHRoaXMuZGV2aWNlO1xuICB2YXIgZGlzdG9ydGlvbiA9IHRoaXMuZGlzdG9ydGlvbjtcbiAgdmFyIGZvdkxlZnQgPSBNYXRoLnRhbigtZGVnVG9SYWQgKiB2aWV3ZXIuZm92KTtcbiAgdmFyIGZvdlRvcCA9IE1hdGgudGFuKGRlZ1RvUmFkICogdmlld2VyLmZvdik7XG4gIHZhciBmb3ZSaWdodCA9IE1hdGgudGFuKGRlZ1RvUmFkICogdmlld2VyLmZvdik7XG4gIHZhciBmb3ZCb3R0b20gPSBNYXRoLnRhbigtZGVnVG9SYWQgKiB2aWV3ZXIuZm92KTtcbiAgdmFyIGhhbGZXaWR0aCA9IGRldmljZS53aWR0aE1ldGVycyAvIDQ7XG4gIHZhciBoYWxmSGVpZ2h0ID0gZGV2aWNlLmhlaWdodE1ldGVycyAvIDI7XG4gIHZhciB2ZXJ0aWNhbExlbnNPZmZzZXQgPSB2aWV3ZXIuYmFzZWxpbmVMZW5zRGlzdGFuY2UgLSBkZXZpY2UuYmV2ZWxNZXRlcnMgLSBoYWxmSGVpZ2h0O1xuICB2YXIgY2VudGVyWCA9IHZpZXdlci5pbnRlckxlbnNEaXN0YW5jZSAvIDIgLSBoYWxmV2lkdGg7XG4gIHZhciBjZW50ZXJZID0gLXZlcnRpY2FsTGVuc09mZnNldDtcbiAgdmFyIGNlbnRlclogPSB2aWV3ZXIuc2NyZWVuTGVuc0Rpc3RhbmNlO1xuICB2YXIgc2NyZWVuTGVmdCA9IGRpc3RvcnRpb24uZGlzdG9ydCgoY2VudGVyWCAtIGhhbGZXaWR0aCkgLyBjZW50ZXJaKTtcbiAgdmFyIHNjcmVlblRvcCA9IGRpc3RvcnRpb24uZGlzdG9ydCgoY2VudGVyWSArIGhhbGZIZWlnaHQpIC8gY2VudGVyWik7XG4gIHZhciBzY3JlZW5SaWdodCA9IGRpc3RvcnRpb24uZGlzdG9ydCgoY2VudGVyWCArIGhhbGZXaWR0aCkgLyBjZW50ZXJaKTtcbiAgdmFyIHNjcmVlbkJvdHRvbSA9IGRpc3RvcnRpb24uZGlzdG9ydCgoY2VudGVyWSAtIGhhbGZIZWlnaHQpIC8gY2VudGVyWik7XG4gIHZhciByZXN1bHQgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICByZXN1bHRbMF0gPSBNYXRoLm1heChmb3ZMZWZ0LCBzY3JlZW5MZWZ0KTtcbiAgcmVzdWx0WzFdID0gTWF0aC5taW4oZm92VG9wLCBzY3JlZW5Ub3ApO1xuICByZXN1bHRbMl0gPSBNYXRoLm1pbihmb3ZSaWdodCwgc2NyZWVuUmlnaHQpO1xuICByZXN1bHRbM10gPSBNYXRoLm1heChmb3ZCb3R0b20sIHNjcmVlbkJvdHRvbSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuRGV2aWNlSW5mby5wcm90b3R5cGUuZ2V0TGVmdEV5ZU5vTGVuc1RhbkFuZ2xlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZpZXdlciA9IHRoaXMudmlld2VyO1xuICB2YXIgZGV2aWNlID0gdGhpcy5kZXZpY2U7XG4gIHZhciBkaXN0b3J0aW9uID0gdGhpcy5kaXN0b3J0aW9uO1xuICB2YXIgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgdmFyIGZvdkxlZnQgPSBkaXN0b3J0aW9uLmRpc3RvcnRJbnZlcnNlKE1hdGgudGFuKC1kZWdUb1JhZCAqIHZpZXdlci5mb3YpKTtcbiAgdmFyIGZvdlRvcCA9IGRpc3RvcnRpb24uZGlzdG9ydEludmVyc2UoTWF0aC50YW4oZGVnVG9SYWQgKiB2aWV3ZXIuZm92KSk7XG4gIHZhciBmb3ZSaWdodCA9IGRpc3RvcnRpb24uZGlzdG9ydEludmVyc2UoTWF0aC50YW4oZGVnVG9SYWQgKiB2aWV3ZXIuZm92KSk7XG4gIHZhciBmb3ZCb3R0b20gPSBkaXN0b3J0aW9uLmRpc3RvcnRJbnZlcnNlKE1hdGgudGFuKC1kZWdUb1JhZCAqIHZpZXdlci5mb3YpKTtcbiAgdmFyIGhhbGZXaWR0aCA9IGRldmljZS53aWR0aE1ldGVycyAvIDQ7XG4gIHZhciBoYWxmSGVpZ2h0ID0gZGV2aWNlLmhlaWdodE1ldGVycyAvIDI7XG4gIHZhciB2ZXJ0aWNhbExlbnNPZmZzZXQgPSB2aWV3ZXIuYmFzZWxpbmVMZW5zRGlzdGFuY2UgLSBkZXZpY2UuYmV2ZWxNZXRlcnMgLSBoYWxmSGVpZ2h0O1xuICB2YXIgY2VudGVyWCA9IHZpZXdlci5pbnRlckxlbnNEaXN0YW5jZSAvIDIgLSBoYWxmV2lkdGg7XG4gIHZhciBjZW50ZXJZID0gLXZlcnRpY2FsTGVuc09mZnNldDtcbiAgdmFyIGNlbnRlclogPSB2aWV3ZXIuc2NyZWVuTGVuc0Rpc3RhbmNlO1xuICB2YXIgc2NyZWVuTGVmdCA9IChjZW50ZXJYIC0gaGFsZldpZHRoKSAvIGNlbnRlclo7XG4gIHZhciBzY3JlZW5Ub3AgPSAoY2VudGVyWSArIGhhbGZIZWlnaHQpIC8gY2VudGVyWjtcbiAgdmFyIHNjcmVlblJpZ2h0ID0gKGNlbnRlclggKyBoYWxmV2lkdGgpIC8gY2VudGVyWjtcbiAgdmFyIHNjcmVlbkJvdHRvbSA9IChjZW50ZXJZIC0gaGFsZkhlaWdodCkgLyBjZW50ZXJaO1xuICByZXN1bHRbMF0gPSBNYXRoLm1heChmb3ZMZWZ0LCBzY3JlZW5MZWZ0KTtcbiAgcmVzdWx0WzFdID0gTWF0aC5taW4oZm92VG9wLCBzY3JlZW5Ub3ApO1xuICByZXN1bHRbMl0gPSBNYXRoLm1pbihmb3ZSaWdodCwgc2NyZWVuUmlnaHQpO1xuICByZXN1bHRbM10gPSBNYXRoLm1heChmb3ZCb3R0b20sIHNjcmVlbkJvdHRvbSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuRGV2aWNlSW5mby5wcm90b3R5cGUuZ2V0TGVmdEV5ZVZpc2libGVTY3JlZW5SZWN0ID0gZnVuY3Rpb24gKHVuZGlzdG9ydGVkRnJ1c3R1bSkge1xuICB2YXIgdmlld2VyID0gdGhpcy52aWV3ZXI7XG4gIHZhciBkZXZpY2UgPSB0aGlzLmRldmljZTtcbiAgdmFyIGRpc3QgPSB2aWV3ZXIuc2NyZWVuTGVuc0Rpc3RhbmNlO1xuICB2YXIgZXllWCA9IChkZXZpY2Uud2lkdGhNZXRlcnMgLSB2aWV3ZXIuaW50ZXJMZW5zRGlzdGFuY2UpIC8gMjtcbiAgdmFyIGV5ZVkgPSB2aWV3ZXIuYmFzZWxpbmVMZW5zRGlzdGFuY2UgLSBkZXZpY2UuYmV2ZWxNZXRlcnM7XG4gIHZhciBsZWZ0ID0gKHVuZGlzdG9ydGVkRnJ1c3R1bVswXSAqIGRpc3QgKyBleWVYKSAvIGRldmljZS53aWR0aE1ldGVycztcbiAgdmFyIHRvcCA9ICh1bmRpc3RvcnRlZEZydXN0dW1bMV0gKiBkaXN0ICsgZXllWSkgLyBkZXZpY2UuaGVpZ2h0TWV0ZXJzO1xuICB2YXIgcmlnaHQgPSAodW5kaXN0b3J0ZWRGcnVzdHVtWzJdICogZGlzdCArIGV5ZVgpIC8gZGV2aWNlLndpZHRoTWV0ZXJzO1xuICB2YXIgYm90dG9tID0gKHVuZGlzdG9ydGVkRnJ1c3R1bVszXSAqIGRpc3QgKyBleWVZKSAvIGRldmljZS5oZWlnaHRNZXRlcnM7XG4gIHJldHVybiB7XG4gICAgeDogbGVmdCxcbiAgICB5OiBib3R0b20sXG4gICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgICBoZWlnaHQ6IHRvcCAtIGJvdHRvbVxuICB9O1xufTtcbkRldmljZUluZm8ucHJvdG90eXBlLmdldEZpZWxkT2ZWaWV3TGVmdEV5ZSA9IGZ1bmN0aW9uIChvcHRfaXNVbmRpc3RvcnRlZCkge1xuICByZXR1cm4gb3B0X2lzVW5kaXN0b3J0ZWQgPyB0aGlzLmdldFVuZGlzdG9ydGVkRmllbGRPZlZpZXdMZWZ0RXllKCkgOiB0aGlzLmdldERpc3RvcnRlZEZpZWxkT2ZWaWV3TGVmdEV5ZSgpO1xufTtcbkRldmljZUluZm8ucHJvdG90eXBlLmdldEZpZWxkT2ZWaWV3UmlnaHRFeWUgPSBmdW5jdGlvbiAob3B0X2lzVW5kaXN0b3J0ZWQpIHtcbiAgdmFyIGZvdiA9IHRoaXMuZ2V0RmllbGRPZlZpZXdMZWZ0RXllKG9wdF9pc1VuZGlzdG9ydGVkKTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0RGVncmVlczogZm92LnJpZ2h0RGVncmVlcyxcbiAgICByaWdodERlZ3JlZXM6IGZvdi5sZWZ0RGVncmVlcyxcbiAgICB1cERlZ3JlZXM6IGZvdi51cERlZ3JlZXMsXG4gICAgZG93bkRlZ3JlZXM6IGZvdi5kb3duRGVncmVlc1xuICB9O1xufTtcbkRldmljZUluZm8ucHJvdG90eXBlLmdldFVuZGlzdG9ydGVkRmllbGRPZlZpZXdMZWZ0RXllID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcCA9IHRoaXMuZ2V0VW5kaXN0b3J0ZWRQYXJhbXNfKCk7XG4gIHJldHVybiB7XG4gICAgbGVmdERlZ3JlZXM6IHJhZFRvRGVnICogTWF0aC5hdGFuKHAub3V0ZXJEaXN0KSxcbiAgICByaWdodERlZ3JlZXM6IHJhZFRvRGVnICogTWF0aC5hdGFuKHAuaW5uZXJEaXN0KSxcbiAgICBkb3duRGVncmVlczogcmFkVG9EZWcgKiBNYXRoLmF0YW4ocC5ib3R0b21EaXN0KSxcbiAgICB1cERlZ3JlZXM6IHJhZFRvRGVnICogTWF0aC5hdGFuKHAudG9wRGlzdClcbiAgfTtcbn07XG5EZXZpY2VJbmZvLnByb3RvdHlwZS5nZXRVbmRpc3RvcnRlZFZpZXdwb3J0TGVmdEV5ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHAgPSB0aGlzLmdldFVuZGlzdG9ydGVkUGFyYW1zXygpO1xuICB2YXIgdmlld2VyID0gdGhpcy52aWV3ZXI7XG4gIHZhciBkZXZpY2UgPSB0aGlzLmRldmljZTtcbiAgdmFyIGV5ZVRvU2NyZWVuRGlzdGFuY2UgPSB2aWV3ZXIuc2NyZWVuTGVuc0Rpc3RhbmNlO1xuICB2YXIgc2NyZWVuV2lkdGggPSBkZXZpY2Uud2lkdGhNZXRlcnMgLyBleWVUb1NjcmVlbkRpc3RhbmNlO1xuICB2YXIgc2NyZWVuSGVpZ2h0ID0gZGV2aWNlLmhlaWdodE1ldGVycyAvIGV5ZVRvU2NyZWVuRGlzdGFuY2U7XG4gIHZhciB4UHhQZXJUYW5BbmdsZSA9IGRldmljZS53aWR0aCAvIHNjcmVlbldpZHRoO1xuICB2YXIgeVB4UGVyVGFuQW5nbGUgPSBkZXZpY2UuaGVpZ2h0IC8gc2NyZWVuSGVpZ2h0O1xuICB2YXIgeCA9IE1hdGgucm91bmQoKHAuZXllUG9zWCAtIHAub3V0ZXJEaXN0KSAqIHhQeFBlclRhbkFuZ2xlKTtcbiAgdmFyIHkgPSBNYXRoLnJvdW5kKChwLmV5ZVBvc1kgLSBwLmJvdHRvbURpc3QpICogeVB4UGVyVGFuQW5nbGUpO1xuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB3aWR0aDogTWF0aC5yb3VuZCgocC5leWVQb3NYICsgcC5pbm5lckRpc3QpICogeFB4UGVyVGFuQW5nbGUpIC0geCxcbiAgICBoZWlnaHQ6IE1hdGgucm91bmQoKHAuZXllUG9zWSArIHAudG9wRGlzdCkgKiB5UHhQZXJUYW5BbmdsZSkgLSB5XG4gIH07XG59O1xuRGV2aWNlSW5mby5wcm90b3R5cGUuZ2V0VW5kaXN0b3J0ZWRQYXJhbXNfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdmlld2VyID0gdGhpcy52aWV3ZXI7XG4gIHZhciBkZXZpY2UgPSB0aGlzLmRldmljZTtcbiAgdmFyIGRpc3RvcnRpb24gPSB0aGlzLmRpc3RvcnRpb247XG4gIHZhciBleWVUb1NjcmVlbkRpc3RhbmNlID0gdmlld2VyLnNjcmVlbkxlbnNEaXN0YW5jZTtcbiAgdmFyIGhhbGZMZW5zRGlzdGFuY2UgPSB2aWV3ZXIuaW50ZXJMZW5zRGlzdGFuY2UgLyAyIC8gZXllVG9TY3JlZW5EaXN0YW5jZTtcbiAgdmFyIHNjcmVlbldpZHRoID0gZGV2aWNlLndpZHRoTWV0ZXJzIC8gZXllVG9TY3JlZW5EaXN0YW5jZTtcbiAgdmFyIHNjcmVlbkhlaWdodCA9IGRldmljZS5oZWlnaHRNZXRlcnMgLyBleWVUb1NjcmVlbkRpc3RhbmNlO1xuICB2YXIgZXllUG9zWCA9IHNjcmVlbldpZHRoIC8gMiAtIGhhbGZMZW5zRGlzdGFuY2U7XG4gIHZhciBleWVQb3NZID0gKHZpZXdlci5iYXNlbGluZUxlbnNEaXN0YW5jZSAtIGRldmljZS5iZXZlbE1ldGVycykgLyBleWVUb1NjcmVlbkRpc3RhbmNlO1xuICB2YXIgbWF4Rm92ID0gdmlld2VyLmZvdjtcbiAgdmFyIHZpZXdlck1heCA9IGRpc3RvcnRpb24uZGlzdG9ydEludmVyc2UoTWF0aC50YW4oZGVnVG9SYWQgKiBtYXhGb3YpKTtcbiAgdmFyIG91dGVyRGlzdCA9IE1hdGgubWluKGV5ZVBvc1gsIHZpZXdlck1heCk7XG4gIHZhciBpbm5lckRpc3QgPSBNYXRoLm1pbihoYWxmTGVuc0Rpc3RhbmNlLCB2aWV3ZXJNYXgpO1xuICB2YXIgYm90dG9tRGlzdCA9IE1hdGgubWluKGV5ZVBvc1ksIHZpZXdlck1heCk7XG4gIHZhciB0b3BEaXN0ID0gTWF0aC5taW4oc2NyZWVuSGVpZ2h0IC0gZXllUG9zWSwgdmlld2VyTWF4KTtcbiAgcmV0dXJuIHtcbiAgICBvdXRlckRpc3Q6IG91dGVyRGlzdCxcbiAgICBpbm5lckRpc3Q6IGlubmVyRGlzdCxcbiAgICB0b3BEaXN0OiB0b3BEaXN0LFxuICAgIGJvdHRvbURpc3Q6IGJvdHRvbURpc3QsXG4gICAgZXllUG9zWDogZXllUG9zWCxcbiAgICBleWVQb3NZOiBleWVQb3NZXG4gIH07XG59O1xuZnVuY3Rpb24gQ2FyZGJvYXJkVmlld2VyKHBhcmFtcykge1xuICB0aGlzLmlkID0gcGFyYW1zLmlkO1xuICB0aGlzLmxhYmVsID0gcGFyYW1zLmxhYmVsO1xuICB0aGlzLmZvdiA9IHBhcmFtcy5mb3Y7XG4gIHRoaXMuaW50ZXJMZW5zRGlzdGFuY2UgPSBwYXJhbXMuaW50ZXJMZW5zRGlzdGFuY2U7XG4gIHRoaXMuYmFzZWxpbmVMZW5zRGlzdGFuY2UgPSBwYXJhbXMuYmFzZWxpbmVMZW5zRGlzdGFuY2U7XG4gIHRoaXMuc2NyZWVuTGVuc0Rpc3RhbmNlID0gcGFyYW1zLnNjcmVlbkxlbnNEaXN0YW5jZTtcbiAgdGhpcy5kaXN0b3J0aW9uQ29lZmZpY2llbnRzID0gcGFyYW1zLmRpc3RvcnRpb25Db2VmZmljaWVudHM7XG4gIHRoaXMuaW52ZXJzZUNvZWZmaWNpZW50cyA9IHBhcmFtcy5pbnZlcnNlQ29lZmZpY2llbnRzO1xufVxuRGV2aWNlSW5mby5WaWV3ZXJzID0gVmlld2VycztcbnZhciBmb3JtYXQgPSAxO1xudmFyIGxhc3RfdXBkYXRlZCA9IFwiMjAxOS0xMS0wOVQxNzozNjoxNFpcIjtcbnZhciBkZXZpY2VzID0gW3tcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcImFzdXMvKi9OZXh1cyA3LypcIn0se1widWFcIjpcIk5leHVzIDdcIn1dLFwiZHBpXCI6WzMyMC44LDMyM10sXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiYXN1cy8qL0FTVVNfWDAwUEQvKlwifSx7XCJ1YVwiOlwiQVNVU19YMDBQRFwifV0sXCJkcGlcIjoyNDUsXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiYXN1cy8qL0FTVVNfWDAwOEQvKlwifSx7XCJ1YVwiOlwiQVNVU19YMDA4RFwifV0sXCJkcGlcIjoyODIsXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiYXN1cy8qL0FTVVNfWjAwQUQvKlwifSx7XCJ1YVwiOlwiQVNVU19aMDBBRFwifV0sXCJkcGlcIjpbNDAzLDQwNC42XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiR29vZ2xlLyovUGl4ZWwgMiBYTC8qXCJ9LHtcInVhXCI6XCJQaXhlbCAyIFhMXCJ9XSxcImRwaVwiOjUzNy45LFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJHb29nbGUvKi9QaXhlbCAzIFhMLypcIn0se1widWFcIjpcIlBpeGVsIDMgWExcIn1dLFwiZHBpXCI6WzU1OC41LDU1My44XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiR29vZ2xlLyovUGl4ZWwgWEwvKlwifSx7XCJ1YVwiOlwiUGl4ZWwgWExcIn1dLFwiZHBpXCI6WzUzNy45LDUzM10sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIkdvb2dsZS8qL1BpeGVsIDMvKlwifSx7XCJ1YVwiOlwiUGl4ZWwgM1wifV0sXCJkcGlcIjo0NDIuNCxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiR29vZ2xlLyovUGl4ZWwgMi8qXCJ9LHtcInVhXCI6XCJQaXhlbCAyXCJ9XSxcImRwaVwiOjQ0MSxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJHb29nbGUvKi9QaXhlbC8qXCJ9LHtcInVhXCI6XCJQaXhlbFwifV0sXCJkcGlcIjpbNDMyLjYsNDM2LjddLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJIVEMvKi9IVEM2NDM1TFZXLypcIn0se1widWFcIjpcIkhUQzY0MzVMVldcIn1dLFwiZHBpXCI6WzQ0OS43LDQ0My4zXSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiSFRDLyovSFRDIE9uZSBYTC8qXCJ9LHtcInVhXCI6XCJIVEMgT25lIFhMXCJ9XSxcImRwaVwiOlszMTUuMywzMTQuNl0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcImh0Yy8qL05leHVzIDkvKlwifSx7XCJ1YVwiOlwiTmV4dXMgOVwifV0sXCJkcGlcIjoyODksXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiSFRDLyovSFRDIE9uZSBNOS8qXCJ9LHtcInVhXCI6XCJIVEMgT25lIE05XCJ9XSxcImRwaVwiOls0NDIuNSw0NDMuM10sXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiSFRDLyovSFRDIE9uZV9NOC8qXCJ9LHtcInVhXCI6XCJIVEMgT25lX004XCJ9XSxcImRwaVwiOls0NDkuNyw0NDcuNF0sXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiSFRDLyovSFRDIE9uZS8qXCJ9LHtcInVhXCI6XCJIVEMgT25lXCJ9XSxcImRwaVwiOjQ3Mi44LFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJIdWF3ZWkvKi9OZXh1cyA2UC8qXCJ9LHtcInVhXCI6XCJOZXh1cyA2UFwifV0sXCJkcGlcIjpbNTE1LjEsNTE4XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiSHVhd2VpLyovQkxOLUwyNC8qXCJ9LHtcInVhXCI6XCJIT05PUkJMTi1MMjRcIn1dLFwiZHBpXCI6NDgwLFwiYndcIjo0LFwiYWNcIjo1MDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIkh1YXdlaS8qL0JLTC1MMDkvKlwifSx7XCJ1YVwiOlwiQktMLUwwOVwifV0sXCJkcGlcIjo0MDMsXCJid1wiOjMuNDcsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiTEVOT1ZPLyovTGVub3ZvIFBCMi02OTBZLypcIn0se1widWFcIjpcIkxlbm92byBQQjItNjkwWVwifV0sXCJkcGlcIjpbNDU3LjIsNDU0LjcxM10sXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiTEdFLyovTmV4dXMgNVgvKlwifSx7XCJ1YVwiOlwiTmV4dXMgNVhcIn1dLFwiZHBpXCI6WzQyMiw0MTkuOV0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIkxHRS8qL0xHTVMzNDUvKlwifSx7XCJ1YVwiOlwiTEdNUzM0NVwifV0sXCJkcGlcIjpbMjIxLjcsMjE5LjFdLFwiYndcIjozLFwiYWNcIjo1MDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIkxHRS8qL0xHLUQ4MDAvKlwifSx7XCJ1YVwiOlwiTEctRDgwMFwifV0sXCJkcGlcIjpbNDIyLDQyNC4xXSxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJMR0UvKi9MRy1EODUwLypcIn0se1widWFcIjpcIkxHLUQ4NTBcIn1dLFwiZHBpXCI6WzUzNy45LDU0MS45XSxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJMR0UvKi9WUzk4NSA0Ry8qXCJ9LHtcInVhXCI6XCJWUzk4NSA0R1wifV0sXCJkcGlcIjpbNTM3LjksNTM1LjZdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJMR0UvKi9OZXh1cyA1LypcIn0se1widWFcIjpcIk5leHVzIDUgQlwifV0sXCJkcGlcIjpbNDQyLjQsNDQ0LjhdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJMR0UvKi9OZXh1cyA0LypcIn0se1widWFcIjpcIk5leHVzIDRcIn1dLFwiZHBpXCI6WzMxOS44LDMxOC40XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiTEdFLyovTEctUDc2OS8qXCJ9LHtcInVhXCI6XCJMRy1QNzY5XCJ9XSxcImRwaVwiOlsyNDAuNiwyNDcuNV0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIkxHRS8qL0xHTVMzMjMvKlwifSx7XCJ1YVwiOlwiTEdNUzMyM1wifV0sXCJkcGlcIjpbMjA2LjYsMjA0LjZdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJMR0UvKi9MR0xTOTk2LypcIn0se1widWFcIjpcIkxHTFM5OTZcIn1dLFwiZHBpXCI6WzQwMy40LDQwMS41XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiTWljcm9tYXgvKi80NTYwTU1YLypcIn0se1widWFcIjpcIjQ1NjBNTVhcIn1dLFwiZHBpXCI6WzI0MCwyMTkuNF0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIk1pY3JvbWF4LyovQTI1MC8qXCJ9LHtcInVhXCI6XCJNaWNyb21heCBBMjUwXCJ9XSxcImRwaVwiOls0ODAsNDQ2LjRdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJNaWNyb21heC8qL01pY3JvbWF4IEFRNDUwMS8qXCJ9LHtcInVhXCI6XCJNaWNyb21heCBBUTQ1MDFcIn1dLFwiZHBpXCI6MjQwLFwiYndcIjozLFwiYWNcIjo1MDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIm1vdG9yb2xhLyovRzUvKlwifSx7XCJ1YVwiOlwiTW90byBHICg1KSBQbHVzXCJ9XSxcImRwaVwiOls0MDMuNCw0MDNdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJtb3Rvcm9sYS8qL0RST0lEIFJBWlIvKlwifSx7XCJ1YVwiOlwiRFJPSUQgUkFaUlwifV0sXCJkcGlcIjpbMzY4LjEsMjU2LjddLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJtb3Rvcm9sYS8qL1hUODMwQy8qXCJ9LHtcInVhXCI6XCJYVDgzMENcIn1dLFwiZHBpXCI6WzI1NCwyNTUuOV0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIm1vdG9yb2xhLyovWFQxMDIxLypcIn0se1widWFcIjpcIlhUMTAyMVwifV0sXCJkcGlcIjpbMjU0LDI1Ni43XSxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJtb3Rvcm9sYS8qL1hUMTAyMy8qXCJ9LHtcInVhXCI6XCJYVDEwMjNcIn1dLFwiZHBpXCI6WzI1NCwyNTYuN10sXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwibW90b3JvbGEvKi9YVDEwMjgvKlwifSx7XCJ1YVwiOlwiWFQxMDI4XCJ9XSxcImRwaVwiOlszMjYuNiwzMjcuNl0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIm1vdG9yb2xhLyovWFQxMDM0LypcIn0se1widWFcIjpcIlhUMTAzNFwifV0sXCJkcGlcIjpbMzI2LjYsMzI4LjRdLFwiYndcIjozLFwiYWNcIjo1MDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIm1vdG9yb2xhLyovWFQxMDUzLypcIn0se1widWFcIjpcIlhUMTA1M1wifV0sXCJkcGlcIjpbMzE1LjMsMzE2LjFdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJtb3Rvcm9sYS8qL1hUMTU2Mi8qXCJ9LHtcInVhXCI6XCJYVDE1NjJcIn1dLFwiZHBpXCI6WzQwMy40LDQwMi43XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwibW90b3JvbGEvKi9OZXh1cyA2LypcIn0se1widWFcIjpcIk5leHVzIDYgQlwifV0sXCJkcGlcIjpbNDk0LjMsNDg5LjddLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJtb3Rvcm9sYS8qL1hUMTA2My8qXCJ9LHtcInVhXCI6XCJYVDEwNjNcIn1dLFwiZHBpXCI6WzI5NSwyOTYuNl0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIm1vdG9yb2xhLyovWFQxMDY0LypcIn0se1widWFcIjpcIlhUMTA2NFwifV0sXCJkcGlcIjpbMjk1LDI5NS42XSxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJtb3Rvcm9sYS8qL1hUMTA5Mi8qXCJ9LHtcInVhXCI6XCJYVDEwOTJcIn1dLFwiZHBpXCI6WzQyMiw0MjQuMV0sXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwibW90b3JvbGEvKi9YVDEwOTUvKlwifSx7XCJ1YVwiOlwiWFQxMDk1XCJ9XSxcImRwaVwiOls0MjIsNDIzLjRdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJtb3Rvcm9sYS8qL0c0LypcIn0se1widWFcIjpcIk1vdG8gRyAoNClcIn1dLFwiZHBpXCI6NDAxLFwiYndcIjo0LFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJPbmVQbHVzLyovQTAwMDEvKlwifSx7XCJ1YVwiOlwiQTAwMDFcIn1dLFwiZHBpXCI6WzQwMy40LDQwMV0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIk9uZVBsdXMvKi9PTkUgRTEwMDEvKlwifSx7XCJ1YVwiOlwiT05FIEUxMDAxXCJ9XSxcImRwaVwiOls0NDIuNCw0NDEuNF0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIk9uZVBsdXMvKi9PTkUgRTEwMDMvKlwifSx7XCJ1YVwiOlwiT05FIEUxMDAzXCJ9XSxcImRwaVwiOls0NDIuNCw0NDEuNF0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIk9uZVBsdXMvKi9PTkUgRTEwMDUvKlwifSx7XCJ1YVwiOlwiT05FIEUxMDA1XCJ9XSxcImRwaVwiOls0NDIuNCw0NDEuNF0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIk9uZVBsdXMvKi9PTkUgQTIwMDEvKlwifSx7XCJ1YVwiOlwiT05FIEEyMDAxXCJ9XSxcImRwaVwiOlszOTEuOSw0MDUuNF0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIk9uZVBsdXMvKi9PTkUgQTIwMDMvKlwifSx7XCJ1YVwiOlwiT05FIEEyMDAzXCJ9XSxcImRwaVwiOlszOTEuOSw0MDUuNF0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIk9uZVBsdXMvKi9PTkUgQTIwMDUvKlwifSx7XCJ1YVwiOlwiT05FIEEyMDA1XCJ9XSxcImRwaVwiOlszOTEuOSw0MDUuNF0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIk9uZVBsdXMvKi9PTkVQTFVTIEEzMDAwLypcIn0se1widWFcIjpcIk9ORVBMVVMgQTMwMDBcIn1dLFwiZHBpXCI6NDAxLFwiYndcIjozLFwiYWNcIjo1MDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIk9uZVBsdXMvKi9PTkVQTFVTIEEzMDAzLypcIn0se1widWFcIjpcIk9ORVBMVVMgQTMwMDNcIn1dLFwiZHBpXCI6NDAxLFwiYndcIjozLFwiYWNcIjo1MDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIk9uZVBsdXMvKi9PTkVQTFVTIEEzMDEwLypcIn0se1widWFcIjpcIk9ORVBMVVMgQTMwMTBcIn1dLFwiZHBpXCI6NDAxLFwiYndcIjozLFwiYWNcIjo1MDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIk9uZVBsdXMvKi9PTkVQTFVTIEE1MDAwLypcIn0se1widWFcIjpcIk9ORVBMVVMgQTUwMDAgXCJ9XSxcImRwaVwiOls0MDMuNDExLDM5OS43MzddLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJPbmVQbHVzLyovT05FIEE1MDEwLypcIn0se1widWFcIjpcIk9ORVBMVVMgQTUwMTBcIn1dLFwiZHBpXCI6WzQwMyw0MDBdLFwiYndcIjoyLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJPbmVQbHVzLyovT05FUExVUyBBNjAwMC8qXCJ9LHtcInVhXCI6XCJPTkVQTFVTIEE2MDAwXCJ9XSxcImRwaVwiOjQwMSxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJPbmVQbHVzLyovT05FUExVUyBBNjAwMy8qXCJ9LHtcInVhXCI6XCJPTkVQTFVTIEE2MDAzXCJ9XSxcImRwaVwiOjQwMSxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJPbmVQbHVzLyovT05FUExVUyBBNjAxMC8qXCJ9LHtcInVhXCI6XCJPTkVQTFVTIEE2MDEwXCJ9XSxcImRwaVwiOjQwMSxcImJ3XCI6MixcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJPbmVQbHVzLyovT05FUExVUyBBNjAxMy8qXCJ9LHtcInVhXCI6XCJPTkVQTFVTIEE2MDEzXCJ9XSxcImRwaVwiOjQwMSxcImJ3XCI6MixcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJPUFBPLyovWDkwOS8qXCJ9LHtcInVhXCI6XCJYOTA5XCJ9XSxcImRwaVwiOls0NDIuNCw0NDQuMV0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcInNhbXN1bmcvKi9HVC1JOTA4Mi8qXCJ9LHtcInVhXCI6XCJHVC1JOTA4MlwifV0sXCJkcGlcIjpbMTg0LjcsMTg1LjRdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tRzM2MFAvKlwifSx7XCJ1YVwiOlwiU00tRzM2MFBcIn1dLFwiZHBpXCI6WzE5Ni43LDIwNS40XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL05leHVzIFMvKlwifSx7XCJ1YVwiOlwiTmV4dXMgU1wifV0sXCJkcGlcIjpbMjM0LjUsMjI5LjhdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovR1QtSTkzMDAvKlwifSx7XCJ1YVwiOlwiR1QtSTkzMDBcIn1dLFwiZHBpXCI6WzMwNC44LDMwMy45XSxcImJ3XCI6NSxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tVDIzME5VLypcIn0se1widWFcIjpcIlNNLVQyMzBOVVwifV0sXCJkcGlcIjoyMTYsXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NHSC1UMzk5LypcIn0se1widWFcIjpcIlNHSC1UMzk5XCJ9XSxcImRwaVwiOlsyMTcuNywyMzEuNF0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcInNhbXN1bmcvKi9TR0gtTTkxOS8qXCJ9LHtcInVhXCI6XCJTR0gtTTkxOVwifV0sXCJkcGlcIjpbNDQwLjgsNDM3LjddLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tTjkwMDUvKlwifSx7XCJ1YVwiOlwiU00tTjkwMDVcIn1dLFwiZHBpXCI6WzM4Ni40LDM4N10sXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NBTVNVTkctU00tTjkwMEEvKlwifSx7XCJ1YVwiOlwiU0FNU1VORy1TTS1OOTAwQVwifV0sXCJkcGlcIjpbMzg2LjQsMzg3LjddLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovR1QtSTk1MDAvKlwifSx7XCJ1YVwiOlwiR1QtSTk1MDBcIn1dLFwiZHBpXCI6WzQ0Mi41LDQ0My4zXSxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovR1QtSTk1MDUvKlwifSx7XCJ1YVwiOlwiR1QtSTk1MDVcIn1dLFwiZHBpXCI6NDM5LjQsXCJid1wiOjQsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcInNhbXN1bmcvKi9TTS1HOTAwRi8qXCJ9LHtcInVhXCI6XCJTTS1HOTAwRlwifV0sXCJkcGlcIjpbNDE1LjYsNDMxLjZdLFwiYndcIjo1LFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tRzkwME0vKlwifSx7XCJ1YVwiOlwiU00tRzkwME1cIn1dLFwiZHBpXCI6WzQxNS42LDQzMS42XSxcImJ3XCI6NSxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NNLUc4MDBGLypcIn0se1widWFcIjpcIlNNLUc4MDBGXCJ9XSxcImRwaVwiOjMyNi44LFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tRzkwNlMvKlwifSx7XCJ1YVwiOlwiU00tRzkwNlNcIn1dLFwiZHBpXCI6WzU2Mi43LDU3Mi40XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL0dULUk5MzAwLypcIn0se1widWFcIjpcIkdULUk5MzAwXCJ9XSxcImRwaVwiOlszMDYuNywzMDQuOF0sXCJid1wiOjUsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcInNhbXN1bmcvKi9TTS1UNTM1LypcIn0se1widWFcIjpcIlNNLVQ1MzVcIn1dLFwiZHBpXCI6WzE0Mi42LDEzNi40XSxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tTjkyMEMvKlwifSx7XCJ1YVwiOlwiU00tTjkyMENcIn1dLFwiZHBpXCI6WzUxNS4xLDUxOC40XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NNLU45MjBQLypcIn0se1widWFcIjpcIlNNLU45MjBQXCJ9XSxcImRwaVwiOlszODYuMzY1NSwzOTAuMTQ0XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NNLU45MjBXOC8qXCJ9LHtcInVhXCI6XCJTTS1OOTIwVzhcIn1dLFwiZHBpXCI6WzUxNS4xLDUxOC40XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL0dULUk5MzAwSS8qXCJ9LHtcInVhXCI6XCJHVC1JOTMwMElcIn1dLFwiZHBpXCI6WzMwNC44LDMwNS44XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL0dULUk5MTk1LypcIn0se1widWFcIjpcIkdULUk5MTk1XCJ9XSxcImRwaVwiOlsyNDkuNCwyNTYuN10sXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NQSC1MNTIwLypcIn0se1widWFcIjpcIlNQSC1MNTIwXCJ9XSxcImRwaVwiOlsyNDkuNCwyNTUuOV0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcInNhbXN1bmcvKi9TQU1TVU5HLVNHSC1JNzE3LypcIn0se1widWFcIjpcIlNBTVNVTkctU0dILUk3MTdcIn1dLFwiZHBpXCI6Mjg1LjgsXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcInNhbXN1bmcvKi9TUEgtRDcxMC8qXCJ9LHtcInVhXCI6XCJTUEgtRDcxMFwifV0sXCJkcGlcIjpbMjE3LjcsMjA0LjJdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovR1QtTjcxMDAvKlwifSx7XCJ1YVwiOlwiR1QtTjcxMDBcIn1dLFwiZHBpXCI6MjY1LjEsXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcInNhbXN1bmcvKi9TQ0gtSTYwNS8qXCJ9LHtcInVhXCI6XCJTQ0gtSTYwNVwifV0sXCJkcGlcIjoyNjUuMSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL0dhbGF4eSBOZXh1cy8qXCJ9LHtcInVhXCI6XCJHYWxheHkgTmV4dXNcIn1dLFwiZHBpXCI6WzMxNS4zLDMxNC4yXSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NNLU45MTBILypcIn0se1widWFcIjpcIlNNLU45MTBIXCJ9XSxcImRwaVwiOls1MTUuMSw1MThdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tTjkxMEMvKlwifSx7XCJ1YVwiOlwiU00tTjkxMENcIn1dLFwiZHBpXCI6WzUxNS4yLDUyMC4yXSxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tRzEzME0vKlwifSx7XCJ1YVwiOlwiU00tRzEzME1cIn1dLFwiZHBpXCI6WzE2NS45LDE2NC44XSxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tRzkyOEkvKlwifSx7XCJ1YVwiOlwiU00tRzkyOElcIn1dLFwiZHBpXCI6WzUxNS4xLDUxOC40XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NNLUc5MjBGLypcIn0se1widWFcIjpcIlNNLUc5MjBGXCJ9XSxcImRwaVwiOjU4MC42LFwiYndcIjozLFwiYWNcIjo1MDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcInNhbXN1bmcvKi9TTS1HOTIwUC8qXCJ9LHtcInVhXCI6XCJTTS1HOTIwUFwifV0sXCJkcGlcIjpbNTIyLjUsNTc3XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NNLUc5MjVGLypcIn0se1widWFcIjpcIlNNLUc5MjVGXCJ9XSxcImRwaVwiOjU4MC42LFwiYndcIjozLFwiYWNcIjo1MDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcInNhbXN1bmcvKi9TTS1HOTI1Vi8qXCJ9LHtcInVhXCI6XCJTTS1HOTI1VlwifV0sXCJkcGlcIjpbNTIyLjUsNTc2LjZdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tRzkzMEYvKlwifSx7XCJ1YVwiOlwiU00tRzkzMEZcIn1dLFwiZHBpXCI6NTc2LjYsXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcInNhbXN1bmcvKi9TTS1HOTM1Ri8qXCJ9LHtcInVhXCI6XCJTTS1HOTM1RlwifV0sXCJkcGlcIjo1MzMsXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NNLUc5NTBGLypcIn0se1widWFcIjpcIlNNLUc5NTBGXCJ9XSxcImRwaVwiOls1NjIuNzA3LDU2NS4yOTNdLFwiYndcIjozLFwiYWNcIjo1MDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcInNhbXN1bmcvKi9TTS1HOTU1VS8qXCJ9LHtcInVhXCI6XCJTTS1HOTU1VVwifV0sXCJkcGlcIjpbNTIyLjUxNCw1MjUuNzYyXSxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tRzk1NUYvKlwifSx7XCJ1YVwiOlwiU00tRzk1NUZcIn1dLFwiZHBpXCI6WzUyMi41MTQsNTI1Ljc2Ml0sXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NNLUc5NjBGLypcIn0se1widWFcIjpcIlNNLUc5NjBGXCJ9XSxcImRwaVwiOls1NjkuNTc1LDU3MS41XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NNLUc5NjAwLypcIn0se1widWFcIjpcIlNNLUc5NjAwXCJ9XSxcImRwaVwiOls1NjkuNTc1LDU3MS41XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NNLUc5NjBULypcIn0se1widWFcIjpcIlNNLUc5NjBUXCJ9XSxcImRwaVwiOls1NjkuNTc1LDU3MS41XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NNLUc5NjBOLypcIn0se1widWFcIjpcIlNNLUc5NjBOXCJ9XSxcImRwaVwiOls1NjkuNTc1LDU3MS41XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NNLUc5NjBVLypcIn0se1widWFcIjpcIlNNLUc5NjBVXCJ9XSxcImRwaVwiOls1NjkuNTc1LDU3MS41XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NNLUc5NjA4LypcIn0se1widWFcIjpcIlNNLUc5NjA4XCJ9XSxcImRwaVwiOls1NjkuNTc1LDU3MS41XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwic2Ftc3VuZy8qL1NNLUc5NjBGRC8qXCJ9LHtcInVhXCI6XCJTTS1HOTYwRkRcIn1dLFwiZHBpXCI6WzU2OS41NzUsNTcxLjVdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tRzk2MFcvKlwifSx7XCJ1YVwiOlwiU00tRzk2MFdcIn1dLFwiZHBpXCI6WzU2OS41NzUsNTcxLjVdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tRzk2NUYvKlwifSx7XCJ1YVwiOlwiU00tRzk2NUZcIn1dLFwiZHBpXCI6NTI5LFwiYndcIjoyLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJTb255LyovQzY5MDMvKlwifSx7XCJ1YVwiOlwiQzY5MDNcIn1dLFwiZHBpXCI6WzQ0Mi41LDQ0My4zXSxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJTb255LyovRDY2NTMvKlwifSx7XCJ1YVwiOlwiRDY2NTNcIn1dLFwiZHBpXCI6WzQyOC42LDQyNy42XSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiYW5kcm9pZFwiLFwicnVsZXNcIjpbe1wibWRtaFwiOlwiU29ueS8qL0U2NjUzLypcIn0se1widWFcIjpcIkU2NjUzXCJ9XSxcImRwaVwiOls0MjguNiw0MjUuN10sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIlNvbnkvKi9FNjg1My8qXCJ9LHtcInVhXCI6XCJFNjg1M1wifV0sXCJkcGlcIjpbNDAzLjQsNDAxLjldLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJTb255LyovU0dQMzIxLypcIn0se1widWFcIjpcIlNHUDMyMVwifV0sXCJkcGlcIjpbMjI0LjcsMjI0LjFdLFwiYndcIjozLFwiYWNcIjo1MDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIlRDVC8qL0FMQ0FURUwgT05FIFRPVUNIIEZpZXJjZS8qXCJ9LHtcInVhXCI6XCJBTENBVEVMIE9ORSBUT1VDSCBGaWVyY2VcIn1dLFwiZHBpXCI6WzI0MCwyNDcuNV0sXCJid1wiOjMsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIlRITC8qL3RobCA1MDAwLypcIn0se1widWFcIjpcInRobCA1MDAwXCJ9XSxcImRwaVwiOls0ODAsNDQzLjNdLFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJGbHkvKi9JUTQ0MTIvKlwifSx7XCJ1YVwiOlwiSVE0NDEyXCJ9XSxcImRwaVwiOjMwNy45LFwiYndcIjozLFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJaVEUvKi9aVEUgQmxhZGUgTDIvKlwifSx7XCJ1YVwiOlwiWlRFIEJsYWRlIEwyXCJ9XSxcImRwaVwiOjI0MCxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJCRU5FVkUvKi9WUjUxOC8qXCJ9LHtcInVhXCI6XCJWUjUxOFwifV0sXCJkcGlcIjo0ODAsXCJid1wiOjMsXCJhY1wiOjUwMH0se1widHlwZVwiOlwiaW9zXCIsXCJydWxlc1wiOlt7XCJyZXNcIjpbNjQwLDk2MF19XSxcImRwaVwiOlszMjUuMSwzMjguNF0sXCJid1wiOjQsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImlvc1wiLFwicnVsZXNcIjpbe1wicmVzXCI6WzY0MCwxMTM2XX1dLFwiZHBpXCI6WzMxNy4xLDMyMC4yXSxcImJ3XCI6MyxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiaW9zXCIsXCJydWxlc1wiOlt7XCJyZXNcIjpbNzUwLDEzMzRdfV0sXCJkcGlcIjozMjYuNCxcImJ3XCI6NCxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiaW9zXCIsXCJydWxlc1wiOlt7XCJyZXNcIjpbMTI0MiwyMjA4XX1dLFwiZHBpXCI6WzQ1My42LDQ1OC40XSxcImJ3XCI6NCxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiaW9zXCIsXCJydWxlc1wiOlt7XCJyZXNcIjpbMTEyNSwyMDAxXX1dLFwiZHBpXCI6WzQxMC45LDQxNS40XSxcImJ3XCI6NCxcImFjXCI6MTAwMH0se1widHlwZVwiOlwiaW9zXCIsXCJydWxlc1wiOlt7XCJyZXNcIjpbMTEyNSwyNDM2XX1dLFwiZHBpXCI6NDU4LFwiYndcIjo0LFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJIdWF3ZWkvKi9FTUwtTDI5LypcIn0se1widWFcIjpcIkVNTC1MMjlcIn1dLFwiZHBpXCI6NDI4LFwiYndcIjozLjQ1LFwiYWNcIjo1MDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcIk5va2lhLyovTm9raWEgNy4xLypcIn0se1widWFcIjpcIk5va2lhIDcuMVwifV0sXCJkcGlcIjpbNDMyLDQzMS45XSxcImJ3XCI6MyxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJpb3NcIixcInJ1bGVzXCI6W3tcInJlc1wiOlsxMjQyLDI2ODhdfV0sXCJkcGlcIjo0NTgsXCJid1wiOjQsXCJhY1wiOjEwMDB9LHtcInR5cGVcIjpcImFuZHJvaWRcIixcInJ1bGVzXCI6W3tcIm1kbWhcIjpcInNhbXN1bmcvKi9TTS1HNTcwTS8qXCJ9LHtcInVhXCI6XCJTTS1HNTcwTVwifV0sXCJkcGlcIjozMjAsXCJid1wiOjMuNjg0LFwiYWNcIjoxMDAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tRzk3MEYvKlwifSx7XCJ1YVwiOlwiU00tRzk3MEZcIn1dLFwiZHBpXCI6NDM4LFwiYndcIjoyLjI4MSxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tRzk3M0YvKlwifSx7XCJ1YVwiOlwiU00tRzk3M0ZcIn1dLFwiZHBpXCI6NTUwLFwiYndcIjoyLjAwMixcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tRzk3NUYvKlwifSx7XCJ1YVwiOlwiU00tRzk3NUZcIn1dLFwiZHBpXCI6NTIyLFwiYndcIjoyLjA1NCxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJhbmRyb2lkXCIsXCJydWxlc1wiOlt7XCJtZG1oXCI6XCJzYW1zdW5nLyovU00tRzk3N0YvKlwifSx7XCJ1YVwiOlwiU00tRzk3N0ZcIn1dLFwiZHBpXCI6NTA1LFwiYndcIjoyLjMzNCxcImFjXCI6NTAwfSx7XCJ0eXBlXCI6XCJpb3NcIixcInJ1bGVzXCI6W3tcInJlc1wiOls4MjgsMTc5Ml19XSxcImRwaVwiOjMyNixcImJ3XCI6NSxcImFjXCI6NTAwfV07XG52YXIgRFBEQl9DQUNIRSA9IHtcblx0Zm9ybWF0OiBmb3JtYXQsXG5cdGxhc3RfdXBkYXRlZDogbGFzdF91cGRhdGVkLFxuXHRkZXZpY2VzOiBkZXZpY2VzXG59O1xuZnVuY3Rpb24gRHBkYih1cmwsIG9uRGV2aWNlUGFyYW1zVXBkYXRlZCkge1xuICB0aGlzLmRwZGIgPSBEUERCX0NBQ0hFO1xuICB0aGlzLnJlY2FsY3VsYXRlRGV2aWNlUGFyYW1zXygpO1xuICBpZiAodXJsKSB7XG4gICAgdGhpcy5vbkRldmljZVBhcmFtc1VwZGF0ZWQgPSBvbkRldmljZVBhcmFtc1VwZGF0ZWQ7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHZhciBvYmogPSB0aGlzO1xuICAgIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgIHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgb2JqLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgIGlmICh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDw9IDI5OSkge1xuICAgICAgICBvYmouZHBkYiA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgb2JqLnJlY2FsY3VsYXRlRGV2aWNlUGFyYW1zXygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBvbmxpbmUgRFBEQiEnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB4aHIuc2VuZCgpO1xuICB9XG59XG5EcGRiLnByb3RvdHlwZS5nZXREZXZpY2VQYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmRldmljZVBhcmFtcztcbn07XG5EcGRiLnByb3RvdHlwZS5yZWNhbGN1bGF0ZURldmljZVBhcmFtc18gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBuZXdEZXZpY2VQYXJhbXMgPSB0aGlzLmNhbGNEZXZpY2VQYXJhbXNfKCk7XG4gIGlmIChuZXdEZXZpY2VQYXJhbXMpIHtcbiAgICB0aGlzLmRldmljZVBhcmFtcyA9IG5ld0RldmljZVBhcmFtcztcbiAgICBpZiAodGhpcy5vbkRldmljZVBhcmFtc1VwZGF0ZWQpIHtcbiAgICAgIHRoaXMub25EZXZpY2VQYXJhbXNVcGRhdGVkKHRoaXMuZGV2aWNlUGFyYW1zKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlY2FsY3VsYXRlIGRldmljZSBwYXJhbWV0ZXJzLicpO1xuICB9XG59O1xuRHBkYi5wcm90b3R5cGUuY2FsY0RldmljZVBhcmFtc18gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkYiA9IHRoaXMuZHBkYjtcbiAgaWYgKCFkYikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0RQREIgbm90IGF2YWlsYWJsZS4nKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoZGIuZm9ybWF0ICE9IDEpIHtcbiAgICBjb25zb2xlLmVycm9yKCdEUERCIGhhcyB1bmV4cGVjdGVkIGZvcm1hdCB2ZXJzaW9uLicpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghZGIuZGV2aWNlcyB8fCAhZGIuZGV2aWNlcy5sZW5ndGgpIHtcbiAgICBjb25zb2xlLmVycm9yKCdEUERCIGRvZXMgbm90IGhhdmUgYSBkZXZpY2VzIHNlY3Rpb24uJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmE7XG4gIHZhciB3aWR0aCA9IGdldFNjcmVlbldpZHRoKCk7XG4gIHZhciBoZWlnaHQgPSBnZXRTY3JlZW5IZWlnaHQoKTtcbiAgaWYgKCFkYi5kZXZpY2VzKSB7XG4gICAgY29uc29sZS5lcnJvcignRFBEQiBoYXMgbm8gZGV2aWNlcyBzZWN0aW9uLicpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGIuZGV2aWNlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXZpY2UgPSBkYi5kZXZpY2VzW2ldO1xuICAgIGlmICghZGV2aWNlLnJ1bGVzKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0RldmljZVsnICsgaSArICddIGhhcyBubyBydWxlcyBzZWN0aW9uLicpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChkZXZpY2UudHlwZSAhPSAnaW9zJyAmJiBkZXZpY2UudHlwZSAhPSAnYW5kcm9pZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybignRGV2aWNlWycgKyBpICsgJ10gaGFzIGludmFsaWQgdHlwZS4nKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaXNJT1MoKSAhPSAoZGV2aWNlLnR5cGUgPT0gJ2lvcycpKSBjb250aW51ZTtcbiAgICB2YXIgbWF0Y2hlZCA9IGZhbHNlO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGV2aWNlLnJ1bGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcnVsZSA9IGRldmljZS5ydWxlc1tqXTtcbiAgICAgIGlmICh0aGlzLnJ1bGVNYXRjaGVzXyhydWxlLCB1c2VyQWdlbnQsIHdpZHRoLCBoZWlnaHQpKSB7XG4gICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtYXRjaGVkKSBjb250aW51ZTtcbiAgICB2YXIgeGRwaSA9IGRldmljZS5kcGlbMF0gfHwgZGV2aWNlLmRwaTtcbiAgICB2YXIgeWRwaSA9IGRldmljZS5kcGlbMV0gfHwgZGV2aWNlLmRwaTtcbiAgICByZXR1cm4gbmV3IERldmljZVBhcmFtcyh7IHhkcGk6IHhkcGksIHlkcGk6IHlkcGksIGJldmVsTW06IGRldmljZS5idyB9KTtcbiAgfVxuICBjb25zb2xlLndhcm4oJ05vIERQREIgZGV2aWNlIG1hdGNoLicpO1xuICByZXR1cm4gbnVsbDtcbn07XG5EcGRiLnByb3RvdHlwZS5ydWxlTWF0Y2hlc18gPSBmdW5jdGlvbiAocnVsZSwgdWEsIHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpIHtcbiAgaWYgKCFydWxlLnVhICYmICFydWxlLnJlcykgcmV0dXJuIGZhbHNlO1xuICBpZiAocnVsZS51YSAmJiBydWxlLnVhLnN1YnN0cmluZygwLCAyKSA9PT0gJ1NNJykgcnVsZS51YSA9IHJ1bGUudWEuc3Vic3RyaW5nKDAsIDcpO1xuICBpZiAocnVsZS51YSAmJiB1YS5pbmRleE9mKHJ1bGUudWEpIDwgMCkgcmV0dXJuIGZhbHNlO1xuICBpZiAocnVsZS5yZXMpIHtcbiAgICBpZiAoIXJ1bGUucmVzWzBdIHx8ICFydWxlLnJlc1sxXSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciByZXNYID0gcnVsZS5yZXNbMF07XG4gICAgdmFyIHJlc1kgPSBydWxlLnJlc1sxXTtcbiAgICBpZiAoTWF0aC5taW4oc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCkgIT0gTWF0aC5taW4ocmVzWCwgcmVzWSkgfHwgTWF0aC5tYXgoc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCkgIT0gTWF0aC5tYXgocmVzWCwgcmVzWSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gRGV2aWNlUGFyYW1zKHBhcmFtcykge1xuICB0aGlzLnhkcGkgPSBwYXJhbXMueGRwaTtcbiAgdGhpcy55ZHBpID0gcGFyYW1zLnlkcGk7XG4gIHRoaXMuYmV2ZWxNbSA9IHBhcmFtcy5iZXZlbE1tO1xufVxuZnVuY3Rpb24gU2Vuc29yU2FtcGxlKHNhbXBsZSwgdGltZXN0YW1wUykge1xuICB0aGlzLnNldChzYW1wbGUsIHRpbWVzdGFtcFMpO1xufVxuU2Vuc29yU2FtcGxlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoc2FtcGxlLCB0aW1lc3RhbXBTKSB7XG4gIHRoaXMuc2FtcGxlID0gc2FtcGxlO1xuICB0aGlzLnRpbWVzdGFtcFMgPSB0aW1lc3RhbXBTO1xufTtcblNlbnNvclNhbXBsZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChzZW5zb3JTYW1wbGUpIHtcbiAgdGhpcy5zZXQoc2Vuc29yU2FtcGxlLnNhbXBsZSwgc2Vuc29yU2FtcGxlLnRpbWVzdGFtcFMpO1xufTtcbmZ1bmN0aW9uIENvbXBsZW1lbnRhcnlGaWx0ZXIoa0ZpbHRlciwgaXNEZWJ1Zykge1xuICB0aGlzLmtGaWx0ZXIgPSBrRmlsdGVyO1xuICB0aGlzLmlzRGVidWcgPSBpc0RlYnVnO1xuICB0aGlzLmN1cnJlbnRBY2NlbE1lYXN1cmVtZW50ID0gbmV3IFNlbnNvclNhbXBsZSgpO1xuICB0aGlzLmN1cnJlbnRHeXJvTWVhc3VyZW1lbnQgPSBuZXcgU2Vuc29yU2FtcGxlKCk7XG4gIHRoaXMucHJldmlvdXNHeXJvTWVhc3VyZW1lbnQgPSBuZXcgU2Vuc29yU2FtcGxlKCk7XG4gIGlmIChpc0lPUygpKSB7XG4gICAgdGhpcy5maWx0ZXJRID0gbmV3IFF1YXRlcm5pb24oLTEsIDAsIDAsIDEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmlsdGVyUSA9IG5ldyBRdWF0ZXJuaW9uKDEsIDAsIDAsIDEpO1xuICB9XG4gIHRoaXMucHJldmlvdXNGaWx0ZXJRID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgdGhpcy5wcmV2aW91c0ZpbHRlclEuY29weSh0aGlzLmZpbHRlclEpO1xuICB0aGlzLmFjY2VsUSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gIHRoaXMuaXNPcmllbnRhdGlvbkluaXRpYWxpemVkID0gZmFsc2U7XG4gIHRoaXMuZXN0aW1hdGVkR3Jhdml0eSA9IG5ldyBWZWN0b3IzKCk7XG4gIHRoaXMubWVhc3VyZWRHcmF2aXR5ID0gbmV3IFZlY3RvcjMoKTtcbiAgdGhpcy5neXJvSW50ZWdyYWxRID0gbmV3IFF1YXRlcm5pb24oKTtcbn1cbkNvbXBsZW1lbnRhcnlGaWx0ZXIucHJvdG90eXBlLmFkZEFjY2VsTWVhc3VyZW1lbnQgPSBmdW5jdGlvbiAodmVjdG9yLCB0aW1lc3RhbXBTKSB7XG4gIHRoaXMuY3VycmVudEFjY2VsTWVhc3VyZW1lbnQuc2V0KHZlY3RvciwgdGltZXN0YW1wUyk7XG59O1xuQ29tcGxlbWVudGFyeUZpbHRlci5wcm90b3R5cGUuYWRkR3lyb01lYXN1cmVtZW50ID0gZnVuY3Rpb24gKHZlY3RvciwgdGltZXN0YW1wUykge1xuICB0aGlzLmN1cnJlbnRHeXJvTWVhc3VyZW1lbnQuc2V0KHZlY3RvciwgdGltZXN0YW1wUyk7XG4gIHZhciBkZWx0YVQgPSB0aW1lc3RhbXBTIC0gdGhpcy5wcmV2aW91c0d5cm9NZWFzdXJlbWVudC50aW1lc3RhbXBTO1xuICBpZiAoaXNUaW1lc3RhbXBEZWx0YVZhbGlkKGRlbHRhVCkpIHtcbiAgICB0aGlzLnJ1bl8oKTtcbiAgfVxuICB0aGlzLnByZXZpb3VzR3lyb01lYXN1cmVtZW50LmNvcHkodGhpcy5jdXJyZW50R3lyb01lYXN1cmVtZW50KTtcbn07XG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5ydW5fID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaXNPcmllbnRhdGlvbkluaXRpYWxpemVkKSB7XG4gICAgdGhpcy5hY2NlbFEgPSB0aGlzLmFjY2VsVG9RdWF0ZXJuaW9uXyh0aGlzLmN1cnJlbnRBY2NlbE1lYXN1cmVtZW50LnNhbXBsZSk7XG4gICAgdGhpcy5wcmV2aW91c0ZpbHRlclEuY29weSh0aGlzLmFjY2VsUSk7XG4gICAgdGhpcy5pc09yaWVudGF0aW9uSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZGVsdGFUID0gdGhpcy5jdXJyZW50R3lyb01lYXN1cmVtZW50LnRpbWVzdGFtcFMgLSB0aGlzLnByZXZpb3VzR3lyb01lYXN1cmVtZW50LnRpbWVzdGFtcFM7XG4gIHZhciBneXJvRGVsdGFRID0gdGhpcy5neXJvVG9RdWF0ZXJuaW9uRGVsdGFfKHRoaXMuY3VycmVudEd5cm9NZWFzdXJlbWVudC5zYW1wbGUsIGRlbHRhVCk7XG4gIHRoaXMuZ3lyb0ludGVncmFsUS5tdWx0aXBseShneXJvRGVsdGFRKTtcbiAgdGhpcy5maWx0ZXJRLmNvcHkodGhpcy5wcmV2aW91c0ZpbHRlclEpO1xuICB0aGlzLmZpbHRlclEubXVsdGlwbHkoZ3lyb0RlbHRhUSk7XG4gIHZhciBpbnZGaWx0ZXJRID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgaW52RmlsdGVyUS5jb3B5KHRoaXMuZmlsdGVyUSk7XG4gIGludkZpbHRlclEuaW52ZXJzZSgpO1xuICB0aGlzLmVzdGltYXRlZEdyYXZpdHkuc2V0KDAsIDAsIC0xKTtcbiAgdGhpcy5lc3RpbWF0ZWRHcmF2aXR5LmFwcGx5UXVhdGVybmlvbihpbnZGaWx0ZXJRKTtcbiAgdGhpcy5lc3RpbWF0ZWRHcmF2aXR5Lm5vcm1hbGl6ZSgpO1xuICB0aGlzLm1lYXN1cmVkR3Jhdml0eS5jb3B5KHRoaXMuY3VycmVudEFjY2VsTWVhc3VyZW1lbnQuc2FtcGxlKTtcbiAgdGhpcy5tZWFzdXJlZEdyYXZpdHkubm9ybWFsaXplKCk7XG4gIHZhciBkZWx0YVEgPSBuZXcgUXVhdGVybmlvbigpO1xuICBkZWx0YVEuc2V0RnJvbVVuaXRWZWN0b3JzKHRoaXMuZXN0aW1hdGVkR3Jhdml0eSwgdGhpcy5tZWFzdXJlZEdyYXZpdHkpO1xuICBkZWx0YVEuaW52ZXJzZSgpO1xuICBpZiAodGhpcy5pc0RlYnVnKSB7XG4gICAgY29uc29sZS5sb2coJ0RlbHRhOiAlZCBkZWcsIEdfZXN0OiAoJXMsICVzLCAlcyksIEdfbWVhczogKCVzLCAlcywgJXMpJywgcmFkVG9EZWcgKiBnZXRRdWF0ZXJuaW9uQW5nbGUoZGVsdGFRKSwgdGhpcy5lc3RpbWF0ZWRHcmF2aXR5LngudG9GaXhlZCgxKSwgdGhpcy5lc3RpbWF0ZWRHcmF2aXR5LnkudG9GaXhlZCgxKSwgdGhpcy5lc3RpbWF0ZWRHcmF2aXR5LnoudG9GaXhlZCgxKSwgdGhpcy5tZWFzdXJlZEdyYXZpdHkueC50b0ZpeGVkKDEpLCB0aGlzLm1lYXN1cmVkR3Jhdml0eS55LnRvRml4ZWQoMSksIHRoaXMubWVhc3VyZWRHcmF2aXR5LnoudG9GaXhlZCgxKSk7XG4gIH1cbiAgdmFyIHRhcmdldFEgPSBuZXcgUXVhdGVybmlvbigpO1xuICB0YXJnZXRRLmNvcHkodGhpcy5maWx0ZXJRKTtcbiAgdGFyZ2V0US5tdWx0aXBseShkZWx0YVEpO1xuICB0aGlzLmZpbHRlclEuc2xlcnAodGFyZ2V0USwgMSAtIHRoaXMua0ZpbHRlcik7XG4gIHRoaXMucHJldmlvdXNGaWx0ZXJRLmNvcHkodGhpcy5maWx0ZXJRKTtcbn07XG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5nZXRPcmllbnRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZmlsdGVyUTtcbn07XG5Db21wbGVtZW50YXJ5RmlsdGVyLnByb3RvdHlwZS5hY2NlbFRvUXVhdGVybmlvbl8gPSBmdW5jdGlvbiAoYWNjZWwpIHtcbiAgdmFyIG5vcm1BY2NlbCA9IG5ldyBWZWN0b3IzKCk7XG4gIG5vcm1BY2NlbC5jb3B5KGFjY2VsKTtcbiAgbm9ybUFjY2VsLm5vcm1hbGl6ZSgpO1xuICB2YXIgcXVhdCA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gIHF1YXQuc2V0RnJvbVVuaXRWZWN0b3JzKG5ldyBWZWN0b3IzKDAsIDAsIC0xKSwgbm9ybUFjY2VsKTtcbiAgcXVhdC5pbnZlcnNlKCk7XG4gIHJldHVybiBxdWF0O1xufTtcbkNvbXBsZW1lbnRhcnlGaWx0ZXIucHJvdG90eXBlLmd5cm9Ub1F1YXRlcm5pb25EZWx0YV8gPSBmdW5jdGlvbiAoZ3lybywgZHQpIHtcbiAgdmFyIHF1YXQgPSBuZXcgUXVhdGVybmlvbigpO1xuICB2YXIgYXhpcyA9IG5ldyBWZWN0b3IzKCk7XG4gIGF4aXMuY29weShneXJvKTtcbiAgYXhpcy5ub3JtYWxpemUoKTtcbiAgcXVhdC5zZXRGcm9tQXhpc0FuZ2xlKGF4aXMsIGd5cm8ubGVuZ3RoKCkgKiBkdCk7XG4gIHJldHVybiBxdWF0O1xufTtcbmZ1bmN0aW9uIFBvc2VQcmVkaWN0b3IocHJlZGljdGlvblRpbWVTLCBpc0RlYnVnKSB7XG4gIHRoaXMucHJlZGljdGlvblRpbWVTID0gcHJlZGljdGlvblRpbWVTO1xuICB0aGlzLmlzRGVidWcgPSBpc0RlYnVnO1xuICB0aGlzLnByZXZpb3VzUSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gIHRoaXMucHJldmlvdXNUaW1lc3RhbXBTID0gbnVsbDtcbiAgdGhpcy5kZWx0YVEgPSBuZXcgUXVhdGVybmlvbigpO1xuICB0aGlzLm91dFEgPSBuZXcgUXVhdGVybmlvbigpO1xufVxuUG9zZVByZWRpY3Rvci5wcm90b3R5cGUuZ2V0UHJlZGljdGlvbiA9IGZ1bmN0aW9uIChjdXJyZW50USwgZ3lybywgdGltZXN0YW1wUykge1xuICBpZiAoIXRoaXMucHJldmlvdXNUaW1lc3RhbXBTKSB7XG4gICAgdGhpcy5wcmV2aW91c1EuY29weShjdXJyZW50USk7XG4gICAgdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMgPSB0aW1lc3RhbXBTO1xuICAgIHJldHVybiBjdXJyZW50UTtcbiAgfVxuICB2YXIgYXhpcyA9IG5ldyBWZWN0b3IzKCk7XG4gIGF4aXMuY29weShneXJvKTtcbiAgYXhpcy5ub3JtYWxpemUoKTtcbiAgdmFyIGFuZ3VsYXJTcGVlZCA9IGd5cm8ubGVuZ3RoKCk7XG4gIGlmIChhbmd1bGFyU3BlZWQgPCBkZWdUb1JhZCAqIDIwKSB7XG4gICAgaWYgKHRoaXMuaXNEZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coJ01vdmluZyBzbG93bHksIGF0ICVzIGRlZy9zOiBubyBwcmVkaWN0aW9uJywgKHJhZFRvRGVnICogYW5ndWxhclNwZWVkKS50b0ZpeGVkKDEpKTtcbiAgICB9XG4gICAgdGhpcy5vdXRRLmNvcHkoY3VycmVudFEpO1xuICAgIHRoaXMucHJldmlvdXNRLmNvcHkoY3VycmVudFEpO1xuICAgIHJldHVybiB0aGlzLm91dFE7XG4gIH1cbiAgdmFyIHByZWRpY3RBbmdsZSA9IGFuZ3VsYXJTcGVlZCAqIHRoaXMucHJlZGljdGlvblRpbWVTO1xuICB0aGlzLmRlbHRhUS5zZXRGcm9tQXhpc0FuZ2xlKGF4aXMsIHByZWRpY3RBbmdsZSk7XG4gIHRoaXMub3V0US5jb3B5KHRoaXMucHJldmlvdXNRKTtcbiAgdGhpcy5vdXRRLm11bHRpcGx5KHRoaXMuZGVsdGFRKTtcbiAgdGhpcy5wcmV2aW91c1EuY29weShjdXJyZW50USk7XG4gIHRoaXMucHJldmlvdXNUaW1lc3RhbXBTID0gdGltZXN0YW1wUztcbiAgcmV0dXJuIHRoaXMub3V0UTtcbn07XG5mdW5jdGlvbiBGdXNpb25Qb3NlU2Vuc29yKGtGaWx0ZXIsIHByZWRpY3Rpb25UaW1lLCB5YXdPbmx5LCBpc0RlYnVnKSB7XG4gIHRoaXMueWF3T25seSA9IHlhd09ubHk7XG4gIHRoaXMuYWNjZWxlcm9tZXRlciA9IG5ldyBWZWN0b3IzKCk7XG4gIHRoaXMuZ3lyb3Njb3BlID0gbmV3IFZlY3RvcjMoKTtcbiAgdGhpcy5maWx0ZXIgPSBuZXcgQ29tcGxlbWVudGFyeUZpbHRlcihrRmlsdGVyLCBpc0RlYnVnKTtcbiAgdGhpcy5wb3NlUHJlZGljdG9yID0gbmV3IFBvc2VQcmVkaWN0b3IocHJlZGljdGlvblRpbWUsIGlzRGVidWcpO1xuICB0aGlzLmlzRmlyZWZveEFuZHJvaWQgPSBpc0ZpcmVmb3hBbmRyb2lkKCk7XG4gIHRoaXMuaXNJT1MgPSBpc0lPUygpO1xuICB2YXIgY2hyb21lVmVyc2lvbiA9IGdldENocm9tZVZlcnNpb24oKTtcbiAgdGhpcy5pc0RldmljZU1vdGlvbkluUmFkaWFucyA9ICF0aGlzLmlzSU9TICYmIGNocm9tZVZlcnNpb24gJiYgY2hyb21lVmVyc2lvbiA8IDY2O1xuICB0aGlzLmlzV2l0aG91dERldmljZU1vdGlvbiA9IGlzQ2hyb21lV2l0aG91dERldmljZU1vdGlvbigpIHx8IGlzU2FmYXJpV2l0aG91dERldmljZU1vdGlvbigpO1xuICB0aGlzLmZpbHRlclRvV29ybGRRID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgaWYgKGlzSU9TKCkpIHtcbiAgICB0aGlzLmZpbHRlclRvV29ybGRRLnNldEZyb21BeGlzQW5nbGUobmV3IFZlY3RvcjMoMSwgMCwgMCksIE1hdGguUEkgLyAyKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZpbHRlclRvV29ybGRRLnNldEZyb21BeGlzQW5nbGUobmV3IFZlY3RvcjMoMSwgMCwgMCksIC1NYXRoLlBJIC8gMik7XG4gIH1cbiAgdGhpcy5pbnZlcnNlV29ybGRUb1NjcmVlblEgPSBuZXcgUXVhdGVybmlvbigpO1xuICB0aGlzLndvcmxkVG9TY3JlZW5RID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgdGhpcy5vcmlnaW5hbFBvc2VBZGp1c3RRID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgdGhpcy5vcmlnaW5hbFBvc2VBZGp1c3RRLnNldEZyb21BeGlzQW5nbGUobmV3IFZlY3RvcjMoMCwgMCwgMSksIC13aW5kb3cub3JpZW50YXRpb24gKiBNYXRoLlBJIC8gMTgwKTtcbiAgdGhpcy5zZXRTY3JlZW5UcmFuc2Zvcm1fKCk7XG4gIGlmIChpc0xhbmRzY2FwZU1vZGUoKSkge1xuICAgIHRoaXMuZmlsdGVyVG9Xb3JsZFEubXVsdGlwbHkodGhpcy5pbnZlcnNlV29ybGRUb1NjcmVlblEpO1xuICB9XG4gIHRoaXMucmVzZXRRID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgdGhpcy5vcmllbnRhdGlvbk91dF8gPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICB0aGlzLnN0YXJ0KCk7XG59XG5GdXNpb25Qb3NlU2Vuc29yLnByb3RvdHlwZS5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuRnVzaW9uUG9zZVNlbnNvci5wcm90b3R5cGUuZ2V0T3JpZW50YXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvcmllbnRhdGlvbiA9IHZvaWQgMDtcbiAgaWYgKHRoaXMuaXNXaXRob3V0RGV2aWNlTW90aW9uICYmIHRoaXMuX2RldmljZU9yaWVudGF0aW9uUSkge1xuICAgIHRoaXMuZGV2aWNlT3JpZW50YXRpb25GaXhRID0gdGhpcy5kZXZpY2VPcmllbnRhdGlvbkZpeFEgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHogPSBuZXcgUXVhdGVybmlvbigpLnNldEZyb21BeGlzQW5nbGUobmV3IFZlY3RvcjMoMCwgMCwgLTEpLCAwKTtcbiAgICAgIHZhciB5ID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICAgIGlmICh3aW5kb3cub3JpZW50YXRpb24gPT09IC05MCkge1xuICAgICAgICB5LnNldEZyb21BeGlzQW5nbGUobmV3IFZlY3RvcjMoMCwgMSwgMCksIE1hdGguUEkgLyAtMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5LnNldEZyb21BeGlzQW5nbGUobmV3IFZlY3RvcjMoMCwgMSwgMCksIE1hdGguUEkgLyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB6Lm11bHRpcGx5KHkpO1xuICAgIH0oKTtcbiAgICB0aGlzLmRldmljZU9yaWVudGF0aW9uRmlsdGVyVG9Xb3JsZFEgPSB0aGlzLmRldmljZU9yaWVudGF0aW9uRmlsdGVyVG9Xb3JsZFEgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHEgPSBuZXcgUXVhdGVybmlvbigpO1xuICAgICAgcS5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBWZWN0b3IzKDEsIDAsIDApLCAtTWF0aC5QSSAvIDIpO1xuICAgICAgcmV0dXJuIHE7XG4gICAgfSgpO1xuICAgIG9yaWVudGF0aW9uID0gdGhpcy5fZGV2aWNlT3JpZW50YXRpb25RO1xuICAgIHZhciBvdXQgPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIG91dC5jb3B5KG9yaWVudGF0aW9uKTtcbiAgICBvdXQubXVsdGlwbHkodGhpcy5kZXZpY2VPcmllbnRhdGlvbkZpbHRlclRvV29ybGRRKTtcbiAgICBvdXQubXVsdGlwbHkodGhpcy5yZXNldFEpO1xuICAgIG91dC5tdWx0aXBseSh0aGlzLndvcmxkVG9TY3JlZW5RKTtcbiAgICBvdXQubXVsdGlwbHlRdWF0ZXJuaW9ucyh0aGlzLmRldmljZU9yaWVudGF0aW9uRml4USwgb3V0KTtcbiAgICBpZiAodGhpcy55YXdPbmx5KSB7XG4gICAgICBvdXQueCA9IDA7XG4gICAgICBvdXQueiA9IDA7XG4gICAgICBvdXQubm9ybWFsaXplKCk7XG4gICAgfVxuICAgIHRoaXMub3JpZW50YXRpb25PdXRfWzBdID0gb3V0Lng7XG4gICAgdGhpcy5vcmllbnRhdGlvbk91dF9bMV0gPSBvdXQueTtcbiAgICB0aGlzLm9yaWVudGF0aW9uT3V0X1syXSA9IG91dC56O1xuICAgIHRoaXMub3JpZW50YXRpb25PdXRfWzNdID0gb3V0Lnc7XG4gICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb25PdXRfO1xuICB9IGVsc2Uge1xuICAgIHZhciBmaWx0ZXJPcmllbnRhdGlvbiA9IHRoaXMuZmlsdGVyLmdldE9yaWVudGF0aW9uKCk7XG4gICAgb3JpZW50YXRpb24gPSB0aGlzLnBvc2VQcmVkaWN0b3IuZ2V0UHJlZGljdGlvbihmaWx0ZXJPcmllbnRhdGlvbiwgdGhpcy5neXJvc2NvcGUsIHRoaXMucHJldmlvdXNUaW1lc3RhbXBTKTtcbiAgfVxuICB2YXIgb3V0ID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgb3V0LmNvcHkodGhpcy5maWx0ZXJUb1dvcmxkUSk7XG4gIG91dC5tdWx0aXBseSh0aGlzLnJlc2V0USk7XG4gIG91dC5tdWx0aXBseShvcmllbnRhdGlvbik7XG4gIG91dC5tdWx0aXBseSh0aGlzLndvcmxkVG9TY3JlZW5RKTtcbiAgaWYgKHRoaXMueWF3T25seSkge1xuICAgIG91dC54ID0gMDtcbiAgICBvdXQueiA9IDA7XG4gICAgb3V0Lm5vcm1hbGl6ZSgpO1xuICB9XG4gIHRoaXMub3JpZW50YXRpb25PdXRfWzBdID0gb3V0Lng7XG4gIHRoaXMub3JpZW50YXRpb25PdXRfWzFdID0gb3V0Lnk7XG4gIHRoaXMub3JpZW50YXRpb25PdXRfWzJdID0gb3V0Lno7XG4gIHRoaXMub3JpZW50YXRpb25PdXRfWzNdID0gb3V0Lnc7XG4gIHJldHVybiB0aGlzLm9yaWVudGF0aW9uT3V0Xztcbn07XG5GdXNpb25Qb3NlU2Vuc29yLnByb3RvdHlwZS5yZXNldFBvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVzZXRRLmNvcHkodGhpcy5maWx0ZXIuZ2V0T3JpZW50YXRpb24oKSk7XG4gIHRoaXMucmVzZXRRLnggPSAwO1xuICB0aGlzLnJlc2V0US55ID0gMDtcbiAgdGhpcy5yZXNldFEueiAqPSAtMTtcbiAgdGhpcy5yZXNldFEubm9ybWFsaXplKCk7XG4gIGlmIChpc0xhbmRzY2FwZU1vZGUoKSkge1xuICAgIHRoaXMucmVzZXRRLm11bHRpcGx5KHRoaXMuaW52ZXJzZVdvcmxkVG9TY3JlZW5RKTtcbiAgfVxuICB0aGlzLnJlc2V0US5tdWx0aXBseSh0aGlzLm9yaWdpbmFsUG9zZUFkanVzdFEpO1xufTtcbkZ1c2lvblBvc2VTZW5zb3IucHJvdG90eXBlLm9uRGV2aWNlT3JpZW50YXRpb25fID0gZnVuY3Rpb24gKGUpIHtcbiAgdGhpcy5fZGV2aWNlT3JpZW50YXRpb25RID0gdGhpcy5fZGV2aWNlT3JpZW50YXRpb25RIHx8IG5ldyBRdWF0ZXJuaW9uKCk7XG4gIHZhciBhbHBoYSA9IGUuYWxwaGEsXG4gICAgICBiZXRhID0gZS5iZXRhLFxuICAgICAgZ2FtbWEgPSBlLmdhbW1hO1xuICBhbHBoYSA9IChhbHBoYSB8fCAwKSAqIE1hdGguUEkgLyAxODA7XG4gIGJldGEgPSAoYmV0YSB8fCAwKSAqIE1hdGguUEkgLyAxODA7XG4gIGdhbW1hID0gKGdhbW1hIHx8IDApICogTWF0aC5QSSAvIDE4MDtcbiAgdGhpcy5fZGV2aWNlT3JpZW50YXRpb25RLnNldEZyb21FdWxlcllYWihiZXRhLCBhbHBoYSwgLWdhbW1hKTtcbn07XG5GdXNpb25Qb3NlU2Vuc29yLnByb3RvdHlwZS5vbkRldmljZU1vdGlvbl8gPSBmdW5jdGlvbiAoZGV2aWNlTW90aW9uKSB7XG4gIHRoaXMudXBkYXRlRGV2aWNlTW90aW9uXyhkZXZpY2VNb3Rpb24pO1xufTtcbkZ1c2lvblBvc2VTZW5zb3IucHJvdG90eXBlLnVwZGF0ZURldmljZU1vdGlvbl8gPSBmdW5jdGlvbiAoZGV2aWNlTW90aW9uKSB7XG4gIHZhciBhY2NHcmF2aXR5ID0gZGV2aWNlTW90aW9uLmFjY2VsZXJhdGlvbkluY2x1ZGluZ0dyYXZpdHk7XG4gIHZhciByb3RSYXRlID0gZGV2aWNlTW90aW9uLnJvdGF0aW9uUmF0ZTtcbiAgdmFyIHRpbWVzdGFtcFMgPSBkZXZpY2VNb3Rpb24udGltZVN0YW1wIC8gMTAwMDtcbiAgdmFyIGRlbHRhUyA9IHRpbWVzdGFtcFMgLSB0aGlzLnByZXZpb3VzVGltZXN0YW1wUztcbiAgaWYgKGRlbHRhUyA8IDApIHtcbiAgICB3YXJuT25jZSgnZnVzaW9uLXBvc2Utc2Vuc29yOmludmFsaWQ6bm9uLW1vbm90b25pYycsICdJbnZhbGlkIHRpbWVzdGFtcHMgZGV0ZWN0ZWQ6IG5vbi1tb25vdG9uaWMgdGltZXN0YW1wIGZyb20gZGV2aWNlbW90aW9uJyk7XG4gICAgdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMgPSB0aW1lc3RhbXBTO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChkZWx0YVMgPD0gTUlOX1RJTUVTVEVQIHx8IGRlbHRhUyA+IE1BWF9USU1FU1RFUCkge1xuICAgIHdhcm5PbmNlKCdmdXNpb24tcG9zZS1zZW5zb3I6aW52YWxpZDpvdXRzaWRlLXRocmVzaG9sZCcsICdJbnZhbGlkIHRpbWVzdGFtcHMgZGV0ZWN0ZWQ6IFRpbWVzdGFtcCBmcm9tIGRldmljZW1vdGlvbiBvdXRzaWRlIGV4cGVjdGVkIHJhbmdlLicpO1xuICAgIHRoaXMucHJldmlvdXNUaW1lc3RhbXBTID0gdGltZXN0YW1wUztcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5hY2NlbGVyb21ldGVyLnNldCgtYWNjR3Jhdml0eS54LCAtYWNjR3Jhdml0eS55LCAtYWNjR3Jhdml0eS56KTtcbiAgaWYgKHJvdFJhdGUpIHtcbiAgICBpZiAoaXNSNygpKSB7XG4gICAgICB0aGlzLmd5cm9zY29wZS5zZXQoLXJvdFJhdGUuYmV0YSwgcm90UmF0ZS5hbHBoYSwgcm90UmF0ZS5nYW1tYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ3lyb3Njb3BlLnNldChyb3RSYXRlLmFscGhhLCByb3RSYXRlLmJldGEsIHJvdFJhdGUuZ2FtbWEpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNEZXZpY2VNb3Rpb25JblJhZGlhbnMpIHtcbiAgICAgIHRoaXMuZ3lyb3Njb3BlLm11bHRpcGx5U2NhbGFyKE1hdGguUEkgLyAxODApO1xuICAgIH1cbiAgICB0aGlzLmZpbHRlci5hZGRHeXJvTWVhc3VyZW1lbnQodGhpcy5neXJvc2NvcGUsIHRpbWVzdGFtcFMpO1xuICB9XG4gIHRoaXMuZmlsdGVyLmFkZEFjY2VsTWVhc3VyZW1lbnQodGhpcy5hY2NlbGVyb21ldGVyLCB0aW1lc3RhbXBTKTtcbiAgdGhpcy5wcmV2aW91c1RpbWVzdGFtcFMgPSB0aW1lc3RhbXBTO1xufTtcbkZ1c2lvblBvc2VTZW5zb3IucHJvdG90eXBlLm9uT3JpZW50YXRpb25DaGFuZ2VfID0gZnVuY3Rpb24gKHNjcmVlbk9yaWVudGF0aW9uKSB7XG4gIHRoaXMuc2V0U2NyZWVuVHJhbnNmb3JtXygpO1xufTtcbkZ1c2lvblBvc2VTZW5zb3IucHJvdG90eXBlLm9uTWVzc2FnZV8gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIG1lc3NhZ2UgPSBldmVudC5kYXRhO1xuICBpZiAoIW1lc3NhZ2UgfHwgIW1lc3NhZ2UudHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdHlwZSA9IG1lc3NhZ2UudHlwZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAodHlwZSAhPT0gJ2RldmljZW1vdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy51cGRhdGVEZXZpY2VNb3Rpb25fKG1lc3NhZ2UuZGV2aWNlTW90aW9uRXZlbnQpO1xufTtcbkZ1c2lvblBvc2VTZW5zb3IucHJvdG90eXBlLnNldFNjcmVlblRyYW5zZm9ybV8gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMud29ybGRUb1NjcmVlblEuc2V0KDAsIDAsIDAsIDEpO1xuICBzd2l0Y2ggKHdpbmRvdy5vcmllbnRhdGlvbikge1xuICAgIGNhc2UgMDpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgOTA6XG4gICAgICB0aGlzLndvcmxkVG9TY3JlZW5RLnNldEZyb21BeGlzQW5nbGUobmV3IFZlY3RvcjMoMCwgMCwgMSksIC1NYXRoLlBJIC8gMik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIC05MDpcbiAgICAgIHRoaXMud29ybGRUb1NjcmVlblEuc2V0RnJvbUF4aXNBbmdsZShuZXcgVmVjdG9yMygwLCAwLCAxKSwgTWF0aC5QSSAvIDIpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxODA6XG4gICAgICBicmVhaztcbiAgfVxuICB0aGlzLmludmVyc2VXb3JsZFRvU2NyZWVuUS5jb3B5KHRoaXMud29ybGRUb1NjcmVlblEpO1xuICB0aGlzLmludmVyc2VXb3JsZFRvU2NyZWVuUS5pbnZlcnNlKCk7XG59O1xuRnVzaW9uUG9zZVNlbnNvci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub25EZXZpY2VNb3Rpb25DYWxsYmFja18gPSB0aGlzLm9uRGV2aWNlTW90aW9uXy5iaW5kKHRoaXMpO1xuICB0aGlzLm9uT3JpZW50YXRpb25DaGFuZ2VDYWxsYmFja18gPSB0aGlzLm9uT3JpZW50YXRpb25DaGFuZ2VfLmJpbmQodGhpcyk7XG4gIHRoaXMub25NZXNzYWdlQ2FsbGJhY2tfID0gdGhpcy5vbk1lc3NhZ2VfLmJpbmQodGhpcyk7XG4gIHRoaXMub25EZXZpY2VPcmllbnRhdGlvbkNhbGxiYWNrXyA9IHRoaXMub25EZXZpY2VPcmllbnRhdGlvbl8uYmluZCh0aGlzKTtcbiAgaWYgKGlzSU9TKCkgJiYgaXNJbnNpZGVDcm9zc09yaWdpbklGcmFtZSgpKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9uTWVzc2FnZUNhbGxiYWNrXyk7XG4gIH1cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy5vbk9yaWVudGF0aW9uQ2hhbmdlQ2FsbGJhY2tfKTtcbiAgaWYgKHRoaXMuaXNXaXRob3V0RGV2aWNlTW90aW9uKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2RldmljZW9yaWVudGF0aW9uJywgdGhpcy5vbkRldmljZU9yaWVudGF0aW9uQ2FsbGJhY2tfKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlbW90aW9uJywgdGhpcy5vbkRldmljZU1vdGlvbkNhbGxiYWNrXyk7XG4gIH1cbn07XG5GdXNpb25Qb3NlU2Vuc29yLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGV2aWNlbW90aW9uJywgdGhpcy5vbkRldmljZU1vdGlvbkNhbGxiYWNrXyk7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VvcmllbnRhdGlvbicsIHRoaXMub25EZXZpY2VPcmllbnRhdGlvbkNhbGxiYWNrXyk7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMub25PcmllbnRhdGlvbkNoYW5nZUNhbGxiYWNrXyk7XG4gIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5vbk1lc3NhZ2VDYWxsYmFja18pO1xufTtcbnZhciBTRU5TT1JfRlJFUVVFTkNZID0gNjA7XG52YXIgWF9BWElTID0gbmV3IFZlY3RvcjMoMSwgMCwgMCk7XG52YXIgWl9BWElTID0gbmV3IFZlY3RvcjMoMCwgMCwgMSk7XG52YXIgU0VOU09SX1RPX1ZSID0gbmV3IFF1YXRlcm5pb24oKTtcblNFTlNPUl9UT19WUi5zZXRGcm9tQXhpc0FuZ2xlKFhfQVhJUywgLU1hdGguUEkgLyAyKTtcblNFTlNPUl9UT19WUi5tdWx0aXBseShuZXcgUXVhdGVybmlvbigpLnNldEZyb21BeGlzQW5nbGUoWl9BWElTLCBNYXRoLlBJIC8gMikpO1xudmFyIFBvc2VTZW5zb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBvc2VTZW5zb3IoY29uZmlnKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9zZVNlbnNvcik7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5zZW5zb3IgPSBudWxsO1xuICAgIHRoaXMuZnVzaW9uU2Vuc29yID0gbnVsbDtcbiAgICB0aGlzLl9vdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgIHRoaXMuYXBpID0gbnVsbDtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMuX3NlbnNvclEgPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIHRoaXMuX291dFEgPSBuZXcgUXVhdGVybmlvbigpO1xuICAgIHRoaXMuX29uU2Vuc29yUmVhZCA9IHRoaXMuX29uU2Vuc29yUmVhZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uU2Vuc29yRXJyb3IgPSB0aGlzLl9vblNlbnNvckVycm9yLmJpbmQodGhpcyk7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgY3JlYXRlQ2xhc3MoUG9zZVNlbnNvciwgW3tcbiAgICBrZXk6ICdpbml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBzZW5zb3IgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2Vuc29yID0gbmV3IFJlbGF0aXZlT3JpZW50YXRpb25TZW5zb3Ioe1xuICAgICAgICAgIGZyZXF1ZW5jeTogU0VOU09SX0ZSRVFVRU5DWSxcbiAgICAgICAgICByZWZlcmVuY2VGcmFtZTogJ3NjcmVlbidcbiAgICAgICAgfSk7XG4gICAgICAgIHNlbnNvci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX29uU2Vuc29yRXJyb3IpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnU2VjdXJpdHlFcnJvcicpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgY29uc3RydWN0IHNlbnNvcnMgZHVlIHRvIHRoZSBGZWF0dXJlIFBvbGljeScpO1xuICAgICAgICAgIGNvbnNvbGUud2FybignQXR0ZW1wdGluZyB0byBmYWxsIGJhY2sgdXNpbmcgXCJkZXZpY2Vtb3Rpb25cIjsgaG93ZXZlciB0aGlzIHdpbGwgJyArICdmYWlsIGluIHRoZSBmdXR1cmUgd2l0aG91dCBjb3JyZWN0IHBlcm1pc3Npb25zLicpO1xuICAgICAgICAgIHRoaXMudXNlRGV2aWNlTW90aW9uKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1JlZmVyZW5jZUVycm9yJykge1xuICAgICAgICAgIHRoaXMudXNlRGV2aWNlTW90aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZW5zb3IpIHtcbiAgICAgICAgdGhpcy5hcGkgPSAnc2Vuc29yJztcbiAgICAgICAgdGhpcy5zZW5zb3IgPSBzZW5zb3I7XG4gICAgICAgIHRoaXMuc2Vuc29yLmFkZEV2ZW50TGlzdGVuZXIoJ3JlYWRpbmcnLCB0aGlzLl9vblNlbnNvclJlYWQpO1xuICAgICAgICB0aGlzLnNlbnNvci5zdGFydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VzZURldmljZU1vdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVzZURldmljZU1vdGlvbigpIHtcbiAgICAgIHRoaXMuYXBpID0gJ2RldmljZW1vdGlvbic7XG4gICAgICB0aGlzLmZ1c2lvblNlbnNvciA9IG5ldyBGdXNpb25Qb3NlU2Vuc29yKHRoaXMuY29uZmlnLktfRklMVEVSLCB0aGlzLmNvbmZpZy5QUkVESUNUSU9OX1RJTUVfUywgdGhpcy5jb25maWcuWUFXX09OTFksIHRoaXMuY29uZmlnLkRFQlVHKTtcbiAgICAgIGlmICh0aGlzLnNlbnNvcikge1xuICAgICAgICB0aGlzLnNlbnNvci5yZW1vdmVFdmVudExpc3RlbmVyKCdyZWFkaW5nJywgdGhpcy5fb25TZW5zb3JSZWFkKTtcbiAgICAgICAgdGhpcy5zZW5zb3IucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9vblNlbnNvckVycm9yKTtcbiAgICAgICAgdGhpcy5zZW5zb3IgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldE9yaWVudGF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JpZW50YXRpb24oKSB7XG4gICAgICBpZiAodGhpcy5mdXNpb25TZW5zb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVzaW9uU2Vuc29yLmdldE9yaWVudGF0aW9uKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc2Vuc29yIHx8ICF0aGlzLnNlbnNvci5xdWF0ZXJuaW9uKSB7XG4gICAgICAgIHRoaXMuX291dFswXSA9IHRoaXMuX291dFsxXSA9IHRoaXMuX291dFsyXSA9IDA7XG4gICAgICAgIHRoaXMuX291dFszXSA9IDE7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdXQ7XG4gICAgICB9XG4gICAgICB2YXIgcSA9IHRoaXMuc2Vuc29yLnF1YXRlcm5pb247XG4gICAgICB0aGlzLl9zZW5zb3JRLnNldChxWzBdLCBxWzFdLCBxWzJdLCBxWzNdKTtcbiAgICAgIHZhciBvdXQgPSB0aGlzLl9vdXRRO1xuICAgICAgb3V0LmNvcHkoU0VOU09SX1RPX1ZSKTtcbiAgICAgIG91dC5tdWx0aXBseSh0aGlzLl9zZW5zb3JRKTtcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5ZQVdfT05MWSkge1xuICAgICAgICBvdXQueCA9IG91dC56ID0gMDtcbiAgICAgICAgb3V0Lm5vcm1hbGl6ZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fb3V0WzBdID0gb3V0Lng7XG4gICAgICB0aGlzLl9vdXRbMV0gPSBvdXQueTtcbiAgICAgIHRoaXMuX291dFsyXSA9IG91dC56O1xuICAgICAgdGhpcy5fb3V0WzNdID0gb3V0Lnc7XG4gICAgICByZXR1cm4gdGhpcy5fb3V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19vblNlbnNvckVycm9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uU2Vuc29yRXJyb3IoZXZlbnQpIHtcbiAgICAgIHRoaXMuZXJyb3JzLnB1c2goZXZlbnQuZXJyb3IpO1xuICAgICAgaWYgKGV2ZW50LmVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ1Blcm1pc3Npb24gdG8gYWNjZXNzIHNlbnNvciB3YXMgZGVuaWVkJyk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmVycm9yLm5hbWUgPT09ICdOb3RSZWFkYWJsZUVycm9yJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdTZW5zb3IgY291bGQgbm90IGJlIHJlYWQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXZlbnQuZXJyb3IpO1xuICAgICAgfVxuICAgICAgdGhpcy51c2VEZXZpY2VNb3Rpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfb25TZW5zb3JSZWFkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uU2Vuc29yUmVhZCgpIHt9XG4gIH1dKTtcbiAgcmV0dXJuIFBvc2VTZW5zb3I7XG59KCk7XG52YXIgcm90YXRlSW5zdHJ1Y3Rpb25zQXNzZXQgPSBcIjxzdmcgd2lkdGg9JzE5OCcgaGVpZ2h0PScyNDAnIHZpZXdCb3g9JzAgMCAxOTggMjQwJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnPjxnIGZpbGw9J25vbmUnIGZpbGwtcnVsZT0nZXZlbm9kZCc+PHBhdGggZD0nTTE0OS42MjUgMTA5LjUyN2w2LjczNyAzLjg5MXYuODg2YzAgLjE3Ny4wMTMuMzYuMDM4LjU0OS4wMS4wODEuMDIuMTYyLjAyNy4yNDIuMTQgMS40MTUuOTc0IDIuOTk4IDIuMTA1IDMuOTk5bDUuNzIgNS4wNjIuMDgxLS4wOXM0LjM4Mi0yLjUzIDUuMjM1LTMuMDI0bDI1Ljk3IDE0Ljk5M3Y1NC4wMDFjMCAuNzcxLS4zODYgMS4yMTctLjk0OCAxLjIxNy0uMjMzIDAtLjQ5NS0uMDc2LS43NzItLjIzNmwtMjMuOTY3LTEzLjgzOC0uMDE0LjAyNC0yNy4zMjIgMTUuNzc1LS44NS0xLjMyM2MtNC43MzEtMS41MjktOS43NDgtMi43NC0xNC45NTEtMy42MWEuMjcuMjcgMCAwIDAtLjAwNy4wMjRsLTUuMDY3IDE2Ljk2MS03Ljg5MSA0LjU1Ni0uMDM3LS4wNjN2MjcuNTljMCAuNzcyLS4zODYgMS4yMTctLjk0OCAxLjIxNy0uMjMyIDAtLjQ5NS0uMDc2LS43NzItLjIzNmwtNDIuNDczLTI0LjUyMmMtLjk1LS41NDktMS43Mi0xLjg3Ny0xLjcyLTIuOTY3di0xLjAzNWwtLjAyMS4wNDdhNS4xMTEgNS4xMTEgMCAwIDAtMS44MTYtLjM5OSA1LjY4MiA1LjY4MiAwIDAgMC0uNTQ2LjAwMSAxMy43MjQgMTMuNzI0IDAgMCAxLTEuOTE4LS4wNDFjLTEuNjU1LS4xNTMtMy4yLS42LTQuNDA0LTEuMjk2bC00Ni41NzYtMjYuODkuMDA1LjAxMi0xMC4yNzgtMTguNzVjLTEuMDAxLTEuODI3LS4yNDEtNC4yMTYgMS42OTgtNS4zMzZsNTYuMDExLTMyLjM0NWE0LjE5NCA0LjE5NCAwIDAgMSAyLjA5OS0uNTcyYzEuMzI2IDAgMi41NzIuNjU5IDMuMjI3IDEuODUzbC4wMDUtLjAwMy4yMjcuNDEzLS4wMDYuMDA0YTkuNjMgOS42MyAwIDAgMCAxLjQ3NyAyLjAxOGwuMjc3LjI3YzEuOTE0IDEuODUgNC40NjggMi44MDEgNy4xMTMgMi44MDEgMS45NDkgMCAzLjk0OC0uNTE3IDUuNzc1LTEuNTcyLjAxMyAwIDcuMzE5LTQuMjE5IDcuMzE5LTQuMjE5YTQuMTk0IDQuMTk0IDAgMCAxIDIuMDk5LS41NzJjMS4zMjYgMCAyLjU3Mi42NTggMy4yMjYgMS44NTNsMy4yNSA1LjkyOC4wMjItLjAxOCA2Ljc4NSAzLjkxNy0uMTA1LS4xODIgNDYuODgxLTI2Ljk2NW0wLTEuNjM1Yy0uMjgyIDAtLjU2My4wNzMtLjgxNS4yMThsLTQ2LjE2OSAyNi41NTYtNS40MS0zLjEyNC0zLjAwNS01LjQ4MWMtLjkxMy0xLjY2Ny0yLjY5OS0yLjcwMi00LjY2LTIuNzAzLTEuMDExIDAtMi4wMi4yNzQtMi45MTcuNzkyYTM4MjUgMzgyNSAwIDAgMS03LjI3NSA0LjE5NWwtLjA0NC4wMjRhOS45MzcgOS45MzcgMCAwIDEtNC45NTcgMS4zNTNjLTIuMjkyIDAtNC40MTQtLjgzMi01Ljk3Ni0yLjM0MmwtLjI1Mi0uMjQ1YTcuOTkyIDcuOTkyIDAgMCAxLTEuMTM5LTEuNTM0IDEuMzc5IDEuMzc5IDAgMCAwLS4wNi0uMTIybC0uMjI3LS40MTRhMS43MTggMS43MTggMCAwIDAtLjA5NS0uMTU0Yy0uOTM4LTEuNTc0LTIuNjczLTIuNTQ1LTQuNTcxLTIuNTQ1LTEuMDExIDAtMi4wMi4yNzQtMi45MTcuNzkyTDMuMTI1IDE1NS41MDJjLTIuNjk5IDEuNTU5LTMuNzM4IDQuOTQtMi4zMTQgNy41MzhsMTAuMjc4IDE4Ljc1Yy4xNzcuMzIzLjQ0OC41NjMuNzYxLjcwNGw0Ni40MjYgMjYuODA0YzEuNDAzLjgxIDMuMTU3IDEuMzMyIDUuMDcyIDEuNTA4YTE1LjY2MSAxNS42NjEgMCAwIDAgMi4xNDYuMDQ2IDQuNzY2IDQuNzY2IDAgMCAxIC4zOTYgMGMuMDk2LjAwNC4xOS4wMTEuMjgzLjAyMi4xMDkgMS41OTMgMS4xNTkgMy4zMjMgMi41MjkgNC4xMTRsNDIuNDcyIDI0LjUyMmMuNTI0LjMwMiAxLjA1OC40NTUgMS41OS40NTUgMS40OTcgMCAyLjU4My0xLjIgMi41ODMtMi44NTJ2LTI2LjU2Mmw3LjExMS00LjEwNWExLjY0IDEuNjQgMCAwIDAgLjc0OS0uOTQ4bDQuNjU4LTE1LjU5M2M0LjQxNC43OTcgOC42OTIgMS44NDggMTIuNzQyIDMuMTI4bC41MzMuODI5YTEuNjM0IDEuNjM0IDAgMCAwIDIuMTkzLjUzMWwyNi41MzItMTUuMzE3TDE5MyAxOTIuNDMzYy41MjMuMzAyIDEuMDU4LjQ1NSAxLjU5LjQ1NSAxLjQ5NyAwIDIuNTgzLTEuMTk5IDIuNTgzLTIuODUydi01NC4wMDFjMC0uNTg0LS4zMTItMS4xMjQtLjgxOC0xLjQxNmwtMjUuOTctMTQuOTkzYTEuNjMzIDEuNjMzIDAgMCAwLTEuNjM2LjAwMWMtLjYwNi4zNTEtMi45OTMgMS43My00LjMyNSAyLjQ5OGwtNC44MDktNC4yNTVjLS44MTktLjcyNS0xLjQ2MS0xLjkzMy0xLjU2MS0yLjkzNmE3Ljc3NiA3Ljc3NiAwIDAgMC0uMDMzLS4yOTQgMi40ODcgMi40ODcgMCAwIDEtLjAyMy0uMzM2di0uODg2YzAtLjU4NC0uMzEyLTEuMTIzLS44MTctMS40MTZsLTYuNzM5LTMuODkxYTEuNjMzIDEuNjMzIDAgMCAwLS44MTctLjIxOScgZmlsbD0nIzQ1NUE2NCcvPjxwYXRoIGQ9J005Ni4wMjcgMTMyLjYzNmw0Ni41NzYgMjYuODkxYzEuMjA0LjY5NSAxLjk3OSAxLjU4NyAyLjI0MiAyLjU0MWwtLjAxLjAwNy04MS4zNzQgNDYuOTgyaC0uMDAxYy0xLjY1NC0uMTUyLTMuMTk5LS42LTQuNDAzLTEuMjk1bC00Ni41NzYtMjYuODkxIDgzLjU0Ni00OC4yMzUnIGZpbGw9JyNGQUZBRkEnLz48cGF0aCBkPSdNNjMuNDYxIDIwOS4xNzRjLS4wMDggMC0uMDE1IDAtLjAyMi0uMDAyLTEuNjkzLS4xNTYtMy4yMjgtLjYwOS00LjQ0MS0xLjMwOWwtNDYuNTc2LTI2Ljg5YS4xMTguMTE4IDAgMCAxIDAtLjIwM2w4My41NDYtNDguMjM1YS4xMTcuMTE3IDAgMCAxIC4xMTcgMGw0Ni41NzYgMjYuODkxYzEuMjI3LjcwOCAyLjAyMSAxLjYxMiAyLjI5NiAyLjYxMWEuMTE2LjExNiAwIDAgMS0uMDQyLjEyNGwtLjAyMS4wMTYtODEuMzc1IDQ2Ljk4MWEuMTEuMTEgMCAwIDEtLjA1OC4wMTZ6bS01MC43NDctMjguMzAzbDQ2LjQwMSAyNi43OWMxLjE3OC42OCAyLjY3MSAxLjEyMSA0LjMyIDEuMjc2bDgxLjI3Mi00Ni45MjJjLS4yNzktLjkwNy0xLjAyNS0xLjczLTIuMTYzLTIuMzg3bC00Ni41MTctMjYuODU3LTgzLjMxMyA0OC4xeicgZmlsbD0nIzYwN0Q4QicvPjxwYXRoIGQ9J00xNDguMzI3IDE2NS40NzFhNS44NSA1Ljg1IDAgMCAxLS41NDYuMDAxYy0xLjg5NC0uMDgzLTMuMzAyLTEuMDM4LTMuMTQ1LTIuMTMyYTIuNjkzIDIuNjkzIDAgMCAwLS4wNzItMS4xMDVsLTgxLjEwMyA0Ni44MjJjLjYyOC4wNTggMS4yNzIuMDczIDEuOTE4LjA0Mi4xODItLjAwOS4zNjQtLjAwOS41NDYtLjAwMSAxLjg5NC4wODMgMy4zMDIgMS4wMzggMy4xNDUgMi4xMzJsNzkuMjU3LTQ1Ljc1OScgZmlsbD0nI0ZGRicvPjxwYXRoIGQ9J002OS4wNyAyMTEuMzQ3YS4xMTguMTE4IDAgMCAxLS4xMTUtLjEzNGMuMDQ1LS4zMTctLjA1Ny0uNjM3LS4yOTctLjkyNS0uNTA1LS42MS0xLjU1NS0xLjAyMi0yLjczOC0xLjA3NGE1Ljk2NiA1Ljk2NiAwIDAgMC0uNTM1LjAwMSAxNC4wMyAxNC4wMyAwIDAgMS0xLjkzNS0uMDQxLjExNy4xMTcgMCAwIDEtLjEwMy0uMDkyLjExNi4xMTYgMCAwIDEgLjA1NS0uMTI2bDgxLjEwNC00Ni44MjJhLjExNy4xMTcgMCAwIDEgLjE3MS4wN2MuMTA0LjM4MS4xMjkuNzY4LjA3NCAxLjE1My0uMDQ1LjMxNi4wNTcuNjM3LjI5Ni45MjUuNTA2LjYxIDEuNTU1IDEuMDIxIDIuNzM5IDEuMDczLjE3OC4wMDguMzU3LjAwOC41MzUtLjAwMWEuMTE3LjExNyAwIDAgMSAuMDY0LjIxOGwtNzkuMjU2IDQ1Ljc1OWEuMTE0LjExNCAwIDAgMS0uMDU5LjAxNnptLTMuNDA1LTIuMzcyYy4wODkgMCAuMTc3LjAwMi4yNjUuMDA2IDEuMjY2LjA1NiAyLjM1My40ODggMi45MDggMS4xNTguMjI3LjI3NC4zNS41NzUuMzYuODgybDc4LjY4NS00NS40MjljLS4wMzYgMC0uMDcyLS4wMDEtLjEwNy0uMDAzLTEuMjY3LS4wNTYtMi4zNTQtLjQ4OS0yLjkwOS0xLjE1OC0uMjgyLS4zNC0uNDAyLS43MjQtLjM0Ny0xLjEwN2EyLjYwNCAyLjYwNCAwIDAgMC0uMDMyLS45MUw2My44NDYgMjA4Ljk3YTEzLjkxIDEzLjkxIDAgMCAwIDEuNTI4LjAxMmMuMDk3LS4wMDUuMTk0LS4wMDcuMjkxLS4wMDd6JyBmaWxsPScjNjA3RDhCJy8+PHBhdGggZD0nTTIuMjA4IDE2Mi4xMzRjLTEuMDAxLTEuODI3LS4yNDEtNC4yMTcgMS42OTgtNS4zMzdsNTYuMDExLTMyLjM0NGMxLjkzOS0xLjEyIDQuMzI0LS41NDYgNS4zMjYgMS4yODFsLjIzMi40MWE5LjM0NCA5LjM0NCAwIDAgMCAxLjQ3IDIuMDIxbC4yNzguMjdjMy4zMjUgMy4yMTQgOC41ODMgMy43MTYgMTIuODg4IDEuMjNsNy4zMTktNC4yMmMxLjk0LTEuMTE5IDQuMzI0LS41NDYgNS4zMjUgMS4yODJsMy4yNSA1LjkyOC04My41MTkgNDguMjI5LTEwLjI3OC0xOC43NXonIGZpbGw9JyNGQUZBRkEnLz48cGF0aCBkPSdNMTIuNDg2IDE4MS4wMDFhLjExMi4xMTIgMCAwIDEtLjAzMS0uMDA1LjExNC4xMTQgMCAwIDEtLjA3MS0uMDU2TDIuMTA2IDE2Mi4xOWMtMS4wMzEtMS44OC0uMjQ5LTQuMzQ1IDEuNzQyLTUuNDk0bDU2LjAxLTMyLjM0NGE0LjMyOCA0LjMyOCAwIDAgMSAyLjE1OC0uNTg4YzEuNDE1IDAgMi42NS43MDIgMy4zMTEgMS44ODIuMDEuMDA4LjAxOC4wMTcuMDI0LjAyOGwuMjI3LjQxNGEuMTIyLjEyMiAwIDAgMSAuMDEzLjAzOCA5LjUwOCA5LjUwOCAwIDAgMCAxLjQzOSAxLjk1OWwuMjc1LjI2NmMxLjg0NiAxLjc4NiA0LjM0NCAyLjc2OSA3LjAzMSAyLjc2OSAxLjk3NyAwIDMuOTU0LS41MzggNS43MTctMS41NTdhLjE0OC4xNDggMCAwIDEgLjAzNS0uMDEzbDcuMjg0LTQuMjA2YTQuMzIxIDQuMzIxIDAgMCAxIDIuMTU3LS41ODhjMS40MjcgMCAyLjY3Mi43MTYgMy4zMjkgMS45MTRsMy4yNDkgNS45MjlhLjExNi4xMTYgMCAwIDEtLjA0NC4xNTdsLTgzLjUxOCA0OC4yMjlhLjExNi4xMTYgMCAwIDEtLjA1OS4wMTZ6bTQ5LjUzLTU3LjAwNGMtLjcwNCAwLTEuNDEuMTkzLTIuMDQxLjU1N2wtNTYuMDEgMzIuMzQ1Yy0xLjg4MiAxLjA4Ni0yLjYyNCAzLjQwOS0xLjY1NSA1LjE3OWwxMC4yMjEgMTguNjQ1IDgzLjMxNy00OC4xMTItMy4xOTUtNS44MjljLS42MTUtMS4xMjItMS43ODMtMS43OTItMy4xMjQtMS43OTJhNC4wOCA0LjA4IDAgMCAwLTIuMDQuNTU3bC03LjMxNyA0LjIyNWEuMTQ4LjE0OCAwIDAgMS0uMDM1LjAxMyAxMS43IDExLjcgMCAwIDEtNS44MDEgMS41NjljLTIuNzQ4IDAtNS4zMDMtMS4wMDctNy4xOTQtMi44MzVsLS4yNzgtLjI3YTkuNzE2IDkuNzE2IDAgMCAxLTEuNDk3LTIuMDQ2LjA5Ni4wOTYgMCAwIDEtLjAxMy0uMDM3bC0uMTkxLS4zNDdhLjExLjExIDAgMCAxLS4wMjMtLjAyOWMtLjYxNS0xLjEyMy0xLjc4My0xLjc5My0zLjEyNC0xLjc5M3onIGZpbGw9JyM2MDdEOEInLz48cGF0aCBkPSdNNDIuNDM0IDE1NS44MDhjLTIuNTEtLjAwMS00LjY5Ny0xLjI1OC01Ljg1Mi0zLjM2NS0xLjgxMS0zLjMwNC0uNDM4LTcuNjM0IDMuMDU5LTkuNjU0bDEyLjI5MS03LjA5OGE3LjU5OSA3LjU5OSAwIDAgMSAzLjc4OS0xLjAzM2MyLjUxIDAgNC42OTcgMS4yNTggNS44NTIgMy4zNjUgMS44MTEgMy4zMDQuNDM5IDcuNjM0LTMuMDU5IDkuNjU0bC0xMi4yOTEgNy4wOThhNy42MDYgNy42MDYgMCAwIDEtMy43ODkgMS4wMzN6bTEzLjI4Ny0yMC42ODNhNy4xMjggNy4xMjggMCAwIDAtMy41NTUuOTcxbC0xMi4yOTEgNy4wOThjLTMuMjc5IDEuODkzLTQuNTczIDUuOTQyLTIuODgzIDkuMDI0IDEuMDcxIDEuOTU1IDMuMTA2IDMuMTIyIDUuNDQyIDMuMTIyYTcuMTMgNy4xMyAwIDAgMCAzLjU1Ni0uOTdsMTIuMjkxLTcuMDk4YzMuMjc5LTEuODkzIDQuNTcyLTUuOTQyIDIuODgzLTkuMDI0LTEuMDcyLTEuOTU1LTMuMTA2LTMuMTIzLTUuNDQzLTMuMTIzeicgZmlsbD0nIzYwN0Q4QicvPjxwYXRoIGQ9J00xNDkuNTg4IDEwOS40MDdsNi43MzcgMy44OXYuODg3YzAgLjE3Ni4wMTMuMzYuMDM3LjU0OS4wMTEuMDgxLjAyLjE2MS4wMjguMjQyLjE0IDEuNDE1Ljk3MyAyLjk5OCAyLjEwNSAzLjk5OWw3LjM5NiA2LjU0NWMuMTc3LjE1Ni4zNTguMjk1LjU0MS40MTUgMS41NzkgMS4wNCAyLjk1LjQ2NiAzLjA2Mi0xLjI4Mi4wNDktLjc4NC4wNTctMS41OTUuMDIzLTIuNDI5bC0uMDAzLS4xNnYtMS4xNTFsMjUuOTg3IDE1LjAwM3Y1NGMwIDEuMDktLjc3IDEuNTMtMS43Mi45ODJsLTQyLjQ3My0yNC41MjNjLS45NS0uNTQ4LTEuNzItMS44NzctMS43Mi0yLjk2NnYtMzQuMDMzJyBmaWxsPScjRkFGQUZBJy8+PHBhdGggZD0nTTE5NC41NTMgMTkxLjI1Yy0uMjU3IDAtLjU0LS4wODUtLjgzMS0uMjUzbC00Mi40NzItMjQuNTIxYy0uOTgxLS41NjctMS43NzktMS45NDMtMS43NzktMy4wNjh2LTM0LjAzM2guMjM0djM0LjAzM2MwIDEuMDUxLjc0NSAyLjMzNiAxLjY2MSAyLjg2Nmw0Mi40NzMgMjQuNTIxYy40MjQuMjQ1LjgxNi4yODggMS4xMDMuMTIyLjI4NS0uMTY0LjQ0Mi0uNTIuNDQyLTEuMDAydi01My45MzNsLTI1Ljc1My0xNC44NjguMDAzIDEuMTA2Yy4wMzQuODMyLjAyNiAxLjY1NC0uMDI0IDIuNDM5LS4wNTQuODQ0LS4zOTYgMS40NjQtLjk2MyAxLjc0Ni0uNjE5LjMwOS0xLjQ1LjE3My0yLjI4LS4zNzNhNS4wMjMgNS4wMjMgMCAwIDEtLjU1My0uNDI2bC03LjM5Ny02LjU0NGMtMS4xNTgtMS4wMjYtMS45OTktMi42MjUtMi4xNDMtNC4wNzZhOS42MjQgOS42MjQgMCAwIDAtLjAyNy0uMjM4IDQuMjQxIDQuMjQxIDAgMCAxLS4wMzgtLjU2NHYtLjgybC02LjY4LTMuODU2LjExNy0uMjAyIDYuNzM4IDMuODkuMDU4LjAzNHYuOTU0YzAgLjE3MS4wMTIuMzUxLjAzNi41MzMuMDExLjA4My4wMjEuMTY1LjAyOS4yNDYuMTM4IDEuMzk1Ljk0OCAyLjkzNSAyLjA2NSAzLjkyM2w3LjM5NyA2LjU0NWMuMTczLjE1My4zNS4yODkuNTI3LjQwNi43NTguNDk5IDEuNTA0LjYzIDIuMDQ3LjM1OS40OS0uMjQzLjc4Ni0uNzk1LjgzNC0xLjU1MS4wNS0uNzc4LjA1Ny0xLjU5MS4wMjQtMi40MTdsLS4wMDQtLjE2M3YtMS4zNTVsLjE3NS4xIDI1Ljk4NyAxNS4wMDQuMDU5LjAzM3Y1NC4wNjhjMCAuNTY5LS4xOTguOTk2LS41NTkgMS4yMDRhMS4wMDIgMS4wMDIgMCAwIDEtLjUwNi4xMzEnIGZpbGw9JyM2MDdEOEInLz48cGF0aCBkPSdNMTQ1LjY4NSAxNjMuMTYxbDI0LjExNSAxMy45MjItMjUuOTc4IDE0Ljk5OC0xLjQ2Mi0uMzA3Yy02LjUzNC0yLjE3LTEzLjYyOC0zLjcyOC0yMS4wMTktNC42MTYtNC4zNjUtLjUyNC04LjY2MyAxLjA5Ni05LjU5OCAzLjYyYTIuNzQ2IDIuNzQ2IDAgMCAwLS4wMTEgMS45MjhjMS41MzggNC4yNjcgNC4yMzYgOC4zNjMgNy45OTUgMTIuMTM1bC41MzIuODQ1LTI1Ljk3NyAxNC45OTctMjQuMTE1LTEzLjkyMiA3NS41MTgtNDMuNicgZmlsbD0nI0ZGRicvPjxwYXRoIGQ9J005NC4yODIgMjIwLjgxOGwtLjA1OS0uMDMzLTI0LjI5LTE0LjAyNC4xNzUtLjEwMSA3NS41NzctNDMuNjM0LjA1OC4wMzMgMjQuMjkgMTQuMDI0LTI2LjE5MSAxNS4xMjItLjA0NS0uMDEtMS40NjEtLjMwN2MtNi41NDktMi4xNzQtMTMuNjEzLTMuNzI1LTIxLjAwOS00LjYxNGExMy43NDQgMTMuNzQ0IDAgMCAwLTEuNjM4LS4wOTdjLTMuNzU4IDAtNy4wNTQgMS41MzEtNy44MzcgMy42NDJhMi42MiAyLjYyIDAgMCAwLS4wMSAxLjg0OGMxLjUzNSA0LjI1OCA0LjIxNiA4LjMyNiA3Ljk2OCAxMi4wOTFsLjAxNi4wMjEuNTI2LjgzNS4wMDYuMDEuMDY0LjEwMi0uMTA1LjA2MS0yNS45NzcgMTQuOTk4LS4wNTguMDMzem0tMjMuODgxLTE0LjA1N2wyMy44ODEgMTMuNzg4IDI0LjgwMi0xNC4zMmMuNTQ2LS4zMTUuODQ2LS40ODkgMS4wMTctLjU3NWwtLjQ2Ni0uNzRjLTMuNzcxLTMuNzg3LTYuNDY3LTcuODgxLTguMDEzLTEyLjE2OGEyLjg1MSAyLjg1MSAwIDAgMSAuMDExLTIuMDA4Yy44MTUtMi4xOTkgNC4yMDMtMy43OTUgOC4wNTYtMy43OTUuNTU3IDAgMS4xMTcuMDMzIDEuNjY2LjA5OSA3LjQxMi44OTEgMTQuNDkxIDIuNDQ1IDIxLjA0MSA0LjYyMS44MzYuMTc1IDEuMjE1LjI1NCAxLjM5LjMwNGwyNS43OC0xNC44ODQtMjMuODgxLTEzLjc4OC03NS4yODQgNDMuNDY2eicgZmlsbD0nIzYwN0Q4QicvPjxwYXRoIGQ9J00xNjcuMjMgMTI1Ljk3OXY1MC44NzFsLTI3LjMyMSAxNS43NzMtNi40NjEtMTQuMTY3Yy0uOTEtMS45OTYtMy40MjgtMS43MzgtNS42MjQuNTc0YTEwLjIzOCAxMC4yMzggMCAwIDAtMi4zMyA0LjAxOGwtNi40NiAyMS42MjgtMjcuMzIyIDE1Ljc3NHYtNTAuODcxbDc1LjUxOC00My42JyBmaWxsPScjRkZGJy8+PHBhdGggZD0nTTkxLjcxMiAyMjAuNTY3YS4xMjcuMTI3IDAgMCAxLS4wNTktLjAxNi4xMTguMTE4IDAgMCAxLS4wNTgtLjEwMXYtNTAuODcxYzAtLjA0Mi4wMjMtLjA4LjA1OC0uMTAxbDc1LjUxOS00My42YS4xMTcuMTE3IDAgMCAxIC4xNzUuMTAxdjUwLjg3MWMwIC4wNDEtLjAyMy4wOC0uMDU5LjFsLTI3LjMyMSAxNS43NzVhLjExOC4xMTggMCAwIDEtLjA5NC4wMS4xMi4xMiAwIDAgMS0uMDcxLS4wNjNsLTYuNDYtMTQuMTY4Yy0uMzc1LS44MjItMS4wNjItMS4yNzUtMS45MzQtMS4yNzUtMS4wODkgMC0yLjM2NC42ODYtMy41IDEuODgxYTEwLjIwNiAxMC4yMDYgMCAwIDAtMi4zMDIgMy45NzJsLTYuNDYgMjEuNjI3YS4xMTguMTE4IDAgMCAxLS4wNTQuMDY4TDkxLjc3IDIyMC41NTFhLjEyLjEyIDAgMCAxLS4wNTguMDE2em0uMTE3LTUwLjkydjUwLjYwMWwyNy4xMDYtMTUuNjUgNi40NDctMjEuNTgzYTEwLjI4NiAxMC4yODYgMCAwIDEgMi4zNTctNC4wNjVjMS4xOC0xLjI0MiAyLjUxNy0xLjk1NCAzLjY2OS0xLjk1NC45NjkgMCAxLjczMS41MDEgMi4xNDYgMS40MTFsNi40MDcgMTQuMDUxIDI3LjE1Mi0xNS42NzZ2LTUwLjYwMWwtNzUuMjg0IDQzLjQ2NnonIGZpbGw9JyM2MDdEOEInLz48cGF0aCBkPSdNMTY4LjU0MyAxMjYuMjEzdjUwLjg3bC0yNy4zMjIgMTUuNzc0LTYuNDYtMTQuMTY4Yy0uOTEtMS45OTUtMy40MjgtMS43MzgtNS42MjQuNTc0YTEwLjI0OCAxMC4yNDggMCAwIDAtMi4zMyA0LjAxOWwtNi40NjEgMjEuNjI3LTI3LjMyMSAxNS43NzR2LTUwLjg3bDc1LjUxOC00My42JyBmaWxsPScjRkZGJy8+PHBhdGggZD0nTTkzLjAyNSAyMjAuOGEuMTIzLjEyMyAwIDAgMS0uMDU5LS4wMTUuMTIuMTIgMCAwIDEtLjA1OC0uMTAxdi01MC44NzFjMC0uMDQyLjAyMy0uMDguMDU4LS4xMDFsNzUuNTE4LTQzLjZhLjExMi4xMTIgMCAwIDEgLjExNyAwYy4wMzYuMDIuMDU5LjA1OS4wNTkuMXY1MC44NzFhLjExNi4xMTYgMCAwIDEtLjA1OS4xMDFsLTI3LjMyMSAxNS43NzRhLjExMS4xMTEgMCAwIDEtLjA5NC4wMS4xMTUuMTE1IDAgMCAxLS4wNzEtLjA2MmwtNi40Ni0xNC4xNjhjLS4zNzUtLjgyMy0xLjA2Mi0xLjI3NS0xLjkzNS0xLjI3NS0xLjA4OCAwLTIuMzYzLjY4NS0zLjQ5OSAxLjg4MWExMC4xOSAxMC4xOSAwIDAgMC0yLjMwMiAzLjk3MWwtNi40NjEgMjEuNjI4YS4xMDguMTA4IDAgMCAxLS4wNTMuMDY3bC0yNy4zMjIgMTUuNzc1YS4xMi4xMiAwIDAgMS0uMDU4LjAxNXptLjExNy01MC45MTl2NTAuNmwyNy4xMDYtMTUuNjQ5IDYuNDQ3LTIxLjU4NGExMC4yOTMgMTAuMjkzIDAgMCAxIDIuMzU3LTQuMDY1YzEuMTc5LTEuMjQxIDIuNTE2LTEuOTU0IDMuNjY4LTEuOTU0Ljk2OSAwIDEuNzMyLjUwMiAyLjE0NyAxLjQxMmw2LjQwNyAxNC4wNTEgMjcuMTUyLTE1LjY3NnYtNTAuNjAxbC03NS4yODQgNDMuNDY2eicgZmlsbD0nIzYwN0Q4QicvPjxwYXRoIGQ9J00xNjkuOCAxNzcuMDgzbC0yNy4zMjIgMTUuNzc0LTYuNDYtMTQuMTY4Yy0uOTEtMS45OTUtMy40MjgtMS43MzgtNS42MjUuNTc0YTEwLjI0NiAxMC4yNDYgMCAwIDAtMi4zMjkgNC4wMTlsLTYuNDYxIDIxLjYyNy0yNy4zMjEgMTUuNzc0di01MC44N2w3NS41MTgtNDMuNnY1MC44N3onIGZpbGw9JyNGQUZBRkEnLz48cGF0aCBkPSdNOTQuMjgyIDIyMC45MTdhLjIzNC4yMzQgMCAwIDEtLjIzNC0uMjMzdi01MC44NzFjMC0uMDgzLjA0NS0uMTYxLjExNy0uMjAybDc1LjUxOC00My42MDFhLjIzNC4yMzQgMCAxIDEgLjM1LjIwMnY1MC44NzFhLjIzMy4yMzMgMCAwIDEtLjExNi4yMDJsLTI3LjMyMiAxNS43NzVhLjIzMi4yMzIgMCAwIDEtLjMyOS0uMTA2bC02LjQ2MS0xNC4xNjhjLS4zNi0uNzg5LS45OTItMS4yMDYtMS44MjgtMS4yMDYtMS4wNTYgMC0yLjMwMS42NzItMy40MTUgMS44NDRhMTAuMDk5IDEwLjA5OSAwIDAgMC0yLjI3NSAzLjkyNGwtNi40NiAyMS42MjhhLjIzNS4yMzUgMCAwIDEtLjEwNy4xMzZsLTI3LjMyMiAxNS43NzRhLjIzLjIzIDAgMCAxLS4xMTYuMDMxem0uMjMzLTUwLjk2OXY1MC4zMzFsMjYuODkxLTE1LjUyNSA2LjQzNC0yMS41MzlhMTAuNDEgMTAuNDEgMCAwIDEgMi4zODQtNC4xMTJjMS4yMDEtMS4yNjUgMi41NjktMS45OTEgMy43NTMtMS45OTEgMS4wMTggMCAxLjgxOC41MjYgMi4yNTMgMS40OGw2LjM1NCAxMy45MzQgMjYuOTgyLTE1LjU3OHYtNTAuMzMxbC03NS4wNTEgNDMuMzMxeicgZmlsbD0nIzYwN0Q4QicvPjxwYXRoIGQ9J00xMDkuODk0IDE5OS45NDNjLTEuNzc0IDAtMy4yNDEtLjcyNS00LjI0NC0yLjEyYS4yMjQuMjI0IDAgMCAxIC4wMjMtLjI5NC4yMzMuMjMzIDAgMCAxIC4zMDEtLjAyM2MuNzguNTQ3IDEuNzA1LjgyNyAyLjc1LjgyNyAxLjMyMyAwIDIuNzU0LS40MzkgNC4yNTYtMS4zMDYgNS4zMTEtMy4wNjcgOS42MzEtMTAuNTE4IDkuNjMxLTE2LjYxMSAwLTEuOTI3LS40NDItMy41Ni0xLjI3OC00LjcyNGEuMjMyLjIzMiAwIDAgMSAuMzIzLS4zMjdjMS42NzEgMS4xNzIgMi41OTEgMy4zODEgMi41OTEgNi4yMTkgMCA2LjI0Mi00LjQyNiAxMy44NjMtOS44NjUgMTcuMDAzLTEuNTc0LjkwOC0zLjA4NCAxLjM1Ni00LjQ4OCAxLjM1NnptLTIuOTY5LTEuNTQyYy44MTMuNjUxIDEuODIuODc3IDIuOTY4Ljg3N2guMDAxYzEuMzIxIDAgMi43NTMtLjMyNyA0LjI1NC0xLjE5NCA1LjMxMS0zLjA2NyA5LjYzMi0xMC40NjMgOS42MzItMTYuNTU2IDAtMS45NzktLjQ2My0zLjU5OS0xLjMyNi00Ljc2MS40MTEgMS4wMzUuNjI1IDIuMjc1LjYyNSAzLjYzNSAwIDYuMjQzLTQuNDI2IDEzLjg4My05Ljg2NSAxNy4wMjMtMS41NzQuOTA5LTMuMDg0IDEuMzE3LTQuNDkgMS4zMTctLjY0MSAwLTEuMjQzLS4xNDktMS43OTktLjM0MXonIGZpbGw9JyM2MDdEOEInLz48cGF0aCBkPSdNMTEzLjA5NyAxOTcuMjNjNS4zODQtMy4xMDggOS43NDgtMTAuNjM2IDkuNzQ4LTE2LjgxNCAwLTIuMDUxLS40ODMtMy42OTItMS4zMjMtNC44Ni0xLjc4NC0xLjI1Mi00LjM3NC0xLjE5NC03LjI1Ny40Ny01LjM4NCAzLjEwOC05Ljc0OCAxMC42MzYtOS43NDggMTYuODE0IDAgMi4wNTEuNDgzIDMuNjkyIDEuMzIzIDQuODYgMS43ODQgMS4yNTIgNC4zNzQgMS4xOTQgNy4yNTctLjQ3JyBmaWxsPScjRkFGQUZBJy8+PHBhdGggZD0nTTEwOC43MjQgMTk4LjYxNGMtMS4xNDIgMC0yLjE1OC0uMjEzLTMuMDE5LS44MTctLjAyMS0uMDE0LS4wNC4wMTQtLjA1NS0uMDA3LS44OTQtMS4yNDQtMS4zNjctMi45NDgtMS4zNjctNC45NzMgMC02LjI0MiA0LjQyNi0xMy44NjQgOS44NjUtMTcuMDA1IDEuNTc0LS45MDggMy4wODQtMS4zNjMgNC40OS0xLjM2MyAxLjE0MiAwIDIuMTU4LjMwOSAzLjAxOC45MTNhLjIzLjIzIDAgMCAxIC4wNTYuMDU2Yy44OTQgMS4yNDQgMS4zNjcgMi45NzIgMS4zNjcgNC45OTcgMCA2LjI0My00LjQyNiAxMy43ODMtOS44NjUgMTYuOTIzLTEuNTc0LjkwOS0zLjA4NCAxLjI3Ni00LjQ5IDEuMjc2em0tMi43MTgtMS4xMDljLjc3NC41MzIgMS42ODguNzc2IDIuNzE4Ljc3NiAxLjMyMyAwIDIuNzU0LS40MTMgNC4yNTYtMS4yOCA1LjMxMS0zLjA2NiA5LjYzMS0xMC41MDUgOS42MzEtMTYuNTk4IDAtMS45MDktLjQzNC0zLjUyMy0xLjI1NS00LjY4NS0uNzc0LS41MzMtMS42ODgtLjc5OS0yLjcxOC0uNzk5LTEuMzIzIDAtMi43NTUuNDQxLTQuMjU2IDEuMzA4LTUuMzExIDMuMDY2LTkuNjMxIDEwLjUwNi05LjYzMSAxNi41OTkgMCAxLjkwOS40MzQgMy41MTcgMS4yNTUgNC42Nzl6JyBmaWxsPScjNjA3RDhCJy8+PHBhdGggZD0nTTE0OS4zMTggMTE0LjI2MmwtOS45ODQgOC44NzggMTUuODkzIDExLjAzMSA1LjU4OS02LjExMi0xMS40OTgtMTMuNzk3JyBmaWxsPScjRkFGQUZBJy8+PHBhdGggZD0nTTE2OS42NzYgMTIwLjg0bC05Ljc0OCA1LjYyN2MtMy42NDIgMi4xMDMtOS41MjggMi4xMTMtMTMuMTQ3LjAyNC0zLjYyLTIuMDg5LTMuNjAxLTUuNDg4LjA0MS03LjU5MWw5LjQ5NS01LjYwOC02LjcyOS0zLjg4NS04MS44MzYgNDcuMDcxIDQ1LjkyMyAyNi41MTQgMy4wODEtMS43NzljLjYzMS0uMzY1Ljg2OS0uODk4LjYxOC0xLjM5LTIuMzU3LTQuNjMyLTIuNTkzLTkuNTQ2LS42ODMtMTQuMjYyIDUuNjM4LTEzLjkyIDI0LjUwOS0yNC44MTUgNDguNjE4LTI4LjA3IDguMTY5LTEuMTAzIDE2LjY4LS45NjcgMjQuNzA0LjM5NC44NTIuMTQ1IDEuNzc2LjAwOCAyLjQwNy0uMzU3bDMuMDgxLTEuNzc4LTI1LjgyNS0xNC45MScgZmlsbD0nI0ZBRkFGQScvPjxwYXRoIGQ9J00xMTMuNjc1IDE4My40NTlhLjQ3LjQ3IDAgMCAxLS4yMzMtLjA2MmwtNDUuOTI0LTI2LjUxNWEuNDY4LjQ2OCAwIDAgMSAuMDAxLS44MDlsODEuODM2LTQ3LjA3MWEuNDY3LjQ2NyAwIDAgMSAuNDY2IDBsNi43MjkgMy44ODVhLjQ2Ny40NjcgMCAwIDEtLjQ2Ny44MDlsLTYuNDk2LTMuNzUtODAuOSA0Ni41MzMgNDQuOTg4IDI1Ljk3MyAyLjg0OC0xLjY0NGMuMTkyLS4xMTEuNjItLjQwOS40MzUtLjc3My0yLjQxNi00Ljc0OC0yLjY1OC05LjgxNC0uNy0xNC42NSAyLjgwNi02LjkyNyA4Ljg4NS0xMy4yNDIgMTcuNTgyLTE4LjI2MyA4LjY1Ny00Ljk5OCAxOS41MTgtOC40ODkgMzEuNDA3LTEwLjA5NCA4LjE5OC0xLjEwNyAxNi43OS0uOTcgMjQuODQ0LjM5Ny43MzkuMTI1IDEuNTYxLjAwNyAyLjA5NS0uMzAxbDIuMzgxLTEuMzc0LTI1LjEyNS0xNC41MDZhLjQ2Ny40NjcgMCAwIDEgLjQ2Ny0uODA5bDI1LjgyNSAxNC45MWEuNDY3LjQ2NyAwIDAgMSAwIC44MDlsLTMuMDgxIDEuNzc5Yy0uNzIxLjQxNy0xLjc2My41NzUtMi43MTguNDEzLTcuOTYzLTEuMzUxLTE2LjQ1Ny0xLjQ4Ni0yNC41NjMtLjM5Mi0xMS43NyAxLjU4OS0yMi41MTIgNS4wMzktMzEuMDY1IDkuOTc3LTguNTE0IDQuOTE2LTE0LjQ1NiAxMS4wNzMtMTcuMTgzIDE3LjgwNS0xLjg1NCA0LjU3OC0xLjYyMyA5LjM3Ni42NjYgMTMuODc1LjM3LjcyNS4wNTUgMS41MTMtLjggMi4wMDZsLTMuMDgxIDEuNzhhLjQ3Ni40NzYgMCAwIDEtLjIzNC4wNjInIGZpbGw9JyM0NTVBNjQnLz48cGF0aCBkPSdNMTUzLjMxNiAxMjguMjc5Yy0yLjQxMyAwLTQuODIxLS41MjgtNi42NTItMS41ODYtMS44MTgtMS4wNDktMi44Mi0yLjQ2MS0yLjgyLTMuOTc1IDAtMS41MjcgMS4wMTYtMi45NTUgMi44NjEtNC4wMmw5LjQ5My01LjYwN2EuMjMzLjIzMyAwIDEgMSAuMjM4LjQwMmwtOS40OTYgNS42MDljLTEuNjk2Ljk3OS0yLjYyOCAyLjI2My0yLjYyOCAzLjYxNiAwIDEuMzQuOTE4IDIuNjA4IDIuNTg1IDMuNTcxIDMuNTQ5IDIuMDQ5IDkuMzQzIDIuMDM4IDEyLjkxNC0uMDI0bDkuNzQ4LTUuNjI4YS4yMzQuMjM0IDAgMCAxIC4yMzQuNDA1bC05Ljc0OCA1LjYyOGMtMS44NTggMS4wNzItNC4yOTYgMS42MDktNi43MjkgMS42MDknIGZpbGw9JyM2MDdEOEInLz48cGF0aCBkPSdNMTEzLjY3NSAxODIuOTkybC00NS45MTMtMjYuNTA4TTExMy42NzUgMTgzLjM0MmEuMzQ2LjM0NiAwIDAgMS0uMTc1LS4wNDdsLTQ1LjkxMy0yNi41MDhhLjM1LjM1IDAgMSAxIC4zNS0uNjA3bDQ1LjkxMyAyNi41MDhhLjM1LjM1IDAgMCAxLS4xNzUuNjU0JyBmaWxsPScjNDU1QTY0Jy8+PHBhdGggZD0nTTY3Ljc2MiAxNTYuNDg0djU0LjAwMWMwIDEuMDkuNzcgMi40MTggMS43MiAyLjk2N2w0Mi40NzMgMjQuNTIxYy45NS41NDkgMS43Mi4xMSAxLjcyLS45OHYtNTQuMDAxJyBmaWxsPScjRkFGQUZBJy8+PHBhdGggZD0nTTExMi43MjcgMjM4LjU2MWMtLjI5NyAwLS42Mi0uMDk1LS45NDctLjI4NWwtNDIuNDczLTI0LjUyMWMtMS4wNjMtLjYxMy0xLjg5NS0yLjA1LTEuODk1LTMuMjd2LTU0LjAwMWEuMzUuMzUgMCAxIDEgLjcwMSAwdjU0LjAwMWMwIC45Ni43MDcgMi4xOCAxLjU0NCAyLjY2M2w0Mi40NzMgMjQuNTIyYy4zNDQuMTk4LjY2MS4yNDMuODcuMTIyLjIwNi0uMTE5LjMyNS0uNDExLjMyNS0uNzk5di01NC4wMDFhLjM1LjM1IDAgMSAxIC43IDB2NTQuMDAxYzAgLjY1NS0uMjM5IDEuMTU0LS42NzUgMS40MDZhMS4yMzUgMS4yMzUgMCAwIDEtLjYyMy4xNjInIGZpbGw9JyM0NTVBNjQnLz48cGF0aCBkPSdNMTEyLjg2IDE0Ny41MTJoLS4wMDFjLTIuMzE4IDAtNC40OTktLjUyMi02LjE0Mi0xLjQ3MS0xLjcwNS0uOTg0LTIuNjQzLTIuMzE1LTIuNjQzLTMuNzQ5IDAtMS40NDUuOTUyLTIuNzkxIDIuNjgtMy43ODhsMTIuMDQxLTYuOTUzYzEuNjY4LS45NjIgMy44NzQtMS40OTMgNi4yMTItMS40OTMgMi4zMTggMCA0LjQ5OS41MjMgNi4xNDMgMS40NzIgMS43MDQuOTg0IDIuNjQzIDIuMzE1IDIuNjQzIDMuNzQ4IDAgMS40NDYtLjk1MiAyLjc5MS0yLjY4IDMuNzg5bC0xMi4wNDIgNi45NTJjLTEuNjY4Ljk2My0zLjg3NCAxLjQ5My02LjIxMSAxLjQ5M3ptMTIuMTQ3LTE2Ljc1M2MtMi4yMTcgMC00LjI5OC40OTctNS44NjEgMS4zOTlsLTEyLjA0MiA2Ljk1MmMtMS41MDIuODY4LTIuMzMgMS45OTgtMi4zMyAzLjE4MiAwIDEuMTczLjgxNSAyLjI4OSAyLjI5MyAzLjE0MiAxLjUzOC44ODkgMy41OTYgMS4zNzggNS43OTIgMS4zNzhoLjAwMWMyLjIxNiAwIDQuMjk4LS40OTcgNS44NjEtMS4zOTlsMTIuMDQxLTYuOTUzYzEuNTAyLS44NjcgMi4zMy0xLjk5NyAyLjMzLTMuMTgyIDAtMS4xNzItLjgxNC0yLjI4OC0yLjI5Mi0zLjE0Mi0xLjUzOS0uODg4LTMuNTk2LTEuMzc3LTUuNzkzLTEuMzc3eicgZmlsbD0nIzYwN0Q4QicvPjxwYXRoIGQ9J00xNjUuNjMgMTIzLjIxOWwtNS43MzQgMy4zMTFjLTMuMTY3IDEuODI4LTguMjg2IDEuODM3LTExLjQzMy4wMi0zLjE0Ny0xLjgxNy0zLjEzMS00Ljc3Mi4wMzYtNi42MDFsNS43MzQtMy4zMSAxMS4zOTcgNi41OCcgZmlsbD0nI0ZBRkFGQScvPjxwYXRoIGQ9J00xNTQuMjMzIDExNy40NDhsOS45OTUgNS43NzEtNC42ODIgMi43MDRjLTEuNDM0LjgyNy0zLjM1MiAxLjI4My01LjM5OSAxLjI4My0yLjAyOSAwLTMuOTIzLS40NDktNS4zMzMtMS4yNjMtMS4yOS0uNzQ0LTItMS42OTQtMi0yLjY3NCAwLS45OTEuNzIzLTEuOTU1IDIuMDM2LTIuNzEzbDUuMzgzLTMuMTA4bTAtLjgwOWwtNS43MzQgMy4zMWMtMy4xNjcgMS44MjktMy4xODMgNC43ODQtLjAzNiA2LjYwMSAxLjU2OC45MDUgMy42MjMgMS4zNTcgNS42ODQgMS4zNTcgMi4wNzcgMCA0LjE1OS0uNDYgNS43NDktMS4zNzdsNS43MzQtMy4zMTEtMTEuMzk3LTYuNThNMTQ1LjQ0NSAxNzkuNjY3Yy0xLjc3MyAwLTMuMjQxLS44NS00LjI0My0yLjI0NS0uMDY3LS4wOTItLjA1Ny0uMjc1LjAyMy0uMzU2LjA4LS4wODEuMjA3LS4xMi4zLS4wNTUuNzgxLjU0OCAxLjcwNi44MTIgMi43NTEuODExIDEuMzIyIDAgMi43NTQtLjQ0NiA0LjI1Ni0xLjMxMyA1LjMxLTMuMDY2IDkuNjMxLTEwLjUyMiA5LjYzMS0xNi42MTUgMC0xLjkyNy0uNDQyLTMuNTYyLTEuMjc5LTQuNzI2YS4yMzUuMjM1IDAgMCAxIC4wMjQtLjMwMS4yMzIuMjMyIDAgMCAxIC4zLS4wMjdjMS42NyAxLjE3MiAyLjU5IDMuMzggMi41OSA2LjIxOSAwIDYuMjQyLTQuNDI1IDEzLjk4Ny05Ljg2NSAxNy4xMjctMS41NzMuOTA4LTMuMDgzIDEuNDgxLTQuNDg4IDEuNDgxek0xNDIuNDc2IDE3OGMuODE0LjY1MSAxLjgyIDEuMDAyIDIuOTY5IDEuMDAyIDEuMzIyIDAgMi43NTMtLjQ1MiA0LjI1NS0xLjMyIDUuMzEtMy4wNjUgOS42MzEtMTAuNTIzIDkuNjMxLTE2LjYxNyAwLTEuOTgtLjQ2My0zLjYzLTEuMzI1LTQuNzkzLjQxMSAxLjAzNS42MjQgMi4yNi42MjQgMy42MiAwIDYuMjQyLTQuNDI1IDEzLjg3NS05Ljg2NSAxNy4wMTUtMS41NzMuOTA5LTMuMDg0IDEuMzc2LTQuNDg5IDEuMzc2YTUuNDkgNS40OSAwIDAgMS0xLjgtLjI4M3onIGZpbGw9JyM2MDdEOEInLz48cGF0aCBkPSdNMTQ4LjY0OCAxNzYuNzA0YzUuMzg0LTMuMTA4IDkuNzQ4LTEwLjYzNiA5Ljc0OC0xNi44MTMgMC0yLjA1Mi0uNDgzLTMuNjkzLTEuMzIyLTQuODYxLTEuNzg1LTEuMjUyLTQuMzc1LTEuMTk0LTcuMjU4LjQ3MS01LjM4MyAzLjEwOC05Ljc0OCAxMC42MzYtOS43NDggMTYuODEzIDAgMi4wNTEuNDg0IDMuNjkyIDEuMzIzIDQuODYgMS43ODUgMS4yNTMgNC4zNzQgMS4xOTUgNy4yNTctLjQ3JyBmaWxsPScjRkFGQUZBJy8+PHBhdGggZD0nTTE0NC4yNzYgMTc4LjI3NmMtMS4xNDMgMC0yLjE1OC0uMzA3LTMuMDE5LS45MTFhLjIxNy4yMTcgMCAwIDEtLjA1NS0uMDU0Yy0uODk1LTEuMjQ0LTEuMzY3LTIuOTcyLTEuMzY3LTQuOTk3IDAtNi4yNDEgNC40MjUtMTMuODc1IDkuODY1LTE3LjAxNiAxLjU3My0uOTA4IDMuMDg0LTEuMzY5IDQuNDg5LTEuMzY5IDEuMTQzIDAgMi4xNTguMzA3IDMuMDE5LjkxYS4yNC4yNCAwIDAgMSAuMDU1LjA1NWMuODk0IDEuMjQ0IDEuMzY3IDIuOTcxIDEuMzY3IDQuOTk3IDAgNi4yNDEtNC40MjUgMTMuODc1LTkuODY1IDE3LjAxNi0xLjU3My45MDgtMy4wODQgMS4zNjktNC40ODkgMS4zNjl6bS0yLjcxOC0xLjE3MmMuNzczLjUzMyAxLjY4Ny45MDEgMi43MTguOTAxIDEuMzIyIDAgMi43NTQtLjUzOCA0LjI1Ni0xLjQwNSA1LjMxLTMuMDY2IDkuNjMxLTEwLjU2NyA5LjYzMS0xNi42NjEgMC0xLjkwOC0uNDM0LTMuNTU0LTEuMjU2LTQuNzE2LS43NzQtLjUzMi0xLjY4OC0uODE0LTIuNzE4LS44MTQtMS4zMjIgMC0yLjc1NC40MzMtNC4yNTYgMS4zLTUuMzEgMy4wNjYtOS42MzEgMTAuNTY0LTkuNjMxIDE2LjY1NyAwIDEuOTEuNDM0IDMuNTc2IDEuMjU2IDQuNzM4eicgZmlsbD0nIzYwN0Q4QicvPjxwYXRoIGQ9J00xNTAuNzIgMTcyLjM2MWwtLjM2My0uMjk1YTI0LjEwNSAyNC4xMDUgMCAwIDAgMi4xNDgtMy4xMjggMjQuMDUgMjQuMDUgMCAwIDAgMS45NzctNC4zNzVsLjQ0My4xNDlhMjQuNTQgMjQuNTQgMCAwIDEtMi4wMTUgNC40NiAyNC42MSAyNC42MSAwIDAgMS0yLjE5IDMuMTg5TTExNS45MTcgMTkxLjUxNGwtLjM2My0uMjk0YTI0LjE3NCAyNC4xNzQgMCAwIDAgMi4xNDgtMy4xMjggMjQuMDM4IDI0LjAzOCAwIDAgMCAxLjk3Ni00LjM3NWwuNDQzLjE0OGEyNC40OCAyNC40OCAwIDAgMS0yLjAxNSA0LjQ2MSAyNC42NjIgMjQuNjYyIDAgMCAxLTIuMTg5IDMuMTg4TTExNCAyMzcuNDc2VjE4Mi41ODQgMjM3LjQ3NicgZmlsbD0nIzYwN0Q4QicvPjxnPjxwYXRoIGQ9J004MS44MjIgMzcuNDc0Yy4wMTctLjEzNS0uMDc1LS4yOC0uMjY3LS4zOTItLjMyNy0uMTg4LS44MjYtLjIxLTEuMTA5LS4wNDVsLTYuMDEyIDMuNDcxYy0uMTMxLjA3Ni0uMTk0LjE3OC0uMTkxLjI4NS4wMDIuMTMyLjAwMi40NjEuMDAyLjU3OHYuMDQzbC0uMDA3LjEyOC02LjU5MSAzLjc3OWMtLjAwMSAwLTIuMDc3IDEuMDQ2LTIuNzg3IDUuMTkyIDAgMC0uOTEyIDYuOTYxLS44OTggMTkuNzQ1LjAxNSAxMi41Ny42MDYgMTcuMDcgMS4xNjcgMjEuMzUxLjIyIDEuNjg0IDMuMDAxIDIuMTI1IDMuMDAxIDIuMTI1LjMzMS4wNC42OTgtLjAyNyAxLjA4LS4yNDhsNzUuMjczLTQzLjU1MWMxLjgwOC0xLjA2OSAyLjY2Ny0zLjcxOSAzLjA1Ni02LjI4NCAxLjIxMy03Ljk5IDEuNjc1LTMyLjk3OC0uMjc1LTM5Ljg3OC0uMTk2LS42OTMtLjUxLTEuMDgzLS44NjgtMS4yODJsLTIuMDg2LS43OWMtLjcyNy4wMjgtMS40MTYuNDY3LTEuNTM0LjUzNUw4Mi4wMzIgMzcuMDcybC0uMjEuNDAyJyBmaWxsPScjRkZGJy8+PHBhdGggZD0nTTE0NC4zMTEgMS43MDFsMi4wODUuNzljLjM1OC4xOTkuNjcyLjU4OS44NjggMS4yODIgMS45NDkgNi45IDEuNDg3IDMxLjg4Ny4yNzUgMzkuODc4LS4zOSAyLjU2NS0xLjI0OSA1LjIxNS0zLjA1NiA2LjI4NEw2OS4yMSA5My40ODZhMS43OCAxLjc4IDAgMCAxLS44OTYuMjU4bC0uMTgzLS4wMTFjMCAuMDAxLTIuNzgyLS40NC0zLjAwMy0yLjEyNC0uNTYtNC4yODItMS4xNTEtOC43ODEtMS4xNjUtMjEuMzUxLS4wMTUtMTIuNzg0Ljg5Ny0xOS43NDUuODk3LTE5Ljc0NS43MS00LjE0NiAyLjc4Ny01LjE5MiAyLjc4Ny01LjE5Mmw2LjU5MS0zLjc3OS4wMDctLjEyOHYtLjA0M2MwLS4xMTcgMC0uNDQ2LS4wMDItLjU3OC0uMDAzLS4xMDcuMDU5LS4yMS4xOTEtLjI4NWw2LjAxMi0zLjQ3MmEuOTguOTggMCAwIDEgLjQ4MS0uMTFjLjIxOCAwIC40NDkuMDUzLjYyNy4xNTYuMTkzLjExMi4yODUuMjU4LjI2OC4zOTJsLjIxMS0uNDAyIDYwLjc0NC0zNC44MzZjLjExNy0uMDY4LjgwNi0uNTA3IDEuNTM0LS41MzVtMC0uOTk3bC0uMDM5LjAwMWMtLjYxOC4wMjMtMS4yODMuMjQ0LTEuOTc0LjY1NmwtLjAyMS4wMTItNjAuNTE5IDM0LjcwNmEyLjM1OCAyLjM1OCAwIDAgMC0uODMxLS4xNWMtLjM2NSAwLS43MDQuMDg0LS45OC4yNDRsLTYuMDEyIDMuNDcxYy0uNDQyLjI1NS0uNjk5LjY5LS42ODkgMS4xNjZsLjAwMS4xNS02LjA4IDMuNDg3Yy0uMzczLjE5OS0yLjU0MiAxLjUzMS0zLjI5IDUuODk4bC0uMDA2LjAzOWMtLjAwOS4wNy0uOTIgNy4xNzMtLjkwNiAxOS44NzUuMDE0IDEyLjYyLjYwMyAxNy4xMTYgMS4xNzIgMjEuNDY1bC4wMDIuMDE1Yy4zMDggMi4zNTUgMy40NzUgMi45MjMgMy44MzYgMi45OGwuMDM0LjAwNGMuMTAxLjAxMy4yMDQuMDE5LjMwNS4wMTlhMi43NyAyLjc3IDAgMCAwIDEuMzk2LS4zOTJsNzUuMjczLTQzLjU1MmMxLjgxMS0xLjA3MSAyLjk5OS0zLjQyMyAzLjU0Mi02Ljk5NyAxLjE4Ni03LjgxNCAxLjczNC0zMy4wOTYtLjMwMS00MC4yOTktLjI1My0uODkzLS43MDQtMS41MjctMS4zNDMtMS44ODJsLS4xMzItLjA2Mi0yLjA4NS0uNzg5YS45NzMuOTczIDAgMCAwLS4zNTMtLjA2NScgZmlsbD0nIzQ1NUE2NCcvPjxwYXRoIGQ9J00xMjguMjY3IDExLjU2NWwxLjQ5NS40MzQtNTYuMzM5IDMyLjMyNicgZmlsbD0nI0ZGRicvPjxwYXRoIGQ9J003NC4yMDIgOTAuNTQ1YS41LjUgMCAwIDEtLjI1LS45MzFsMTguNDM3LTEwLjY0NWEuNDk5LjQ5OSAwIDEgMSAuNDk5Ljg2NEw3NC40NTEgOTAuNDc4bC0uMjQ5LjA2N003NS43NjQgNDIuNjU0bC0uMTA4LS4wNjIuMDQ2LS4xNzEgNS4xMzUtMi45NjQuMTcuMDQ1LS4wNDUuMTcxLTUuMTM1IDIuOTY0LS4wNjMuMDE3TTcwLjUyIDkwLjM3NVY0Ni40MjFsLjA2My0uMDM2TDEzNy44NCA3LjU1NHY0My45NTRsLS4wNjIuMDM2TDcwLjUyIDkwLjM3NXptLjI1LTQzLjgxMXY0My4zOGw2Ni44MjEtMzguNTc5VjcuOTg1TDcwLjc3IDQ2LjU2NHonIGZpbGw9JyM2MDdEOEInLz48cGF0aCBkPSdNODYuOTg2IDgzLjE4MmMtLjIzLjE0OS0uNjEyLjM4NC0uODQ5LjUyM2wtMTEuNTA1IDYuNzAxYy0uMjM3LjEzOS0uMjA2LjI1Mi4wNjguMjUyaC41NjVjLjI3NSAwIC42OTMtLjExMy45My0uMjUyTDg3LjcgODMuNzA1Yy4yMzctLjEzOS40MjgtLjI1My40MjUtLjI1NmExMS4yOSAxMS4yOSAwIDAgMS0uMDA2LS41MDNjMC0uMjc0LS4xODgtLjM3Ny0uNDE4LS4yMjdsLS43MTUuNDYzJyBmaWxsPScjNjA3RDhCJy8+PHBhdGggZD0nTTc1LjI2NiA5MC43ODJINzQuN2MtLjIgMC0uMzE2LS4wNTYtLjM0Ni0uMTY2LS4wMy0uMTEuMDQzLS4yMTcuMjE1LS4zMTdsMTEuNTA1LTYuNzAyYy4yMzYtLjEzOC42MTUtLjM3MS44NDQtLjUxOWwuNzE1LS40NjRhLjQ4OC40ODggMCAwIDEgLjI2Ni0uMDg5Yy4xNzIgMCAuMzQ1LjEzLjM0NS40MjEgMCAuMjE0LjAwMS4zNjMuMDAzLjQzN2wuMDA2LjAwNC0uMDA0LjA2OWMtLjAwMy4wNzUtLjAwMy4wNzUtLjQ4Ni4zNTZsLTExLjUwNSA2LjcwMmEyLjI4MiAyLjI4MiAwIDAgMS0uOTkyLjI2OHptLS42LS4yNWwuMDM0LjAwMWguNTY2Yy4yNTIgMCAuNjQ5LS4xMDguODY2LS4yMzRsMTEuNTA1LTYuNzAyYy4xNjgtLjA5OC4yOTQtLjE3My4zNjEtLjIxNC0uMDA0LS4wODQtLjAwNC0uMjE4LS4wMDQtLjQzN2wtLjA5NS0uMTcxLS4xMzEuMDQ5LS43MTQuNDYzYy0uMjMyLjE1LS42MTYuMzg2LS44NTQuNTI1bC0xMS41MDUgNi43MDItLjAyOS4wMTh6JyBmaWxsPScjNjA3RDhCJy8+PHBhdGggZD0nTTc1LjI2NiA4OS44NzFINzQuN2MtLjIgMC0uMzE2LS4wNTYtLjM0Ni0uMTY2LS4wMy0uMTEuMDQzLS4yMTcuMjE1LS4zMTdsMTEuNTA1LTYuNzAyYy4yNTgtLjE1MS42OTQtLjI2OC45OTMtLjI2OGguNTY1Yy4yIDAgLjMxNi4wNTYuMzQ2LjE2Ni4wMy4xMS0uMDQzLjIxNy0uMjE1LjMxN2wtMTEuNTA1IDYuNzAyYTIuMjgyIDIuMjgyIDAgMCAxLS45OTIuMjY4em0tLjYtLjI1bC4wMzQuMDAxaC41NjZjLjI1MiAwIC42NDktLjEwNy44NjYtLjIzNGwxMS41MDUtNi43MDIuMDMtLjAxOC0uMDM1LS4wMDFoLS41NjVjLS4yNTIgMC0uNjQ5LjEwOC0uODY3LjIzNGwtMTEuNTA1IDYuNzAyLS4wMjkuMDE4ek03NC4zNyA5MC44MDF2LTEuMjQ3IDEuMjQ3JyBmaWxsPScjNjA3RDhCJy8+PHBhdGggZD0nTTY4LjEzIDkzLjkwMWMtLjc1MS0uMDkzLTEuMzE0LS43MzctMS40MzktMS4zNzYtLjgzMS00LjIzOC0xLjE1MS04Ljc4Mi0xLjE2NS0yMS4zNTItLjAxNS0xMi43ODQuODk3LTE5Ljc0NS44OTctMTkuNzQ1LjcxMS00LjE0NiAyLjc4Ny01LjE5MiAyLjc4Ny01LjE5Mmw3NC44NTktNDMuMjE5Yy4yMjMtLjEyOSAyLjQ4Ny0xLjU4NCAzLjE5NS45MjMgMS45NSA2LjkgMS40ODggMzEuODg3LjI3NSAzOS44NzgtLjM4OSAyLjU2NS0xLjI0OCA1LjIxNS0zLjA1NiA2LjI4M0w2OS4yMSA5My42NTNjLS4zODIuMjIxLS43NDkuMjg4LTEuMDguMjQ4IDAgMC0yLjc4MS0uNDQxLTMuMDAxLTIuMTI1LS41NjEtNC4yODEtMS4xNTItOC43ODEtMS4xNjctMjEuMzUxLS4wMTQtMTIuNzg0Ljg5OC0xOS43NDUuODk4LTE5Ljc0NS43MS00LjE0NiAyLjc4Ny01LjE5MSAyLjc4Ny01LjE5MWw2LjU5OC0zLjgxLjg3MS0uMTE5IDYuNTk5LTMuODMuMDQ2LS40NjFMNjguMTMgOTMuOTAxJyBmaWxsPScjRkFGQUZBJy8+PHBhdGggZD0nTTY4LjMxNyA5NC4xNjFsLS4yMTUtLjAxM2gtLjAwMWwtLjI0NC0uMDQ3Yy0uNzE5LS4xNTYtMi43NzItLjczNi0yLjk3Ni0yLjI5Mi0uNTY4LTQuMzQtMS4xNTQtOC44MTMtMS4xNjgtMjEuMzg0LS4wMTQtMTIuNjU0Ljg5MS0xOS43MDcuOS0xOS43NzcuNzI1LTQuMjMxIDIuODMyLTUuMzM4IDIuOTIyLTUuMzgybDYuNjI4LTMuODI3Ljg3LS4xMTkgNi40NDYtMy43NDIuMDM0LS4zMzRhLjI0OC4yNDggMCAwIDEgLjI3My0uMjIzLjI0OC4yNDggMCAwIDEgLjIyMy4yNzJsLS4wNTkuNTg5LTYuNzUyIDMuOTE5LS44Ny4xMTgtNi41NTYgMy43ODVjLS4wMzEuMDE2LTEuOTkgMS4wNjgtMi42NjYgNS4wMTgtLjAwNy4wNi0uOTA4IDcuMDg2LS44OTQgMTkuNzAyLjAxNCAxMi41MzkuNTk3IDE2Ljk5NiAxLjE2MSAyMS4zMDUuMDkxLjY5MS42ODkgMS4xNTQgMS4zMDkgMS40NTJhMS45NSAxLjk1IDAgMCAxLS4yMzYtLjYwOWMtLjc4MS0zLjk4NC0xLjE1NS04LjIwMi0xLjE3LTIxLjM5OS0uMDE0LTEyLjY1My44OTEtMTkuNzA3LjktMTkuNzc3LjcyNS00LjIzMSAyLjgzMi01LjMzNyAyLjkyMi01LjM4Mi0uMDA0LjAwMSA3NC40NDQtNDIuOTggNzQuODQ2LTQzLjIxMmwuMDI4LS4wMTdjLjkwNC0uNTM4IDEuNzItLjY4OCAyLjM2LS40MzMuNTU1LjIyMS45NDkuNzMzIDEuMTcyIDEuNTIgMi4wMTQgNy4xMjggMS40NiAzMi4yMTkuMjgxIDM5Ljk4My0uNTA3IDMuMzQxLTEuNTc1IDUuNTE1LTMuMTc1IDYuNDYyTDY5LjMzNSA5My44NjlhMi4wMjMgMi4wMjMgMCAwIDEtMS4wMTguMjkyem0tLjE0Ny0uNTA3Yy4yOTMuMDM2LjYwNC0uMDM3LjkxNS0uMjE3bDc1LjI3My00My41NTFjMS44MjMtMS4wNzggMi42MDItMy45MTUgMi45MzQtNi4xMDYgMS4xNzQtNy43MzEgMS43MzEtMzIuNjk1LS4yNjgtMzkuNzcyLS4xNzgtLjYzMS0uNDczLTEuMDMyLS44NzYtMS4xOTItLjQ4NC0uMTkzLTEuMTY2LS4wNTItMS45MjEuMzk3bC0uMDM0LjAyMS03NC44NTggNDMuMjE4Yy0uMDMxLjAxNy0xLjk4OSAxLjA2OS0yLjY2NiA1LjAxOS0uMDA3LjA1OS0uOTA4IDcuMDg1LS44OTQgMTkuNzAyLjAxNSAxMy4xNTUuMzg2IDE3LjM1MSAxLjE2MSAyMS4zMDMuMDkuNDYxLjQ3Ni45ODMgMS4wMzcgMS4xMzkuMTE0LjAyNS4xODUuMDM3LjE5Ni4wMzloLjAwMXonIGZpbGw9JyM0NTVBNjQnLz48cGF0aCBkPSdNNjkuMzE3IDY4Ljk4MmMuNDg5LS4yODEuODg1LS4wNTYuODg1LjUwNSAwIC41Ni0uMzk2IDEuMjQzLS44ODUgMS41MjUtLjQ4OC4yODItLjg4NC4wNTctLjg4NC0uNTA0IDAtLjU2LjM5Ni0xLjI0My44ODQtMS41MjYnIGZpbGw9JyNGRkYnLz48cGF0aCBkPSdNNjguOTIgNzEuMTMzYy0uMjg5IDAtLjQ4Ny0uMjI4LS40ODctLjYyNSAwLS41Ni4zOTYtMS4yNDMuODg0LTEuNTI2YS44MTIuODEyIDAgMCAxIC4zOTctLjEyMWMuMjg5IDAgLjQ4OC4yMjkuNDg4LjYyNiAwIC41Ni0uMzk2IDEuMjQzLS44ODUgMS41MjVhLjgxMi44MTIgMCAwIDEtLjM5Ny4xMjFtLjc5NC0yLjQ1OWEuOTc2Ljk3NiAwIDAgMC0uNDkuMTQ3Yy0uNTQ4LjMxNy0uOTc4IDEuMDU4LS45NzggMS42ODcgMCAuNDg2LjI3MS44MTIuNjc0LjgxMmEuOTg1Ljk4NSAwIDAgMCAuNDkxLS4xNDZjLjU0OC0uMzE3Ljk3OC0xLjA1Ny45NzgtMS42ODcgMC0uNDg2LS4yNzItLjgxMy0uNjc1LS44MTMnIGZpbGw9JyM4MDk3QTInLz48cGF0aCBkPSdNNjguOTIgNzAuOTQ3Yy0uMjcxIDAtLjI5OS0uMzA3LS4yOTktLjQzOSAwLS40OTEuMzYxLTEuMTE2Ljc5LTEuMzYzYS42MzIuNjMyIDAgMCAxIC4zMDMtLjA5NmMuMjcyIDAgLjMwMS4zMDYuMzAxLjQzOCAwIC40OTEtLjM2MyAxLjExNi0uNzkxIDEuMzY0YS42MjkuNjI5IDAgMCAxLS4zMDQuMDk2bS43OTQtMi4wODZhLjgxMi44MTIgMCAwIDAtLjM5Ny4xMjFjLS40ODguMjgzLS44ODQuOTY2LS44ODQgMS41MjYgMCAuMzk3LjE5OC42MjUuNDg3LjYyNWEuODEyLjgxMiAwIDAgMCAuMzk3LS4xMjFjLjQ4OS0uMjgyLjg4NS0uOTY1Ljg4NS0xLjUyNSAwLS4zOTctLjE5OS0uNjI2LS40ODgtLjYyNicgZmlsbD0nIzgwOTdBMicvPjxwYXRoIGQ9J002OS40NDQgODUuMzVjLjI2NC0uMTUyLjQ3Ny0uMDMxLjQ3Ny4yNzIgMCAuMzAzLS4yMTMuNjctLjQ3Ny44MjItLjI2My4xNTMtLjQ3Ny4wMzEtLjQ3Ny0uMjcxIDAtLjMwMi4yMTQtLjY3MS40NzctLjgyMycgZmlsbD0nI0ZGRicvPjxwYXRoIGQ9J002OS4yMyA4Ni41MWMtLjE1NiAwLS4yNjMtLjEyMy0uMjYzLS4zMzcgMC0uMzAyLjIxNC0uNjcxLjQ3Ny0uODIzYS40MzEuNDMxIDAgMCAxIC4yMTQtLjA2NmMuMTU2IDAgLjI2My4xMjQuMjYzLjMzOCAwIC4zMDMtLjIxMy42Ny0uNDc3LjgyMmEuNDMxLjQzMSAwIDAgMS0uMjE0LjA2Nm0uNDI4LTEuNDEyYy0uMSAwLS4yMDMuMDI5LS4zMDcuMDktLjMyLjE4NS0uNTcuNjE4LS41Ny45ODUgMCAuMzA5LjE4NS41MjQuNDQ5LjUyNGEuNjMuNjMgMCAwIDAgLjMwOC0uMDljLjMyLS4xODUuNTctLjYxOC41Ny0uOTg1IDAtLjMwOS0uMTg1LS41MjQtLjQ1LS41MjQnIGZpbGw9JyM4MDk3QTInLz48cGF0aCBkPSdNNjkuMjMgODYuMzIybC0uMDc2LS4xNDljMC0uMjM1LjE3OS0uNTQ0LjM4NC0uNjYxbC4xMi0uMDQxLjA3Ni4xNTFjMCAuMjM0LS4xNzkuNTQyLS4zODMuNjZsLS4xMjEuMDRtLjQyOC0xLjAzOGEuNDMxLjQzMSAwIDAgMC0uMjE0LjA2NmMtLjI2My4xNTItLjQ3Ny41MjEtLjQ3Ny44MjMgMCAuMjE0LjEwNy4zMzcuMjYzLjMzN2EuNDMxLjQzMSAwIDAgMCAuMjE0LS4wNjZjLjI2NC0uMTUyLjQ3Ny0uNTE5LjQ3Ny0uODIyIDAtLjIxNC0uMTA3LS4zMzgtLjI2My0uMzM4JyBmaWxsPScjODA5N0EyJy8+PHBhdGggZD0nTTEzOS4yNzggNy43Njl2NDMuNjY3TDcyLjIwOCA5MC4xNlY0Ni40OTNsNjcuMDctMzguNzI0JyBmaWxsPScjNDU1QTY0Jy8+PHBhdGggZD0nTTcyLjA4MyA5MC4zNzVWNDYuNDIxbC4wNjMtLjAzNiA2Ny4yNTctMzguODMxdjQzLjk1NGwtLjA2Mi4wMzYtNjcuMjU4IDM4LjgzMXptLjI1LTQzLjgxMXY0My4zOGw2Ni44MjEtMzguNTc5VjcuOTg1TDcyLjMzMyA0Ni41NjR6JyBmaWxsPScjNjA3RDhCJy8+PC9nPjxwYXRoIGQ9J00xMjUuNzM3IDg4LjY0N2wtNy42MzkgMy4zMzRWODRsLTExLjQ1OSA0LjcxM3Y4LjI2OUw5OSAxMDAuMzE1bDEzLjM2OSAzLjY0NiAxMy4zNjgtMTUuMzE0JyBmaWxsPScjNDU1QTY0Jy8+PC9nPjwvc3ZnPlwiO1xuZnVuY3Rpb24gUm90YXRlSW5zdHJ1Y3Rpb25zKCkge1xuICB0aGlzLmxvYWRJY29uXygpO1xuICB2YXIgb3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgcyA9IG92ZXJsYXkuc3R5bGU7XG4gIHMucG9zaXRpb24gPSAnZml4ZWQnO1xuICBzLnRvcCA9IDA7XG4gIHMucmlnaHQgPSAwO1xuICBzLmJvdHRvbSA9IDA7XG4gIHMubGVmdCA9IDA7XG4gIHMuYmFja2dyb3VuZENvbG9yID0gJ2dyYXknO1xuICBzLmZvbnRGYW1pbHkgPSAnc2Fucy1zZXJpZic7XG4gIHMuekluZGV4ID0gMTAwMDAwMDtcbiAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICBpbWcuc3JjID0gdGhpcy5pY29uO1xuICB2YXIgcyA9IGltZy5zdHlsZTtcbiAgcy5tYXJnaW5MZWZ0ID0gJzI1JSc7XG4gIHMubWFyZ2luVG9wID0gJzI1JSc7XG4gIHMud2lkdGggPSAnNTAlJztcbiAgb3ZlcmxheS5hcHBlbmRDaGlsZChpbWcpO1xuICB2YXIgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgcyA9IHRleHQuc3R5bGU7XG4gIHMudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gIHMuZm9udFNpemUgPSAnMTZweCc7XG4gIHMubGluZUhlaWdodCA9ICcyNHB4JztcbiAgcy5tYXJnaW4gPSAnMjRweCAyNSUnO1xuICBzLndpZHRoID0gJzUwJSc7XG4gIHRleHQuaW5uZXJIVE1MID0gJ1BsYWNlIHlvdXIgcGhvbmUgaW50byB5b3VyIENhcmRib2FyZCB2aWV3ZXIuJztcbiAgb3ZlcmxheS5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgdmFyIHNuYWNrYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBzID0gc25hY2tiYXIuc3R5bGU7XG4gIHMuYmFja2dyb3VuZENvbG9yID0gJyNDRkQ4REMnO1xuICBzLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgcy5ib3R0b20gPSAwO1xuICBzLndpZHRoID0gJzEwMCUnO1xuICBzLmhlaWdodCA9ICc0OHB4JztcbiAgcy5wYWRkaW5nID0gJzE0cHggMjRweCc7XG4gIHMuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICBzLmNvbG9yID0gJyM2NTZBNkInO1xuICBvdmVybGF5LmFwcGVuZENoaWxkKHNuYWNrYmFyKTtcbiAgdmFyIHNuYWNrYmFyVGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBzbmFja2JhclRleHQuc3R5bGUuZmxvYXQgPSAnbGVmdCc7XG4gIHNuYWNrYmFyVGV4dC5pbm5lckhUTUwgPSAnTm8gQ2FyZGJvYXJkIHZpZXdlcj8nO1xuICB2YXIgc25hY2tiYXJCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIHNuYWNrYmFyQnV0dG9uLmhyZWYgPSAnaHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9nZXQvY2FyZGJvYXJkL2dldC1jYXJkYm9hcmQvJztcbiAgc25hY2tiYXJCdXR0b24uaW5uZXJIVE1MID0gJ2dldCBvbmUnO1xuICBzbmFja2JhckJ1dHRvbi50YXJnZXQgPSAnX2JsYW5rJztcbiAgdmFyIHMgPSBzbmFja2JhckJ1dHRvbi5zdHlsZTtcbiAgcy5mbG9hdCA9ICdyaWdodCc7XG4gIHMuZm9udFdlaWdodCA9IDYwMDtcbiAgcy50ZXh0VHJhbnNmb3JtID0gJ3VwcGVyY2FzZSc7XG4gIHMuYm9yZGVyTGVmdCA9ICcxcHggc29saWQgZ3JheSc7XG4gIHMucGFkZGluZ0xlZnQgPSAnMjRweCc7XG4gIHMudGV4dERlY29yYXRpb24gPSAnbm9uZSc7XG4gIHMuY29sb3IgPSAnIzY1NkE2Qic7XG4gIHNuYWNrYmFyLmFwcGVuZENoaWxkKHNuYWNrYmFyVGV4dCk7XG4gIHNuYWNrYmFyLmFwcGVuZENoaWxkKHNuYWNrYmFyQnV0dG9uKTtcbiAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5oaWRlKCk7XG59XG5Sb3RhdGVJbnN0cnVjdGlvbnMucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAocGFyZW50KSB7XG4gIGlmICghcGFyZW50ICYmICF0aGlzLm92ZXJsYXkucGFyZW50RWxlbWVudCkge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5vdmVybGF5KTtcbiAgfSBlbHNlIGlmIChwYXJlbnQpIHtcbiAgICBpZiAodGhpcy5vdmVybGF5LnBhcmVudEVsZW1lbnQgJiYgdGhpcy5vdmVybGF5LnBhcmVudEVsZW1lbnQgIT0gcGFyZW50KSB0aGlzLm92ZXJsYXkucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLm92ZXJsYXkpO1xuICAgIHBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXkpO1xuICB9XG4gIHRoaXMub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgdmFyIGltZyA9IHRoaXMub3ZlcmxheS5xdWVyeVNlbGVjdG9yKCdpbWcnKTtcbiAgdmFyIHMgPSBpbWcuc3R5bGU7XG4gIGlmIChpc0xhbmRzY2FwZU1vZGUoKSkge1xuICAgIHMud2lkdGggPSAnMjAlJztcbiAgICBzLm1hcmdpbkxlZnQgPSAnNDAlJztcbiAgICBzLm1hcmdpblRvcCA9ICczJSc7XG4gIH0gZWxzZSB7XG4gICAgcy53aWR0aCA9ICc1MCUnO1xuICAgIHMubWFyZ2luTGVmdCA9ICcyNSUnO1xuICAgIHMubWFyZ2luVG9wID0gJzI1JSc7XG4gIH1cbn07XG5Sb3RhdGVJbnN0cnVjdGlvbnMucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xufTtcblJvdGF0ZUluc3RydWN0aW9ucy5wcm90b3R5cGUuc2hvd1RlbXBvcmFyaWx5ID0gZnVuY3Rpb24gKG1zLCBwYXJlbnQpIHtcbiAgdGhpcy5zaG93KHBhcmVudCk7XG4gIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuaGlkZS5iaW5kKHRoaXMpLCBtcyk7XG59O1xuUm90YXRlSW5zdHJ1Y3Rpb25zLnByb3RvdHlwZS5kaXNhYmxlU2hvd1RlbXBvcmFyaWx5ID0gZnVuY3Rpb24gKCkge1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG59O1xuUm90YXRlSW5zdHJ1Y3Rpb25zLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZGlzYWJsZVNob3dUZW1wb3JhcmlseSgpO1xuICBpZiAoIWlzTGFuZHNjYXBlTW9kZSgpICYmIGlzTW9iaWxlKCkpIHtcbiAgICB0aGlzLnNob3coKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhpZGUoKTtcbiAgfVxufTtcblJvdGF0ZUluc3RydWN0aW9ucy5wcm90b3R5cGUubG9hZEljb25fID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmljb24gPSBkYXRhVXJpKCdpbWFnZS9zdmcreG1sJywgcm90YXRlSW5zdHJ1Y3Rpb25zQXNzZXQpO1xufTtcbnZhciBERUZBVUxUX1ZJRVdFUiA9ICdDYXJkYm9hcmRWMSc7XG52YXIgVklFV0VSX0tFWSA9ICdXRUJWUl9DQVJEQk9BUkRfVklFV0VSJztcbnZhciBDTEFTU19OQU1FID0gJ3dlYnZyLXBvbHlmaWxsLXZpZXdlci1zZWxlY3Rvcic7XG5mdW5jdGlvbiBWaWV3ZXJTZWxlY3RvcihkZWZhdWx0Vmlld2VyKSB7XG4gIHRyeSB7XG4gICAgdGhpcy5zZWxlY3RlZEtleSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFZJRVdFUl9LRVkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHZpZXdlciBwcm9maWxlOiAlcycsIGVycm9yKTtcbiAgfVxuICBpZiAoIXRoaXMuc2VsZWN0ZWRLZXkpIHtcbiAgICB0aGlzLnNlbGVjdGVkS2V5ID0gZGVmYXVsdFZpZXdlciB8fCBERUZBVUxUX1ZJRVdFUjtcbiAgfVxuICB0aGlzLmRpYWxvZyA9IHRoaXMuY3JlYXRlRGlhbG9nXyhEZXZpY2VJbmZvLlZpZXdlcnMpO1xuICB0aGlzLnJvb3QgPSBudWxsO1xuICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2tzXyA9IFtdO1xufVxuVmlld2VyU2VsZWN0b3IucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAocm9vdCkge1xuICB0aGlzLnJvb3QgPSByb290O1xuICByb290LmFwcGVuZENoaWxkKHRoaXMuZGlhbG9nKTtcbiAgdmFyIHNlbGVjdGVkID0gdGhpcy5kaWFsb2cucXVlcnlTZWxlY3RvcignIycgKyB0aGlzLnNlbGVjdGVkS2V5KTtcbiAgc2VsZWN0ZWQuY2hlY2tlZCA9IHRydWU7XG4gIHRoaXMuZGlhbG9nLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xufTtcblZpZXdlclNlbGVjdG9yLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5yb290ICYmIHRoaXMucm9vdC5jb250YWlucyh0aGlzLmRpYWxvZykpIHtcbiAgICB0aGlzLnJvb3QucmVtb3ZlQ2hpbGQodGhpcy5kaWFsb2cpO1xuICB9XG4gIHRoaXMuZGlhbG9nLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG59O1xuVmlld2VyU2VsZWN0b3IucHJvdG90eXBlLmdldEN1cnJlbnRWaWV3ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBEZXZpY2VJbmZvLlZpZXdlcnNbdGhpcy5zZWxlY3RlZEtleV07XG59O1xuVmlld2VyU2VsZWN0b3IucHJvdG90eXBlLmdldFNlbGVjdGVkS2V5XyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGlucHV0ID0gdGhpcy5kaWFsb2cucXVlcnlTZWxlY3RvcignaW5wdXRbbmFtZT1maWVsZF06Y2hlY2tlZCcpO1xuICBpZiAoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQuaWQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuVmlld2VyU2VsZWN0b3IucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGNiKSB7XG4gIHRoaXMub25DaGFuZ2VDYWxsYmFja3NfLnB1c2goY2IpO1xufTtcblZpZXdlclNlbGVjdG9yLnByb3RvdHlwZS5maXJlT25DaGFuZ2VfID0gZnVuY3Rpb24gKHZpZXdlcikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub25DaGFuZ2VDYWxsYmFja3NfLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrc19baV0odmlld2VyKTtcbiAgfVxufTtcblZpZXdlclNlbGVjdG9yLnByb3RvdHlwZS5vblNhdmVfID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlbGVjdGVkS2V5ID0gdGhpcy5nZXRTZWxlY3RlZEtleV8oKTtcbiAgaWYgKCF0aGlzLnNlbGVjdGVkS2V5IHx8ICFEZXZpY2VJbmZvLlZpZXdlcnNbdGhpcy5zZWxlY3RlZEtleV0pIHtcbiAgICBjb25zb2xlLmVycm9yKCdWaWV3ZXJTZWxlY3Rvci5vblNhdmVfOiB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW4hJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuZmlyZU9uQ2hhbmdlXyhEZXZpY2VJbmZvLlZpZXdlcnNbdGhpcy5zZWxlY3RlZEtleV0pO1xuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFZJRVdFUl9LRVksIHRoaXMuc2VsZWN0ZWRLZXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIHZpZXdlciBwcm9maWxlOiAlcycsIGVycm9yKTtcbiAgfVxuICB0aGlzLmhpZGUoKTtcbn07XG5WaWV3ZXJTZWxlY3Rvci5wcm90b3R5cGUuY3JlYXRlRGlhbG9nXyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRSk7XG4gIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB2YXIgb3ZlcmxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgcyA9IG92ZXJsYXkuc3R5bGU7XG4gIHMucG9zaXRpb24gPSAnZml4ZWQnO1xuICBzLmxlZnQgPSAwO1xuICBzLnRvcCA9IDA7XG4gIHMud2lkdGggPSAnMTAwJSc7XG4gIHMuaGVpZ2h0ID0gJzEwMCUnO1xuICBzLmJhY2tncm91bmQgPSAncmdiYSgwLCAwLCAwLCAwLjMpJztcbiAgb3ZlcmxheS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGlkZS5iaW5kKHRoaXMpKTtcbiAgdmFyIHdpZHRoID0gMjgwO1xuICB2YXIgZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciBzID0gZGlhbG9nLnN0eWxlO1xuICBzLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgcy5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gIHMudG9wID0gJzI0cHgnO1xuICBzLmxlZnQgPSAnNTAlJztcbiAgcy5tYXJnaW5MZWZ0ID0gLXdpZHRoIC8gMiArICdweCc7XG4gIHMud2lkdGggPSB3aWR0aCArICdweCc7XG4gIHMucGFkZGluZyA9ICcyNHB4JztcbiAgcy5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICBzLmJhY2tncm91bmQgPSAnI2ZhZmFmYSc7XG4gIHMuZm9udEZhbWlseSA9IFwiJ1JvYm90bycsIHNhbnMtc2VyaWZcIjtcbiAgcy5ib3hTaGFkb3cgPSAnMHB4IDVweCAyMHB4ICM2NjYnO1xuICBkaWFsb2cuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVIMV8oJ1NlbGVjdCB5b3VyIHZpZXdlcicpKTtcbiAgZm9yICh2YXIgaWQgaW4gb3B0aW9ucykge1xuICAgIGRpYWxvZy5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUNob2ljZV8oaWQsIG9wdGlvbnNbaWRdLmxhYmVsKSk7XG4gIH1cbiAgZGlhbG9nLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlQnV0dG9uXygnU2F2ZScsIHRoaXMub25TYXZlXy5iaW5kKHRoaXMpKSk7XG4gIGNvbnRhaW5lci5hcHBlbmRDaGlsZChvdmVybGF5KTtcbiAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRpYWxvZyk7XG4gIHJldHVybiBjb250YWluZXI7XG59O1xuVmlld2VyU2VsZWN0b3IucHJvdG90eXBlLmNyZWF0ZUgxXyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciBoMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gxJyk7XG4gIHZhciBzID0gaDEuc3R5bGU7XG4gIHMuY29sb3IgPSAnYmxhY2snO1xuICBzLmZvbnRTaXplID0gJzIwcHgnO1xuICBzLmZvbnRXZWlnaHQgPSAnYm9sZCc7XG4gIHMubWFyZ2luVG9wID0gMDtcbiAgcy5tYXJnaW5Cb3R0b20gPSAnMjRweCc7XG4gIGgxLmlubmVySFRNTCA9IG5hbWU7XG4gIHJldHVybiBoMTtcbn07XG5WaWV3ZXJTZWxlY3Rvci5wcm90b3R5cGUuY3JlYXRlQ2hvaWNlXyA9IGZ1bmN0aW9uIChpZCwgbmFtZSkge1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5zdHlsZS5tYXJnaW5Ub3AgPSAnOHB4JztcbiAgZGl2LnN0eWxlLmNvbG9yID0gJ2JsYWNrJztcbiAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgaW5wdXQuc3R5bGUuZm9udFNpemUgPSAnMzBweCc7XG4gIGlucHV0LnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gIGlucHV0LnNldEF0dHJpYnV0ZSgndHlwZScsICdyYWRpbycpO1xuICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgaWQpO1xuICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ25hbWUnLCAnZmllbGQnKTtcbiAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgbGFiZWwuc3R5bGUubWFyZ2luTGVmdCA9ICc0cHgnO1xuICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ2ZvcicsIGlkKTtcbiAgbGFiZWwuaW5uZXJIVE1MID0gbmFtZTtcbiAgZGl2LmFwcGVuZENoaWxkKGlucHV0KTtcbiAgZGl2LmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgcmV0dXJuIGRpdjtcbn07XG5WaWV3ZXJTZWxlY3Rvci5wcm90b3R5cGUuY3JlYXRlQnV0dG9uXyA9IGZ1bmN0aW9uIChsYWJlbCwgb25jbGljaykge1xuICB2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gIGJ1dHRvbi5pbm5lckhUTUwgPSBsYWJlbDtcbiAgdmFyIHMgPSBidXR0b24uc3R5bGU7XG4gIHMuZmxvYXQgPSAncmlnaHQnO1xuICBzLnRleHRUcmFuc2Zvcm0gPSAndXBwZXJjYXNlJztcbiAgcy5jb2xvciA9ICcjMTA5NGY3JztcbiAgcy5mb250U2l6ZSA9ICcxNHB4JztcbiAgcy5sZXR0ZXJTcGFjaW5nID0gMDtcbiAgcy5ib3JkZXIgPSAwO1xuICBzLmJhY2tncm91bmQgPSAnbm9uZSc7XG4gIHMubWFyZ2luVG9wID0gJzE2cHgnO1xuICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbmNsaWNrKTtcbiAgcmV0dXJuIGJ1dHRvbjtcbn07XG52YXIgY29tbW9uanNHbG9iYWwkJDEgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBjb21tb25qc0dsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBjb21tb25qc0dsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcbmZ1bmN0aW9uIHVud3JhcEV4cG9ydHMkJDEgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlJCQxKGZuLCBtb2R1bGUpIHtcblx0cmV0dXJuIG1vZHVsZSA9IHsgZXhwb3J0czoge30gfSwgZm4obW9kdWxlLCBtb2R1bGUuZXhwb3J0cyksIG1vZHVsZS5leHBvcnRzO1xufVxudmFyIE5vU2xlZXAgPSBjcmVhdGVDb21tb25qc01vZHVsZSQkMShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbn0pKGNvbW1vbmpzR2xvYmFsJCQxLCBmdW5jdGlvbigpIHtcbnJldHVybiAgICAgICAgICAoZnVuY3Rpb24obW9kdWxlcykge1xuICAgICAgICAgXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuICAgICAgICAgXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4gICAgICAgICBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiAgICAgICAgIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuICAgICAgICAgXHRcdH1cbiAgICAgICAgIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gICAgICAgICBcdFx0XHRpOiBtb2R1bGVJZCxcbiAgICAgICAgIFx0XHRcdGw6IGZhbHNlLFxuICAgICAgICAgXHRcdFx0ZXhwb3J0czoge31cbiAgICAgICAgIFx0XHR9O1xuICAgICAgICAgXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuICAgICAgICAgXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbiAgICAgICAgIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gICAgICAgICBcdH1cbiAgICAgICAgIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbiAgICAgICAgIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbiAgICAgICAgIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gICAgICAgICBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuICAgICAgICAgXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiAgICAgICAgIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiAgICAgICAgIFx0XHRcdH0pO1xuICAgICAgICAgXHRcdH1cbiAgICAgICAgIFx0fTtcbiAgICAgICAgIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gICAgICAgICBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gICAgICAgICBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuICAgICAgICAgXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiAgICAgICAgIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gICAgICAgICBcdFx0cmV0dXJuIGdldHRlcjtcbiAgICAgICAgIFx0fTtcbiAgICAgICAgIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuICAgICAgICAgXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuICAgICAgICAgXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAwKTtcbiAgICAgICAgIH0pXG4gICAgICAgICAoW1xuICAgICAgKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG52YXIgbWVkaWFGaWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbnZhciBvbGRJT1MgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBwYXJzZUZsb2F0KCgnJyArICgvQ1BVLipPUyAoWzAtOV9dezMsNH0pWzAtOV9dezAsMX18KENQVSBsaWtlKS4qQXBwbGVXZWJLaXQuKk1vYmlsZS9pLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgWzAsICcnXSlbMV0pLnJlcGxhY2UoJ3VuZGVmaW5lZCcsICczXzInKS5yZXBsYWNlKCdfJywgJy4nKS5yZXBsYWNlKCdfJywgJycpKSA8IDEwICYmICF3aW5kb3cuTVNTdHJlYW07XG52YXIgTm9TbGVlcCA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTm9TbGVlcCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9TbGVlcCk7XG4gICAgaWYgKG9sZElPUykge1xuICAgICAgdGhpcy5ub1NsZWVwVGltZXIgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5vU2xlZXBWaWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICB0aGlzLm5vU2xlZXBWaWRlby5zZXRBdHRyaWJ1dGUoJ3BsYXlzaW5saW5lJywgJycpO1xuICAgICAgdGhpcy5ub1NsZWVwVmlkZW8uc2V0QXR0cmlidXRlKCdzcmMnLCBtZWRpYUZpbGUpO1xuICAgICAgdGhpcy5ub1NsZWVwVmlkZW8uYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLm5vU2xlZXBWaWRlby5jdXJyZW50VGltZSA+IDAuNSkge1xuICAgICAgICAgIHRoaXMubm9TbGVlcFZpZGVvLmN1cnJlbnRUaW1lID0gTWF0aC5yYW5kb20oKTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKE5vU2xlZXAsIFt7XG4gICAga2V5OiAnZW5hYmxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgaWYgKG9sZElPUykge1xuICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgdGhpcy5ub1NsZWVwVGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJy8nO1xuICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHdpbmRvdy5zdG9wLCAwKTtcbiAgICAgICAgfSwgMTUwMDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ub1NsZWVwVmlkZW8ucGxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgaWYgKG9sZElPUykge1xuICAgICAgICBpZiAodGhpcy5ub1NsZWVwVGltZXIpIHtcbiAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLm5vU2xlZXBUaW1lcik7XG4gICAgICAgICAgdGhpcy5ub1NsZWVwVGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5vU2xlZXBWaWRlby5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTm9TbGVlcDtcbn0oKTtcbm1vZHVsZS5leHBvcnRzID0gTm9TbGVlcDtcbiAgICAgIH0pLFxuICAgICAgKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xubW9kdWxlLmV4cG9ydHMgPSAnZGF0YTp2aWRlby9tcDQ7YmFzZTY0LEFBQUFJR1owZVhCdGNEUXlBQUFDQUdsemIyMXBjMjh5WVhaak1XMXdOREVBQUFBSVpuSmxaUUFBQ0tCdFpHRjBBQUFDOHdZRi8vL3YzRVhwdmViWlNMZVdMTmdnMlNQdTczZ3lOalFnTFNCamIzSmxJREUwTWlCeU1qUTNPU0JrWkRjNVlUWXhJQzBnU0M0eU5qUXZUVkJGUnkwMElFRldReUJqYjJSbFl5QXRJRU52Y0hsc1pXWjBJREl3TURNdE1qQXhOQ0F0SUdoMGRIQTZMeTkzZDNjdWRtbGtaVzlzWVc0dWIzSm5MM2d5TmpRdWFIUnRiQ0F0SUc5d2RHbHZibk02SUdOaFltRmpQVEVnY21WbVBURWdaR1ZpYkc5amF6MHhPakE2TUNCaGJtRnNlWE5sUFRCNE1Ub3dlREV4TVNCdFpUMW9aWGdnYzNWaWJXVTlNaUJ3YzNrOU1TQndjM2xmY21ROU1TNHdNRG93TGpBd0lHMXBlR1ZrWDNKbFpqMHdJRzFsWDNKaGJtZGxQVEUySUdOb2NtOXRZVjl0WlQweElIUnlaV3hzYVhNOU1DQTRlRGhrWTNROU1DQmpjVzA5TUNCa1pXRmtlbTl1WlQweU1Td3hNU0JtWVhOMFgzQnphMmx3UFRFZ1kyaHliMjFoWDNGd1gyOW1abk5sZEQwd0lIUm9jbVZoWkhNOU5pQnNiMjlyWVdobFlXUmZkR2h5WldGa2N6MHhJSE5zYVdObFpGOTBhSEpsWVdSelBUQWdibkk5TUNCa1pXTnBiV0YwWlQweElHbHVkR1Z5YkdGalpXUTlNQ0JpYkhWeVlYbGZZMjl0Y0dGMFBUQWdZMjl1YzNSeVlXbHVaV1JmYVc1MGNtRTlNQ0JpWm5KaGJXVnpQVE1nWWw5d2VYSmhiV2xrUFRJZ1lsOWhaR0Z3ZEQweElHSmZZbWxoY3owd0lHUnBjbVZqZEQweElIZGxhV2RvZEdJOU1TQnZjR1Z1WDJkdmNEMHdJSGRsYVdkb2RIQTlNU0JyWlhscGJuUTlNekF3SUd0bGVXbHVkRjl0YVc0OU16QWdjMk5sYm1WamRYUTlOREFnYVc1MGNtRmZjbVZtY21WemFEMHdJSEpqWDJ4dmIydGhhR1ZoWkQweE1DQnlZejFqY21ZZ2JXSjBjbVZsUFRFZ1kzSm1QVEl3TGpBZ2NXTnZiWEE5TUM0Mk1DQnhjRzFwYmowd0lIRndiV0Y0UFRZNUlIRndjM1JsY0QwMElIWmlkbDl0WVhoeVlYUmxQVEl3TURBd0lIWmlkbDlpZFdaemFYcGxQVEkxTURBd0lHTnlabDl0WVhnOU1DNHdJRzVoYkY5b2NtUTlibTl1WlNCbWFXeHNaWEk5TUNCcGNGOXlZWFJwYnoweExqUXdJR0Z4UFRFNk1TNHdNQUNBQUFBQU9XV0loQUEzLy9wK0M3djh0RERTVGpmOTd3NTVpM1NiUlBPNFpZK2hrakQ1aGJrQWtMM3pwSjZoL0xSMUNBQUJ6Z0Ixa3FxelVvcmxoUUFBQUF4Qm1pUVlobi8rcVpZQURMZ0FBQUFKUVo1Q1FoWC9BQWo1SVFBRFFHZ2NJUUFEUUdnY0FBQUFDUUdlWVVRbi93QUxLQ0VBQTBCb0hBQUFBQWtCbm1ORUovOEFDeWtoQUFOQWFCd2hBQU5BYUJ3QUFBQU5RWnBvTkV4RFAvNnBsZ0FNdVNFQUEwQm9IQUFBQUF0Qm5vWkZFU3dyL3dBSStTRUFBMEJvSENFQUEwQm9IQUFBQUFrQm5xVkVKLzhBQ3lraEFBTkFhQndBQUFBSkFaNm5SQ2YvQUFzb0lRQURRR2djSVFBRFFHZ2NBQUFBRFVHYXJEUk1Rei8rcVpZQURMZ2hBQU5BYUJ3QUFBQUxRWjdLUlJVc0svOEFDUGtoQUFOQWFCd0FBQUFKQVo3cFJDZi9BQXNvSVFBRFFHZ2NJUUFEUUdnY0FBQUFDUUdlNjBRbi93QUxLQ0VBQTBCb0hBQUFBQTFCbXZBMFRFTS8vcW1XQUF5NUlRQURRR2djSVFBRFFHZ2NBQUFBQzBHZkRrVVZMQ3YvQUFqNUlRQURRR2djQUFBQUNRR2ZMVVFuL3dBTEtTRUFBMEJvSENFQUEwQm9IQUFBQUFrQm55OUVKLzhBQ3lnaEFBTkFhQndBQUFBTlFaczBORXhEUC82cGxnQU11Q0VBQTBCb0hBQUFBQXRCbjFKRkZTd3Ivd0FJK1NFQUEwQm9IQ0VBQTBCb0hBQUFBQWtCbjNGRUovOEFDeWdoQUFOQWFCd0FBQUFKQVo5elJDZi9BQXNvSVFBRFFHZ2NJUUFEUUdnY0FBQUFEVUdiZURSTVF6LytxWllBRExraEFBTkFhQndBQUFBTFFaK1dSUlVzSy84QUNQZ2hBQU5BYUJ3aEFBTkFhQndBQUFBSkFaKzFSQ2YvQUFzcElRQURRR2djQUFBQUNRR2Z0MFFuL3dBTEtTRUFBMEJvSENFQUEwQm9IQUFBQUExQm03dzBURU0vL3FtV0FBeTRJUUFEUUdnY0FBQUFDMEdmMmtVVkxDdi9BQWo1SVFBRFFHZ2NBQUFBQ1FHZitVUW4vd0FMS0NFQUEwQm9IQ0VBQTBCb0hBQUFBQWtCbi90RUovOEFDeWtoQUFOQWFCd0FBQUFOUVp2Z05FeERQLzZwbGdBTXVTRUFBMEJvSENFQUEwQm9IQUFBQUF0Qm5oNUZGU3dyL3dBSStDRUFBMEJvSEFBQUFBa0JuajFFSi84QUN5Z2hBQU5BYUJ3aEFBTkFhQndBQUFBSkFaNC9SQ2YvQUFzcElRQURRR2djQUFBQURVR2FKRFJNUXovK3FaWUFETGdoQUFOQWFCd0FBQUFMUVo1Q1JSVXNLLzhBQ1BraEFBTkFhQndoQUFOQWFCd0FBQUFKQVo1aFJDZi9BQXNvSVFBRFFHZ2NBQUFBQ1FHZVkwUW4vd0FMS1NFQUEwQm9IQ0VBQTBCb0hBQUFBQTFCbW1nMFRFTS8vcW1XQUF5NUlRQURRR2djQUFBQUMwR2Voa1VWTEN2L0FBajVJUUFEUUdnY0lRQURRR2djQUFBQUNRR2VwVVFuL3dBTEtTRUFBMEJvSEFBQUFBa0JucWRFSi84QUN5Z2hBQU5BYUJ3QUFBQU5RWnFzTkV4RFAvNnBsZ0FNdUNFQUEwQm9IQ0VBQTBCb0hBQUFBQXRCbnNwRkZTd3Ivd0FJK1NFQUEwQm9IQUFBQUFrQm51bEVKLzhBQ3lnaEFBTkFhQndoQUFOQWFCd0FBQUFKQVo3clJDZi9BQXNvSVFBRFFHZ2NBQUFBRFVHYThEUk1Rei8rcVpZQURMa2hBQU5BYUJ3aEFBTkFhQndBQUFBTFFaOE9SUlVzSy84QUNQa2hBQU5BYUJ3QUFBQUpBWjh0UkNmL0FBc3BJUUFEUUdnY0lRQURRR2djQUFBQUNRR2ZMMFFuL3dBTEtDRUFBMEJvSEFBQUFBMUJtelEwVEVNLy9xbVdBQXk0SVFBRFFHZ2NBQUFBQzBHZlVrVVZMQ3YvQUFqNUlRQURRR2djSVFBRFFHZ2NBQUFBQ1FHZmNVUW4vd0FMS0NFQUEwQm9IQUFBQUFrQm4zTkVKLzhBQ3lnaEFBTkFhQndoQUFOQWFCd0FBQUFOUVp0NE5FeEMvLzZwbGdBTXVTRUFBMEJvSEFBQUFBdEJuNVpGRlN3ci93QUkrQ0VBQTBCb0hDRUFBMEJvSEFBQUFBa0JuN1ZFSi84QUN5a2hBQU5BYUJ3QUFBQUpBWiszUkNmL0FBc3BJUUFEUUdnY0FBQUFEVUdidXpSTVFuLytuaEFBWXNBaEFBTkFhQndoQUFOQWFCd0FBQUFKUVovYVFoUC9BQXNwSVFBRFFHZ2NBQUFBQ1FHZitVUW4vd0FMS0NFQUEwQm9IQ0VBQTBCb0hDRUFBMEJvSENFQUEwQm9IQ0VBQTBCb0hDRUFBMEJvSEFBQUNpRnRiMjkyQUFBQWJHMTJhR1FBQUFBQTFZQ0NYOVdBZ2w4QUFBUG9BQUFIL0FBQkFBQUJBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFEQUFBQUdHbHZaSE1BQUFBQUVJQ0FnQWNBVC8vLy92Ny9BQUFGK1hSeVlXc0FBQUJjZEd0b1pBQUFBQVBWZ0lKZjFZQ0NYd0FBQUFFQUFBQUFBQUFIMEFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBeWdBQUFNb0FBQUFBQUNSbFpIUnpBQUFBSEdWc2MzUUFBQUFBQUFBQUFRQUFCOUFBQUJkd0FBRUFBQUFBQlhGdFpHbGhBQUFBSUcxa2FHUUFBQUFBMVlDQ1g5V0FnbDhBQVYrUUFBSy9JRlhFQUFBQUFBQXRhR1JzY2dBQUFBQUFBQUFBZG1sa1pRQUFBQUFBQUFBQUFBQUFBRlpwWkdWdlNHRnVaR3hsY2dBQUFBVWNiV2x1WmdBQUFCUjJiV2hrQUFBQUFRQUFBQUFBQUFBQUFBQUFKR1JwYm1ZQUFBQWNaSEpsWmdBQUFBQUFBQUFCQUFBQURIVnliQ0FBQUFBQkFBQUUzSE4wWW13QUFBQ1ljM1J6WkFBQUFBQUFBQUFCQUFBQWlHRjJZekVBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUF5Z0RLQUVnQUFBQklBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBWS8vOEFBQUF5WVhaalF3Rk5RQ2ovNFFBYlowMUFLT3lobzN5U1RVQkFRRkFBQUFNQUVBQXI4Z0R4Z3hsZ0FRQUVhTytHOGdBQUFCaHpkSFJ6QUFBQUFBQUFBQUVBQUFBOEFBQUx1QUFBQUJSemRITnpBQUFBQUFBQUFBRUFBQUFCQUFBQjhHTjBkSE1BQUFBQUFBQUFQQUFBQUFFQUFCZHdBQUFBQVFBQU9wZ0FBQUFCQUFBWGNBQUFBQUVBQUFBQUFBQUFBUUFBQzdnQUFBQUJBQUE2bUFBQUFBRUFBQmR3QUFBQUFRQUFBQUFBQUFBQkFBQUx1QUFBQUFFQUFEcVlBQUFBQVFBQUYzQUFBQUFCQUFBQUFBQUFBQUVBQUF1NEFBQUFBUUFBT3BnQUFBQUJBQUFYY0FBQUFBRUFBQUFBQUFBQUFRQUFDN2dBQUFBQkFBQTZtQUFBQUFFQUFCZHdBQUFBQVFBQUFBQUFBQUFCQUFBTHVBQUFBQUVBQURxWUFBQUFBUUFBRjNBQUFBQUJBQUFBQUFBQUFBRUFBQXU0QUFBQUFRQUFPcGdBQUFBQkFBQVhjQUFBQUFFQUFBQUFBQUFBQVFBQUM3Z0FBQUFCQUFBNm1BQUFBQUVBQUJkd0FBQUFBUUFBQUFBQUFBQUJBQUFMdUFBQUFBRUFBRHFZQUFBQUFRQUFGM0FBQUFBQkFBQUFBQUFBQUFFQUFBdTRBQUFBQVFBQU9wZ0FBQUFCQUFBWGNBQUFBQUVBQUFBQUFBQUFBUUFBQzdnQUFBQUJBQUE2bUFBQUFBRUFBQmR3QUFBQUFRQUFBQUFBQUFBQkFBQUx1QUFBQUFFQUFEcVlBQUFBQVFBQUYzQUFBQUFCQUFBQUFBQUFBQUVBQUF1NEFBQUFBUUFBT3BnQUFBQUJBQUFYY0FBQUFBRUFBQUFBQUFBQUFRQUFDN2dBQUFBQkFBQTZtQUFBQUFFQUFCZHdBQUFBQVFBQUFBQUFBQUFCQUFBTHVBQUFBQUVBQUM3Z0FBQUFBUUFBRjNBQUFBQUJBQUFBQUFBQUFCeHpkSE5qQUFBQUFBQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBRUVjM1J6ZWdBQUFBQUFBQUFBQUFBQVBBQUFBelFBQUFBUUFBQUFEUUFBQUEwQUFBQU5BQUFBRVFBQUFBOEFBQUFOQUFBQURRQUFBQkVBQUFBUEFBQUFEUUFBQUEwQUFBQVJBQUFBRHdBQUFBMEFBQUFOQUFBQUVRQUFBQThBQUFBTkFBQUFEUUFBQUJFQUFBQVBBQUFBRFFBQUFBMEFBQUFSQUFBQUR3QUFBQTBBQUFBTkFBQUFFUUFBQUE4QUFBQU5BQUFBRFFBQUFCRUFBQUFQQUFBQURRQUFBQTBBQUFBUkFBQUFEd0FBQUEwQUFBQU5BQUFBRVFBQUFBOEFBQUFOQUFBQURRQUFBQkVBQUFBUEFBQUFEUUFBQUEwQUFBQVJBQUFBRHdBQUFBMEFBQUFOQUFBQUVRQUFBQThBQUFBTkFBQUFEUUFBQUJFQUFBQU5BQUFBRFFBQUFRQnpkR052QUFBQUFBQUFBRHdBQUFBd0FBQURaQUFBQTNRQUFBT05BQUFEb0FBQUE3a0FBQVBRQUFBRDZ3QUFBLzRBQUFRWEFBQUVMZ0FBQkVNQUFBUmNBQUFFYndBQUJJd0FBQVNoQUFBRXVnQUFCTTBBQUFUa0FBQUUvd0FBQlJJQUFBVXJBQUFGUWdBQUJWMEFBQVZ3QUFBRmlRQUFCYUFBQUFXMUFBQUZ6Z0FBQmVFQUFBWCtBQUFHRXdBQUJpd0FBQVkvQUFBR1ZnQUFCbkVBQUFhRUFBQUduUUFBQnJRQUFBYlBBQUFHNGdBQUJ2VUFBQWNTQUFBSEp3QUFCMEFBQUFkVEFBQUhjQUFBQjRVQUFBZWVBQUFIc1FBQUI4Z0FBQWZqQUFBSDlnQUFDQThBQUFnbUFBQUlRUUFBQ0ZRQUFBaG5BQUFJaEFBQUNKY0FBQU1zZEhKaGF3QUFBRngwYTJoa0FBQUFBOVdBZ2wvVmdJSmZBQUFBQWdBQUFBQUFBQWY4QUFBQUFBQUFBQUFBQUFBQkFRQUFBQUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFDc20xa2FXRUFBQUFnYldSb1pBQUFBQURWZ0lKZjFZQ0NYd0FBckVRQUFXQUFWY1FBQUFBQUFDZG9aR3h5QUFBQUFBQUFBQUJ6YjNWdUFBQUFBQUFBQUFBQUFBQUFVM1JsY21WdkFBQUFBbU50YVc1bUFBQUFFSE50YUdRQUFBQUFBQUFBQUFBQUFDUmthVzVtQUFBQUhHUnlaV1lBQUFBQUFBQUFBUUFBQUF4MWNtd2dBQUFBQVFBQUFpZHpkR0pzQUFBQVozTjBjMlFBQUFBQUFBQUFBUUFBQUZkdGNEUmhBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUNBQkFBQUFBQXJFUUFBQUFBQURObGMyUnpBQUFBQUFPQWdJQWlBQUlBQklDQWdCUkFGUUFBQUFBRERVQUFBQUFBQllDQWdBSVNFQWFBZ0lBQkFnQUFBQmh6ZEhSekFBQUFBQUFBQUFFQUFBQllBQUFFQUFBQUFCeHpkSE5qQUFBQUFBQUFBQUVBQUFBQkFBQUFBUUFBQUFFQUFBQVVjM1J6ZWdBQUFBQUFBQUFHQUFBQVdBQUFBWEJ6ZEdOdkFBQUFBQUFBQUZnQUFBT0JBQUFEaHdBQUE1b0FBQU90QUFBRHN3QUFBOG9BQUFQZkFBQUQ1UUFBQS9nQUFBUUxBQUFFRVFBQUJDZ0FBQVE5QUFBRVVBQUFCRllBQUFScEFBQUVnQUFBQklZQUFBU2JBQUFFcmdBQUJMUUFBQVRIQUFBRTNnQUFCUE1BQUFUNUFBQUZEQUFBQlI4QUFBVWxBQUFGUEFBQUJWRUFBQVZYQUFBRmFnQUFCWDBBQUFXREFBQUZtZ0FBQmE4QUFBWENBQUFGeUFBQUJkc0FBQVh5QUFBRitBQUFCZzBBQUFZZ0FBQUdKZ0FBQmprQUFBWlFBQUFHWlFBQUJtc0FBQVorQUFBR2tRQUFCcGNBQUFhdUFBQUd3d0FBQnNrQUFBYmNBQUFHN3dBQUJ3WUFBQWNNQUFBSElRQUFCelFBQUFjNkFBQUhUUUFBQjJRQUFBZHFBQUFIZndBQUI1SUFBQWVZQUFBSHF3QUFCOElBQUFmWEFBQUgzUUFBQi9BQUFBZ0RBQUFJQ1FBQUNDQUFBQWcxQUFBSU93QUFDRTRBQUFoaEFBQUllQUFBQ0g0QUFBaVJBQUFJcEFBQUNLb0FBQWl3QUFBSXRnQUFDTHdBQUFqQ0FBQUFGblZrZEdFQUFBQU9ibUZ0WlZOMFpYSmxid0FBQUhCMVpIUmhBQUFBYUcxbGRHRUFBQUFBQUFBQUlXaGtiSElBQUFBQUFBQUFBRzFrYVhKaGNIQnNBQUFBQUFBQUFBQUFBQUFBTzJsc2MzUUFBQUF6cVhSdmJ3QUFBQ3RrWVhSaEFBQUFBUUFBQUFCSVlXNWtRbkpoYTJVZ01DNHhNQzR5SURJd01UVXdOakV4TURBPSc7XG4gICAgICB9KVxuICAgICAgICAgXSk7XG59KTtcbn0pO1xudmFyIE5vU2xlZXAkMSA9IHVud3JhcEV4cG9ydHMkJDEoTm9TbGVlcCk7XG52YXIgbmV4dERpc3BsYXlJZCA9IDEwMDA7XG52YXIgZGVmYXVsdExlZnRCb3VuZHMgPSBbMCwgMCwgMC41LCAxXTtcbnZhciBkZWZhdWx0UmlnaHRCb3VuZHMgPSBbMC41LCAwLCAwLjUsIDFdO1xudmFyIHJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG52YXIgY2FmID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuZnVuY3Rpb24gVlJGcmFtZURhdGEoKSB7XG4gIHRoaXMubGVmdFByb2plY3Rpb25NYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgdGhpcy5sZWZ0Vmlld01hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICB0aGlzLnJpZ2h0UHJvamVjdGlvbk1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICB0aGlzLnJpZ2h0Vmlld01hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xuICB0aGlzLnBvc2UgPSBudWxsO1xufVxuZnVuY3Rpb24gVlJEaXNwbGF5Q2FwYWJpbGl0aWVzKGNvbmZpZykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgaGFzUG9zaXRpb246IHtcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSwgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IGNvbmZpZy5oYXNQb3NpdGlvblxuICAgIH0sXG4gICAgaGFzRXh0ZXJuYWxEaXNwbGF5OiB7XG4gICAgICB3cml0YWJsZTogZmFsc2UsIGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBjb25maWcuaGFzRXh0ZXJuYWxEaXNwbGF5XG4gICAgfSxcbiAgICBjYW5QcmVzZW50OiB7XG4gICAgICB3cml0YWJsZTogZmFsc2UsIGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBjb25maWcuY2FuUHJlc2VudFxuICAgIH0sXG4gICAgbWF4TGF5ZXJzOiB7XG4gICAgICB3cml0YWJsZTogZmFsc2UsIGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiBjb25maWcubWF4TGF5ZXJzXG4gICAgfSxcbiAgICBoYXNPcmllbnRhdGlvbjoge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGRlcHJlY2F0ZVdhcm5pbmcoJ1ZSRGlzcGxheUNhcGFiaWxpdGllcy5wcm90b3R5cGUuaGFzT3JpZW50YXRpb24nLCAnVlJEaXNwbGF5LnByb3RvdHlwZS5nZXRGcmFtZURhdGEnKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5oYXNPcmllbnRhdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gVlJEaXNwbGF5KGNvbmZpZykge1xuICBjb25maWcgPSBjb25maWcgfHwge307XG4gIHZhciBVU0VfV0FLRUxPQ0sgPSAnd2FrZWxvY2snIGluIGNvbmZpZyA/IGNvbmZpZy53YWtlbG9jayA6IHRydWU7XG4gIHRoaXMuaXNQb2x5ZmlsbGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXNwbGF5SWQgPSBuZXh0RGlzcGxheUlkKys7XG4gIHRoaXMuZGlzcGxheU5hbWUgPSAnJztcbiAgdGhpcy5kZXB0aE5lYXIgPSAwLjAxO1xuICB0aGlzLmRlcHRoRmFyID0gMTAwMDAuMDtcbiAgdGhpcy5pc1ByZXNlbnRpbmcgPSBmYWxzZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdpc0Nvbm5lY3RlZCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGRlcHJlY2F0ZVdhcm5pbmcoJ1ZSRGlzcGxheS5wcm90b3R5cGUuaXNDb25uZWN0ZWQnLCAnVlJEaXNwbGF5Q2FwYWJpbGl0aWVzLnByb3RvdHlwZS5oYXNFeHRlcm5hbERpc3BsYXknKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICB0aGlzLmNhcGFiaWxpdGllcyA9IG5ldyBWUkRpc3BsYXlDYXBhYmlsaXRpZXMoe1xuICAgIGhhc1Bvc2l0aW9uOiBmYWxzZSxcbiAgICBoYXNPcmllbnRhdGlvbjogZmFsc2UsXG4gICAgaGFzRXh0ZXJuYWxEaXNwbGF5OiBmYWxzZSxcbiAgICBjYW5QcmVzZW50OiBmYWxzZSxcbiAgICBtYXhMYXllcnM6IDFcbiAgfSk7XG4gIHRoaXMuc3RhZ2VQYXJhbWV0ZXJzID0gbnVsbDtcbiAgdGhpcy53YWl0aW5nRm9yUHJlc2VudF8gPSBmYWxzZTtcbiAgdGhpcy5sYXllcl8gPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsUGFyZW50XyA9IG51bGw7XG4gIHRoaXMuZnVsbHNjcmVlbkVsZW1lbnRfID0gbnVsbDtcbiAgdGhpcy5mdWxsc2NyZWVuV3JhcHBlcl8gPSBudWxsO1xuICB0aGlzLmZ1bGxzY3JlZW5FbGVtZW50Q2FjaGVkU3R5bGVfID0gbnVsbDtcbiAgdGhpcy5mdWxsc2NyZWVuRXZlbnRUYXJnZXRfID0gbnVsbDtcbiAgdGhpcy5mdWxsc2NyZWVuQ2hhbmdlSGFuZGxlcl8gPSBudWxsO1xuICB0aGlzLmZ1bGxzY3JlZW5FcnJvckhhbmRsZXJfID0gbnVsbDtcbiAgaWYgKFVTRV9XQUtFTE9DSyAmJiBpc01vYmlsZSgpKSB7XG4gICAgdGhpcy53YWtlbG9ja18gPSBuZXcgTm9TbGVlcCQxKCk7XG4gIH1cbn1cblZSRGlzcGxheS5wcm90b3R5cGUuZ2V0RnJhbWVEYXRhID0gZnVuY3Rpb24gKGZyYW1lRGF0YSkge1xuICByZXR1cm4gZnJhbWVEYXRhRnJvbVBvc2UoZnJhbWVEYXRhLCB0aGlzLl9nZXRQb3NlKCksIHRoaXMpO1xufTtcblZSRGlzcGxheS5wcm90b3R5cGUuZ2V0UG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVwcmVjYXRlV2FybmluZygnVlJEaXNwbGF5LnByb3RvdHlwZS5nZXRQb3NlJywgJ1ZSRGlzcGxheS5wcm90b3R5cGUuZ2V0RnJhbWVEYXRhJyk7XG4gIHJldHVybiB0aGlzLl9nZXRQb3NlKCk7XG59O1xuVlJEaXNwbGF5LnByb3RvdHlwZS5yZXNldFBvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlcHJlY2F0ZVdhcm5pbmcoJ1ZSRGlzcGxheS5wcm90b3R5cGUucmVzZXRQb3NlJyk7XG4gIHJldHVybiB0aGlzLl9yZXNldFBvc2UoKTtcbn07XG5WUkRpc3BsYXkucHJvdG90eXBlLmdldEltbWVkaWF0ZVBvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlcHJlY2F0ZVdhcm5pbmcoJ1ZSRGlzcGxheS5wcm90b3R5cGUuZ2V0SW1tZWRpYXRlUG9zZScsICdWUkRpc3BsYXkucHJvdG90eXBlLmdldEZyYW1lRGF0YScpO1xuICByZXR1cm4gdGhpcy5fZ2V0UG9zZSgpO1xufTtcblZSRGlzcGxheS5wcm90b3R5cGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHJldHVybiByYWYoY2FsbGJhY2spO1xufTtcblZSRGlzcGxheS5wcm90b3R5cGUuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIGNhZihpZCk7XG59O1xuVlJEaXNwbGF5LnByb3RvdHlwZS53cmFwRm9yRnVsbHNjcmVlbiA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIGlmIChpc0lPUygpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgaWYgKCF0aGlzLmZ1bGxzY3JlZW5XcmFwcGVyXykge1xuICAgIHRoaXMuZnVsbHNjcmVlbldyYXBwZXJfID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdmFyIGNzc1Byb3BlcnRpZXMgPSBbJ2hlaWdodDogJyArIE1hdGgubWluKHNjcmVlbi5oZWlnaHQsIHNjcmVlbi53aWR0aCkgKyAncHggIWltcG9ydGFudCcsICd0b3A6IDAgIWltcG9ydGFudCcsICdsZWZ0OiAwICFpbXBvcnRhbnQnLCAncmlnaHQ6IDAgIWltcG9ydGFudCcsICdib3JkZXI6IDAnLCAnbWFyZ2luOiAwJywgJ3BhZGRpbmc6IDAnLCAnei1pbmRleDogOTk5OTk5ICFpbXBvcnRhbnQnLCAncG9zaXRpb246IGZpeGVkJ107XG4gICAgdGhpcy5mdWxsc2NyZWVuV3JhcHBlcl8uc2V0QXR0cmlidXRlKCdzdHlsZScsIGNzc1Byb3BlcnRpZXMuam9pbignOyAnKSArICc7Jyk7XG4gICAgdGhpcy5mdWxsc2NyZWVuV3JhcHBlcl8uY2xhc3NMaXN0LmFkZCgnd2VidnItcG9seWZpbGwtZnVsbHNjcmVlbi13cmFwcGVyJyk7XG4gIH1cbiAgaWYgKHRoaXMuZnVsbHNjcmVlbkVsZW1lbnRfID09IGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5mdWxsc2NyZWVuV3JhcHBlcl87XG4gIH1cbiAgaWYgKHRoaXMuZnVsbHNjcmVlbkVsZW1lbnRfKSB7XG4gICAgaWYgKHRoaXMub3JpZ2luYWxQYXJlbnRfKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsUGFyZW50Xy5hcHBlbmRDaGlsZCh0aGlzLmZ1bGxzY3JlZW5FbGVtZW50Xyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZnVsbHNjcmVlbkVsZW1lbnRfLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5mdWxsc2NyZWVuRWxlbWVudF8pO1xuICAgIH1cbiAgfVxuICB0aGlzLmZ1bGxzY3JlZW5FbGVtZW50XyA9IGVsZW1lbnQ7XG4gIHRoaXMub3JpZ2luYWxQYXJlbnRfID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICBpZiAoIXRoaXMub3JpZ2luYWxQYXJlbnRfKSB7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgfVxuICBpZiAoIXRoaXMuZnVsbHNjcmVlbldyYXBwZXJfLnBhcmVudEVsZW1lbnQpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5mdWxsc2NyZWVuRWxlbWVudF8ucGFyZW50RWxlbWVudDtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMuZnVsbHNjcmVlbldyYXBwZXJfLCB0aGlzLmZ1bGxzY3JlZW5FbGVtZW50Xyk7XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuZnVsbHNjcmVlbkVsZW1lbnRfKTtcbiAgfVxuICB0aGlzLmZ1bGxzY3JlZW5XcmFwcGVyXy5pbnNlcnRCZWZvcmUodGhpcy5mdWxsc2NyZWVuRWxlbWVudF8sIHRoaXMuZnVsbHNjcmVlbldyYXBwZXJfLmZpcnN0Q2hpbGQpO1xuICB0aGlzLmZ1bGxzY3JlZW5FbGVtZW50Q2FjaGVkU3R5bGVfID0gdGhpcy5mdWxsc2NyZWVuRWxlbWVudF8uZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGZ1bmN0aW9uIGFwcGx5RnVsbHNjcmVlbkVsZW1lbnRTdHlsZSgpIHtcbiAgICBpZiAoIXNlbGYuZnVsbHNjcmVlbkVsZW1lbnRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjc3NQcm9wZXJ0aWVzID0gWydwb3NpdGlvbjogYWJzb2x1dGUnLCAndG9wOiAwJywgJ2xlZnQ6IDAnLCAnd2lkdGg6ICcgKyBNYXRoLm1heChzY3JlZW4ud2lkdGgsIHNjcmVlbi5oZWlnaHQpICsgJ3B4JywgJ2hlaWdodDogJyArIE1hdGgubWluKHNjcmVlbi5oZWlnaHQsIHNjcmVlbi53aWR0aCkgKyAncHgnLCAnYm9yZGVyOiAwJywgJ21hcmdpbjogMCcsICdwYWRkaW5nOiAwJ107XG4gICAgc2VsZi5mdWxsc2NyZWVuRWxlbWVudF8uc2V0QXR0cmlidXRlKCdzdHlsZScsIGNzc1Byb3BlcnRpZXMuam9pbignOyAnKSArICc7Jyk7XG4gIH1cbiAgYXBwbHlGdWxsc2NyZWVuRWxlbWVudFN0eWxlKCk7XG4gIHJldHVybiB0aGlzLmZ1bGxzY3JlZW5XcmFwcGVyXztcbn07XG5WUkRpc3BsYXkucHJvdG90eXBlLnJlbW92ZUZ1bGxzY3JlZW5XcmFwcGVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuZnVsbHNjcmVlbkVsZW1lbnRfKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBlbGVtZW50ID0gdGhpcy5mdWxsc2NyZWVuRWxlbWVudF87XG4gIGlmICh0aGlzLmZ1bGxzY3JlZW5FbGVtZW50Q2FjaGVkU3R5bGVfKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgdGhpcy5mdWxsc2NyZWVuRWxlbWVudENhY2hlZFN0eWxlXyk7XG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gIH1cbiAgdGhpcy5mdWxsc2NyZWVuRWxlbWVudF8gPSBudWxsO1xuICB0aGlzLmZ1bGxzY3JlZW5FbGVtZW50Q2FjaGVkU3R5bGVfID0gbnVsbDtcbiAgdmFyIHBhcmVudCA9IHRoaXMuZnVsbHNjcmVlbldyYXBwZXJfLnBhcmVudEVsZW1lbnQ7XG4gIHRoaXMuZnVsbHNjcmVlbldyYXBwZXJfLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICBpZiAodGhpcy5vcmlnaW5hbFBhcmVudF8gPT09IHBhcmVudCkge1xuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZWxlbWVudCwgdGhpcy5mdWxsc2NyZWVuV3JhcHBlcl8pO1xuICB9XG4gIGVsc2UgaWYgKHRoaXMub3JpZ2luYWxQYXJlbnRfKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsUGFyZW50Xy5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLmZ1bGxzY3JlZW5XcmFwcGVyXyk7XG4gIHJldHVybiBlbGVtZW50O1xufTtcblZSRGlzcGxheS5wcm90b3R5cGUucmVxdWVzdFByZXNlbnQgPSBmdW5jdGlvbiAobGF5ZXJzKSB7XG4gIHZhciB3YXNQcmVzZW50aW5nID0gdGhpcy5pc1ByZXNlbnRpbmc7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKCEobGF5ZXJzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgZGVwcmVjYXRlV2FybmluZygnVlJEaXNwbGF5LnByb3RvdHlwZS5yZXF1ZXN0UHJlc2VudCB3aXRoIG5vbi1hcnJheSBhcmd1bWVudCcsICdhbiBhcnJheSBvZiBWUkxheWVycyBhcyB0aGUgZmlyc3QgYXJndW1lbnQnKTtcbiAgICBsYXllcnMgPSBbbGF5ZXJzXTtcbiAgfVxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmICghc2VsZi5jYXBhYmlsaXRpZXMuY2FuUHJlc2VudCkge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcignVlJEaXNwbGF5IGlzIG5vdCBjYXBhYmxlIG9mIHByZXNlbnRpbmcuJykpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobGF5ZXJzLmxlbmd0aCA9PSAwIHx8IGxheWVycy5sZW5ndGggPiBzZWxmLmNhcGFiaWxpdGllcy5tYXhMYXllcnMpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIGxheWVycy4nKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbmNvbWluZ0xheWVyID0gbGF5ZXJzWzBdO1xuICAgIGlmICghaW5jb21pbmdMYXllci5zb3VyY2UpIHtcbiAgICAgIHJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxlZnRCb3VuZHMgPSBpbmNvbWluZ0xheWVyLmxlZnRCb3VuZHMgfHwgZGVmYXVsdExlZnRCb3VuZHM7XG4gICAgdmFyIHJpZ2h0Qm91bmRzID0gaW5jb21pbmdMYXllci5yaWdodEJvdW5kcyB8fCBkZWZhdWx0UmlnaHRCb3VuZHM7XG4gICAgaWYgKHdhc1ByZXNlbnRpbmcpIHtcbiAgICAgIHZhciBsYXllciA9IHNlbGYubGF5ZXJfO1xuICAgICAgaWYgKGxheWVyLnNvdXJjZSAhPT0gaW5jb21pbmdMYXllci5zb3VyY2UpIHtcbiAgICAgICAgbGF5ZXIuc291cmNlID0gaW5jb21pbmdMYXllci5zb3VyY2U7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICBsYXllci5sZWZ0Qm91bmRzW2ldID0gbGVmdEJvdW5kc1tpXTtcbiAgICAgICAgbGF5ZXIucmlnaHRCb3VuZHNbaV0gPSByaWdodEJvdW5kc1tpXTtcbiAgICAgIH1cbiAgICAgIHNlbGYud3JhcEZvckZ1bGxzY3JlZW4oc2VsZi5sYXllcl8uc291cmNlKTtcbiAgICAgIHNlbGYudXBkYXRlUHJlc2VudF8oKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZi5sYXllcl8gPSB7XG4gICAgICBwcmVkaXN0b3J0ZWQ6IGluY29taW5nTGF5ZXIucHJlZGlzdG9ydGVkLFxuICAgICAgc291cmNlOiBpbmNvbWluZ0xheWVyLnNvdXJjZSxcbiAgICAgIGxlZnRCb3VuZHM6IGxlZnRCb3VuZHMuc2xpY2UoMCksXG4gICAgICByaWdodEJvdW5kczogcmlnaHRCb3VuZHMuc2xpY2UoMClcbiAgICB9O1xuICAgIHNlbGYud2FpdGluZ0ZvclByZXNlbnRfID0gZmFsc2U7XG4gICAgaWYgKHNlbGYubGF5ZXJfICYmIHNlbGYubGF5ZXJfLnNvdXJjZSkge1xuICAgICAgdmFyIGZ1bGxzY3JlZW5FbGVtZW50ID0gc2VsZi53cmFwRm9yRnVsbHNjcmVlbihzZWxmLmxheWVyXy5zb3VyY2UpO1xuICAgICAgdmFyIG9uRnVsbHNjcmVlbkNoYW5nZSA9IGZ1bmN0aW9uIG9uRnVsbHNjcmVlbkNoYW5nZSgpIHtcbiAgICAgICAgdmFyIGFjdHVhbEZ1bGxzY3JlZW5FbGVtZW50ID0gZ2V0RnVsbHNjcmVlbkVsZW1lbnQoKTtcbiAgICAgICAgc2VsZi5pc1ByZXNlbnRpbmcgPSBmdWxsc2NyZWVuRWxlbWVudCA9PT0gYWN0dWFsRnVsbHNjcmVlbkVsZW1lbnQ7XG4gICAgICAgIGlmIChzZWxmLmlzUHJlc2VudGluZykge1xuICAgICAgICAgIGlmIChzY3JlZW4ub3JpZW50YXRpb24gJiYgc2NyZWVuLm9yaWVudGF0aW9uLmxvY2spIHtcbiAgICAgICAgICAgIHNjcmVlbi5vcmllbnRhdGlvbi5sb2NrKCdsYW5kc2NhcGUtcHJpbWFyeScpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdzY3JlZW4ub3JpZW50YXRpb24ubG9jaygpIGZhaWxlZCBkdWUgdG8nLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxmLndhaXRpbmdGb3JQcmVzZW50XyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuYmVnaW5QcmVzZW50XygpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2NyZWVuLm9yaWVudGF0aW9uICYmIHNjcmVlbi5vcmllbnRhdGlvbi51bmxvY2spIHtcbiAgICAgICAgICAgIHNjcmVlbi5vcmllbnRhdGlvbi51bmxvY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5yZW1vdmVGdWxsc2NyZWVuV3JhcHBlcigpO1xuICAgICAgICAgIHNlbGYuZGlzYWJsZVdha2VMb2NrKCk7XG4gICAgICAgICAgc2VsZi5lbmRQcmVzZW50XygpO1xuICAgICAgICAgIHNlbGYucmVtb3ZlRnVsbHNjcmVlbkxpc3RlbmVyc18oKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmZpcmVWUkRpc3BsYXlQcmVzZW50Q2hhbmdlXygpO1xuICAgICAgfTtcbiAgICAgIHZhciBvbkZ1bGxzY3JlZW5FcnJvciA9IGZ1bmN0aW9uIG9uRnVsbHNjcmVlbkVycm9yKCkge1xuICAgICAgICBpZiAoIXNlbGYud2FpdGluZ0ZvclByZXNlbnRfKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYucmVtb3ZlRnVsbHNjcmVlbldyYXBwZXIoKTtcbiAgICAgICAgc2VsZi5yZW1vdmVGdWxsc2NyZWVuTGlzdGVuZXJzXygpO1xuICAgICAgICBzZWxmLmRpc2FibGVXYWtlTG9jaygpO1xuICAgICAgICBzZWxmLndhaXRpbmdGb3JQcmVzZW50XyA9IGZhbHNlO1xuICAgICAgICBzZWxmLmlzUHJlc2VudGluZyA9IGZhbHNlO1xuICAgICAgICByZWplY3QobmV3IEVycm9yKCdVbmFibGUgdG8gcHJlc2VudC4nKSk7XG4gICAgICB9O1xuICAgICAgc2VsZi5hZGRGdWxsc2NyZWVuTGlzdGVuZXJzXyhmdWxsc2NyZWVuRWxlbWVudCwgb25GdWxsc2NyZWVuQ2hhbmdlLCBvbkZ1bGxzY3JlZW5FcnJvcik7XG4gICAgICBpZiAocmVxdWVzdEZ1bGxzY3JlZW4oZnVsbHNjcmVlbkVsZW1lbnQpKSB7XG4gICAgICAgIHNlbGYuZW5hYmxlV2FrZUxvY2soKTtcbiAgICAgICAgc2VsZi53YWl0aW5nRm9yUHJlc2VudF8gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChpc0lPUygpIHx8IGlzV2ViVmlld0FuZHJvaWQoKSkge1xuICAgICAgICBzZWxmLmVuYWJsZVdha2VMb2NrKCk7XG4gICAgICAgIHNlbGYuaXNQcmVzZW50aW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5iZWdpblByZXNlbnRfKCk7XG4gICAgICAgIHNlbGYuZmlyZVZSRGlzcGxheVByZXNlbnRDaGFuZ2VfKCk7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzZWxmLndhaXRpbmdGb3JQcmVzZW50XyAmJiAhaXNJT1MoKSkge1xuICAgICAgZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1VuYWJsZSB0byBwcmVzZW50LicpKTtcbiAgICB9XG4gIH0pO1xufTtcblZSRGlzcGxheS5wcm90b3R5cGUuZXhpdFByZXNlbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB3YXNQcmVzZW50aW5nID0gdGhpcy5pc1ByZXNlbnRpbmc7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5pc1ByZXNlbnRpbmcgPSBmYWxzZTtcbiAgdGhpcy5sYXllcl8gPSBudWxsO1xuICB0aGlzLmRpc2FibGVXYWtlTG9jaygpO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmICh3YXNQcmVzZW50aW5nKSB7XG4gICAgICBpZiAoIWV4aXRGdWxsc2NyZWVuKCkgJiYgaXNJT1MoKSkge1xuICAgICAgICBzZWxmLmVuZFByZXNlbnRfKCk7XG4gICAgICAgIHNlbGYuZmlyZVZSRGlzcGxheVByZXNlbnRDaGFuZ2VfKCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNXZWJWaWV3QW5kcm9pZCgpKSB7XG4gICAgICAgIHNlbGYucmVtb3ZlRnVsbHNjcmVlbldyYXBwZXIoKTtcbiAgICAgICAgc2VsZi5yZW1vdmVGdWxsc2NyZWVuTGlzdGVuZXJzXygpO1xuICAgICAgICBzZWxmLmVuZFByZXNlbnRfKCk7XG4gICAgICAgIHNlbGYuZmlyZVZSRGlzcGxheVByZXNlbnRDaGFuZ2VfKCk7XG4gICAgICB9XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1dhcyBub3QgcHJlc2VudGluZyB0byBWUkRpc3BsYXkuJykpO1xuICAgIH1cbiAgfSk7XG59O1xuVlJEaXNwbGF5LnByb3RvdHlwZS5nZXRMYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxheWVyXykge1xuICAgIHJldHVybiBbdGhpcy5sYXllcl9dO1xuICB9XG4gIHJldHVybiBbXTtcbn07XG5WUkRpc3BsYXkucHJvdG90eXBlLmZpcmVWUkRpc3BsYXlQcmVzZW50Q2hhbmdlXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCd2cmRpc3BsYXlwcmVzZW50Y2hhbmdlJywgeyBkZXRhaWw6IHsgZGlzcGxheTogdGhpcyB9IH0pO1xuICB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG59O1xuVlJEaXNwbGF5LnByb3RvdHlwZS5maXJlVlJEaXNwbGF5Q29ubmVjdF8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgndnJkaXNwbGF5Y29ubmVjdCcsIHsgZGV0YWlsOiB7IGRpc3BsYXk6IHRoaXMgfSB9KTtcbiAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufTtcblZSRGlzcGxheS5wcm90b3R5cGUuYWRkRnVsbHNjcmVlbkxpc3RlbmVyc18gPSBmdW5jdGlvbiAoZWxlbWVudCwgY2hhbmdlSGFuZGxlciwgZXJyb3JIYW5kbGVyKSB7XG4gIHRoaXMucmVtb3ZlRnVsbHNjcmVlbkxpc3RlbmVyc18oKTtcbiAgdGhpcy5mdWxsc2NyZWVuRXZlbnRUYXJnZXRfID0gZWxlbWVudDtcbiAgdGhpcy5mdWxsc2NyZWVuQ2hhbmdlSGFuZGxlcl8gPSBjaGFuZ2VIYW5kbGVyO1xuICB0aGlzLmZ1bGxzY3JlZW5FcnJvckhhbmRsZXJfID0gZXJyb3JIYW5kbGVyO1xuICBpZiAoY2hhbmdlSGFuZGxlcikge1xuICAgIGlmIChkb2N1bWVudC5mdWxsc2NyZWVuRW5hYmxlZCkge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgY2hhbmdlSGFuZGxlciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVuYWJsZWQpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignd2Via2l0ZnVsbHNjcmVlbmNoYW5nZScsIGNoYW5nZUhhbmRsZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbmFibGVkKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3pmdWxsc2NyZWVuY2hhbmdlJywgY2hhbmdlSGFuZGxlciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQubXNGdWxsc2NyZWVuRW5hYmxlZCkge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtc2Z1bGxzY3JlZW5jaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIGlmIChlcnJvckhhbmRsZXIpIHtcbiAgICBpZiAoZG9jdW1lbnQuZnVsbHNjcmVlbkVuYWJsZWQpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmVycm9yJywgZXJyb3JIYW5kbGVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCkge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3ZWJraXRmdWxsc2NyZWVuZXJyb3InLCBlcnJvckhhbmRsZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbmFibGVkKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3pmdWxsc2NyZWVuZXJyb3InLCBlcnJvckhhbmRsZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50Lm1zRnVsbHNjcmVlbkVuYWJsZWQpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbXNmdWxsc2NyZWVuZXJyb3InLCBlcnJvckhhbmRsZXIsIGZhbHNlKTtcbiAgICB9XG4gIH1cbn07XG5WUkRpc3BsYXkucHJvdG90eXBlLnJlbW92ZUZ1bGxzY3JlZW5MaXN0ZW5lcnNfID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuZnVsbHNjcmVlbkV2ZW50VGFyZ2V0XykgcmV0dXJuO1xuICB2YXIgZWxlbWVudCA9IHRoaXMuZnVsbHNjcmVlbkV2ZW50VGFyZ2V0XztcbiAgaWYgKHRoaXMuZnVsbHNjcmVlbkNoYW5nZUhhbmRsZXJfKSB7XG4gICAgdmFyIGNoYW5nZUhhbmRsZXIgPSB0aGlzLmZ1bGxzY3JlZW5DaGFuZ2VIYW5kbGVyXztcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyLCBmYWxzZSk7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgY2hhbmdlSGFuZGxlciwgZmFsc2UpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vemZ1bGxzY3JlZW5jaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyLCBmYWxzZSk7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtc2Z1bGxzY3JlZW5jaGFuZ2UnLCBjaGFuZ2VIYW5kbGVyLCBmYWxzZSk7XG4gIH1cbiAgaWYgKHRoaXMuZnVsbHNjcmVlbkVycm9ySGFuZGxlcl8pIHtcbiAgICB2YXIgZXJyb3JIYW5kbGVyID0gdGhpcy5mdWxsc2NyZWVuRXJyb3JIYW5kbGVyXztcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5lcnJvcicsIGVycm9ySGFuZGxlciwgZmFsc2UpO1xuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2Via2l0ZnVsbHNjcmVlbmVycm9yJywgZXJyb3JIYW5kbGVyLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW96ZnVsbHNjcmVlbmVycm9yJywgZXJyb3JIYW5kbGVyLCBmYWxzZSk7XG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtc2Z1bGxzY3JlZW5lcnJvcicsIGVycm9ySGFuZGxlciwgZmFsc2UpO1xuICB9XG4gIHRoaXMuZnVsbHNjcmVlbkV2ZW50VGFyZ2V0XyA9IG51bGw7XG4gIHRoaXMuZnVsbHNjcmVlbkNoYW5nZUhhbmRsZXJfID0gbnVsbDtcbiAgdGhpcy5mdWxsc2NyZWVuRXJyb3JIYW5kbGVyXyA9IG51bGw7XG59O1xuVlJEaXNwbGF5LnByb3RvdHlwZS5lbmFibGVXYWtlTG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMud2FrZWxvY2tfKSB7XG4gICAgdGhpcy53YWtlbG9ja18uZW5hYmxlKCk7XG4gIH1cbn07XG5WUkRpc3BsYXkucHJvdG90eXBlLmRpc2FibGVXYWtlTG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMud2FrZWxvY2tfKSB7XG4gICAgdGhpcy53YWtlbG9ja18uZGlzYWJsZSgpO1xuICB9XG59O1xuVlJEaXNwbGF5LnByb3RvdHlwZS5iZWdpblByZXNlbnRfID0gZnVuY3Rpb24gKCkge1xufTtcblZSRGlzcGxheS5wcm90b3R5cGUuZW5kUHJlc2VudF8gPSBmdW5jdGlvbiAoKSB7XG59O1xuVlJEaXNwbGF5LnByb3RvdHlwZS5zdWJtaXRGcmFtZSA9IGZ1bmN0aW9uIChwb3NlKSB7XG59O1xuVlJEaXNwbGF5LnByb3RvdHlwZS5nZXRFeWVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHdoaWNoRXllKSB7XG4gIHJldHVybiBudWxsO1xufTtcbnZhciBjb25maWcgPSB7XG4gIEFERElUSU9OQUxfVklFV0VSUzogW10sXG4gIERFRkFVTFRfVklFV0VSOiAnJyxcbiAgTU9CSUxFX1dBS0VfTE9DSzogdHJ1ZSxcbiAgREVCVUc6IGZhbHNlLFxuICBEUERCX1VSTDogJ2h0dHBzOi8vZHBkYi53ZWJ2ci5yb2Nrcy9kcGRiLmpzb24nLFxuICBLX0ZJTFRFUjogMC45OCxcbiAgUFJFRElDVElPTl9USU1FX1M6IDAuMDQwLFxuICBDQVJEQk9BUkRfVUlfRElTQUJMRUQ6IGZhbHNlLFxuICBST1RBVEVfSU5TVFJVQ1RJT05TX0RJU0FCTEVEOiBmYWxzZSxcbiAgWUFXX09OTFk6IGZhbHNlLFxuICBCVUZGRVJfU0NBTEU6IDAuNSxcbiAgRElSVFlfU1VCTUlUX0ZSQU1FX0JJTkRJTkdTOiBmYWxzZVxufTtcbnZhciBFeWUgPSB7XG4gIExFRlQ6ICdsZWZ0JyxcbiAgUklHSFQ6ICdyaWdodCdcbn07XG5mdW5jdGlvbiBDYXJkYm9hcmRWUkRpc3BsYXkoY29uZmlnJCQxKSB7XG4gIHZhciBkZWZhdWx0cyA9IGV4dGVuZCh7fSwgY29uZmlnKTtcbiAgY29uZmlnJCQxID0gZXh0ZW5kKGRlZmF1bHRzLCBjb25maWckJDEgfHwge30pO1xuICBWUkRpc3BsYXkuY2FsbCh0aGlzLCB7XG4gICAgd2FrZWxvY2s6IGNvbmZpZyQkMS5NT0JJTEVfV0FLRV9MT0NLXG4gIH0pO1xuICB0aGlzLmNvbmZpZyA9IGNvbmZpZyQkMTtcbiAgdGhpcy5kaXNwbGF5TmFtZSA9ICdDYXJkYm9hcmQgVlJEaXNwbGF5JztcbiAgdGhpcy5jYXBhYmlsaXRpZXMgPSBuZXcgVlJEaXNwbGF5Q2FwYWJpbGl0aWVzKHtcbiAgICBoYXNQb3NpdGlvbjogZmFsc2UsXG4gICAgaGFzT3JpZW50YXRpb246IHRydWUsXG4gICAgaGFzRXh0ZXJuYWxEaXNwbGF5OiBmYWxzZSxcbiAgICBjYW5QcmVzZW50OiB0cnVlLFxuICAgIG1heExheWVyczogMVxuICB9KTtcbiAgdGhpcy5zdGFnZVBhcmFtZXRlcnMgPSBudWxsO1xuICB0aGlzLmJ1ZmZlclNjYWxlXyA9IHRoaXMuY29uZmlnLkJVRkZFUl9TQ0FMRTtcbiAgdGhpcy5wb3NlU2Vuc29yXyA9IG5ldyBQb3NlU2Vuc29yKHRoaXMuY29uZmlnKTtcbiAgdGhpcy5kaXN0b3J0ZXJfID0gbnVsbDtcbiAgdGhpcy5jYXJkYm9hcmRVSV8gPSBudWxsO1xuICB0aGlzLmRwZGJfID0gbmV3IERwZGIodGhpcy5jb25maWcuRFBEQl9VUkwsIHRoaXMub25EZXZpY2VQYXJhbXNVcGRhdGVkXy5iaW5kKHRoaXMpKTtcbiAgdGhpcy5kZXZpY2VJbmZvXyA9IG5ldyBEZXZpY2VJbmZvKHRoaXMuZHBkYl8uZ2V0RGV2aWNlUGFyYW1zKCksIGNvbmZpZyQkMS5BRERJVElPTkFMX1ZJRVdFUlMpO1xuICB0aGlzLnZpZXdlclNlbGVjdG9yXyA9IG5ldyBWaWV3ZXJTZWxlY3Rvcihjb25maWckJDEuREVGQVVMVF9WSUVXRVIpO1xuICB0aGlzLnZpZXdlclNlbGVjdG9yXy5vbkNoYW5nZSh0aGlzLm9uVmlld2VyQ2hhbmdlZF8uYmluZCh0aGlzKSk7XG4gIHRoaXMuZGV2aWNlSW5mb18uc2V0Vmlld2VyKHRoaXMudmlld2VyU2VsZWN0b3JfLmdldEN1cnJlbnRWaWV3ZXIoKSk7XG4gIGlmICghdGhpcy5jb25maWcuUk9UQVRFX0lOU1RSVUNUSU9OU19ESVNBQkxFRCkge1xuICAgIHRoaXMucm90YXRlSW5zdHJ1Y3Rpb25zXyA9IG5ldyBSb3RhdGVJbnN0cnVjdGlvbnMoKTtcbiAgfVxuICBpZiAoaXNJT1MoKSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLm9uUmVzaXplXy5iaW5kKHRoaXMpKTtcbiAgfVxufVxuQ2FyZGJvYXJkVlJEaXNwbGF5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVlJEaXNwbGF5LnByb3RvdHlwZSk7XG5DYXJkYm9hcmRWUkRpc3BsYXkucHJvdG90eXBlLl9nZXRQb3NlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBudWxsLFxuICAgIG9yaWVudGF0aW9uOiB0aGlzLnBvc2VTZW5zb3JfLmdldE9yaWVudGF0aW9uKCksXG4gICAgbGluZWFyVmVsb2NpdHk6IG51bGwsXG4gICAgbGluZWFyQWNjZWxlcmF0aW9uOiBudWxsLFxuICAgIGFuZ3VsYXJWZWxvY2l0eTogbnVsbCxcbiAgICBhbmd1bGFyQWNjZWxlcmF0aW9uOiBudWxsXG4gIH07XG59O1xuQ2FyZGJvYXJkVlJEaXNwbGF5LnByb3RvdHlwZS5fcmVzZXRQb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wb3NlU2Vuc29yXy5yZXNldFBvc2UpIHtcbiAgICB0aGlzLnBvc2VTZW5zb3JfLnJlc2V0UG9zZSgpO1xuICB9XG59O1xuQ2FyZGJvYXJkVlJEaXNwbGF5LnByb3RvdHlwZS5fZ2V0RmllbGRPZlZpZXcgPSBmdW5jdGlvbiAod2hpY2hFeWUpIHtcbiAgdmFyIGZpZWxkT2ZWaWV3O1xuICBpZiAod2hpY2hFeWUgPT0gRXllLkxFRlQpIHtcbiAgICBmaWVsZE9mVmlldyA9IHRoaXMuZGV2aWNlSW5mb18uZ2V0RmllbGRPZlZpZXdMZWZ0RXllKCk7XG4gIH0gZWxzZSBpZiAod2hpY2hFeWUgPT0gRXllLlJJR0hUKSB7XG4gICAgZmllbGRPZlZpZXcgPSB0aGlzLmRldmljZUluZm9fLmdldEZpZWxkT2ZWaWV3UmlnaHRFeWUoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKCdJbnZhbGlkIGV5ZSBwcm92aWRlZDogJXMnLCB3aGljaEV5ZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGZpZWxkT2ZWaWV3O1xufTtcbkNhcmRib2FyZFZSRGlzcGxheS5wcm90b3R5cGUuX2dldEV5ZU9mZnNldCA9IGZ1bmN0aW9uICh3aGljaEV5ZSkge1xuICB2YXIgb2Zmc2V0O1xuICBpZiAod2hpY2hFeWUgPT0gRXllLkxFRlQpIHtcbiAgICBvZmZzZXQgPSBbLXRoaXMuZGV2aWNlSW5mb18udmlld2VyLmludGVyTGVuc0Rpc3RhbmNlICogMC41LCAwLjAsIDAuMF07XG4gIH0gZWxzZSBpZiAod2hpY2hFeWUgPT0gRXllLlJJR0hUKSB7XG4gICAgb2Zmc2V0ID0gW3RoaXMuZGV2aWNlSW5mb18udmlld2VyLmludGVyTGVuc0Rpc3RhbmNlICogMC41LCAwLjAsIDAuMF07XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcignSW52YWxpZCBleWUgcHJvdmlkZWQ6ICVzJywgd2hpY2hFeWUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBvZmZzZXQ7XG59O1xuQ2FyZGJvYXJkVlJEaXNwbGF5LnByb3RvdHlwZS5nZXRFeWVQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHdoaWNoRXllKSB7XG4gIHZhciBvZmZzZXQgPSB0aGlzLl9nZXRFeWVPZmZzZXQod2hpY2hFeWUpO1xuICB2YXIgZmllbGRPZlZpZXcgPSB0aGlzLl9nZXRGaWVsZE9mVmlldyh3aGljaEV5ZSk7XG4gIHZhciBleWVQYXJhbXMgPSB7XG4gICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgcmVuZGVyV2lkdGg6IHRoaXMuZGV2aWNlSW5mb18uZGV2aWNlLndpZHRoICogMC41ICogdGhpcy5idWZmZXJTY2FsZV8sXG4gICAgcmVuZGVySGVpZ2h0OiB0aGlzLmRldmljZUluZm9fLmRldmljZS5oZWlnaHQgKiB0aGlzLmJ1ZmZlclNjYWxlX1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXllUGFyYW1zLCAnZmllbGRPZlZpZXcnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGRlcHJlY2F0ZVdhcm5pbmcoJ1ZSRmllbGRPZlZpZXcnLCAnVlJGcmFtZURhdGFcXCdzIHByb2plY3Rpb24gbWF0cmljZXMnKTtcbiAgICAgIHJldHVybiBmaWVsZE9mVmlldztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZXllUGFyYW1zO1xufTtcbkNhcmRib2FyZFZSRGlzcGxheS5wcm90b3R5cGUub25EZXZpY2VQYXJhbXNVcGRhdGVkXyA9IGZ1bmN0aW9uIChuZXdQYXJhbXMpIHtcbiAgaWYgKHRoaXMuY29uZmlnLkRFQlVHKSB7XG4gICAgY29uc29sZS5sb2coJ0RQREIgcmVwb3J0ZWQgdGhhdCBkZXZpY2UgcGFyYW1zIHdlcmUgdXBkYXRlZC4nKTtcbiAgfVxuICB0aGlzLmRldmljZUluZm9fLnVwZGF0ZURldmljZVBhcmFtcyhuZXdQYXJhbXMpO1xuICBpZiAodGhpcy5kaXN0b3J0ZXJfKSB7XG4gICAgdGhpcy5kaXN0b3J0ZXJfLnVwZGF0ZURldmljZUluZm8odGhpcy5kZXZpY2VJbmZvXyk7XG4gIH1cbn07XG5DYXJkYm9hcmRWUkRpc3BsYXkucHJvdG90eXBlLnVwZGF0ZUJvdW5kc18gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmxheWVyXyAmJiB0aGlzLmRpc3RvcnRlcl8gJiYgKHRoaXMubGF5ZXJfLmxlZnRCb3VuZHMgfHwgdGhpcy5sYXllcl8ucmlnaHRCb3VuZHMpKSB7XG4gICAgdGhpcy5kaXN0b3J0ZXJfLnNldFRleHR1cmVCb3VuZHModGhpcy5sYXllcl8ubGVmdEJvdW5kcywgdGhpcy5sYXllcl8ucmlnaHRCb3VuZHMpO1xuICB9XG59O1xuQ2FyZGJvYXJkVlJEaXNwbGF5LnByb3RvdHlwZS5iZWdpblByZXNlbnRfID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZ2wgPSB0aGlzLmxheWVyXy5zb3VyY2UuZ2V0Q29udGV4dCgnd2ViZ2wnKTtcbiAgaWYgKCFnbCkgZ2wgPSB0aGlzLmxheWVyXy5zb3VyY2UuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJyk7XG4gIGlmICghZ2wpIGdsID0gdGhpcy5sYXllcl8uc291cmNlLmdldENvbnRleHQoJ3dlYmdsMicpO1xuICBpZiAoIWdsKSByZXR1cm47XG4gIGlmICh0aGlzLmxheWVyXy5wcmVkaXN0b3J0ZWQpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLkNBUkRCT0FSRF9VSV9ESVNBQkxFRCkge1xuICAgICAgZ2wuY2FudmFzLndpZHRoID0gZ2V0U2NyZWVuV2lkdGgoKSAqIHRoaXMuYnVmZmVyU2NhbGVfO1xuICAgICAgZ2wuY2FudmFzLmhlaWdodCA9IGdldFNjcmVlbkhlaWdodCgpICogdGhpcy5idWZmZXJTY2FsZV87XG4gICAgICB0aGlzLmNhcmRib2FyZFVJXyA9IG5ldyBDYXJkYm9hcmRVSShnbCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghdGhpcy5jb25maWcuQ0FSREJPQVJEX1VJX0RJU0FCTEVEKSB7XG4gICAgICB0aGlzLmNhcmRib2FyZFVJXyA9IG5ldyBDYXJkYm9hcmRVSShnbCk7XG4gICAgfVxuICAgIHRoaXMuZGlzdG9ydGVyXyA9IG5ldyBDYXJkYm9hcmREaXN0b3J0ZXIoZ2wsIHRoaXMuY2FyZGJvYXJkVUlfLCB0aGlzLmNvbmZpZy5CVUZGRVJfU0NBTEUsIHRoaXMuY29uZmlnLkRJUlRZX1NVQk1JVF9GUkFNRV9CSU5ESU5HUyk7XG4gICAgdGhpcy5kaXN0b3J0ZXJfLnVwZGF0ZURldmljZUluZm8odGhpcy5kZXZpY2VJbmZvXyk7XG4gIH1cbiAgaWYgKHRoaXMuY2FyZGJvYXJkVUlfKSB7XG4gICAgdGhpcy5jYXJkYm9hcmRVSV8ubGlzdGVuKGZ1bmN0aW9uIChlKSB7XG4gICAgICB0aGlzLnZpZXdlclNlbGVjdG9yXy5zaG93KHRoaXMubGF5ZXJfLnNvdXJjZS5wYXJlbnRFbGVtZW50KTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfS5iaW5kKHRoaXMpLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcy5leGl0UHJlc2VudCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG4gIGlmICh0aGlzLnJvdGF0ZUluc3RydWN0aW9uc18pIHtcbiAgICBpZiAoaXNMYW5kc2NhcGVNb2RlKCkgJiYgaXNNb2JpbGUoKSkge1xuICAgICAgdGhpcy5yb3RhdGVJbnN0cnVjdGlvbnNfLnNob3dUZW1wb3JhcmlseSgzMDAwLCB0aGlzLmxheWVyXy5zb3VyY2UucGFyZW50RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucm90YXRlSW5zdHJ1Y3Rpb25zXy51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5vcmllbnRhdGlvbkhhbmRsZXIgPSB0aGlzLm9uT3JpZW50YXRpb25DaGFuZ2VfLmJpbmQodGhpcyk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsIHRoaXMub3JpZW50YXRpb25IYW5kbGVyKTtcbiAgdGhpcy52cmRpc3BsYXlwcmVzZW50Y2hhbmdlSGFuZGxlciA9IHRoaXMudXBkYXRlQm91bmRzXy5iaW5kKHRoaXMpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndnJkaXNwbGF5cHJlc2VudGNoYW5nZScsIHRoaXMudnJkaXNwbGF5cHJlc2VudGNoYW5nZUhhbmRsZXIpO1xuICB0aGlzLmZpcmVWUkRpc3BsYXlEZXZpY2VQYXJhbXNDaGFuZ2VfKCk7XG59O1xuQ2FyZGJvYXJkVlJEaXNwbGF5LnByb3RvdHlwZS5lbmRQcmVzZW50XyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZGlzdG9ydGVyXykge1xuICAgIHRoaXMuZGlzdG9ydGVyXy5kZXN0cm95KCk7XG4gICAgdGhpcy5kaXN0b3J0ZXJfID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5jYXJkYm9hcmRVSV8pIHtcbiAgICB0aGlzLmNhcmRib2FyZFVJXy5kZXN0cm95KCk7XG4gICAgdGhpcy5jYXJkYm9hcmRVSV8gPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLnJvdGF0ZUluc3RydWN0aW9uc18pIHtcbiAgICB0aGlzLnJvdGF0ZUluc3RydWN0aW9uc18uaGlkZSgpO1xuICB9XG4gIHRoaXMudmlld2VyU2VsZWN0b3JfLmhpZGUoKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJywgdGhpcy5vcmllbnRhdGlvbkhhbmRsZXIpO1xuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndnJkaXNwbGF5cHJlc2VudGNoYW5nZScsIHRoaXMudnJkaXNwbGF5cHJlc2VudGNoYW5nZUhhbmRsZXIpO1xufTtcbkNhcmRib2FyZFZSRGlzcGxheS5wcm90b3R5cGUudXBkYXRlUHJlc2VudF8gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW5kUHJlc2VudF8oKTtcbiAgdGhpcy5iZWdpblByZXNlbnRfKCk7XG59O1xuQ2FyZGJvYXJkVlJEaXNwbGF5LnByb3RvdHlwZS5zdWJtaXRGcmFtZSA9IGZ1bmN0aW9uIChwb3NlKSB7XG4gIGlmICh0aGlzLmRpc3RvcnRlcl8pIHtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kc18oKTtcbiAgICB0aGlzLmRpc3RvcnRlcl8uc3VibWl0RnJhbWUoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmNhcmRib2FyZFVJXyAmJiB0aGlzLmxheWVyXykge1xuICAgIHZhciBnbCA9IHRoaXMubGF5ZXJfLnNvdXJjZS5nZXRDb250ZXh0KCd3ZWJnbCcpO1xuICAgIGlmICghZ2wpIGdsID0gdGhpcy5sYXllcl8uc291cmNlLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpO1xuICAgIGlmICghZ2wpIGdsID0gdGhpcy5sYXllcl8uc291cmNlLmdldENvbnRleHQoJ3dlYmdsMicpO1xuICAgIHZhciBjYW52YXMgPSBnbC5jYW52YXM7XG4gICAgaWYgKGNhbnZhcy53aWR0aCAhPSB0aGlzLmxhc3RXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9IHRoaXMubGFzdEhlaWdodCkge1xuICAgICAgdGhpcy5jYXJkYm9hcmRVSV8ub25SZXNpemUoKTtcbiAgICB9XG4gICAgdGhpcy5sYXN0V2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgdGhpcy5sYXN0SGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICB0aGlzLmNhcmRib2FyZFVJXy5yZW5kZXIoKTtcbiAgfVxufTtcbkNhcmRib2FyZFZSRGlzcGxheS5wcm90b3R5cGUub25PcmllbnRhdGlvbkNoYW5nZV8gPSBmdW5jdGlvbiAoZSkge1xuICB0aGlzLnZpZXdlclNlbGVjdG9yXy5oaWRlKCk7XG4gIGlmICh0aGlzLnJvdGF0ZUluc3RydWN0aW9uc18pIHtcbiAgICB0aGlzLnJvdGF0ZUluc3RydWN0aW9uc18udXBkYXRlKCk7XG4gIH1cbiAgdGhpcy5vblJlc2l6ZV8oKTtcbn07XG5DYXJkYm9hcmRWUkRpc3BsYXkucHJvdG90eXBlLm9uUmVzaXplXyA9IGZ1bmN0aW9uIChlKSB7XG4gIGlmICh0aGlzLmxheWVyXykge1xuICAgIHZhciBnbCA9IHRoaXMubGF5ZXJfLnNvdXJjZS5nZXRDb250ZXh0KCd3ZWJnbCcpO1xuICAgIGlmICghZ2wpIGdsID0gdGhpcy5sYXllcl8uc291cmNlLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcpO1xuICAgIGlmICghZ2wpIGdsID0gdGhpcy5sYXllcl8uc291cmNlLmdldENvbnRleHQoJ3dlYmdsMicpO1xuICAgIHZhciBjc3NQcm9wZXJ0aWVzID0gWydwb3NpdGlvbjogYWJzb2x1dGUnLCAndG9wOiAwJywgJ2xlZnQ6IDAnLFxuICAgICd3aWR0aDogMTAwdncnLCAnaGVpZ2h0OiAxMDB2aCcsICdib3JkZXI6IDAnLCAnbWFyZ2luOiAwJyxcbiAgICAncGFkZGluZzogMHB4JywgJ2JveC1zaXppbmc6IGNvbnRlbnQtYm94J107XG4gICAgZ2wuY2FudmFzLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBjc3NQcm9wZXJ0aWVzLmpvaW4oJzsgJykgKyAnOycpO1xuICAgIHNhZmFyaUNzc1NpemVXb3JrYXJvdW5kKGdsLmNhbnZhcyk7XG4gIH1cbn07XG5DYXJkYm9hcmRWUkRpc3BsYXkucHJvdG90eXBlLm9uVmlld2VyQ2hhbmdlZF8gPSBmdW5jdGlvbiAodmlld2VyKSB7XG4gIHRoaXMuZGV2aWNlSW5mb18uc2V0Vmlld2VyKHZpZXdlcik7XG4gIGlmICh0aGlzLmRpc3RvcnRlcl8pIHtcbiAgICB0aGlzLmRpc3RvcnRlcl8udXBkYXRlRGV2aWNlSW5mbyh0aGlzLmRldmljZUluZm9fKTtcbiAgfVxuICB0aGlzLmZpcmVWUkRpc3BsYXlEZXZpY2VQYXJhbXNDaGFuZ2VfKCk7XG59O1xuQ2FyZGJvYXJkVlJEaXNwbGF5LnByb3RvdHlwZS5maXJlVlJEaXNwbGF5RGV2aWNlUGFyYW1zQ2hhbmdlXyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCd2cmRpc3BsYXlkZXZpY2VwYXJhbXNjaGFuZ2UnLCB7XG4gICAgZGV0YWlsOiB7XG4gICAgICB2cmRpc3BsYXk6IHRoaXMsXG4gICAgICBkZXZpY2VJbmZvOiB0aGlzLmRldmljZUluZm9fXG4gICAgfVxuICB9KTtcbiAgd2luZG93LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xufTtcbkNhcmRib2FyZFZSRGlzcGxheS5WUkZyYW1lRGF0YSA9IFZSRnJhbWVEYXRhO1xuQ2FyZGJvYXJkVlJEaXNwbGF5LlZSRGlzcGxheSA9IFZSRGlzcGxheTtcbnJldHVybiBDYXJkYm9hcmRWUkRpc3BsYXk7XG59KSkpO1xufSk7XG52YXIgQ2FyZGJvYXJkVlJEaXNwbGF5ID0gdW53cmFwRXhwb3J0cyhjYXJkYm9hcmRWckRpc3BsYXkpO1xuXG52YXIgdmVyc2lvbiA9IFwiMC4xMC4xMlwiO1xuXG52YXIgRGVmYXVsdENvbmZpZyA9IHtcbiAgQURESVRJT05BTF9WSUVXRVJTOiBbXSxcbiAgREVGQVVMVF9WSUVXRVI6ICcnLFxuICBQUk9WSURFX01PQklMRV9WUkRJU1BMQVk6IHRydWUsXG4gIE1PQklMRV9XQUtFX0xPQ0s6IHRydWUsXG4gIERFQlVHOiBmYWxzZSxcbiAgRFBEQl9VUkw6ICdodHRwczovL2RwZGIud2VidnIucm9ja3MvZHBkYi5qc29uJyxcbiAgS19GSUxURVI6IDAuOTgsXG4gIFBSRURJQ1RJT05fVElNRV9TOiAwLjA0MCxcbiAgQ0FSREJPQVJEX1VJX0RJU0FCTEVEOiBmYWxzZSxcbiAgUk9UQVRFX0lOU1RSVUNUSU9OU19ESVNBQkxFRDogZmFsc2UsXG4gIFlBV19PTkxZOiBmYWxzZSxcbiAgQlVGRkVSX1NDQUxFOiAwLjUsXG4gIERJUlRZX1NVQk1JVF9GUkFNRV9CSU5ESU5HUzogZmFsc2Vcbn07XG5cbmZ1bmN0aW9uIFdlYlZSUG9seWZpbGwoY29uZmlnKSB7XG4gIHRoaXMuY29uZmlnID0gZXh0ZW5kKGV4dGVuZCh7fSwgRGVmYXVsdENvbmZpZyksIGNvbmZpZyk7XG4gIHRoaXMucG9seWZpbGxEaXNwbGF5cyA9IFtdO1xuICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgdGhpcy5oYXNOYXRpdmUgPSAnZ2V0VlJEaXNwbGF5cycgaW4gbmF2aWdhdG9yO1xuICB0aGlzLm5hdGl2ZSA9IHt9O1xuICB0aGlzLm5hdGl2ZS5nZXRWUkRpc3BsYXlzID0gbmF2aWdhdG9yLmdldFZSRGlzcGxheXM7XG4gIHRoaXMubmF0aXZlLlZSRnJhbWVEYXRhID0gd2luZG93LlZSRnJhbWVEYXRhO1xuICB0aGlzLm5hdGl2ZS5WUkRpc3BsYXkgPSB3aW5kb3cuVlJEaXNwbGF5O1xuICBpZiAoIXRoaXMuaGFzTmF0aXZlIHx8IHRoaXMuY29uZmlnLlBST1ZJREVfTU9CSUxFX1ZSRElTUExBWSAmJiBpc01vYmlsZSgpKSB7XG4gICAgdGhpcy5lbmFibGUoKTtcbiAgICB0aGlzLmdldFZSRGlzcGxheXMoKS50aGVuKGZ1bmN0aW9uIChkaXNwbGF5cykge1xuICAgICAgaWYgKGRpc3BsYXlzICYmIGRpc3BsYXlzWzBdICYmIGRpc3BsYXlzWzBdLmZpcmVWUkRpc3BsYXlDb25uZWN0Xykge1xuICAgICAgICBkaXNwbGF5c1swXS5maXJlVlJEaXNwbGF5Q29ubmVjdF8oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuV2ViVlJQb2x5ZmlsbC5wcm90b3R5cGUuZ2V0UG9seWZpbGxEaXNwbGF5cyA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuX3BvbHlmaWxsRGlzcGxheXNQb3B1bGF0ZWQpIHtcbiAgICByZXR1cm4gdGhpcy5wb2x5ZmlsbERpc3BsYXlzO1xuICB9XG4gIGlmIChpc01vYmlsZSgpKSB7XG4gICAgdmFyIHZyRGlzcGxheSA9IG5ldyBDYXJkYm9hcmRWUkRpc3BsYXkoe1xuICAgICAgQURESVRJT05BTF9WSUVXRVJTOiB0aGlzLmNvbmZpZy5BRERJVElPTkFMX1ZJRVdFUlMsXG4gICAgICBERUZBVUxUX1ZJRVdFUjogdGhpcy5jb25maWcuREVGQVVMVF9WSUVXRVIsXG4gICAgICBNT0JJTEVfV0FLRV9MT0NLOiB0aGlzLmNvbmZpZy5NT0JJTEVfV0FLRV9MT0NLLFxuICAgICAgREVCVUc6IHRoaXMuY29uZmlnLkRFQlVHLFxuICAgICAgRFBEQl9VUkw6IHRoaXMuY29uZmlnLkRQREJfVVJMLFxuICAgICAgQ0FSREJPQVJEX1VJX0RJU0FCTEVEOiB0aGlzLmNvbmZpZy5DQVJEQk9BUkRfVUlfRElTQUJMRUQsXG4gICAgICBLX0ZJTFRFUjogdGhpcy5jb25maWcuS19GSUxURVIsXG4gICAgICBQUkVESUNUSU9OX1RJTUVfUzogdGhpcy5jb25maWcuUFJFRElDVElPTl9USU1FX1MsXG4gICAgICBST1RBVEVfSU5TVFJVQ1RJT05TX0RJU0FCTEVEOiB0aGlzLmNvbmZpZy5ST1RBVEVfSU5TVFJVQ1RJT05TX0RJU0FCTEVELFxuICAgICAgWUFXX09OTFk6IHRoaXMuY29uZmlnLllBV19PTkxZLFxuICAgICAgQlVGRkVSX1NDQUxFOiB0aGlzLmNvbmZpZy5CVUZGRVJfU0NBTEUsXG4gICAgICBESVJUWV9TVUJNSVRfRlJBTUVfQklORElOR1M6IHRoaXMuY29uZmlnLkRJUlRZX1NVQk1JVF9GUkFNRV9CSU5ESU5HU1xuICAgIH0pO1xuICAgIHRoaXMucG9seWZpbGxEaXNwbGF5cy5wdXNoKHZyRGlzcGxheSk7XG4gIH1cbiAgdGhpcy5fcG9seWZpbGxEaXNwbGF5c1BvcHVsYXRlZCA9IHRydWU7XG4gIHJldHVybiB0aGlzLnBvbHlmaWxsRGlzcGxheXM7XG59O1xuV2ViVlJQb2x5ZmlsbC5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICBpZiAodGhpcy5oYXNOYXRpdmUgJiYgdGhpcy5uYXRpdmUuVlJGcmFtZURhdGEpIHtcbiAgICB2YXIgTmF0aXZlVlJGcmFtZURhdGEgPSB0aGlzLm5hdGl2ZS5WUkZyYW1lRGF0YTtcbiAgICB2YXIgbmF0aXZlRnJhbWVEYXRhID0gbmV3IHRoaXMubmF0aXZlLlZSRnJhbWVEYXRhKCk7XG4gICAgdmFyIG5hdGl2ZUdldEZyYW1lRGF0YSA9IHRoaXMubmF0aXZlLlZSRGlzcGxheS5wcm90b3R5cGUuZ2V0RnJhbWVEYXRhO1xuICAgIHdpbmRvdy5WUkRpc3BsYXkucHJvdG90eXBlLmdldEZyYW1lRGF0YSA9IGZ1bmN0aW9uIChmcmFtZURhdGEpIHtcbiAgICAgIGlmIChmcmFtZURhdGEgaW5zdGFuY2VvZiBOYXRpdmVWUkZyYW1lRGF0YSkge1xuICAgICAgICBuYXRpdmVHZXRGcmFtZURhdGEuY2FsbCh0aGlzLCBmcmFtZURhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBuYXRpdmVHZXRGcmFtZURhdGEuY2FsbCh0aGlzLCBuYXRpdmVGcmFtZURhdGEpO1xuICAgICAgZnJhbWVEYXRhLnBvc2UgPSBuYXRpdmVGcmFtZURhdGEucG9zZTtcbiAgICAgIGNvcHlBcnJheShuYXRpdmVGcmFtZURhdGEubGVmdFByb2plY3Rpb25NYXRyaXgsIGZyYW1lRGF0YS5sZWZ0UHJvamVjdGlvbk1hdHJpeCk7XG4gICAgICBjb3B5QXJyYXkobmF0aXZlRnJhbWVEYXRhLnJpZ2h0UHJvamVjdGlvbk1hdHJpeCwgZnJhbWVEYXRhLnJpZ2h0UHJvamVjdGlvbk1hdHJpeCk7XG4gICAgICBjb3B5QXJyYXkobmF0aXZlRnJhbWVEYXRhLmxlZnRWaWV3TWF0cml4LCBmcmFtZURhdGEubGVmdFZpZXdNYXRyaXgpO1xuICAgICAgY29weUFycmF5KG5hdGl2ZUZyYW1lRGF0YS5yaWdodFZpZXdNYXRyaXgsIGZyYW1lRGF0YS5yaWdodFZpZXdNYXRyaXgpO1xuICAgIH07XG4gIH1cbiAgbmF2aWdhdG9yLmdldFZSRGlzcGxheXMgPSB0aGlzLmdldFZSRGlzcGxheXMuYmluZCh0aGlzKTtcbiAgd2luZG93LlZSRGlzcGxheSA9IENhcmRib2FyZFZSRGlzcGxheS5WUkRpc3BsYXk7XG4gIHdpbmRvdy5WUkZyYW1lRGF0YSA9IENhcmRib2FyZFZSRGlzcGxheS5WUkZyYW1lRGF0YTtcbn07XG5XZWJWUlBvbHlmaWxsLnByb3RvdHlwZS5nZXRWUkRpc3BsYXlzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB2YXIgY29uZmlnID0gdGhpcy5jb25maWc7XG4gIGlmICghdGhpcy5oYXNOYXRpdmUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZ2V0UG9seWZpbGxEaXNwbGF5cygpKTtcbiAgfVxuICByZXR1cm4gdGhpcy5uYXRpdmUuZ2V0VlJEaXNwbGF5cy5jYWxsKG5hdmlnYXRvcikudGhlbihmdW5jdGlvbiAobmF0aXZlRGlzcGxheXMpIHtcbiAgICByZXR1cm4gbmF0aXZlRGlzcGxheXMubGVuZ3RoID4gMCA/IG5hdGl2ZURpc3BsYXlzIDogX3RoaXMuZ2V0UG9seWZpbGxEaXNwbGF5cygpO1xuICB9KTtcbn07XG5XZWJWUlBvbHlmaWxsLnZlcnNpb24gPSB2ZXJzaW9uO1xuV2ViVlJQb2x5ZmlsbC5WUkZyYW1lRGF0YSA9IENhcmRib2FyZFZSRGlzcGxheS5WUkZyYW1lRGF0YTtcbldlYlZSUG9seWZpbGwuVlJEaXNwbGF5ID0gQ2FyZGJvYXJkVlJEaXNwbGF5LlZSRGlzcGxheTtcblxuXG52YXIgd2VidnJQb2x5ZmlsbCA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBXZWJWUlBvbHlmaWxsXG59KTtcblxudmFyIHJlcXVpcmUkJDAgPSAoIHdlYnZyUG9seWZpbGwgJiYgV2ViVlJQb2x5ZmlsbCApIHx8IHdlYnZyUG9seWZpbGw7XG5cbmlmICh0eXBlb2YgY29tbW9uanNHbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGNvbW1vbmpzR2xvYmFsLndpbmRvdykge1xuICBpZiAoIWNvbW1vbmpzR2xvYmFsLmRvY3VtZW50KSB7XG4gICAgY29tbW9uanNHbG9iYWwuZG9jdW1lbnQgPSBjb21tb25qc0dsb2JhbC53aW5kb3cuZG9jdW1lbnQ7XG4gIH1cbiAgaWYgKCFjb21tb25qc0dsb2JhbC5uYXZpZ2F0b3IpIHtcbiAgICBjb21tb25qc0dsb2JhbC5uYXZpZ2F0b3IgPSBjb21tb25qc0dsb2JhbC53aW5kb3cubmF2aWdhdG9yO1xuICB9XG59XG52YXIgc3JjID0gcmVxdWlyZSQkMDtcblxucmV0dXJuIHNyYztcblxufSkpKTtcbiIsIi8qIGVzbGludCBuby1tYWdpYy1udW1iZXJzOiAwICovXG5pbXBvcnQgUmVhY3QsIHtDb21wb25lbnR9IGZyb20gJ3JlYWN0JztcblxuaW1wb3J0IHsgVnRrVmlldywgVnRrR2VvbWV0cnlSZXByZXNlbnRhdGlvbiwgVnRrUG9seURhdGFTb3VyY2UsIFZ0a1BvaW50RGF0YSwgVnRrRGF0YUFycmF5IH0gZnJvbSAnLi4vbGliJztcblxuY2xhc3MgQXBwIGV4dGVuZHMgQ29tcG9uZW50IHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNldFByb3BzID0gdGhpcy5zZXRQcm9wcy5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIHNldFByb3BzKG5ld1Byb3BzKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUobmV3UHJvcHMpO1xuICAgIH1cblxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgPFZ0a1ZpZXcgc2V0UHJvcHM9e3RoaXMuc2V0UHJvcHN9IGJhY2tncm91bmQ9e1swLjEsIDAuMSwgMC4xXX0gPlxuICAgICAgICAgICAgICAgICAgICA8VnRrR2VvbWV0cnlSZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JCeT17Wydwb2ludERhdGEnLCAnVGVtcGVyYXR1cmUnXX1cbiAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgPFZ0a1BvbHlEYXRhU291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzPXtbMCwwLDAsMSwwLDAsMSwxLDAsMCwxLDBdfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlzPXtbNCwwLDEsMiwzXX1cbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8VnRrUG9pbnREYXRhPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8VnRrRGF0YUFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwiVGVtcGVyYXR1cmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzPXtbMCwzLDIsMV19XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9WdGtQb2ludERhdGE+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L1Z0a1BvbHlEYXRhU291cmNlPlxuICAgICAgICAgICAgICAgICAgICA8L1Z0a0dlb21ldHJ5UmVwcmVzZW50YXRpb24+XG4gICAgICAgICAgICAgICAgPC9WdGtWaWV3PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEFwcDtcbiIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKipcbiAqIFZ0a0NlbGxEYXRhIGlzIGV4cG9zaW5nIGEgVnRrQ2VsbERhdGEgdG8gYSBkb3duc3RyZWFtIGVsZW1lbnRcbiAqIEl0IHByb3ZpZGVzIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyB0byBpdHMgY2hpbGRyZW46XG4gKiAgIC0gcGFzcyBhbG9uZzogJ3ZpZXcnLCAncmVwcmVzZW50YXRpb25gLCBgc2V0UHJvcHNgXG4gKiAgIC0gYGZpZWxkc2AgPT0gYFZ0a0NlbGxEYXRhYFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWdGtDZWxsRGF0YSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGlkLCBzZXRQcm9wcywgY2hpbGRyZW4sIHZpZXcsIHJlcHJlc2VudGF0aW9uLCBkYXRhc2V0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGFkZE9uUHJvcHMgPSB7XG4gICAgICBmaWVsZHM6IGRhdGFzZXQuZ2V0Q2VsbERhdGEoKSxcbiAgICAgIGRhdGFzZXQsXG4gICAgICByZXByZXNlbnRhdGlvbixcbiAgICAgIHZpZXcsXG4gICAgICBzZXRQcm9wcyxcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkcmVuV2l0aFZpZXdQcm9wID0gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBjaGlsZCA9PiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGFkZE9uUHJvcHMpKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBpZD17aWR9PlxuICAgICAgICB7Y2hpbGRyZW5XaXRoVmlld1Byb3B9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cblZ0a0NlbGxEYXRhLmRlZmF1bHRQcm9wcyA9IHtcbn07XG5cblZ0a0NlbGxEYXRhLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIFRoZSBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgY29tcG9uZW50IGluIERhc2ggY2FsbGJhY2tzLlxuICAgKi9cbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIERhc2gtYXNzaWduZWQgY2FsbGJhY2sgdGhhdCBzaG91bGQgYmUgY2FsbGVkIHRvIHJlcG9ydCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIHRvIERhc2gsIHRvIG1ha2UgdGhlbSBhdmFpbGFibGUgZm9yIGNhbGxiYWNrcy5cbiAgICovXG4gIHNldFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogTGlzdCBvZiByZXByZXNlbnRhdGlvbiB0byBzaG93XG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm5vZGUpLFxuICAgIFByb3BUeXBlcy5ub2RlXG4gIF0pLFxuICAvKipcbiAgICogUGFzc2VkIGJ5IHBhcmVudFxuICAgKi9cbiAgdmlldzogUHJvcFR5cGVzLm9iamVjdCxcbiAgLyoqXG4gICAqIFBhc3NlZCBieSBwYXJlbnRcbiAgICovXG4gIHJlcHJlc2VudGF0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICAvKipcbiAgICogUGFzc2VkIGJ5IHBhcmVudFxuICAgKi9cbiAgZGF0YXNldDogUHJvcFR5cGVzLm9iamVjdCxcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IHZ0a0RhdGFBcnJheSBmcm9tICd2dGsuanMvU291cmNlcy9Db21tb24vQ29yZS9EYXRhQXJyYXknO1xuaW1wb3J0IHsgVFlQRURfQVJSQVlTIH0gZnJvbSAndnRrLmpzL1NvdXJjZXMvbWFjcm8nO1xuXG4vKipcbiAqIFZ0a0RhdGFBcnJheSBpcyBjcmVhdGluZyBhIHZ0a0RhdGFBcnJheSBmb3IgdGhlIGNvbnRhaW5lciBmaWVsZHNcbiAqIEl0IHRha2VzIHRoZSBmb2xsb3dpbmcgc2V0IG9mIHByb3BlcnRpZXM6XG4gKiAgIC0gdHlwZTogJ0Zsb2F0MzJBcnJheScsICdGbG9hdDY0QXJyYXknLCAnVWludDE2QXJyYXknLCAuLi5cbiAqICAgLSB2YWx1ZXM6IFtudW1iZXIsIG51bWJlciwgLi4uXVxuICogICAtIG51bWJlck9mQ29tcG9uZW50czogMSxcbiAqICAgLSByZWdpc3RyYXRpb246ICdhZGRBcnJheScsICdzZXRTY2FsYXJzJywgLi4uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZ0a0RhdGFBcnJheSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgLy8gQ3JlYXRlIHZ0ay5qcyBkYXRhIGFycmF5XG4gICAgdGhpcy5hcnJheSA9IHZ0a0RhdGFBcnJheS5uZXdJbnN0YW5jZSh7IGVtcHR5OiB0cnVlIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnNvbGUubG9nKCdWdGtEYXRhQXJyYXknLCB0aGlzLnByb3BzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgZmllbGRzLCByZWdpc3RyYXRpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgdGhpcy51cGRhdGUodGhpcy5wcm9wcyk7XG4gICAgZmllbGRzW3JlZ2lzdHJhdGlvbl0odGhpcy5hcnJheSk7XG4gIH1cblxuICBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUsIHNuYXBzaG90KSB7XG4gICAgdGhpcy51cGRhdGUodGhpcy5wcm9wcywgcHJldlByb3BzKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGNvbnN0IHsgZmllbGRzIH0gPSB0aGlzLnByb3BzO1xuICAgIGZpZWxkcy5yZW1vdmVBcnJheSh0aGlzLmFycmF5KTtcbiAgICB0aGlzLmFycmF5LmRlbGV0ZSgpO1xuICAgIHRoaXMuYXJyYXkgPSBudWxsO1xuICB9XG5cbiAgdXBkYXRlKHByb3BzLCBwcmV2aW91cykge1xuICAgIGNvbnN0IHsgbmFtZSwgdHlwZSwgdmFsdWVzLCBudW1iZXJPZkNvbXBvbmVudHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IGtsYXNzID0gVFlQRURfQVJSQVlTW3R5cGVdO1xuXG4gICAgdGhpcy5hcnJheS5zZXROYW1lKG5hbWUpO1xuXG4gICAgbGV0IGNoYW5nZURldGVjdGVkID0gZmFsc2U7XG4gICAgaWYgKHR5cGUgJiYgKCFwcmV2aW91cyB8fCB0eXBlICE9PSBwcmV2aW91cy50eXBlKSkge1xuICAgICAgY2hhbmdlRGV0ZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobnVtYmVyT2ZDb21wb25lbnRzICYmICghcHJldmlvdXMgfHwgbnVtYmVyT2ZDb21wb25lbnRzICE9PSBwcmV2aW91cy5udW1iZXJPZkNvbXBvbmVudHMpKSB7XG4gICAgICBjaGFuZ2VEZXRlY3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlcyAmJiAoY2hhbmdlRGV0ZWN0ZWQgfHwgIXByZXZpb3VzIHx8IHZhbHVlcyAhPT0gcHJldmlvdXMudmFsdWVzKSkge1xuICAgICAgdGhpcy5hcnJheS5zZXREYXRhKGtsYXNzLmZyb20odmFsdWVzKSwgbnVtYmVyT2ZDb21wb25lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxuVnRrRGF0YUFycmF5LmRlZmF1bHRQcm9wcyA9IHtcbiAgbmFtZTogJ3NjYWxhcnMnLFxuICB0eXBlOiAnRmxvYXQzMkFycmF5JyxcbiAgdmFsdWVzOiBbXSxcbiAgbnVtYmVyT2ZDb21wb25lbnRzOiAxLFxuICByZWdpc3RyYXRpb246ICdhZGRBcnJheScsXG59O1xuXG5WdGtEYXRhQXJyYXkucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogVGhlIElEIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBjb21wb25lbnQgaW4gRGFzaCBjYWxsYmFja3MuXG4gICAqL1xuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogRGFzaC1hc3NpZ25lZCBjYWxsYmFjayB0aGF0IHNob3VsZCBiZSBjYWxsZWQgdG8gcmVwb3J0IHByb3BlcnR5IGNoYW5nZXNcbiAgICogdG8gRGFzaCwgdG8gbWFrZSB0aGVtIGF2YWlsYWJsZSBmb3IgY2FsbGJhY2tzLlxuICAgKi9cbiAgc2V0UHJvcHM6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8vIC0tIHZ0ay5qcyBleHBvc2VkIHByb3BlcnRpZXNcblxuICAvKipcbiAgICogVHlwZWQgYXJyYXkgbmFtZVxuICAgKi9cbiAgdHlwZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogRmllbGQgbmFtZVxuICAgKi9cbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQWN0dWFsIHZhbHVlcyB0byB1c2UgaW5zaWRlIG91ciBhcnJheVxuICAgKi9cbiAgdmFsdWVzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSxcblxuICAvKipcbiAgICogTnVtYmVyIG9mIGNvbXBvbmVudHMgLyBUdXBsZSBzaXplXG4gICAqL1xuICBudW1iZXJPZkNvbXBvbmVudHM6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIG1ldGhvZCB0byBjYWxsIG9uIHRoZSBmaWVsZERhdGEgKGFkZEFycmF5LCBzZXRTY2FsYXJzLCBzZXRWZWN0b3JzLi4uKVxuICAgKi9cbiAgcmVnaXN0cmF0aW9uOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHJlcHJlc2VudGF0aW9uIHRvIHNob3dcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubm9kZSksXG4gICAgUHJvcFR5cGVzLm5vZGVcbiAgXSksXG4gIC8qKlxuICAgKiBQYXNzZWQgYnkgcGFyZW50XG4gICAqL1xuICBmaWVsZHM6IFByb3BUeXBlcy5vYmplY3QsXG59O1xuIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbi8qKlxuICogVnRrRmllbGREYXRhIGlzIGV4cG9zaW5nIGEgVnRrRmllbGREYXRhIHRvIGEgZG93bnN0cmVhbSBlbGVtZW50XG4gKiBJdCBwcm92aWRlcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgdG8gaXRzIGNoaWxkcmVuOlxuICogICAtIHBhc3MgYWxvbmc6ICd2aWV3JywgJ3JlcHJlc2VudGF0aW9uYCwgYHNldFByb3BzYFxuICogICAtIGBmaWVsZHNgID09IGBWdGtGaWVsZERhdGFgXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZ0a0ZpZWxkRGF0YSBleHRlbmRzIENvbXBvbmVudCB7XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGlkLCBzZXRQcm9wcywgY2hpbGRyZW4sIHZpZXcsIHJlcHJlc2VudGF0aW9uLCBkYXRhc2V0IH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IGFkZE9uUHJvcHMgPSB7XG4gICAgICBmaWVsZHM6IGRhdGFzZXQuZ2V0RmllbGREYXRhKCksXG4gICAgICBkYXRhc2V0LFxuICAgICAgcmVwcmVzZW50YXRpb24sXG4gICAgICB2aWV3LFxuICAgICAgc2V0UHJvcHMsXG4gICAgfTtcbiAgICBjb25zdCBjaGlsZHJlbldpdGhWaWV3UHJvcCA9IFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgY2hpbGQgPT4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBhZGRPblByb3BzKSk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgaWQ9e2lkfT5cbiAgICAgICAge2NoaWxkcmVuV2l0aFZpZXdQcm9wfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxufVxuXG5WdGtGaWVsZERhdGEuZGVmYXVsdFByb3BzID0ge1xufTtcblxuVnRrRmllbGREYXRhLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIFRoZSBJRCB1c2VkIHRvIGlkZW50aWZ5IHRoaXMgY29tcG9uZW50IGluIERhc2ggY2FsbGJhY2tzLlxuICAgKi9cbiAgaWQ6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIERhc2gtYXNzaWduZWQgY2FsbGJhY2sgdGhhdCBzaG91bGQgYmUgY2FsbGVkIHRvIHJlcG9ydCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAqIHRvIERhc2gsIHRvIG1ha2UgdGhlbSBhdmFpbGFibGUgZm9yIGNhbGxiYWNrcy5cbiAgICovXG4gIHNldFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogTGlzdCBvZiByZXByZXNlbnRhdGlvbiB0byBzaG93XG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm5vZGUpLFxuICAgIFByb3BUeXBlcy5ub2RlXG4gIF0pLFxuICAvKipcbiAgICogUGFzc2VkIGJ5IHBhcmVudFxuICAgKi9cbiAgdmlldzogUHJvcFR5cGVzLm9iamVjdCxcbiAgLyoqXG4gICAqIFBhc3NlZCBieSBwYXJlbnRcbiAgICovXG4gIHJlcHJlc2VudGF0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxuICAvKipcbiAgICogUGFzc2VkIGJ5IHBhcmVudFxuICAgKi9cbiAgZGF0YXNldDogUHJvcFR5cGVzLm9iamVjdCxcbn07XG4iLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IHZ0a0FjdG9yIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL0FjdG9yJztcbmltcG9ydCB2dGtNYXBwZXIgZnJvbSAndnRrLmpzL1NvdXJjZXMvUmVuZGVyaW5nL0NvcmUvTWFwcGVyJztcblxuLyoqXG4gKiBWdGtHZW9tZXRyeVJlcHJlc2VudGF0aW9uIGlzIHJlc3BvbnNpYmxlIHRvIGNvbnZlcnQgYSB2dGtQb2x5RGF0YSBpbnRvIHJlbmRlcmluZ1xuICogSXQgdGFrZXMgdGhlIGZvbGxvd2luZyBzZXQgb2YgcHJvcGVydGllczpcbiAqICAgLSBjb2xvckJ5OiBbJ1BPSU5UUycsICcnXSxcbiAqICAgLSBwb2ludFNpemU6IDEsXG4gKiAgIC0gY29sb3I6IFsxLDEsMV0sXG4gKiBJdCBwcm92aWRlcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgdG8gaXRzIGNoaWxkcmVuOlxuICogICAtICdyZXByZXNlbnRhdGlvbmA6IHRoaXNcbiAqICAgLSBgZG93bnN0cmVhbWAgPT0gYG1hcHBlcmAgd2hpY2ggc2hvdWxkIGJlIHVzZWQgdG8gY2FsbCBzZXRJbnB1dENvbm5lY3Rpb24vc2V0SW5wdXREYXRhXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZ0a0dlb21ldHJ5UmVwcmVzZW50YXRpb24gZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIC8vIENyZWF0ZSB2dGsuanMgYWN0b3IvbWFwcGVyXG4gICAgdGhpcy5hY3RvciA9IHZ0a0FjdG9yLm5ld0luc3RhbmNlKCk7XG4gICAgdGhpcy5tYXBwZXIgPSB2dGtNYXBwZXIubmV3SW5zdGFuY2UoKTtcbiAgICB0aGlzLmFjdG9yLnNldE1hcHBlcih0aGlzLm1hcHBlcik7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc29sZS5sb2coJ1Z0a0dlb21ldHJ5UmVwcmVzZW50YXRpb24nLCB0aGlzLnByb3BzKTtcbiAgICBjb25zdCB7IGlkLCBzZXRQcm9wcywgY2hpbGRyZW4sIHZpZXcgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgYWRkT25Qcm9wcyA9IHtcbiAgICAgIGRvd25zdHJlYW06IHRoaXMubWFwcGVyLFxuICAgICAgcmVwcmVzZW50YXRpb246IHRoaXMsXG4gICAgICB2aWV3LFxuICAgICAgc2V0UHJvcHMsXG4gICAgfTtcbiAgICBjb25zdCBjaGlsZHJlbldpdGhWaWV3UHJvcCA9IFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgY2hpbGQgPT4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBhZGRPblByb3BzKSk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgaWQ9e2lkfT5cbiAgICAgICAge2NoaWxkcmVuV2l0aFZpZXdQcm9wfVxuICAgICAgPC9kaXY+XG4gICAgKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGNvbnN0IHsgcmVuZGVyZXIgfSA9IHRoaXMucHJvcHMudmlldztcbiAgICByZW5kZXJlci5hZGRBY3Rvcih0aGlzLmFjdG9yKTtcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLnByb3BzKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgc25hcHNob3QpIHtcbiAgICB0aGlzLnVwZGF0ZSh0aGlzLnByb3BzLCBwcmV2UHJvcHMpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgY29uc3QgeyByZW5kZXJlciB9ID0gdGhpcy5wcm9wcy52aWV3O1xuICAgIHJlbmRlcmVyLnJlbW90ZUFjdG9yKHRoaXMuYWN0b3IpO1xuXG4gICAgdGhpcy5hY3Rvci5kZWxldGUoKTtcbiAgICB0aGlzLmFjdG9yID0gbnVsbDtcblxuICAgIHRoaXMubWFwcGVyLmRlbGV0ZSgpO1xuICAgIHRoaXMubWFwcGVyID0gbnVsbDtcbiAgfVxuXG4gIHVwZGF0ZShwcm9wcywgcHJldmlvdXMpIHtcbiAgICBjb25zdCB7IHBvaW50U2l6ZSwgY29sb3IsIGNvbG9yQnkgfSA9IHByb3BzO1xuICAgIGlmIChwb2ludFNpemUgJiYgKCFwcmV2aW91cyB8fCBwb2ludFNpemUgIT09IHByZXZpb3VzLnBvaW50U2l6ZSkpIHtcbiAgICAgIHRoaXMuYWN0b3IuZ2V0UHJvcGVydHkoKS5zZXRQb2ludFNpemUocG9pbnRTaXplKTtcbiAgICB9XG4gICAgaWYgKGNvbG9yICYmICghcHJldmlvdXMgfHwgY29sb3IgIT09IHByZXZpb3VzLmNvbG9yKSkge1xuICAgICAgdGhpcy5hY3Rvci5nZXRQcm9wZXJ0eSgpLnNldENvbG9yKGNvbG9yKTtcbiAgICB9XG4gICAgaWYgKGNvbG9yQnkgJiYgKCFwcmV2aW91cyB8fCBjb2xvckJ5ICE9PSBwcmV2aW91cy5jb2xvckJ5KSkge1xuICAgICAgdGhpcy5zZXRDb2xvckJ5KC4uLmNvbG9yQnkpXG4gICAgfVxuICB9XG5cbiAgc2V0Q29sb3JCeShhcnJheUxvY2F0aW9uLCBhcnJheU5hbWUpIHtcbiAgICBsZXQgY29sb3JNb2RlID0gdnRrTWFwcGVyLkNvbG9yTW9kZS5ERUZBVUxUO1xuICAgIGxldCBzY2FsYXJNb2RlID0gdnRrTWFwcGVyLlNjYWxhck1vZGUuREVGQVVMVDtcbiAgICBjb25zdCBjb2xvckJ5QXJyYXlOYW1lID0gYXJyYXlOYW1lO1xuICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMubWFwcGVyLmdldElucHV0RGF0YSgpLmdldFJlZmVyZW5jZUJ5TmFtZShhcnJheUxvY2F0aW9uKTtcbiAgICBjb25zdCBhY3RpdmVBcnJheSA9IGZpZWxkcyAmJiBmaWVsZHMuZ2V0QXJyYXkoYXJyYXlOYW1lKTtcbiAgICBjb25zdCBzY2FsYXJWaXNpYmlsaXR5ID0gISFhY3RpdmVBcnJheTtcblxuICAgIGlmIChzY2FsYXJWaXNpYmlsaXR5KSB7XG4gICAgICBjb2xvck1vZGUgPSB2dGtNYXBwZXIuQ29sb3JNb2RlLk1BUF9TQ0FMQVJTO1xuICAgICAgc2NhbGFyTW9kZSA9XG4gICAgICAgIGFycmF5TG9jYXRpb24gPT09ICdwb2ludERhdGEnXG4gICAgICAgICAgPyB2dGtNYXBwZXIuU2NhbGFyTW9kZS5VU0VfUE9JTlRfRklFTERfREFUQVxuICAgICAgICAgIDogdnRrTWFwcGVyLlNjYWxhck1vZGUuVVNFX0NFTExfRklFTERfREFUQTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIG1hcHBlcnMgaGF2ZSB0aG9zZSBmaWVsZHNcbiAgICB0aGlzLm1hcHBlci5zZXQoXG4gICAgICB7XG4gICAgICAgIGNvbG9yQnlBcnJheU5hbWUsXG4gICAgICAgIGNvbG9yTW9kZSxcbiAgICAgICAgc2NhbGFyTW9kZSxcbiAgICAgICAgc2NhbGFyVmlzaWJpbGl0eSxcbiAgICAgIH0sXG4gICAgICB0cnVlXG4gICAgKTtcbiAgfTtcbn1cblxuVnRrR2VvbWV0cnlSZXByZXNlbnRhdGlvbi5kZWZhdWx0UHJvcHMgPSB7XG4gIGNvbG9yQnk6IFsncG9pbnREYXRhJywgJyddLFxuICBwb2ludFNpemU6IDEsXG4gIGNvbG9yOiBbMSwxLDFdLFxufTtcblxuVnRrR2VvbWV0cnlSZXByZXNlbnRhdGlvbi5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBUaGUgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGNvbXBvbmVudCBpbiBEYXNoIGNhbGxiYWNrcy5cbiAgICovXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBEYXNoLWFzc2lnbmVkIGNhbGxiYWNrIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB0byByZXBvcnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiB0byBEYXNoLCB0byBtYWtlIHRoZW0gYXZhaWxhYmxlIGZvciBjYWxsYmFja3MuXG4gICAqL1xuICBzZXRQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLy8gLS0gdnRrLmpzIGV4cG9zZWQgcHJvcGVydGllc1xuXG4gIC8qKlxuICAgKiBDaG9vc2Ugd2hpY2ggYXJyYXkgdG8gY29sb3IgdGhlIG91dHB1dCB3aXRoLlxuICAgKiAtIFsncG9pbnREYXRhJywgJ3RlbXBlcmF0dXJlJ11cbiAgICogLSBbJ2NlbGxEYXRhJywgJ3ByZXNzdXJlJ11cbiAgICovXG4gIGNvbG9yQnk6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuXG4gIC8qKlxuICAgKiBwb2ludFNpemUgZm9yIHZlcnRleCByZW5kZXJpbmdcbiAgICovXG4gIHBvaW50U2l6ZTogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogV2hlbiBubyBjb2xvckJ5IGFycmF5IGlzIHByb3ZpZGVkIHVzZSBwcm92aWRlZCBzb2xpZCBjb2xvclxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5udW1iZXIpLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHJlcHJlc2VudGF0aW9uIHRvIHNob3dcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubm9kZSksXG4gICAgUHJvcFR5cGVzLm5vZGVcbiAgXSksXG4gIC8qKlxuICAgKiBQYXNzZWQgYnkgcGFyZW50XG4gICAqL1xuICB2aWV3OiBQcm9wVHlwZXMub2JqZWN0LFxufTtcbiIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG4vKipcbiAqIFZ0a1BvaW50RGF0YSBpcyBleHBvc2luZyBhIHZ0a1BvaW50RGF0YSB0byBhIGRvd25zdHJlYW0gZWxlbWVudFxuICogSXQgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIHRvIGl0cyBjaGlsZHJlbjpcbiAqICAgLSBwYXNzIGFsb25nOiAndmlldycsICdyZXByZXNlbnRhdGlvbmAsIGBzZXRQcm9wc2BcbiAqICAgLSBgZmllbGRzYCA9PSBgdnRrUG9pbnREYXRhYFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWdGtQb2ludERhdGEgZXh0ZW5kcyBDb21wb25lbnQge1xuICByZW5kZXIoKSB7XG4gICAgY29uc29sZS5sb2coJ1Z0a1BvaW50RGF0YScsIHRoaXMucHJvcHMpO1xuICAgIGNvbnN0IHsgaWQsIHNldFByb3BzLCBjaGlsZHJlbiwgdmlldywgcmVwcmVzZW50YXRpb24sIGRhdGFzZXQgfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgYWRkT25Qcm9wcyA9IHtcbiAgICAgIGZpZWxkczogZGF0YXNldC5nZXRQb2ludERhdGEoKSxcbiAgICAgIGRhdGFzZXQsXG4gICAgICByZXByZXNlbnRhdGlvbixcbiAgICAgIHZpZXcsXG4gICAgICBzZXRQcm9wcyxcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkcmVuV2l0aFZpZXdQcm9wID0gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBjaGlsZCA9PiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGFkZE9uUHJvcHMpKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBpZD17aWR9PlxuICAgICAgICB7Y2hpbGRyZW5XaXRoVmlld1Byb3B9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG59XG5cblZ0a1BvaW50RGF0YS5kZWZhdWx0UHJvcHMgPSB7XG59O1xuXG5WdGtQb2ludERhdGEucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogVGhlIElEIHVzZWQgdG8gaWRlbnRpZnkgdGhpcyBjb21wb25lbnQgaW4gRGFzaCBjYWxsYmFja3MuXG4gICAqL1xuICBpZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogRGFzaC1hc3NpZ25lZCBjYWxsYmFjayB0aGF0IHNob3VsZCBiZSBjYWxsZWQgdG8gcmVwb3J0IHByb3BlcnR5IGNoYW5nZXNcbiAgICogdG8gRGFzaCwgdG8gbWFrZSB0aGVtIGF2YWlsYWJsZSBmb3IgY2FsbGJhY2tzLlxuICAgKi9cbiAgc2V0UHJvcHM6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIHJlcHJlc2VudGF0aW9uIHRvIHNob3dcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubm9kZSksXG4gICAgUHJvcFR5cGVzLm5vZGVcbiAgXSksXG4gIC8qKlxuICAgKiBQYXNzZWQgYnkgcGFyZW50XG4gICAqL1xuICB2aWV3OiBQcm9wVHlwZXMub2JqZWN0LFxuICAvKipcbiAgICogUGFzc2VkIGJ5IHBhcmVudFxuICAgKi9cbiAgcmVwcmVzZW50YXRpb246IFByb3BUeXBlcy5vYmplY3QsXG4gIC8qKlxuICAgKiBQYXNzZWQgYnkgcGFyZW50XG4gICAqL1xuICBkYXRhc2V0OiBQcm9wVHlwZXMub2JqZWN0LFxufTtcbiIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuXG5pbXBvcnQgdnRrUG9seURhdGEgZnJvbSAndnRrLmpzL1NvdXJjZXMvQ29tbW9uL0RhdGFNb2RlbC9Qb2x5RGF0YSc7XG5cbi8qKlxuICogVnRrUG9seURhdGFTb3VyY2UgaXMgZXhwb3NpbmcgYSBwb2x5ZGF0YSB0byBhIGRvd25zdHJlYW0gZmlsdGVyIG9yIHJlcHJlc2VudGF0aW9uXG4gKiBJdCB0YWtlcyB0aGUgZm9sbG93aW5nIHNldCBvZiBwcm9wZXJ0aWVzOlxuICogICAtIHBvaW50czogW3gsIHksIHosIHgsIHksIHosIC4uLl0sXG4gKiAgIC0gdmVydHM6IFtjZWxsU2l6ZSwgcG9pbnRJZDAsIHBvaW50SWQxLCAuLi4sIGNlbGxTaXplLCBwb2ludElkMCwgLi4uXVxuICogICAtIGxpbmVzOiBbY2VsbFNpemUsIHBvaW50SWQwLCBwb2ludElkMSwgLi4uLCBjZWxsU2l6ZSwgcG9pbnRJZDAsIC4uLl1cbiAqICAgLSBwb2x5czogW2NlbGxTaXplLCBwb2ludElkMCwgcG9pbnRJZDEsIC4uLiwgY2VsbFNpemUsIHBvaW50SWQwLCAuLi5dXG4gKiAgIC0gc3RyaXBzOiBbY2VsbFNpemUsIHBvaW50SWQwLCBwb2ludElkMSwgLi4uLCBjZWxsU2l6ZSwgcG9pbnRJZDAsIC4uLl1cbiAqICAgLSBwb2ludENsb3VkOiBmYWxzZS90cnVlIChpZiBvbiBpdCB3aWxsIGdlbmVyYXRlIHZlcnRzIGF1dG9tYXRpY2FsbHkpXG4gKiBJdCBwcm92aWRlcyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgdG8gaXRzIGNoaWxkcmVuOlxuICogICAtIHBhc3MgYWxvbmc6ICd2aWV3JywgJ3JlcHJlc2VudGF0aW9uYCwgYHNldFByb3BzYFxuICogICAtIGBkYXRhc2V0YCA9PSBgdGhpcy5kYXRhc2V0YFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWdGtQb2x5RGF0YVNvdXJjZSBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgLy8gQ3JlYXRlIHZ0ay5qcyBwb2x5ZGF0YVxuICAgIHRoaXMucG9seWRhdGEgPSB2dGtQb2x5RGF0YS5uZXdJbnN0YW5jZSgpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnNvbGUubG9nKCdWdGtQb2x5RGF0YVNvdXJjZScsIHRoaXMucHJvcHMpO1xuICAgIGNvbnN0IHsgaWQsIHNldFByb3BzLCBjaGlsZHJlbiwgdmlldywgcmVwcmVzZW50YXRpb24gfSA9IHRoaXMucHJvcHM7XG4gICAgY29uc3QgYWRkT25Qcm9wcyA9IHtcbiAgICAgIGRhdGFzZXQ6IHRoaXMucG9seWRhdGEsXG4gICAgICByZXByZXNlbnRhdGlvbixcbiAgICAgIHZpZXcsXG4gICAgICBzZXRQcm9wcyxcbiAgICB9O1xuICAgIGNvbnN0IGNoaWxkcmVuV2l0aFZpZXdQcm9wID0gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBjaGlsZCA9PiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGFkZE9uUHJvcHMpKTtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBpZD17aWR9PlxuICAgICAgICB7Y2hpbGRyZW5XaXRoVmlld1Byb3B9XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgY29uc3QgeyBkb3duc3RyZWFtLCBwb3J0IH0gPSB0aGlzLnByb3BzO1xuICAgIHRoaXMudXBkYXRlKHRoaXMucHJvcHMpO1xuICAgIGRvd25zdHJlYW0uc2V0SW5wdXREYXRhKHRoaXMucG9seWRhdGEsIHBvcnQpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBzbmFwc2hvdCkge1xuICAgIHRoaXMudXBkYXRlKHRoaXMucHJvcHMsIHByZXZQcm9wcyk7XG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICB0aGlzLnBvbHlkYXRhLmRlbGV0ZSgpO1xuICAgIHRoaXMucG9seWRhdGEgPSBudWxsO1xuICB9XG5cbiAgdXBkYXRlKHByb3BzLCBwcmV2aW91cykge1xuICAgIGNvbnN0IHsgcG9pbnRDbG91ZCwgcG9pbnRzLCB2ZXJ0cywgbGluZXMsIHBvbHlzLCBzdHJpcHMgfSA9IHByb3BzO1xuICAgIGxldCBjaGFuZ2VEZXRlY3RlZCA9IGZhbHNlO1xuICAgIGxldCBwb2ludENoYW5nZWQgPSBmYWxzZTtcbiAgICBpZiAocG9pbnRzICYmICghcHJldmlvdXMgfHwgcG9pbnRzICE9PSBwcmV2aW91cy5wb2ludHMpKSB7XG4gICAgICB0aGlzLnBvbHlkYXRhLmdldFBvaW50cygpLnNldERhdGEoRmxvYXQzMkFycmF5LmZyb20ocG9pbnRzKSwgMyk7XG4gICAgICBwb2ludENoYW5nZWQgPSB0cnVlO1xuICAgICAgY2hhbmdlRGV0ZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh2ZXJ0cyAmJiAoIXByZXZpb3VzIHx8IHZlcnRzICE9PSBwcmV2aW91cy52ZXJ0cykpIHtcbiAgICAgIHRoaXMucG9seWRhdGEuZ2V0VmVydHMoKS5zZXREYXRhKFVpbnQxNkFycmF5LmZyb20odmVydHMpKTtcbiAgICAgIGNoYW5nZURldGVjdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobGluZXMgJiYgKCFwcmV2aW91cyB8fCBsaW5lcyAhPT0gcHJldmlvdXMubGluZXMpKSB7XG4gICAgICB0aGlzLnBvbHlkYXRhLmdldExpbmVzKCkuc2V0RGF0YShVaW50MTZBcnJheS5mcm9tKGxpbmVzKSk7XG4gICAgICBjaGFuZ2VEZXRlY3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHBvbHlzICYmICghcHJldmlvdXMgfHwgcG9seXMgIT09IHByZXZpb3VzLnBvbHlzKSkge1xuICAgICAgdGhpcy5wb2x5ZGF0YS5nZXRQb2x5cygpLnNldERhdGEoVWludDE2QXJyYXkuZnJvbShwb2x5cykpO1xuICAgICAgY2hhbmdlRGV0ZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzdHJpcHMgJiYgKCFwcmV2aW91cyB8fCBzdHJpcHMgIT09IHByZXZpb3VzLnN0cmlwcykpIHtcbiAgICAgIHRoaXMucG9seWRhdGEuZ2V0U3RyaXBzKCkuc2V0RGF0YShVaW50MTZBcnJheS5mcm9tKHN0cmlwcykpO1xuICAgICAgY2hhbmdlRGV0ZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwb2ludENsb3VkICYmIChwb2ludENoYW5nZWQgfHwgIXByZXZpb3VzIHx8IHBvaW50Q2xvdWQgIT09IHByZXZpb3VzLnBvaW50Q2xvdWQpKSB7XG4gICAgICBjb25zdCBuYlBvaW50cyA9IHBvaW50cy5sZW5ndGggLyAzO1xuICAgICAgY29uc3QgdmFsdWVzID0gbmV3IFVpbnQxNkFycmF5KG5iUG9pbnRzICsgMSk7XG4gICAgICB2YWx1ZXNbMF0gPSBuYlBvaW50cztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmJQb2ludHM7IGkrKykge1xuICAgICAgICB2YWx1ZXNbaSArIDFdID0gaTtcbiAgICAgIH1cbiAgICAgIHRoaXMucG9seWRhdGEuZ2V0VmVydHMoKS5zZXREYXRhKHZhbHVlcyk7XG4gICAgICBjaGFuZ2VEZXRlY3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5nZURldGVjdGVkKSB7XG4gICAgICB0aGlzLnBvbHlkYXRhLm1vZGlmaWVkKCk7XG4gICAgfVxuICB9XG59XG5cblZ0a1BvbHlEYXRhU291cmNlLmRlZmF1bHRQcm9wcyA9IHtcbiAgcG9ydDogMCxcbiAgcG9pbnRzOiBbXSxcbiAgcG9pbnRDbG91ZDogZmFsc2UsXG59O1xuXG5WdGtQb2x5RGF0YVNvdXJjZS5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBUaGUgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGNvbXBvbmVudCBpbiBEYXNoIGNhbGxiYWNrcy5cbiAgICovXG4gIGlkOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBEYXNoLWFzc2lnbmVkIGNhbGxiYWNrIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCB0byByZXBvcnQgcHJvcGVydHkgY2hhbmdlc1xuICAgKiB0byBEYXNoLCB0byBtYWtlIHRoZW0gYXZhaWxhYmxlIGZvciBjYWxsYmFja3MuXG4gICAqL1xuICBzZXRQcm9wczogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLy8gLS0gdnRrLmpzIGV4cG9zZWQgcHJvcGVydGllc1xuXG4gIC8qKlxuICAgKiBkb3duc3RyZWFtIGNvbm5lY3Rpb24gcG9ydFxuICAgKi9cbiAgcG9ydDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogeHl6IGNvb3JkaW5hdGVzXG4gICAqL1xuICBwb2ludHM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5udW1iZXIpLFxuXG4gIC8qKlxuICAgKiB2ZXJ0cyBjZWxsc1xuICAgKi9cbiAgdmVydHM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5udW1iZXIpLFxuXG4gIC8qKlxuICAgKiBsaW5lcyBjZWxsc1xuICAgKi9cbiAgbGluZXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5udW1iZXIpLFxuXG4gIC8qKlxuICAgKiBwb2x5cyBjZWxsc1xuICAgKi9cbiAgcG9seXM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5udW1iZXIpLFxuXG4gIC8qKlxuICAgKiBzdHJpcHMgY2VsbHNcbiAgICovXG4gIHN0cmlwczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksXG5cbiAgLyoqXG4gICAqIElzIGl0IHBvaW50IGNsb3VkXG4gICAqL1xuICBwb2ludENsb3VkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogTGlzdCBvZiByZXByZXNlbnRhdGlvbiB0byBzaG93XG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbXG4gICAgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm5vZGUpLFxuICAgIFByb3BUeXBlcy5ub2RlXG4gIF0pLFxuICAvKipcbiAgICogUGFzc2VkIGJ5IHBhcmVudFxuICAgKi9cbiAgdmlldzogUHJvcFR5cGVzLm9iamVjdCxcbiAgLyoqXG4gICAqIFBhc3NlZCBieSBwYXJlbnRcbiAgICovXG4gIHJlcHJlc2VudGF0aW9uOiBQcm9wVHlwZXMub2JqZWN0LFxufTtcbiIsImltcG9ydCBSZWFjdCwge0NvbXBvbmVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcblxuaW1wb3J0IHZ0a09wZW5HTFJlbmRlcldpbmRvdyBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvT3BlbkdML1JlbmRlcldpbmRvdyc7XG5pbXBvcnQgdnRrUmVuZGVyV2luZG93IGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL1JlbmRlcmluZy9Db3JlL1JlbmRlcldpbmRvdyc7XG5pbXBvcnQgdnRrUmVuZGVyV2luZG93SW50ZXJhY3RvciBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9SZW5kZXJXaW5kb3dJbnRlcmFjdG9yJztcbmltcG9ydCB2dGtSZW5kZXJlciBmcm9tICd2dGsuanMvU291cmNlcy9SZW5kZXJpbmcvQ29yZS9SZW5kZXJlcic7XG5pbXBvcnQgdnRrSW50ZXJhY3RvclN0eWxlVHJhY2tiYWxsQ2FtZXJhIGZyb20gJ3Z0ay5qcy9Tb3VyY2VzL0ludGVyYWN0aW9uL1N0eWxlL0ludGVyYWN0b3JTdHlsZVRyYWNrYmFsbENhbWVyYSc7XG5cbmNvbnN0IENPTlRBSU5FUl9TVFlMRSA9IHsgd2lkdGg6ICcxMDAlJywgaGVpZ2h0OiAnMTAwJScsIHBvc2l0aW9uOiAncmVsYXRpdmUnIH07XG5jb25zdCBSRU5ERVJFUl9TVFlMRSA9IHsgcG9zaXRpb246ICdhYnNvbHV0ZScsIHdpZHRoOiAnMTAwJScsIGhlaWdodDogJzEwMCUnLCBvdmVyZmxvdzogJ2hpZGRlbicgfTtcbmNvbnN0IEhJRERFTl9TVFlMRSA9IHsgZGlzcGxheTogJ25vbmUnIH07XG5cbi8qKlxuICogVnRrVmlldyBpcyByZXNwb25zaWJsZSB0byByZW5kZXIgdnRrLmpzIGRhdGEuXG4gKiBJdCB0YWtlcyB0aGUgZm9sbG93aW5nIHNldCBvZiBwcm9wZXJ0aWVzOlxuICogICAtIGBiYWNrZ3JvdW5kYDpcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVnRrVmlldyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lclJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXG4gICAgICAgIC8vIENyZWF0ZSB2dGsuanMgdmlld1xuICAgICAgICB0aGlzLnJlbmRlcldpbmRvdyA9IHZ0a1JlbmRlcldpbmRvdy5uZXdJbnN0YW5jZSgpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gdnRrUmVuZGVyZXIubmV3SW5zdGFuY2UoeyBiYWNrZ3JvdW5kOiBwcm9wcy5iYWNrZ3JvdW5kIH0pO1xuICAgICAgICB0aGlzLnJlbmRlcldpbmRvdy5hZGRSZW5kZXJlcih0aGlzLnJlbmRlcmVyKTtcblxuICAgICAgICB0aGlzLm9wZW5nbFJlbmRlcldpbmRvdyA9IHZ0a09wZW5HTFJlbmRlcldpbmRvdy5uZXdJbnN0YW5jZSgpO1xuICAgICAgICB0aGlzLnJlbmRlcldpbmRvdy5hZGRWaWV3KHRoaXMub3BlbmdsUmVuZGVyV2luZG93KTtcblxuICAgICAgICB0aGlzLmludGVyYWN0b3IgPSB2dGtSZW5kZXJXaW5kb3dJbnRlcmFjdG9yLm5ld0luc3RhbmNlKCk7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rvci5zZXRWaWV3KHRoaXMub3BlbmdsUmVuZGVyV2luZG93KTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdG9yLmluaXRpYWxpemUoKTtcblxuICAgICAgICAvLyBXZSBtYXkgd2FudCBzb21ldGhpbmcgZGlmZmVyZW50XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rvci5zZXRJbnRlcmFjdG9yU3R5bGUodnRrSW50ZXJhY3RvclN0eWxlVHJhY2tiYWxsQ2FtZXJhLm5ld0luc3RhbmNlKCkpO1xuXG4gICAgICAgIC8vIFJlc2l6ZSBoYW5kbGluZ1xuICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHRoaXMub25SZXNpemUoKSk7XG4gICAgfVxuXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGlkLCBjaGlsZHJlbiwgc2V0UHJvcHMgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGFkZE9uUHJvcHMgPSB7IHZpZXc6IHRoaXMsIHNldFByb3BzIH07XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuV2l0aFZpZXdQcm9wID0gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCBjaGlsZCA9PiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIGFkZE9uUHJvcHMpKTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICBpZD17aWR9XG4gICAgICAgICAgICAgICAgc3R5bGU9e0NPTlRBSU5FUl9TVFlMRX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXtSRU5ERVJFUl9TVFlMRX1cbiAgICAgICAgICAgICAgICAgICAgcmVmPXt0aGlzLmNvbnRhaW5lclJlZn1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9e0hJRERFTl9TVFlMRX0+XG4gICAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbldpdGhWaWV3UHJvcH1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICApO1xuICAgIH1cblxuICAgIG9uUmVzaXplKCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lclJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHRoaXMub3BlbmdsUmVuZGVyV2luZG93LnNldFNpemUoTWF0aC5tYXgod2lkdGgsIDEwKSwgTWF0aC5tYXgoaGVpZ2h0LCAxMCkpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJXaW5kb3cucmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5jb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgICAgdGhpcy5vcGVuZ2xSZW5kZXJXaW5kb3cuc2V0Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rvci5iaW5kRXZlbnRzKGNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMub25SZXNpemUoKTtcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIC8vIFN0b3Agc2l6ZSBsaXN0ZW5pbmdcbiAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAgIC8vIERldGF0Y2ggZnJvbSBET01cbiAgICAgICAgdGhpcy5pbnRlcmFjdG9yLnVuYmluZEV2ZW50cygpO1xuICAgICAgICB0aGlzLm9wZW5nbFJlbmRlcldpbmRvdy5zZXRDb250YWluZXIobnVsbCk7XG5cbiAgICAgICAgLy8gRnJlZSBtZW1vcnlcbiAgICAgICAgdGhpcy5yZW5kZXJXaW5kb3cucmVtb3ZlUmVuZGVyZXIodGhpcy5yZW5kZXJlcik7XG4gICAgICAgIHRoaXMucmVuZGVyV2luZG93LnJlbW92ZVZpZXcodGhpcy5vcGVuZ2xSZW5kZXJXaW5kb3cpO1xuXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rvci5kZWxldGUoKTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdG9yID0gbnVsbDtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLmRlbGV0ZSgpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcblxuICAgICAgICB0aGlzLnJlbmRlcldpbmRvdy5kZWxldGUoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJXaW5kb3cgPSBudWxsO1xuXG4gICAgICAgIHRoaXMub3BlbmdsUmVuZGVyV2luZG93LmRlbGV0ZSgpO1xuICAgICAgICB0aGlzLm9wZW5nbFJlbmRlcldpbmRvdyA9IG51bGw7XG4gICAgfVxufVxuXG5WdGtWaWV3LmRlZmF1bHRQcm9wcyA9IHtcbiAgICBiYWNrZ3JvdW5kOiBbMC4yLCAwLjMsIDAuNF0sXG59O1xuXG5WdGtWaWV3LnByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgdXNlZCB0byBpZGVudGlmeSB0aGlzIGNvbXBvbmVudCBpbiBEYXNoIGNhbGxiYWNrcy5cbiAgICAgKi9cbiAgICBpZDogUHJvcFR5cGVzLnN0cmluZyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb2xvciBvZiB0aGUgdmlldyBiYWNrZ3JvdW5kIHVzaW5nIDMgZmxvYXRpbmcgbnVtYmVyc1xuICAgICAqIGJldHdlZW4gMC0xIG9mIFJlZCwgR3JlZW4sIEJsdWUgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGJhY2tncm91bmQ6IFByb3BUeXBlcy5hcnJheSxcblxuICAgIC8qKlxuICAgICAqIERhc2gtYXNzaWduZWQgY2FsbGJhY2sgdGhhdCBzaG91bGQgYmUgY2FsbGVkIHRvIHJlcG9ydCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAgICogdG8gRGFzaCwgdG8gbWFrZSB0aGVtIGF2YWlsYWJsZSBmb3IgY2FsbGJhY2tzLlxuICAgICAqL1xuICAgIHNldFByb3BzOiBQcm9wVHlwZXMuZnVuYyxcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcmVwcmVzZW50YXRpb24gdG8gc2hvd1xuICAgICAqL1xuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgICAgUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm5vZGUpLFxuICAgICAgICBQcm9wVHlwZXMubm9kZVxuICAgIF0pLFxufTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIGltcG9ydC9wcmVmZXItZGVmYXVsdC1leHBvcnQgKi9cbmltcG9ydCBWdGtDZWxsRGF0YSBmcm9tICcuL2NvbXBvbmVudHMvVnRrQ2VsbERhdGEucmVhY3QnO1xuaW1wb3J0IFZ0a0RhdGFBcnJheSBmcm9tICcuL2NvbXBvbmVudHMvVnRrRGF0YUFycmF5LnJlYWN0JztcbmltcG9ydCBWdGtGaWVsZERhdGEgZnJvbSAnLi9jb21wb25lbnRzL1Z0a0ZpZWxkRGF0YS5yZWFjdCc7XG5pbXBvcnQgVnRrR2VvbWV0cnlSZXByZXNlbnRhdGlvbiBmcm9tICcuL2NvbXBvbmVudHMvVnRrR2VvbWV0cnlSZXByZXNlbnRhdGlvbi5yZWFjdCc7XG5pbXBvcnQgVnRrUG9pbnREYXRhIGZyb20gJy4vY29tcG9uZW50cy9WdGtQb2ludERhdGEucmVhY3QnO1xuaW1wb3J0IFZ0a1BvbHlEYXRhU291cmNlIGZyb20gJy4vY29tcG9uZW50cy9WdGtQb2x5RGF0YVNvdXJjZS5yZWFjdCc7XG5pbXBvcnQgVnRrVmlldyBmcm9tICcuL2NvbXBvbmVudHMvVnRrVmlldy5yZWFjdCc7XG5cbmV4cG9ydCB7XG4gICAgVnRrQ2VsbERhdGEsXG4gICAgVnRrRGF0YUFycmF5LFxuICAgIFZ0a0ZpZWxkRGF0YSxcbiAgICBWdGtHZW9tZXRyeVJlcHJlc2VudGF0aW9uLFxuICAgIFZ0a1BvaW50RGF0YSxcbiAgICBWdGtQb2x5RGF0YVNvdXJjZSxcbiAgICBWdGtWaWV3LFxufTtcbiIsIi8qIChpZ25vcmVkKSAqLyJdLCJzb3VyY2VSb290IjoiIn0=